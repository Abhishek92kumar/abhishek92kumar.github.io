/* Generated from Java with JSweet 3.1.0 - http://www.jsweet.org */
var net;
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var shuntingyard;
            (function (shuntingyard) {
                /**
                 * Shunting yard implementation to convert infix to reverse polish notation
                 * @class
                 */
                class ShuntingYard {
                    /**
                     * Convert a Set of tokens from infix to reverse polish notation
                     * @param {string} expression the expression to convert
                     * @param {*} userFunctions the custom functions used
                     * @param {*} userOperators the custom operators used
                     * @param {*} variableNames the variable names used in the expression
                     * @param {boolean} implicitMultiplication set to fasle to turn off implicit multiplication
                     * @return {net.objecthunter.exp4j.tokenizer.Token[]} a {@link net.objecthunter.exp4j.tokenizer.Token} array containing the result
                     */
                    static convertToRPN(expression, userFunctions, userOperators, variableNames, implicitMultiplication) {
                        const stack = (new java.util.Stack());
                        const output = (new java.util.ArrayList());
                        const tokenizer = new net.objecthunter.exp4j.tokenizer.Tokenizer(expression, userFunctions, userOperators, variableNames, implicitMultiplication);
                        while ((tokenizer.hasNext())) {
                            {
                                const token = tokenizer.nextToken();
                                switch ((token.getType())) {
                                    case net.objecthunter.exp4j.tokenizer.Token.TOKEN_NUMBER:
                                    case net.objecthunter.exp4j.tokenizer.Token.TOKEN_VARIABLE:
                                        output.add(token);
                                        break;
                                    case net.objecthunter.exp4j.tokenizer.Token.TOKEN_FUNCTION:
                                        stack.add(token);
                                        break;
                                    case net.objecthunter.exp4j.tokenizer.Token.TOKEN_SEPARATOR:
                                        while ((!stack.empty() && stack.peek().getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_OPEN)) {
                                            {
                                                output.add(stack.pop());
                                            }
                                        }
                                        ;
                                        if (stack.empty() || stack.peek().getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_OPEN) {
                                            throw new java.lang.IllegalArgumentException("Misplaced function separator \',\' or mismatched parentheses");
                                        }
                                        break;
                                    case net.objecthunter.exp4j.tokenizer.Token.TOKEN_OPERATOR:
                                        while ((!stack.empty() && stack.peek().getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_OPERATOR)) {
                                            {
                                                const o1 = token;
                                                const o2 = stack.peek();
                                                if (o1.getOperator().getNumOperands() === 1 && o2.getOperator().getNumOperands() === 2) {
                                                    break;
                                                }
                                                else if ((o1.getOperator().isLeftAssociative() && o1.getOperator().getPrecedence() <= o2.getOperator().getPrecedence()) || (o1.getOperator().getPrecedence() < o2.getOperator().getPrecedence())) {
                                                    output.add(stack.pop());
                                                }
                                                else {
                                                    break;
                                                }
                                            }
                                        }
                                        ;
                                        stack.push(token);
                                        break;
                                    case net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_OPEN:
                                        stack.push(token);
                                        break;
                                    case net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_CLOSE:
                                        while ((stack.peek().getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_OPEN)) {
                                            {
                                                output.add(stack.pop());
                                            }
                                        }
                                        ;
                                        stack.pop();
                                        if (!stack.isEmpty() && stack.peek().getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_FUNCTION) {
                                            output.add(stack.pop());
                                        }
                                        break;
                                    default:
                                        throw new java.lang.IllegalArgumentException("Unknown Token type encountered. This should not happen");
                                }
                            }
                        }
                        ;
                        while ((!stack.empty())) {
                            {
                                const t = stack.pop();
                                if (t.getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_CLOSE || t.getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_OPEN) {
                                    throw new java.lang.IllegalArgumentException("Mismatched parentheses detected. Please check the expression");
                                }
                                else {
                                    output.add(t);
                                }
                            }
                        }
                        ;
                        return output.toArray((s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(output.size()));
                    }
                }
                shuntingyard.ShuntingYard = ShuntingYard;
                ShuntingYard["__class"] = "net.objecthunter.exp4j.shuntingyard.ShuntingYard";
            })(shuntingyard = exp4j.shuntingyard || (exp4j.shuntingyard = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            /**
             * Create a new instance
             * @param {boolean} valid Whether the validation of the expression was successful
             * @param {*} errors The list of errors returned if the validation was unsuccessful
             * @class
             */
            class ValidationResult {
                constructor(valid, errors) {
                    if (this.valid === undefined) {
                        this.valid = false;
                    }
                    if (this.errors === undefined) {
                        this.errors = null;
                    }
                    this.valid = valid;
                    this.errors = errors;
                }
                /**
                 * Check if an expression has been validated successfully
                 * @return {boolean} true if the validation was successful, false otherwise
                 */
                isValid() {
                    return this.valid;
                }
                /**
                 * Get the list of errors describing the issues while validating the expression
                 * @return {*} The List of errors
                 */
                getErrors() {
                    return this.errors;
                }
                static SUCCESS_$LI$() { if (ValidationResult.SUCCESS == null) {
                    ValidationResult.SUCCESS = new ValidationResult(true, null);
                } return ValidationResult.SUCCESS; }
            }
            exp4j.ValidationResult = ValidationResult;
            ValidationResult["__class"] = "net.objecthunter.exp4j.ValidationResult";
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            /**
             * Create a new ExpressionBuilder instance and initialize it with a given expression string.
             * @param {string} expression the expression to be parsed
             * @class
             */
            class ExpressionBuilder {
                constructor(expression) {
                    if (this.expression === undefined) {
                        this.expression = null;
                    }
                    if (this.userFunctions === undefined) {
                        this.userFunctions = null;
                    }
                    if (this.userOperators === undefined) {
                        this.userOperators = null;
                    }
                    if (this.variableNames === undefined) {
                        this.variableNames = null;
                    }
                    this.__implicitMultiplication = true;
                    if (expression == null || expression.trim().length === 0) {
                        throw new java.lang.IllegalArgumentException("Expression can not be empty");
                    }
                    this.expression = expression;
                    this.userOperators = (new java.util.HashMap(4));
                    this.userFunctions = (new java.util.HashMap(4));
                    this.variableNames = (new java.util.HashSet(4));
                }
                /**
                 * Add a {@link net.objecthunter.exp4j.function._Function} implementation available for use in the expression
                 * @param function the custom {@link net.objecthunter.exp4j.function._Function} implementation that should be available for use in the expression.
                 * @return {net.objecthunter.exp4j.ExpressionBuilder} the ExpressionBuilder instance
                 * @param {net.objecthunter.exp4j.__function._Function} _function
                 */
                _function(_function) {
                    this.userFunctions.put(_function.getName(), _function);
                    return this;
                }
                functions$net_objecthunter_exp4j_function__Function_A(...functions) {
                    if (functions == null)
                        return this;
                    for (let index = 0; index < functions.length; index++) {
                        let f = functions[index];
                        {
                            this.userFunctions.put(f.getName(), f);
                        }
                    }
                    return this;
                }
                /**
                 * Add multiple {@link net.objecthunter.exp4j.function._Function} implementations available for use in the expression
                 * @param {net.objecthunter.exp4j.function._Function[]} functions the custom {@link net.objecthunter.exp4j.function._Function} implementations
                 * @return {net.objecthunter.exp4j.ExpressionBuilder} the ExpressionBuilder instance
                 */
                functions(...functions) {
                    if (((functions != null && functions instanceof Array && (functions.length == 0 || functions[0] == null || (functions[0] != null && functions[0] instanceof net.objecthunter.exp4j.__function._Function))) || functions === null)) {
                        return this.functions$net_objecthunter_exp4j_function__Function_A(...functions);
                    }
                    else if (((functions != null && (functions.constructor != null && functions.constructor["__interfaces"] != null && functions.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || functions === null)) {
                        return this.functions$java_util_List(functions);
                    }
                    else
                        throw new Error('invalid overload');
                }
                functions$java_util_List(functions) {
                    for (let index = functions.iterator(); index.hasNext();) {
                        let f = index.next();
                        {
                            this.userFunctions.put(f.getName(), f);
                        }
                    }
                    return this;
                }
                variables$java_util_Set(variableNames) {
                    this.variableNames.addAll(variableNames);
                    return this;
                }
                /**
                 * Declare variable names used in the expression
                 * @param {*} variableNames the variables used in the expression
                 * @return {net.objecthunter.exp4j.ExpressionBuilder} the ExpressionBuilder instance
                 */
                variables(variableNames) {
                    if (((variableNames != null && (variableNames.constructor != null && variableNames.constructor["__interfaces"] != null && variableNames.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || variableNames === null)) {
                        return this.variables$java_util_Set(variableNames);
                    }
                    else if (((variableNames != null && variableNames instanceof Array && (variableNames.length == 0 || variableNames[0] == null || (typeof variableNames[0] === 'string'))) || variableNames === null)) {
                        return this.variables$java_lang_String_A(variableNames);
                    }
                    else
                        throw new Error('invalid overload');
                }
                variables$java_lang_String_A(variableNames) {
                    if (variableNames != null) {
                        for (let index = 0; index < variableNames.length; index++) {
                            let s = variableNames[index];
                            this.variableNames.add(s);
                        }
                    }
                    return this;
                }
                /**
                 * Declare a variable used in the expression
                 * @param {string} variableName the variable used in the expression
                 * @return {net.objecthunter.exp4j.ExpressionBuilder} the ExpressionBuilder instance
                 */
                variable(variableName) {
                    this.variableNames.add(variableName);
                    return this;
                }
                implicitMultiplication(enabled) {
                    this.__implicitMultiplication = enabled;
                    return this;
                }
                operator$net_objecthunter_exp4j_operator_Operator(operator) {
                    this.checkOperatorSymbol(operator);
                    this.userOperators.put(operator.getSymbol(), operator);
                    return this;
                }
                /**
                 * Add an {@link net.objecthunter.exp4j.operator.Operator} which should be available for use in the expression
                 * @param {net.objecthunter.exp4j.operator.Operator} operator the custom {@link net.objecthunter.exp4j.operator.Operator} to add
                 * @return {net.objecthunter.exp4j.ExpressionBuilder} the ExpressionBuilder instance
                 */
                operator(operator) {
                    if (((operator != null && operator instanceof net.objecthunter.exp4j.operator.Operator) || operator === null)) {
                        return this.operator$net_objecthunter_exp4j_operator_Operator(operator);
                    }
                    else if (((operator != null && operator instanceof Array && (operator.length == 0 || operator[0] == null || (operator[0] != null && operator[0] instanceof net.objecthunter.exp4j.operator.Operator))) || operator === null)) {
                        return this.operator$net_objecthunter_exp4j_operator_Operator_A(operator);
                    }
                    else if (((operator != null && (operator.constructor != null && operator.constructor["__interfaces"] != null && operator.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || operator === null)) {
                        return this.operator$java_util_List(operator);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ checkOperatorSymbol(op) {
                    const name = op.getSymbol();
                    {
                        let array = /* toCharArray */ (name).split('');
                        for (let index = 0; index < array.length; index++) {
                            let ch = array[index];
                            {
                                if (!net.objecthunter.exp4j.operator.Operator.isAllowedOperatorChar(ch)) {
                                    throw new java.lang.IllegalArgumentException("The operator symbol \'" + name + "\' is invalid");
                                }
                            }
                        }
                    }
                }
                operator$net_objecthunter_exp4j_operator_Operator_A(operators) {
                    if (operators == null)
                        return this;
                    for (let index = 0; index < operators.length; index++) {
                        let o = operators[index];
                        {
                            this.operator$net_objecthunter_exp4j_operator_Operator(o);
                        }
                    }
                    return this;
                }
                operator$java_util_List(operators) {
                    for (let index = operators.iterator(); index.hasNext();) {
                        let o = index.next();
                        {
                            this.operator$net_objecthunter_exp4j_operator_Operator(o);
                        }
                    }
                    return this;
                }
                /**
                 * Build the {@link Expression} instance using the custom operators and functions set.
                 * @return {net.objecthunter.exp4j.Expression} an {@link Expression} instance which can be used to evaluate the result of the expression
                 */
                build() {
                    if (this.expression.length === 0) {
                        throw new java.lang.IllegalArgumentException("The expression can not be empty");
                    }
                    this.variableNames.add("pi");
                    this.variableNames.add("\u03c0");
                    this.variableNames.add("e");
                    this.variableNames.add("\u03c6");
                    for (let index = this.variableNames.iterator(); index.hasNext();) {
                        let _var = index.next();
                        {
                            if (net.objecthunter.exp4j.__function.Functions.getBuiltinFunction(_var) != null || this.userFunctions.containsKey(_var)) {
                                throw new java.lang.IllegalArgumentException("A variable can not have the same name as a function [" + _var + "]");
                            }
                        }
                    }
                    return new net.objecthunter.exp4j.Expression(net.objecthunter.exp4j.shuntingyard.ShuntingYard.convertToRPN(this.expression, this.userFunctions, this.userOperators, this.variableNames, this.__implicitMultiplication), this.userFunctions.keySet());
                }
            }
            exp4j.ExpressionBuilder = ExpressionBuilder;
            ExpressionBuilder["__class"] = "net.objecthunter.exp4j.ExpressionBuilder";
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var tokenizer;
            (function (tokenizer) {
                /**
                 * This exception is being thrown whenever {@link Tokenizer} finds unknown function or variable.
                 *
                 * @author Bartosz Firyn (sarxos)
                 * @param {string} expression
                 * @param {number} position
                 * @param {number} length
                 * @class
                 * @extends java.lang.IllegalArgumentException
                 */
                class UnknownFunctionOrVariableException extends java.lang.IllegalArgumentException {
                    constructor(expression, position, length) {
                        super();
                        Object.setPrototypeOf(this, UnknownFunctionOrVariableException.prototype);
                        if (this.message === undefined) {
                            this.message = null;
                        }
                        if (this.expression === undefined) {
                            this.expression = null;
                        }
                        if (this.__token === undefined) {
                            this.__token = null;
                        }
                        if (this.position === undefined) {
                            this.position = 0;
                        }
                        this.expression = expression;
                        this.__token = UnknownFunctionOrVariableException.token(expression, position, length);
                        this.position = position;
                        this.message = "Unknown function or variable \'" + this.__token + "\' at pos " + position + " in expression \'" + expression + "\'";
                    }
                    /*private*/ static token(expression, position, length) {
                        const len = expression.length;
                        let end = position + length - 1;
                        if (len < end) {
                            end = len;
                        }
                        return expression.substring(position, end);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getMessage() {
                        return this.message;
                    }
                    /**
                     * @return {string} Expression which contains unknown function or variable
                     */
                    getExpression() {
                        return this.expression;
                    }
                    /**
                     * @return {string} The name of unknown function or variable
                     */
                    getToken() {
                        return this.__token;
                    }
                    /**
                     * @return {number} The position of unknown function or variable
                     */
                    getPosition() {
                        return this.position;
                    }
                }
                /**
                 * Serial version UID.
                 */
                UnknownFunctionOrVariableException.__net_objecthunter_exp4j_tokenizer_UnknownFunctionOrVariableException_serialVersionUID = 1;
                tokenizer.UnknownFunctionOrVariableException = UnknownFunctionOrVariableException;
                UnknownFunctionOrVariableException["__class"] = "net.objecthunter.exp4j.tokenizer.UnknownFunctionOrVariableException";
                UnknownFunctionOrVariableException["__interfaces"] = ["java.io.Serializable"];
            })(tokenizer = exp4j.tokenizer || (exp4j.tokenizer = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var tokenizer;
            (function (tokenizer) {
                class Tokenizer {
                    constructor(expression, userFunctions, userOperators, variableNames, implicitMultiplication) {
                        if (((typeof expression === 'string') || expression === null) && ((userFunctions != null && (userFunctions.constructor != null && userFunctions.constructor["__interfaces"] != null && userFunctions.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || userFunctions === null) && ((userOperators != null && (userOperators.constructor != null && userOperators.constructor["__interfaces"] != null && userOperators.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || userOperators === null) && ((variableNames != null && (variableNames.constructor != null && variableNames.constructor["__interfaces"] != null && variableNames.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || variableNames === null) && ((typeof implicitMultiplication === 'boolean') || implicitMultiplication === null)) {
                            let __args = arguments;
                            if (this.expression === undefined) {
                                this.expression = null;
                            }
                            if (this.expressionLength === undefined) {
                                this.expressionLength = 0;
                            }
                            if (this.userFunctions === undefined) {
                                this.userFunctions = null;
                            }
                            if (this.userOperators === undefined) {
                                this.userOperators = null;
                            }
                            if (this.variableNames === undefined) {
                                this.variableNames = null;
                            }
                            if (this.implicitMultiplication === undefined) {
                                this.implicitMultiplication = false;
                            }
                            if (this.lastToken === undefined) {
                                this.lastToken = null;
                            }
                            this.pos = 0;
                            this.expression = /* toCharArray */ (expression.trim()).split('');
                            this.expressionLength = this.expression.length;
                            this.userFunctions = userFunctions;
                            this.userOperators = userOperators;
                            this.variableNames = variableNames;
                            this.implicitMultiplication = implicitMultiplication;
                        }
                        else if (((typeof expression === 'string') || expression === null) && ((userFunctions != null && (userFunctions.constructor != null && userFunctions.constructor["__interfaces"] != null && userFunctions.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || userFunctions === null) && ((userOperators != null && (userOperators.constructor != null && userOperators.constructor["__interfaces"] != null && userOperators.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || userOperators === null) && ((variableNames != null && (variableNames.constructor != null && variableNames.constructor["__interfaces"] != null && variableNames.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || variableNames === null) && implicitMultiplication === undefined) {
                            let __args = arguments;
                            if (this.expression === undefined) {
                                this.expression = null;
                            }
                            if (this.expressionLength === undefined) {
                                this.expressionLength = 0;
                            }
                            if (this.userFunctions === undefined) {
                                this.userFunctions = null;
                            }
                            if (this.userOperators === undefined) {
                                this.userOperators = null;
                            }
                            if (this.variableNames === undefined) {
                                this.variableNames = null;
                            }
                            if (this.implicitMultiplication === undefined) {
                                this.implicitMultiplication = false;
                            }
                            if (this.lastToken === undefined) {
                                this.lastToken = null;
                            }
                            this.pos = 0;
                            this.expression = /* toCharArray */ (expression.trim()).split('');
                            this.expressionLength = this.expression.length;
                            this.userFunctions = userFunctions;
                            this.userOperators = userOperators;
                            this.variableNames = variableNames;
                            this.implicitMultiplication = true;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    hasNext() {
                        return this.expression.length > this.pos;
                    }
                    nextToken() {
                        let ch = this.expression[this.pos];
                        while ((Tokenizer.isWhiteSpace((ch).charCodeAt(0)))) {
                            {
                                ch = this.expression[++this.pos];
                            }
                        }
                        ;
                        if (Tokenizer.isDigit((ch).charCodeAt(0)) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == '.'.charCodeAt(0)) {
                            if (this.lastToken != null) {
                                if (this.lastToken.getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_NUMBER) {
                                    throw new java.lang.IllegalArgumentException("Unable to parse char \'" + ch + "\' (Code:" + (ch).charCodeAt(0) + ") at [" + this.pos + "]");
                                }
                                else if (this.implicitMultiplication && (this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_OPERATOR && this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_OPEN && this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_FUNCTION && this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_SEPARATOR)) {
                                    this.lastToken = new net.objecthunter.exp4j.tokenizer.OperatorToken(net.objecthunter.exp4j.operator.Operators.getBuiltinOperator('*', 2));
                                    return this.lastToken;
                                }
                            }
                            return this.parseNumberToken(ch);
                        }
                        else if (this.isArgumentSeparator(ch)) {
                            return this.parseArgumentSeparatorToken(ch);
                        }
                        else if (this.isOpenParentheses(ch)) {
                            if (this.lastToken != null && this.implicitMultiplication && (this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_OPERATOR && this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_OPEN && this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_FUNCTION && this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_SEPARATOR)) {
                                this.lastToken = new net.objecthunter.exp4j.tokenizer.OperatorToken(net.objecthunter.exp4j.operator.Operators.getBuiltinOperator('*', 2));
                                return this.lastToken;
                            }
                            return this.parseParentheses(true);
                        }
                        else if (this.isCloseParentheses(ch)) {
                            return this.parseParentheses(false);
                        }
                        else if (net.objecthunter.exp4j.operator.Operator.isAllowedOperatorChar(ch)) {
                            return this.parseOperatorToken(ch);
                        }
                        else if (Tokenizer.isAlphabetic((ch).charCodeAt(0)) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == '_'.charCodeAt(0)) {
                            if (this.lastToken != null && this.implicitMultiplication && (this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_OPERATOR && this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_OPEN && this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_FUNCTION && this.lastToken.getType() !== net.objecthunter.exp4j.tokenizer.Token.TOKEN_SEPARATOR)) {
                                this.lastToken = new net.objecthunter.exp4j.tokenizer.OperatorToken(net.objecthunter.exp4j.operator.Operators.getBuiltinOperator('*', 2));
                                return this.lastToken;
                            }
                            return this.parseFunctionOrVariable();
                        }
                        throw new java.lang.IllegalArgumentException("Unable to parse char \'" + ch + "\' (Code:" + (ch).charCodeAt(0) + ") at [" + this.pos + "]");
                    }
                    /*private*/ parseArgumentSeparatorToken(ch) {
                        this.pos++;
                        this.lastToken = new net.objecthunter.exp4j.tokenizer.ArgumentSeparatorToken();
                        return this.lastToken;
                    }
                    /*private*/ isArgumentSeparator(ch) {
                        return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == ','.charCodeAt(0);
                    }
                    /*private*/ parseParentheses(open) {
                        if (open) {
                            this.lastToken = new net.objecthunter.exp4j.tokenizer.OpenParenthesesToken();
                        }
                        else {
                            this.lastToken = new net.objecthunter.exp4j.tokenizer.CloseParenthesesToken();
                        }
                        this.pos++;
                        return this.lastToken;
                    }
                    /*private*/ isOpenParentheses(ch) {
                        return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == '('.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == '{'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == '['.charCodeAt(0);
                    }
                    /*private*/ isCloseParentheses(ch) {
                        return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == ')'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == '}'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == ']'.charCodeAt(0);
                    }
                    /*private*/ parseFunctionOrVariable() {
                        const offset = this.pos;
                        let testPos;
                        let lastValidLen = 1;
                        let lastValidToken = null;
                        let len = 1;
                        if (this.isEndOfExpression(offset)) {
                            this.pos++;
                        }
                        testPos = offset + len - 1;
                        while ((!this.isEndOfExpression(testPos) && Tokenizer.isVariableOrFunctionCharacter((this.expression[testPos]).charCodeAt(0)))) {
                            {
                                const name = ((str, index, len) => str.substring(index, index + len))((this.expression).join(''), offset, len);
                                if (this.variableNames != null && this.variableNames.contains(name)) {
                                    lastValidLen = len;
                                    lastValidToken = new net.objecthunter.exp4j.tokenizer.VariableToken(name);
                                }
                                else {
                                    const f = this.getFunction(name);
                                    if (f != null) {
                                        lastValidLen = len;
                                        lastValidToken = new net.objecthunter.exp4j.tokenizer.FunctionToken(f);
                                    }
                                }
                                len++;
                                testPos = offset + len - 1;
                            }
                        }
                        ;
                        if (lastValidToken == null) {
                            throw new net.objecthunter.exp4j.tokenizer.UnknownFunctionOrVariableException(new String(this.expression), this.pos, len);
                        }
                        this.pos += lastValidLen;
                        this.lastToken = lastValidToken;
                        return this.lastToken;
                    }
                    /*private*/ getFunction(name) {
                        let f = null;
                        if (this.userFunctions != null) {
                            f = this.userFunctions.get(name);
                        }
                        if (f == null) {
                            f = net.objecthunter.exp4j.__function.Functions.getBuiltinFunction(name);
                        }
                        return f;
                    }
                    /*private*/ parseOperatorToken(firstChar) {
                        const offset = this.pos;
                        let len = 1;
                        const symbol = new java.lang.StringBuilder();
                        let lastValid = null;
                        symbol.append(firstChar);
                        while ((!this.isEndOfExpression(offset + len) && net.objecthunter.exp4j.operator.Operator.isAllowedOperatorChar(this.expression[offset + len]))) {
                            {
                                symbol.append(this.expression[offset + len++]);
                            }
                        }
                        ;
                        while ((symbol.length() > 0)) {
                            {
                                const op = this.getOperator(symbol.toString());
                                if (op == null) {
                                    symbol.setLength(symbol.length() - 1);
                                }
                                else {
                                    lastValid = op;
                                    break;
                                }
                            }
                        }
                        ;
                        this.pos += symbol.length();
                        this.lastToken = new net.objecthunter.exp4j.tokenizer.OperatorToken(lastValid);
                        return this.lastToken;
                    }
                    /*private*/ getOperator(symbol) {
                        let op = null;
                        if (this.userOperators != null) {
                            op = this.userOperators.get(symbol);
                        }
                        if (op == null && symbol.length === 1) {
                            let argc = 2;
                            if (this.lastToken == null) {
                                argc = 1;
                            }
                            else {
                                const lastTokenType = this.lastToken.getType();
                                if (lastTokenType === net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_OPEN || lastTokenType === net.objecthunter.exp4j.tokenizer.Token.TOKEN_SEPARATOR) {
                                    argc = 1;
                                }
                                else if (lastTokenType === net.objecthunter.exp4j.tokenizer.Token.TOKEN_OPERATOR) {
                                    const lastOp = this.lastToken.getOperator();
                                    if (lastOp.getNumOperands() === 2 || (lastOp.getNumOperands() === 1 && !lastOp.isLeftAssociative())) {
                                        argc = 1;
                                    }
                                }
                            }
                            op = net.objecthunter.exp4j.operator.Operators.getBuiltinOperator(symbol.charAt(0), argc);
                        }
                        return op;
                    }
                    /*private*/ parseNumberToken(firstChar) {
                        const offset = this.pos;
                        let len = 1;
                        this.pos++;
                        if (this.isEndOfExpression(offset + len)) {
                            this.lastToken = new net.objecthunter.exp4j.tokenizer.NumberToken(javaemul.internal.DoubleHelper.parseDouble(/* valueOf */ String(firstChar).toString()));
                            return this.lastToken;
                        }
                        while ((!this.isEndOfExpression(offset + len) && Tokenizer.isNumeric(this.expression[offset + len], (c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.expression[offset + len - 1]) == 'e'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.expression[offset + len - 1]) == 'E'.charCodeAt(0)))) {
                            {
                                len++;
                                this.pos++;
                            }
                        }
                        ;
                        if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.expression[offset + len - 1]) == 'e'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.expression[offset + len - 1]) == 'E'.charCodeAt(0)) {
                            len--;
                            this.pos--;
                        }
                        this.lastToken = new net.objecthunter.exp4j.tokenizer.NumberToken(this.expression, offset, len);
                        return this.lastToken;
                    }
                    /*private*/ static isNumeric(ch, lastCharE) {
                        return Tokenizer.isDigit((ch).charCodeAt(0)) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == '.'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == 'e'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == 'E'.charCodeAt(0) || (lastCharE && ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == '-'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == '+'.charCodeAt(0)));
                    }
                    static isAlphabetic(codePoint) {
                        return Tokenizer.isLetter(codePoint);
                    }
                    static isVariableOrFunctionCharacter(codePoint) {
                        return Tokenizer.isLetter(codePoint) || Tokenizer.isDigit(codePoint) || codePoint == '_'.charCodeAt(0) || codePoint == '.'.charCodeAt(0);
                    }
                    /*private*/ isEndOfExpression(offset) {
                        return this.expressionLength <= offset;
                    }
                    /*private*/ static isLetter(c) {
                        return (c >= 97 && c <= 122) || (c >= 65 && c <= 90);
                    }
                    /*private*/ static isWhiteSpace(c) {
                        return (c <= 32);
                    }
                    /*private*/ static isDigit(c) {
                        return c >= 48 && c <= 57;
                    }
                }
                tokenizer.Tokenizer = Tokenizer;
                Tokenizer["__class"] = "net.objecthunter.exp4j.tokenizer.Tokenizer";
            })(tokenizer = exp4j.tokenizer || (exp4j.tokenizer = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var tokenizer;
            (function (tokenizer) {
                /**
                 * Abstract class for tokens used by exp4j to tokenize expressions
                 * @class
                 */
                class Token {
                    constructor(type) {
                        if (this.type === undefined) {
                            this.type = 0;
                        }
                        this.type = type;
                    }
                    getType() {
                        return this.type;
                    }
                }
                Token.TOKEN_NUMBER = 1;
                Token.TOKEN_OPERATOR = 2;
                Token.TOKEN_FUNCTION = 3;
                Token.TOKEN_PARENTHESES_OPEN = 4;
                Token.TOKEN_PARENTHESES_CLOSE = 5;
                Token.TOKEN_VARIABLE = 6;
                Token.TOKEN_SEPARATOR = 7;
                tokenizer.Token = Token;
                Token["__class"] = "net.objecthunter.exp4j.tokenizer.Token";
            })(tokenizer = exp4j.tokenizer || (exp4j.tokenizer = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var __function;
            (function (__function) {
                /**
                 * Create a new Function with a given name and number of arguments
                 *
                 * @param {string} name the name of the Function
                 * @param {number} numArguments the number of arguments the function takes
                 * @class
                 */
                class _Function {
                    constructor(name, numArguments) {
                        if (((typeof name === 'string') || name === null) && ((typeof numArguments === 'number') || numArguments === null)) {
                            let __args = arguments;
                            if (this.name === undefined) {
                                this.name = null;
                            }
                            if (this.numArguments === undefined) {
                                this.numArguments = 0;
                            }
                            if (numArguments < 0) {
                                throw new java.lang.IllegalArgumentException("The number of function arguments can not be less than 0 for \'" + name + "\'");
                            }
                            if (!_Function.isValidFunctionName(name)) {
                                throw new java.lang.IllegalArgumentException("The function name \'" + name + "\' is invalid");
                            }
                            this.name = name;
                            this.numArguments = numArguments;
                        }
                        else if (((typeof name === 'string') || name === null) && numArguments === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let numArguments = 1;
                                if (this.name === undefined) {
                                    this.name = null;
                                }
                                if (this.numArguments === undefined) {
                                    this.numArguments = 0;
                                }
                                if (numArguments < 0) {
                                    throw new java.lang.IllegalArgumentException("The number of function arguments can not be less than 0 for \'" + name + "\'");
                                }
                                if (!_Function.isValidFunctionName(name)) {
                                    throw new java.lang.IllegalArgumentException("The function name \'" + name + "\' is invalid");
                                }
                                this.name = name;
                                this.numArguments = numArguments;
                            }
                            if (this.name === undefined) {
                                this.name = null;
                            }
                            if (this.numArguments === undefined) {
                                this.numArguments = 0;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Get the name of the Function
                     *
                     * @return {string} the name
                     */
                    getName() {
                        return this.name;
                    }
                    /**
                     * Get the number of arguments for this function
                     *
                     * @return {number} the number of arguments
                     */
                    getNumArguments() {
                        return this.numArguments;
                    }
                    /**
                     * Get the set of characters which are allowed for use in Function names.
                     *
                     * @return {char[]} the set of characters allowed
                     * @deprecated since 0.4.5 All unicode letters are allowed to be used in function names since 0.4.3. This API
                     * Function can be safely ignored. Checks for function name validity can be done using Character.isLetter() et al.
                     */
                    static getAllowedFunctionCharacters() {
                        const chars = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(53);
                        let count = 0;
                        for (let i = 65; i < 91; i++) {
                            {
                                chars[count++] = String.fromCharCode(i);
                            }
                            ;
                        }
                        for (let i = 97; i < 123; i++) {
                            {
                                chars[count++] = String.fromCharCode(i);
                            }
                            ;
                        }
                        chars[count] = '_';
                        return chars;
                    }
                    static isValidFunctionName(name) {
                        if (name == null) {
                            return false;
                        }
                        const size = name.length;
                        if (size === 0) {
                            return false;
                        }
                        return true;
                    }
                }
                __function._Function = _Function;
                _Function["__class"] = "net.objecthunter.exp4j.function._Function";
            })(__function = exp4j.__function || (exp4j.__function = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            /**
             * Creates a new expression that is a copy of the existing one.
             *
             * @param {net.objecthunter.exp4j.Expression} existing the expression to copy
             * @class
             */
            class Expression {
                constructor(tokens, userFunctionNames) {
                    if (((tokens != null && tokens instanceof Array && (tokens.length == 0 || tokens[0] == null || (tokens[0] != null && tokens[0] instanceof net.objecthunter.exp4j.tokenizer.Token))) || tokens === null) && ((userFunctionNames != null && (userFunctionNames.constructor != null && userFunctionNames.constructor["__interfaces"] != null && userFunctionNames.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || userFunctionNames === null)) {
                        let __args = arguments;
                        if (this.tokens === undefined) {
                            this.tokens = null;
                        }
                        if (this.variables === undefined) {
                            this.variables = null;
                        }
                        if (this.userFunctionNames === undefined) {
                            this.userFunctionNames = null;
                        }
                        this.tokens = tokens;
                        this.variables = Expression.createDefaultVariables();
                        this.userFunctionNames = userFunctionNames;
                    }
                    else if (((tokens != null && tokens instanceof net.objecthunter.exp4j.Expression) || tokens === null) && userFunctionNames === undefined) {
                        let __args = arguments;
                        let existing = __args[0];
                        if (this.tokens === undefined) {
                            this.tokens = null;
                        }
                        if (this.variables === undefined) {
                            this.variables = null;
                        }
                        if (this.userFunctionNames === undefined) {
                            this.userFunctionNames = null;
                        }
                        this.tokens = java.util.Arrays.copyOf(existing.tokens, existing.tokens.length);
                        this.variables = (new java.util.HashMap());
                        this.variables.putAll(existing.variables);
                        this.userFunctionNames = (new java.util.HashSet(existing.userFunctionNames));
                    }
                    else if (((tokens != null && tokens instanceof Array && (tokens.length == 0 || tokens[0] == null || (tokens[0] != null && tokens[0] instanceof net.objecthunter.exp4j.tokenizer.Token))) || tokens === null) && userFunctionNames === undefined) {
                        let __args = arguments;
                        if (this.tokens === undefined) {
                            this.tokens = null;
                        }
                        if (this.variables === undefined) {
                            this.variables = null;
                        }
                        if (this.userFunctionNames === undefined) {
                            this.userFunctionNames = null;
                        }
                        this.tokens = tokens;
                        this.variables = Expression.createDefaultVariables();
                        this.userFunctionNames = java.util.Collections.emptySet();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ static createDefaultVariables() {
                    const vars = (new java.util.HashMap(4));
                    vars.put("pi", Math.PI);
                    vars.put("\u03c0", Math.PI);
                    vars.put("\u03c6", 1.61803398874);
                    vars.put("e", Math.E);
                    return vars;
                }
                setVariable(name, value) {
                    this.checkVariableName(name);
                    this.variables.put(name, javaemul.internal.DoubleHelper.valueOf(value));
                    return this;
                }
                /*private*/ checkVariableName(name) {
                    if (this.userFunctionNames.contains(name) || net.objecthunter.exp4j.__function.Functions.getBuiltinFunction(name) != null) {
                        throw new java.lang.IllegalArgumentException("The variable name \'" + name + "\' is invalid. Since there exists a function with the same name");
                    }
                }
                setVariables(variables) {
                    for (let index = variables.entrySet().iterator(); index.hasNext();) {
                        let v = index.next();
                        {
                            this.setVariable(v.getKey(), v.getValue());
                        }
                    }
                    return this;
                }
                getVariableNames() {
                    const variables = (new java.util.HashSet());
                    for (let index = 0; index < this.tokens.length; index++) {
                        let t = this.tokens[index];
                        {
                            if (t.getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_VARIABLE)
                                variables.add(t.getName());
                        }
                    }
                    return variables;
                }
                validate$boolean(checkVariablesSet) {
                    const errors = (new java.util.ArrayList(0));
                    if (checkVariablesSet) {
                        for (let index = 0; index < this.tokens.length; index++) {
                            let t = this.tokens[index];
                            {
                                if (t.getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_VARIABLE) {
                                    const _var = t.getName();
                                    if (!this.variables.containsKey(_var)) {
                                        errors.add("The setVariable \'" + _var + "\' has not been set");
                                    }
                                }
                            }
                        }
                    }
                    let count = 0;
                    for (let index = 0; index < this.tokens.length; index++) {
                        let tok = this.tokens[index];
                        {
                            switch ((tok.getType())) {
                                case net.objecthunter.exp4j.tokenizer.Token.TOKEN_NUMBER:
                                case net.objecthunter.exp4j.tokenizer.Token.TOKEN_VARIABLE:
                                    count++;
                                    break;
                                case net.objecthunter.exp4j.tokenizer.Token.TOKEN_FUNCTION:
                                    const func = tok.getFunction();
                                    const argsNum = func.getNumArguments();
                                    if (argsNum > count) {
                                        errors.add("Not enough arguments for \'" + func.getName() + "\'");
                                    }
                                    if (argsNum > 1) {
                                        count -= argsNum - 1;
                                    }
                                    else if (argsNum === 0) {
                                        count++;
                                    }
                                    break;
                                case net.objecthunter.exp4j.tokenizer.Token.TOKEN_OPERATOR:
                                    const op = tok.getOperator();
                                    if (op.getNumOperands() === 2) {
                                        count--;
                                    }
                                    break;
                            }
                            if (count < 1) {
                                errors.add("Too many operators");
                                return new net.objecthunter.exp4j.ValidationResult(false, errors);
                            }
                        }
                    }
                    if (count > 1) {
                        errors.add("Too many operands");
                    }
                    return errors.size() === 0 ? net.objecthunter.exp4j.ValidationResult.SUCCESS_$LI$() : new net.objecthunter.exp4j.ValidationResult(false, errors);
                }
                validate(checkVariablesSet) {
                    if (((typeof checkVariablesSet === 'boolean') || checkVariablesSet === null)) {
                        return this.validate$boolean(checkVariablesSet);
                    }
                    else if (checkVariablesSet === undefined) {
                        return this.validate$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                validate$() {
                    return this.validate$boolean(true);
                }
                evaluate() {
                    const output = new net.objecthunter.exp4j.ArrayStack();
                    for (let i = 0; i < this.tokens.length; i++) {
                        {
                            const t = this.tokens[i];
                            if (t.getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_NUMBER) {
                                output.push(t.getValue());
                            }
                            else if (t.getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_VARIABLE) {
                                const name = t.getName();
                                const value = this.variables.get(name);
                                if (value == null) {
                                    throw new java.lang.IllegalArgumentException("No value has been set for the setVariable \'" + name + "\'.");
                                }
                                output.push(value);
                            }
                            else if (t.getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_OPERATOR) {
                                const op = t;
                                if (output.size() < op.getOperator().getNumOperands()) {
                                    throw new java.lang.IllegalArgumentException("Invalid number of operands available for \'" + op.getOperator().getSymbol() + "\' operator");
                                }
                                if (op.getOperator().getNumOperands() === 2) {
                                    const rightArg = output.pop();
                                    const leftArg = output.pop();
                                    output.push(op.getOperator().apply(leftArg, rightArg));
                                }
                                else if (op.getOperator().getNumOperands() === 1) {
                                    const arg = output.pop();
                                    output.push(op.getOperator().apply(arg));
                                }
                            }
                            else if (t.getType() === net.objecthunter.exp4j.tokenizer.Token.TOKEN_FUNCTION) {
                                const func = t;
                                const numArguments = func.getFunction().getNumArguments();
                                if (output.size() < numArguments) {
                                    throw new java.lang.IllegalArgumentException("Invalid number of arguments available for \'" + func.getFunction().getName() + "\' function");
                                }
                                const args = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(numArguments);
                                for (let j = numArguments - 1; j >= 0; j--) {
                                    {
                                        args[j] = output.pop();
                                    }
                                    ;
                                }
                                output.push((o => o.apply.apply(o, args))(func.getFunction()));
                            }
                        }
                        ;
                    }
                    if (output.size() > 1) {
                        throw new java.lang.IllegalArgumentException("Invalid number of items on the output queue. Might be caused by an invalid number of arguments for a function.");
                    }
                    return output.pop();
                }
            }
            exp4j.Expression = Expression;
            Expression["__class"] = "net.objecthunter.exp4j.Expression";
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            /**
             * Simple double stack using a double array as data storage
             *
             * @author Federico Vera (dktcoding [at] gmail)
             * @class
             */
            class ArrayStack {
                constructor(initialCapacity) {
                    if (((typeof initialCapacity === 'number') || initialCapacity === null)) {
                        let __args = arguments;
                        if (this.data === undefined) {
                            this.data = null;
                        }
                        if (this.idx === undefined) {
                            this.idx = 0;
                        }
                        if (initialCapacity <= 0) {
                            throw new java.lang.IllegalArgumentException("Stack\'s capacity must be positive");
                        }
                        this.data = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(initialCapacity);
                        this.idx = -1;
                    }
                    else if (initialCapacity === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let initialCapacity = 5;
                            if (this.data === undefined) {
                                this.data = null;
                            }
                            if (this.idx === undefined) {
                                this.idx = 0;
                            }
                            if (initialCapacity <= 0) {
                                throw new java.lang.IllegalArgumentException("Stack\'s capacity must be positive");
                            }
                            this.data = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(initialCapacity);
                            this.idx = -1;
                        }
                        if (this.data === undefined) {
                            this.data = null;
                        }
                        if (this.idx === undefined) {
                            this.idx = 0;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                push(value) {
                    if (this.idx + 1 === this.data.length) {
                        const temp = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(((this.data.length * 1.2) | 0) + 1);
                        java.lang.System.arraycopy(this.data, 0, temp, 0, this.data.length);
                        this.data = temp;
                    }
                    this.data[++this.idx] = value;
                }
                peek() {
                    if (this.idx === -1) {
                        throw new java.util.EmptyStackException();
                    }
                    return this.data[this.idx];
                }
                pop() {
                    if (this.idx === -1) {
                        throw new java.util.EmptyStackException();
                    }
                    return this.data[this.idx--];
                }
                isEmpty() {
                    return this.idx === -1;
                }
                size() {
                    return this.idx + 1;
                }
            }
            exp4j.ArrayStack = ArrayStack;
            ArrayStack["__class"] = "net.objecthunter.exp4j.ArrayStack";
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var operator;
            (function (operator) {
                /**
                 * Create a new operator for use in expressions
                 * @param {string} symbol the symbol of the operator
                 * @param {number} numberOfOperands the number of operands the operator takes (1 or 2)
                 * @param {boolean} leftAssociative set to true if the operator is left associative, false if it is right associative
                 * @param {number} precedence the precedence value of the operator
                 * @class
                 */
                class Operator {
                    constructor(symbol, numberOfOperands, leftAssociative, precedence) {
                        if (this.numOperands === undefined) {
                            this.numOperands = 0;
                        }
                        if (this.leftAssociative === undefined) {
                            this.leftAssociative = false;
                        }
                        if (this.symbol === undefined) {
                            this.symbol = null;
                        }
                        if (this.precedence === undefined) {
                            this.precedence = 0;
                        }
                        this.numOperands = numberOfOperands;
                        this.leftAssociative = leftAssociative;
                        this.symbol = symbol;
                        this.precedence = precedence;
                    }
                    static PRECEDENCE_SUBTRACTION_$LI$() { if (Operator.PRECEDENCE_SUBTRACTION == null) {
                        Operator.PRECEDENCE_SUBTRACTION = Operator.PRECEDENCE_ADDITION;
                    } return Operator.PRECEDENCE_SUBTRACTION; }
                    static PRECEDENCE_DIVISION_$LI$() { if (Operator.PRECEDENCE_DIVISION == null) {
                        Operator.PRECEDENCE_DIVISION = Operator.PRECEDENCE_MULTIPLICATION;
                    } return Operator.PRECEDENCE_DIVISION; }
                    static PRECEDENCE_MODULO_$LI$() { if (Operator.PRECEDENCE_MODULO == null) {
                        Operator.PRECEDENCE_MODULO = Operator.PRECEDENCE_DIVISION_$LI$();
                    } return Operator.PRECEDENCE_MODULO; }
                    static PRECEDENCE_UNARY_PLUS_$LI$() { if (Operator.PRECEDENCE_UNARY_PLUS == null) {
                        Operator.PRECEDENCE_UNARY_PLUS = Operator.PRECEDENCE_UNARY_MINUS;
                    } return Operator.PRECEDENCE_UNARY_PLUS; }
                    static ALLOWED_OPERATOR_CHARS_$LI$() { if (Operator.ALLOWED_OPERATOR_CHARS == null) {
                        Operator.ALLOWED_OPERATOR_CHARS = ['+', '-', '*', '/', '%', '^', '!', '#', '\u00a7', '$', '&', ';', ':', '~', '<', '>', '|', '='];
                    } return Operator.ALLOWED_OPERATOR_CHARS; }
                    /**
                     * Check if a character is an allowed operator char
                     * @param {string} ch the char to check
                     * @return {boolean} true if the char is allowed an an operator symbol, false otherwise
                     */
                    static isAllowedOperatorChar(ch) {
                        for (let index = 0; index < Operator.ALLOWED_OPERATOR_CHARS_$LI$().length; index++) {
                            let allowed = Operator.ALLOWED_OPERATOR_CHARS_$LI$()[index];
                            {
                                if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) == (c => c.charCodeAt == null ? c : c.charCodeAt(0))(allowed)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    /**
                     * Check if the operator is left associative
                     * @return {boolean} true os the operator is left associative, false otherwise
                     */
                    isLeftAssociative() {
                        return this.leftAssociative;
                    }
                    /**
                     * Check the precedence value for the operator
                     * @return {number} the precedence value
                     */
                    getPrecedence() {
                        return this.precedence;
                    }
                    /**
                     * Get the operator symbol
                     * @return {string} the symbol
                     */
                    getSymbol() {
                        return this.symbol;
                    }
                    /**
                     * Get the number of operands
                     * @return {number} the number of operands
                     */
                    getNumOperands() {
                        return this.numOperands;
                    }
                }
                /**
                 * The precedence value for the addition operation
                 */
                Operator.PRECEDENCE_ADDITION = 500;
                /**
                 * The precedence value for the multiplication operation
                 */
                Operator.PRECEDENCE_MULTIPLICATION = 1000;
                /**
                 * The precedence value for the power operation
                 */
                Operator.PRECEDENCE_POWER = 10000;
                /**
                 * The precedence value for the unary minus operation
                 */
                Operator.PRECEDENCE_UNARY_MINUS = 5000;
                operator.Operator = Operator;
                Operator["__class"] = "net.objecthunter.exp4j.operator.Operator";
            })(operator = exp4j.operator || (exp4j.operator = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
var framework;
(function (framework) {
    class Preferences {
        constructor() {
            this.showAxis = true;
            this.showGrid = true;
            this.MAX_RAY_INTERACTIONS = 10;
            this.ImageColor = new framework.Color(180, 100, 100, 220);
            this.virtualRaysColor = new framework.Color(190, 190, 40, 240);
            this.selectedColor = new framework.Color(100, 100, 200, 200);
            this.gridSize = 0.1;
            this.backgroundColor = new framework.Color(24, 24, 24);
            this.gridColor = new framework.Color(130, 130, 120, 150);
            this.axisColor = new framework.Color(250, 120, 40, 255);
            this.textColor = new framework.Color(255, 255, 255);
            this.tooltipColor = new framework.Color(255, 255, 255, 180);
            if (this.DPI_FACTOR === undefined) {
                this.DPI_FACTOR = 0;
            }
        }
        snapToGrid(p) {
            if (!this.showGrid)
                return p;
            const x = Math.round(p.x / this.gridSize) * this.gridSize;
            const y = Math.round(p.y / this.gridSize) * this.gridSize;
            return new math.Vector2(x, y);
        }
        static getEpsilon() {
            return Preferences.EPSILON;
        }
        static getMaxSignifucantFigures() {
            return 2;
        }
        static getRandomColor() {
            return new framework.Color(math.MathUtils.random$int$int(160, 255), math.MathUtils.random$int$int(160, 255), math.MathUtils.random$int$int(160, 255), 160);
        }
    }
    Preferences.EPSILON = 1.0E-12;
    framework.Preferences = Preferences;
    Preferences["__class"] = "framework.Preferences";
})(framework || (framework = {}));
(function (framework) {
    var input;
    (function (input) {
        class AbstractInputHandler {
            constructor() {
                if (this.enabled === undefined) {
                    this.enabled = false;
                }
                if (this.additive === undefined) {
                    this.additive = false;
                }
                if (this.dependentBehaviors === undefined) {
                    this.dependentBehaviors = null;
                }
                this.enabled = true;
                this.additive = false;
                this.dependentBehaviors = (new java.util.ArrayList());
            }
            /**
             *
             * @return {boolean}
             */
            isEnabled() {
                return this.enabled;
            }
            /**
             *
             * @param {boolean} flag
             */
            setEnabled(flag) {
                this.enabled = flag;
            }
            getDependentBehaviors() {
                return this.dependentBehaviors;
            }
            /**
             *
             * @return {boolean}
             */
            isDependentBehaviorActive() {
                let result = false;
                for (let index = this.dependentBehaviors.iterator(); index.hasNext();) {
                    let behavior = index.next();
                    {
                        if (behavior.isActive()) {
                            result = true;
                        }
                    }
                }
                if (this.additive)
                    return !result;
                return result;
            }
            /**
             *
             * @return {boolean}
             */
            isDependentBehaviorsAdditive() {
                return this.additive;
            }
            /**
             *
             * @param {boolean} flag
             */
            setDependentBehaviorsAdditive(flag) {
                this.additive = flag;
            }
        }
        input.AbstractInputHandler = AbstractInputHandler;
        AbstractInputHandler["__class"] = "framework.input.AbstractInputHandler";
        AbstractInputHandler["__interfaces"] = ["framework.input.InputHandler"];
    })(input = framework.input || (framework.input = {}));
})(framework || (framework = {}));
(function (framework) {
    class ClassUtils {
        static isAssignableFrom(A, B) {
            return (A == B) || (B.prototype instanceof A);
        }
        static isInstanceof(o, clazz) {
            return o != null && o instanceof clazz;
        }
        static createInstance(clazz, params) {
            return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6]);
        }
    }
    framework.ClassUtils = ClassUtils;
    ClassUtils["__class"] = "framework.ClassUtils";
})(framework || (framework = {}));
(function (framework) {
    class EditInfo {
        constructor() {
            this.type = EditInfo.TYPE.EXPRESSION;
            this.value = null;
            this.choices = null;
            this.min = javaemul.internal.DoubleHelper.MIN_VALUE;
            this.max = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
            this.name = "?";
        }
        set$java_lang_String$math_Vector2(name, value) {
            this.name = name;
            this.type = EditInfo.TYPE.VECTOR;
            this.value = math.MathUtils.formatValue(value.x, false) + "," + math.MathUtils.formatValue(value.y, false);
            return this;
        }
        set$java_lang_String$boolean(name, value) {
            this.name = name;
            this.type = EditInfo.TYPE.BOOLEAN;
            this.value = value;
            return this;
        }
        set$java_lang_String$int$double$double(name, value, min, max) {
            this.name = name;
            this.type = EditInfo.TYPE.INTEGER;
            this.min = min;
            this.max = max;
            this.value = value;
            return this;
        }
        set(name, value, min, max) {
            if (((typeof name === 'string') || name === null) && ((typeof value === 'number') || value === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                return this.set$java_lang_String$int$double$double(name, value, min, max);
            }
            else if (((typeof name === 'string') || name === null) && ((typeof value === 'number') || value === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                return this.set$java_lang_String$double$double$double(name, value, min, max);
            }
            else if (((typeof name === 'string') || name === null) && ((typeof value === 'string') || value === null) && ((min != null && min instanceof Array && (min.length == 0 || min[0] == null || (typeof min[0] === 'string'))) || min === null) && max === undefined) {
                return this.set$java_lang_String$java_lang_String$java_lang_String_A(name, value, min);
            }
            else if (((typeof name === 'string') || name === null) && ((typeof value === 'number') || value === null) && ((min != null && min instanceof Array && (min.length == 0 || min[0] == null || (typeof min[0] === 'string'))) || min === null) && max === undefined) {
                return this.set$java_lang_String$int$java_lang_String_A(name, value, min);
            }
            else if (((typeof name === 'string') || name === null) && ((value != null && value instanceof math.Vector2) || value === null) && min === undefined && max === undefined) {
                return this.set$java_lang_String$math_Vector2(name, value);
            }
            else if (((typeof name === 'string') || name === null) && ((typeof value === 'string') || value === null) && min === undefined && max === undefined) {
                return this.set$java_lang_String$java_lang_String(name, value);
            }
            else if (((typeof name === 'string') || name === null) && ((value != null && value instanceof framework.Color) || value === null) && min === undefined && max === undefined) {
                return this.set$java_lang_String$framework_Color(name, value);
            }
            else if (((typeof name === 'string') || name === null) && ((typeof value === 'boolean') || value === null) && min === undefined && max === undefined) {
                return this.set$java_lang_String$boolean(name, value);
            }
            else
                throw new Error('invalid overload');
        }
        set$java_lang_String$double$double$double(name, value, min, max) {
            this.name = name;
            this.type = EditInfo.TYPE.DOUBLE;
            this.min = min;
            this.max = max;
            this.value = value;
            return this;
        }
        set$java_lang_String$java_lang_String(name, text) {
            this.name = name;
            this.type = EditInfo.TYPE.MULTILINE_TEXT;
            this.value = text;
            return this;
        }
        set$java_lang_String$java_lang_String$java_lang_String_A(name, expr, vars) {
            this.name = name;
            this.type = EditInfo.TYPE.EXPRESSION;
            this.value = expr;
            this.choices = vars;
            return this;
        }
        set$java_lang_String$int$java_lang_String_A(name, choiceIndex, choices) {
            this.name = name;
            this.type = EditInfo.TYPE.CHOICE;
            this.value = choices[choiceIndex];
            this.choices = choices;
            return this;
        }
        set$java_lang_String$framework_Color(name, color) {
            this.name = name;
            this.type = EditInfo.TYPE.COLOR;
            this.value = color;
            return this;
        }
    }
    framework.EditInfo = EditInfo;
    EditInfo["__class"] = "framework.EditInfo";
    (function (EditInfo) {
        let TYPE;
        (function (TYPE) {
            TYPE[TYPE["BOOLEAN"] = 0] = "BOOLEAN";
            TYPE[TYPE["INTEGER"] = 1] = "INTEGER";
            TYPE[TYPE["DOUBLE"] = 2] = "DOUBLE";
            TYPE[TYPE["EXPRESSION"] = 3] = "EXPRESSION";
            TYPE[TYPE["CHOICE"] = 4] = "CHOICE";
            TYPE[TYPE["COLOR"] = 5] = "COLOR";
            TYPE[TYPE["STRING"] = 6] = "STRING";
            TYPE[TYPE["BOOLEAN_EXPRESSION"] = 7] = "BOOLEAN_EXPRESSION";
            TYPE[TYPE["VECTOR"] = 8] = "VECTOR";
            TYPE[TYPE["MULTILINE_TEXT"] = 9] = "MULTILINE_TEXT";
        })(TYPE = EditInfo.TYPE || (EditInfo.TYPE = {}));
    })(EditInfo = framework.EditInfo || (framework.EditInfo = {}));
})(framework || (framework = {}));
(function (framework) {
    /**
     * Attaches renderer with default canvas (id ="canvas")
     * @param {HTMLCanvasElement} canvas
     * @class
     */
    class Renderer {
        constructor(canvas) {
            if (this.context === undefined) {
                this.context = null;
            }
            if (this.DPI_FACTOR === undefined) {
                this.DPI_FACTOR = 0;
            }
            this.METER_TO_PIXEL = 100;
            this.scaleFactor = 100;
            this.DPI_FACTOR = window.devicePixelRatio;
            this.context = canvas.getContext("2d");
            this.context.lineJoin = "round";
            this.context.lineCap = "round";
            this.context.lineWidth = 1.5;
        }
        /**
         * Applies camera transformations to the drawing context, must be followed by {@link #end(Camera)}
         * <pre>
         * renderer.begin();
         * ... draw Stuff
         * renderer.end();
         * </pre>
         * @param {framework.Camera} camera
         */
        begin(camera) {
            this.context.save();
            this.context.scale(this.DPI_FACTOR, this.DPI_FACTOR);
            this.context.fillRect(0, 0, camera.screenWidth, camera.screenHeight);
            this.context.translate(camera.screenWidth / 2, camera.screenHeight / 2);
            this.context.translate(camera.offsetX, -camera.offsetY);
            const scale = camera.getScale();
            this.context.scale(scale, -scale);
            this.context.lineWidth = 1 / scale;
            this.METER_TO_PIXEL = camera.METER_TO_PIXEL;
            this.scaleFactor = scale;
        }
        end(camera) {
            this.context.restore();
        }
        setColors(fillColor, strokeColor) {
            if (fillColor != null)
                this.context.fillStyle = fillColor.toString();
            if (strokeColor != null)
                this.context.strokeStyle = strokeColor.toString();
        }
        setLineWidth(lw) {
            this.context.lineWidth = lw * this.DPI_FACTOR / this.scaleFactor;
        }
        setFont(font) {
            this.context.font = font;
        }
        fillAndStroke(color) {
            if (color != null)
                this.context.fillStyle = color.toString();
            this.context.fill();
            if (color != null)
                this.context.strokeStyle = color.darker().toString();
            this.context.stroke();
        }
        drawText$java_lang_String$double$double(txt, x, y) {
            this.context.save();
            this.context.translate(x, y);
            this.context.scale(1.8 / this.METER_TO_PIXEL, -1.8 / this.METER_TO_PIXEL);
            this.context.fillText(txt, 0, 0);
            this.context.restore();
        }
        drawLine(x1, y1, x2, y2) {
            this.context.beginPath();
            this.context.moveTo(x1, y1);
            this.context.lineTo(x2, y2);
            this.context.stroke();
        }
        drawText$java_lang_String$math_Vector2$math_Vector2(txt, v1, v2) {
            const v = v1.to$math_Vector2(v2);
            const th = v.isZero() ? 0 : Math.atan(v.y / v.x);
            v.set$double$double((v1.x + v2.x) * 0.5, (v1.y + v2.y) * 0.5 + 5 / this.METER_TO_PIXEL);
            this.context.save();
            this.context.translate(v.x, v.y);
            this.context.rotate(th);
            this.context.scale(2 / this.METER_TO_PIXEL, -2 / this.METER_TO_PIXEL);
            this.context.fillText(txt, 0, 0);
            this.context.restore();
        }
        drawText(txt, v1, v2) {
            if (((typeof txt === 'string') || txt === null) && ((v1 != null && v1 instanceof math.Vector2) || v1 === null) && ((v2 != null && v2 instanceof math.Vector2) || v2 === null)) {
                return this.drawText$java_lang_String$math_Vector2$math_Vector2(txt, v1, v2);
            }
            else if (((typeof txt === 'string') || txt === null) && ((typeof v1 === 'number') || v1 === null) && ((typeof v2 === 'number') || v2 === null)) {
                return this.drawText$java_lang_String$double$double(txt, v1, v2);
            }
            else
                throw new Error('invalid overload');
        }
        drawArc(x, y, r, startAngle, angleExtent, acw) {
            this.context.beginPath();
            this.context.arc(x, y, r, startAngle, startAngle + angleExtent, acw);
            this.context.stroke();
        }
        /**
         * Renders the given {@link Circle} to the given graphics context using the
         * given scale and color.
         *
         * @param g      the graphics context
         * @param circle the circle to render
         * @param scale  the scale to render the shape (pixels per dyn4j unit (typically
         * meter))
         * @param color  the color
         * @param {number} cx
         * @param {number} cy
         * @param {number} r
         * @param {boolean} fill
         * @param {boolean} stroke
         */
        drawCircle(cx, cy, r, fill, stroke) {
            this.context.beginPath();
            this.context.arc(cx, cy, r, 0, Math.PI * 2, false);
            if (fill)
                this.context.fill();
            if (stroke)
                this.context.stroke();
        }
        drawOval(cx, cy, rx, ry, theta, fill, stroke) {
            this.context.beginPath();
            this.context.ellipse(cx, cy, rx, ry, theta, 0, Math.PI * 2);
            if (fill)
                this.context.fill();
            if (stroke)
                this.context.stroke();
        }
        drawRect(x, y, w, h, fill, stroke) {
            if (fill)
                this.context.fillRect(x, y, w, h);
            if (stroke)
                this.context.strokeRect(x, y, w, h);
        }
        /**
         * Draws a arrow with open lines from the given start in the direction of (dx, dy) with length l.
         * @param gl the OpenGL context
         * @param {number} sx the x coordinate of the start point
         * @param {number} sy the y coordinate of the start point
         * @param {number} dx the x value of the direction
         * @param {number} dy the y value of the direction
         * @param {number} l the length
         */
        drawArrow(sx, sy, dx, dy, l) {
            this.context.beginPath();
            this.context.moveTo(sx, sy);
            this.context.lineTo(sx + dx * l, sy + dy * l);
            this.context.stroke();
            let arrowhead = 0.15;
            if (l < 2 * arrowhead)
                arrowhead = l / 2;
            this.context.moveTo(sx + dx * (l - arrowhead) + 0.5 * arrowhead * dy, sy + dy * (l - arrowhead) - 0.5 * arrowhead * dx);
            this.context.lineTo(sx + dx * l, sy + dy * l);
            this.context.lineTo(sx + dx * (l - arrowhead) - 0.5 * arrowhead * dy, sy + dy * (l - arrowhead) + 0.5 * arrowhead * dx);
            this.context.stroke();
        }
        /**
         * Renders the given {@link Polygon} to the given graphics context using the
         * given scale and color.
         *
         * @param g       the graphics context
         * @param polygon the polygon to render
         * @param scale   the scale to render the shape (pixels per dyn4j unit
         * (typically meter))
         * @param color   the color
         * @param {math.Vector2[]} vertices
         * @param {boolean} fill
         * @param {boolean} stroke
         */
        drawPolygon(vertices, fill, stroke) {
            const l = vertices.length;
            this.context.beginPath();
            this.context.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < l; i++) {
                {
                    this.context.lineTo(vertices[i].x, vertices[i].y);
                }
                ;
            }
            this.context.closePath();
            if (fill)
                this.context.fill();
            if (stroke)
                this.context.stroke();
        }
        /**
         * Renders the given {@link Segment} to the given graphics context using the
         * given scale and color.
         *
         * @param g       the graphics context
         * @param segment the segment to render
         * @param scale   the scale to render the shape (pixels per dyn4j unit
         * (typically meter))
         * @param color   the color
         * @param {math.Vector2[]} vertices
         */
        drawPolylines(vertices) {
            const l = vertices.length;
            this.context.beginPath();
            this.context.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < l; i++) {
                {
                    this.context.lineTo(vertices[i].x, vertices[i].y);
                }
                ;
            }
            this.context.stroke();
        }
        /**
         * Draws the grids on given bounds object.
         * @param {number} minX
         * @param {number} minY
         * @param {number} maxX
         * @param {number} maxY
         * @param {number} gridSize
         * @param {framework.Color} gridColor
         */
        drawGrid(minX, minY, maxX, maxY, gridSize, gridColor) {
            const initX = Math.floor(minX / gridSize) * gridSize;
            const initY = Math.floor(minY / gridSize) * gridSize;
            const endX = Math.ceil(maxX / gridSize) * gridSize;
            const endY = Math.ceil(maxY / gridSize) * gridSize;
            this.setColors(null, gridColor);
            this.context.beginPath();
            for (let x = initX; x < endX; x += gridSize) {
                {
                    this.context.moveTo(x, initY);
                    this.context.lineTo(x, endY);
                }
                ;
            }
            for (let y = initY; y < endY; y += gridSize) {
                {
                    this.context.moveTo(initX, y);
                    this.context.lineTo(endX, y);
                }
                ;
            }
            this.context.stroke();
        }
        drawAxes(minX, minY, maxX, maxY, tickSize, tickGap, drawValues, axesColor) {
            const initX = Math.floor(minX / tickGap) * tickGap;
            const initY = Math.floor(minY / tickGap) * tickGap;
            const endX = Math.ceil(maxX / tickGap) * tickGap;
            const endY = Math.ceil(maxY / tickGap) * tickGap;
            const tm = this.context.measureText("0.0");
            const th = tm.width / this.METER_TO_PIXEL;
            const tw = tm.width / this.METER_TO_PIXEL;
            const majorTickSize = tickSize;
            this.context.save();
            this.setColors(axesColor, axesColor);
            this.setLineWidth(1.0);
            if (initY < 0 && endY > 0) {
                let offsetY = th;
                this.context.textAlign = "center";
                if ((initY + endY) / 2 > 0) {
                    this.context.textBaseline = "bottom";
                    offsetY = majorTickSize + th;
                }
                else {
                    this.context.textBaseline = "top";
                    offsetY = -majorTickSize - th;
                }
                this.drawArrow(0, 0, 1, 0, maxX);
                this.drawArrow(0, 0, -1, 0, -minX);
                this.setLineWidth(0.7);
                for (let x = initX; x < endX; x += tickGap) {
                    {
                        if (x === 0)
                            continue;
                        this.drawLine(x, -tickSize, x, tickSize);
                        this.drawText$java_lang_String$double$double(math.MathUtils.roundOffToPreferredSigFigures(x) + "", x, offsetY);
                    }
                    ;
                }
            }
            this.setLineWidth(1.0);
            if (initX < 0 && endX > 0) {
                let offsetX = tw;
                this.context.textBaseline = "middle";
                if ((initX + endX) / 2 > 0) {
                    this.context.textAlign = "left";
                    offsetX = majorTickSize + th;
                }
                else {
                    this.context.textAlign = "right";
                    offsetX = -majorTickSize - th;
                }
                this.drawArrow(0, 0, 0, 1, maxY);
                this.drawArrow(0, 0, 0, -1, -minY);
                this.setLineWidth(0.7);
                for (let y = initY; y < endY; y += tickGap) {
                    {
                        if (y === 0)
                            continue;
                        this.drawLine(-tickSize, y, tickSize, y);
                        this.drawText$java_lang_String$double$double(math.MathUtils.roundOffToPreferredSigFigures(y) + "", offsetX, y);
                    }
                    ;
                }
            }
            this.context.restore();
        }
        /**
         * Fills the SLICE from centre
         * @param gl the OpenGL context
         * @param {number} cx the x coordinate of the center
         * @param {number} cy the y coordinate of the center
         * @param {number} r radius
         * @param {number} theta
         * @param offsetAnge
         * @param {number} offsetAngle
         * @param {boolean} fill
         * @param {boolean} stroke
         */
        drawSlice(cx, cy, r, theta, offsetAngle, fill, stroke) {
            this.context.beginPath();
            this.context.moveTo(cx, cy);
            this.context.arc(cx, cy, r, offsetAngle, offsetAngle + theta);
            this.context.closePath();
            if (fill)
                this.context.fill();
            if (stroke)
                this.context.stroke();
        }
        /**
         * Draws a vector with arrow head from the given start in the direction of (dx, dy) with length l.
         * @param gl the OpenGL context
         * @param {number} sx the x coordinate of the start point
         * @param {number} sy the y coordinate of the start point
         * @param {number} dx the x value of the direction
         * @param {number} dy the y value of the direction
         * @param {number} l the length
         * @param {boolean} drawEdges if true line are drawn at each side of arrow
         */
        drawDoubleVector(sx, sy, dx, dy, l, drawEdges) {
            this.drawLine(sx, sy, sx + dx * l, sy + dy * l);
            let arrowhead = 0.07;
            if (l < arrowhead)
                arrowhead = l;
            this.context.beginPath();
            if (drawEdges) {
                this.context.moveTo(sx - dy * arrowhead, sy + dx * arrowhead);
                this.context.lineTo(sx + dy * arrowhead, sy - dx * arrowhead);
            }
            this.context.moveTo(sx + dx * l, sy + dy * l);
            this.context.lineTo(sx + dx * (l - arrowhead) + 0.4 * arrowhead * dy, sy + dy * (l - arrowhead) - 0.5 * arrowhead * dx);
            this.context.moveTo(sx + dx * l, sy + dy * l);
            this.context.lineTo(sx + dx * (l - arrowhead) - 0.4 * arrowhead * dy, sy + dy * (l - arrowhead) + 0.5 * arrowhead * dx);
            sx = sx + dx * l;
            sy = sy + dy * l;
            dx = -dx;
            dy = -dy;
            if (drawEdges) {
                this.context.moveTo(sx - dy * arrowhead, sy + dx * arrowhead);
                this.context.lineTo(sx + dy * arrowhead, sy - dx * arrowhead);
            }
            this.context.moveTo(sx + dx * l, sy + dy * l);
            this.context.lineTo(sx + dx * (l - arrowhead) + 0.4 * arrowhead * dy, sy + dy * (l - arrowhead) - 0.5 * arrowhead * dx);
            this.context.moveTo(sx + dx * l, sy + dy * l);
            this.context.lineTo(sx + dx * (l - arrowhead) - 0.4 * arrowhead * dy, sy + dy * (l - arrowhead) + 0.5 * arrowhead * dx);
            this.context.stroke();
        }
    }
    framework.Renderer = Renderer;
    Renderer["__class"] = "framework.Renderer";
})(framework || (framework = {}));
(function (framework) {
    /**
     * Constructor.
     * @param {string} canvasId
     * @class
     */
    class App {
        constructor(canvasId) {
            this.paused = false;
            if (this.addShapeAction === undefined) {
                this.addShapeAction = null;
            }
            if (this.picking === undefined) {
                this.picking = null;
            }
            if (this.panning === undefined) {
                this.panning = null;
            }
            if (this.cameraKey === undefined) {
                this.cameraKey = null;
            }
            if (this.controlsKey === undefined) {
                this.controlsKey = null;
            }
            if (this.renderer === undefined) {
                this.renderer = null;
            }
            if (this.canvas === undefined) {
                this.canvas = null;
            }
            if (this.camera === undefined) {
                this.camera = null;
            }
            if (this.shapesManager === undefined) {
                this.shapesManager = null;
            }
            if (this.preferences === undefined) {
                this.preferences = null;
            }
            this.statusInfo = null;
            this.last = -1;
            this.fillWindow = false;
            this.TMP = [0, 0, 0, 0];
            this.preferences = new framework.Preferences();
            this.canvas = document.getElementById(canvasId);
            this.renderer = new framework.Renderer(this.canvas);
            this.camera = new framework.Camera();
            this.shapesManager = new geom.ShapesManager(this);
            this.setCanvasSize(this.canvas.width, this.canvas.height);
            window.onresize = (e) => {
                const body = document.querySelector("body");
                if (this.fillWindow) {
                    this.setCanvasSize(body.clientWidth, body.clientHeight);
                }
                else {
                    this.setCanvasSize(this.canvas.clientWidth, this.canvas.clientHeight);
                }
                return null;
            };
            this.addShapeAction = new geom.AddShapeAction(this);
            this.addShapeAction.install();
            this.picking = new framework.input.MousePickingInputHandler(this);
            this.picking.install();
            this.panning = new framework.input.MousePanningInputHandler(this);
            this.panning.install();
            this.picking.getDependentBehaviors().add(this.addShapeAction);
            this.panning.getDependentBehaviors().add(this.addShapeAction);
            this.panning.getDependentBehaviors().add(this.picking);
            this.cameraKey = new framework.input.KeyBoardCameraHandler(this);
            this.cameraKey.install();
            this.controlsKey = new framework.input.KeyBoardControlsHandler(this);
            this.controlsKey.install();
            window.requestAnimationFrame((time) => {
                this.update(time);
            });
        }
        /*private*/ setCanvasSize(width, height) {
            const DPI_FACTOR = window.devicePixelRatio;
            this.preferences.DPI_FACTOR = DPI_FACTOR;
            this.canvas.width = DPI_FACTOR * width;
            this.canvas.height = DPI_FACTOR * height;
            this.canvas.style.width = width + "px";
            this.canvas.style.height = height + "px";
            this.camera.updateViewport(width, height);
        }
        /*private*/ update(time) {
            if (this.last < 0 || this.paused)
                this.last = time;
            const dt = this.last - time;
            this.last = time;
            this.shapesManager.update(dt);
            const min = this.camera.toWorldCoordinates(0, this.camera.screenHeight);
            const max = this.camera.toWorldCoordinates(this.camera.screenWidth, 0);
            this.shapesManager.setWorldBounds(min.x, min.y, max.x, max.y);
            this.renderer.setColors(this.preferences.backgroundColor, this.preferences.axisColor);
            this.renderer.begin(this.camera);
            if (this.preferences.showAxis)
                this.renderer.drawGrid(min.x, min.y, max.x, max.y, 5 * this.preferences.gridSize, this.preferences.gridColor);
            if (this.preferences.showGrid)
                this.renderer.drawAxes(min.x, min.y, max.x, max.y, this.preferences.gridSize, this.preferences.gridSize * 10, true, this.preferences.axisColor);
            this.renderer.setColors(this.preferences.textColor, this.preferences.textColor);
            this.shapesManager.render(this.renderer);
            if (this.statusInfo != null) {
                this.renderer.drawText$java_lang_String$double$double(this.statusInfo, min.x + 0.3, max.y - 0.3);
            }
            this.renderer.end(this.camera);
            window.requestAnimationFrame((t) => {
                this.update(t);
            });
        }
        pause() {
            this.paused = true;
            this.last = -1;
        }
        resume() {
            this.paused = false;
            this.last = -1;
            this.update(this.last);
        }
        isPaused() {
            return this.paused;
        }
        /**
         * HAND_CURSOR = "pointer";
         * DRAG_CURSOR = "move";
         * DEFAULT_CURSOR = "default";
         * @param {string} cursor
         */
        setCursor(cursor) {
            this.canvas.style.cursor = (cursor);
        }
        endConstruction() {
            this.addShapeAction.end();
        }
        beginConstruction(clazz) {
            this.addShapeAction.end();
            this.addShapeAction.actionPerformed(clazz);
        }
        setStatusLine(statusInfo) {
            this.statusInfo = statusInfo;
            if (this.shapesManager.eventsListener != null)
                this.shapesManager.eventsListener.onStatusUpdate(statusInfo);
        }
        setFillWindow(fillWindow) {
            this.fillWindow = fillWindow;
            if (fillWindow) {
                const body = document.querySelector("body");
                this.setCanvasSize(body.clientWidth, body.clientHeight);
            }
            else {
                this.setCanvasSize(this.canvas.clientWidth, this.canvas.clientHeight);
            }
        }
        setAppEventsListener(listener) {
            this.shapesManager.eventsListener = listener;
        }
        static main(args) {
            window.onload = (e) => {
                return null;
            };
        }
    }
    framework.App = App;
    App["__class"] = "framework.App";
})(framework || (framework = {}));
(function (framework) {
    /**
     * Stores the zoom and panning state of the camera.
     * @author Mahesh kurmi
     * @class
     */
    class Camera {
        constructor() {
            this.METER_TO_PIXEL = 100;
            this.zoom = 100;
            this.offsetX = 0;
            this.offsetY = 0;
            if (this.screenWidth === undefined) {
                this.screenWidth = 0;
            }
            if (this.screenHeight === undefined) {
                this.screenHeight = 0;
            }
        }
        /**
         *
         * @param {number} w
         * @param {number} h
         */
        updateViewport(w, h) {
            this.screenWidth = w;
            this.screenHeight = h;
        }
        /**
         * Zooms camera to specified percentage zoom about specified point as origin.
         * @param {number} zoomPercentage Desired Percentage ZOOM
         * @param {math.Vector2} pt  Zoom about pt as centre
         */
        zoomToAboutPoint(zoomPercentage, pt) {
            const prevZoom = this.zoom;
            this.zoomTo(zoomPercentage);
            const f = (-this.zoom + prevZoom) * this.METER_TO_PIXEL / 100;
            this.translate(pt.x * f, pt.y * f);
        }
        /**
         * Zooms out the camera.
         */
        zoomOut() {
            this.zoomTo(this.zoom * Camera.ZOOM_FACTOR);
        }
        /**
         * Zooms in the camera.
         */
        zoomIn() {
            this.zoomTo(this.zoom / Camera.ZOOM_FACTOR);
        }
        /**
         * Returns current zoom percentage
         * @return {number}
         */
        getZoom() {
            return this.zoom;
        }
        /**
         * Zooms camera to specified percentage zoom.
         * @param {number} zoomPercentage Desired Percentage ZOOM
         */
        zoomTo(zoomPercentage) {
            if (zoomPercentage < Camera.MIN_ZOOM)
                zoomPercentage = Camera.MIN_ZOOM;
            if (zoomPercentage > Camera.MAX_ZOOM)
                zoomPercentage = Camera.MAX_ZOOM;
            this.zoom = zoomPercentage;
        }
        /**
         * Zooms out the camera about point (in world coordinates).
         * @param {math.Vector2} pt Zoom about pt as centre
         */
        zoomOutAboutPoint(pt) {
            this.zoomToAboutPoint(this.zoom / Camera.ZOOM_FACTOR, pt);
        }
        /**
         * Zooms in the camera about point (in world coordinates).
         * @param {math.Vector2} pt  Zoom about pt as centre
         */
        zoomInAboutPoint(pt) {
            this.zoomToAboutPoint(this.zoom * Camera.ZOOM_FACTOR, pt);
        }
        /**
         * Moves the camera back to the origin (Now World origin will be rendered at screen center).
         */
        toOrigin() {
            this.offsetX = 0;
            this.offsetY = 0;
        }
        /**
         * Translates the camera the given amount along the x and y axes.
         * @param {number} x the x translation
         * @param {number} y the y translation
         */
        translate(x, y) {
            this.offsetX += x;
            this.offsetY += y;
        }
        /**
         * Moves camera to origin  and resets scale to 100
         */
        reset() {
            this.offsetX = 0;
            this.offsetY = 0;
            this.zoom = 1;
        }
        /**
         * Returns the scale factor in pixel per meter.
         * @return {number} double
         */
        getScale() {
            return 0.01 * this.zoom * this.METER_TO_PIXEL;
        }
        /**
         * Sets the scale factor in pixels per meter.
         * @param {number} scale the desired scale factor
         */
        setScale(scale) {
            this.zoomTo(100 * scale / this.METER_TO_PIXEL);
        }
        /**
         * Returns the offset of camera (displacement of screen center in pixels from 'world center rendered on screen').
         * @return {math.Vector2} Vector2
         */
        getTranslation() {
            return new math.Vector2(this.offsetX, this.offsetY);
        }
        /**
         * Sets the Translation in pixels the camera the given amount along the x and y axes.
         * @param {number} x the x translation
         * @param {number} y the y translation
         */
        setTranslation(x, y) {
            this.offsetX = x;
            this.offsetY = y;
        }
        /**
         * Returns World coordinates for the given point
         * @param {number} x screen X coordinate in css pixels with left as zero
         * @param {number} y screen Y coordinate in css pixels with top as zero
         * @return {math.Vector2} new Vector corresponding to world point
         */
        toWorldCoordinates(x, y) {
            const v = new math.Vector2();
            const scale = this.getScale();
            v.x = (x - this.screenWidth * 0.5 - this.offsetX) / scale;
            v.y = -(y - this.screenHeight * 0.5 + this.offsetY) / scale;
            return v;
        }
        /**
         * Returns Screen coordinates in css pixels (where top left is origin) for the given world point
         * @param {number} x X coordinate in world space
         * @param {number} y Y coordinate in world space
         * @return {math.Vector2} new Vector corresponding to screen point
         */
        toScreenCoordinates(x, y) {
            const v = new math.Vector2();
            const scale = this.getScale();
            v.x = x * scale + this.offsetX + this.screenWidth * 0.5;
            v.y = -y * scale - this.offsetY + this.screenHeight * 0.5;
            return v;
        }
    }
    Camera.ZOOM_FACTOR = 1.01;
    Camera.MIN_ZOOM = 0.05;
    Camera.MAX_ZOOM = 2000;
    framework.Camera = Camera;
    Camera["__class"] = "framework.Camera";
})(framework || (framework = {}));
(function (framework) {
    /**
     * Constructs a new Color with all components set to 0.
     * @param {number} red
     * @param {number} green
     * @param {number} blue
     * @param {number} alpha
     * @class
     */
    class Color {
        constructor(red, green, blue, alpha) {
            if (((typeof red === 'number') || red === null) && ((typeof green === 'number') || green === null) && ((typeof blue === 'number') || blue === null) && ((typeof alpha === 'number') || alpha === null)) {
                let __args = arguments;
                if (this.r === undefined) {
                    this.r = 0;
                }
                if (this.g === undefined) {
                    this.g = 0;
                }
                if (this.b === undefined) {
                    this.b = 0;
                }
                if (this.a === undefined) {
                    this.a = 0;
                }
                this.FACTOR = 1.1;
                this.r = red;
                this.g = green;
                this.b = blue;
                this.a = alpha;
            }
            else if (((typeof red === 'number') || red === null) && ((typeof green === 'number') || green === null) && ((typeof blue === 'number') || blue === null) && alpha === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let alpha = 255;
                    if (this.r === undefined) {
                        this.r = 0;
                    }
                    if (this.g === undefined) {
                        this.g = 0;
                    }
                    if (this.b === undefined) {
                        this.b = 0;
                    }
                    if (this.a === undefined) {
                        this.a = 0;
                    }
                    this.FACTOR = 1.1;
                    this.r = red;
                    this.g = green;
                    this.b = blue;
                    this.a = alpha;
                }
                if (this.r === undefined) {
                    this.r = 0;
                }
                if (this.g === undefined) {
                    this.g = 0;
                }
                if (this.b === undefined) {
                    this.b = 0;
                }
                if (this.a === undefined) {
                    this.a = 0;
                }
                this.FACTOR = 1.1;
            }
            else
                throw new Error('invalid overload');
        }
        set(color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            this.a = color.a;
            return this;
        }
        brighter() {
            if (this.r === 255 && this.g === 255 && this.b === 255) {
                return new Color(255, 255, 255);
            }
            let r = ((this.r * this.FACTOR) | 0);
            let g = ((this.g * this.FACTOR) | 0);
            let b = ((this.b * this.FACTOR) | 0);
            if (r > 255)
                r = 255;
            if (g > 255)
                g = 255;
            if (b > 255)
                b = 255;
            return new Color(r, g, b);
        }
        darker() {
            if (this.r === 0 && this.g === 0 && this.b === 0) {
                return new Color(0, 0, 0);
            }
            const r = ((this.r / this.FACTOR) | 0);
            const g = ((this.g / this.FACTOR) | 0);
            const b = ((this.b / this.FACTOR) | 0);
            return new Color(r, g, b);
        }
        /**
         * Returns the color encoded as hex string with the format RRGGBBAA.
         * @return {string}
         */
        toString() {
            let value = javaemul.internal.IntegerHelper.toHexString((this.r << 24) | (this.g << 16) | (this.b << 8) | this.a);
            while ((value.length < 8)) {
                value = "0" + value;
            }
            ;
            return "#" + value;
        }
        copy() {
            return new Color(this.r, this.g, this.b, this.a);
        }
    }
    framework.Color = Color;
    Color["__class"] = "framework.Color";
})(framework || (framework = {}));
(function (framework) {
    /**
     * Class SimpleInput - input class for input of simple input types
     * via simple dialog box.
     * eg. int, char, String,float or boolean.
     *
     * @author: Mahesh kurmi
     * @class
     */
    class UserInput {
        /**
         * String input from the user via a simple dialog.
         * @param {string} prompt the message string to be displayed inside dialog
         * @return {string} String input from the user.
         * @param {string} initialValue
         */
        static getString(prompt, initialValue) {
            const commentArray = [prompt, UserInput.EMPTY_STRING, UserInput.EMPTY_STRING];
            const options = ["OK", "Cancel"];
            let validResponse = false;
            let result = initialValue;
            while ((!validResponse)) {
                {
                    result = window.prompt(prompt);
                    if (result != null) {
                        validResponse = true;
                    }
                    else {
                        return null;
                    }
                }
            }
            ;
            return result;
        }
        /**
         * returns integer input from the user via a simple dialog.
         * @param {string} prompt the message string to be displayed inside dialog
         * @return {number} the input integer
         */
        static getInt(prompt) {
            let validResponse = false;
            while ((!validResponse)) {
                while ((!validResponse)) {
                    {
                        const result = window.prompt(prompt);
                        if (result != null) {
                            try {
                                const n = javaemul.internal.IntegerHelper.parseInt(result);
                                validResponse = true;
                                return n;
                            }
                            catch (e) {
                            }
                        }
                    }
                }
            }
            ;
            return 0;
        }
        /**
         * returns a float input from the user via a simple dialog.
         * @param {string} prompt the message string to be displayed inside dialog
         * @return {number} the input float
         * @param {number} minValue
         * @param {number} maxValue
         */
        static getDouble(prompt, minValue, maxValue) {
            const options = ["OK"];
            const commentArray = [prompt, UserInput.EMPTY_STRING, UserInput.EMPTY_STRING];
            const validResponse = false;
            const response = 0.0;
            while ((!validResponse)) {
                {
                    const result = window.prompt(prompt);
                    if (result != null) {
                        try {
                            const n = javaemul.internal.DoubleHelper.parseDouble(result);
                            if (n > minValue && n < maxValue)
                                return n;
                        }
                        catch (e) {
                        }
                    }
                    else {
                        return javaemul.internal.DoubleHelper.NaN;
                    }
                }
            }
            ;
            return response;
        }
        static getExpression(title, message, initialValue, customVariables) {
            return UserInput.getString(title, initialValue);
        }
    }
    UserInput.STRING_TITLE = "Enter a String";
    UserInput.EXPR_TITLE = "Enter an Expression";
    UserInput.CHAR_TITLE = "Enter a char";
    UserInput.INT_TITLE = "Enter an int";
    UserInput.BOOLEAN_TITLE = "Select True or False";
    UserInput.FLOAT_TITLE = "Enter a float";
    UserInput.TRUE = "True";
    UserInput.FALSE = "False";
    UserInput.EMPTY_STRING = "";
    framework.UserInput = UserInput;
    UserInput["__class"] = "framework.UserInput";
})(framework || (framework = {}));
var math;
(function (math) {
    class MathUtils {
        constructor() {
            if (this.functions === undefined) {
                this.functions = null;
            }
        }
        static TWO_PI_$LI$() { if (MathUtils.TWO_PI == null) {
            MathUtils.TWO_PI = Math.PI * 2;
        } return MathUtils.TWO_PI; }
        static ROOT_2_$LI$() { if (MathUtils.ROOT_2 == null) {
            MathUtils.ROOT_2 = Math.sqrt(2);
        } return MathUtils.ROOT_2; }
        static ROOT_3_$LI$() { if (MathUtils.ROOT_3 == null) {
            MathUtils.ROOT_3 = Math.sqrt(3);
        } return MathUtils.ROOT_3; }
        static ROOT_5_$LI$() { if (MathUtils.ROOT_5 == null) {
            MathUtils.ROOT_5 = Math.sqrt(5);
        } return MathUtils.ROOT_5; }
        static ROOT_6_$LI$() { if (MathUtils.ROOT_6 == null) {
            MathUtils.ROOT_6 = Math.sqrt(6);
        } return MathUtils.ROOT_6; }
        static ROOT_7_$LI$() { if (MathUtils.ROOT_7 == null) {
            MathUtils.ROOT_7 = Math.sqrt(7);
        } return MathUtils.ROOT_7; }
        static PI2_$LI$() { if (MathUtils.PI2 == null) {
            MathUtils.PI2 = 2 * Math.PI;
        } return MathUtils.PI2; }
        static __random_$LI$() { if (MathUtils.__random == null) {
            MathUtils.__random = new java.util.Random();
        } return MathUtils.__random; }
        static nan_$LI$() { if (MathUtils.nan == null) {
            MathUtils.nan = (0.0 / 0.0);
        } return MathUtils.nan; }
        static matcher_trail_0s_$LI$() { if (MathUtils.matcher_trail_0s == null) {
            MathUtils.matcher_trail_0s = java.util.regex.Pattern.compile("\\.0*$|(?<=\\.[0-9]{0,2147483646})0*$").matcher("");
        } return MathUtils.matcher_trail_0s; }
        /**
         * Creates parser for the expression
         * @param {string} expr
         * @return {net.objecthunter.exp4j.Expression} Expression Object if parsed successfully else returns null
         * @param {java.lang.String[]} variables
         * @param {*} globalVariables
         * @param {*} globalFunctions
         */
        static createParser(expr, variables, globalVariables, globalFunctions) {
            if (expr == null || /* isEmpty */ (expr.length === 0))
                throw new Error("parsing error in expr: " + expr + " Empty or null Expression");
            const builder = new net.objecthunter.exp4j.ExpressionBuilder(expr);
            if (variables != null)
                builder.variables$java_lang_String_A(variables);
            if (globalVariables != null) {
                for (let index = globalVariables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    {
                        builder.variable(key);
                    }
                }
            }
            if (globalFunctions != null) {
                for (let index = globalFunctions.values().iterator(); index.hasNext();) {
                    let f = index.next();
                    {
                        builder._function(f);
                    }
                }
            }
            let exp = null;
            try {
                exp = builder.build();
            }
            catch (e) {
                console.error(e.message, e);
                throw new Error("parsing error in expr: " + expr + " " + e.message);
            }
            return exp;
        }
        static evaluateBoolean(expr) {
            if (javaemul.internal.BooleanHelper.parseBoolean(expr))
                return true;
            try {
                const p = MathUtils.evaluateExpression(expr, null, null);
                if ( /* isNaN */isNaN(p) || p === 0) {
                    return false;
                }
                return true;
            }
            catch (e) {
            }
            return false;
        }
        /**
         * throws exception if has bad expression, returns NaN for invalid inputs
         * @param {string} expr
         * @param customFunctions array of user defined custom  functions used in expression
         * @return {number} customVariables user defined variable name-value pair used in expression
         * return NaN if expression is empty or invalid
         * @throws Exception
         * @param {*} functions
         * @param {*} variables
         */
        static evaluateExpression(expr, functions, variables) {
            if (expr == null || /* isEmpty */ (expr.length === 0))
                return javaemul.internal.DoubleHelper.NaN;
            if ( /* equalsIgnoreCase */((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(expr, "true"))
                return 1;
            if ( /* equalsIgnoreCase */((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(expr, "false"))
                return 0;
            const builder = new net.objecthunter.exp4j.ExpressionBuilder(expr);
            if (functions != null) {
                for (let index = functions.values().iterator(); index.hasNext();) {
                    let f = index.next();
                    builder._function(f);
                }
            }
            if (variables != null) {
                for (let index = variables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    builder.variable(key);
                }
            }
            const exp = builder.build();
            if (variables != null) {
                for (let index = variables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    exp.setVariable(key, variables.get(key));
                }
            }
            try {
                return exp.evaluate();
            }
            catch (e) {
                return javaemul.internal.DoubleHelper.NaN;
            }
        }
        /**
         * Creates array of points based on expressions as a a  function of t assuming 0<=t<=1
         * @param {string} xExpr X coordinate  as a function of t
         * @param {string} yExpr Y coordinate  as a function of t
         * @param {number} divisions Number of parts t is to be broken (must be grater than 0)
         * @return {*} non null list of vertices (can be empty if can't be created)
         * @throws Exception If expression cant be parsed or no points can be created
         * @param {number} min
         * @param {number} max
         */
        static generatePoints(xExpr, yExpr, min, max, divisions) {
            const vertices = (new java.util.ArrayList());
            if (divisions <= 0)
                throw new Error("Number of division can not be -ve or zero");
            let t = 0;
            let parserX;
            let parserY;
            try {
                parserX = MathUtils.createParser(xExpr, ["t"], null, null);
                parserY = MathUtils.createParser(yExpr, ["t"], null, null);
            }
            catch (e) {
                throw new Error("Invalid Expression !" + e.message);
            }
            let x;
            let y;
            for (let i = 0; i <= divisions; i++) {
                {
                    t = min + (max - min) * (i + 0.0) / divisions;
                    parserX.setVariable("t", t);
                    parserY.setVariable("t", t);
                    try {
                        x = parserX.evaluate();
                        y = parserY.evaluate();
                        if ( /* isNaN */isNaN(x) || /* isNaN */ isNaN(y))
                            continue;
                        const v = new math.Vector2(x, y);
                        vertices.add(v);
                    }
                    catch (e) {
                    }
                }
                ;
            }
            let closed = false;
            if (vertices.size() >= 2) {
                if (MathUtils.approxEqual(vertices.get(vertices.size() - 1), vertices.get(0)))
                    closed = true;
            }
            if (closed)
                vertices.add(vertices.get(0));
            return vertices;
        }
        /*private*/ static mxatan(arg) {
            let argsq;
            let value;
            argsq = arg * arg;
            value = ((((MathUtils.p4 * argsq + MathUtils.p3) * argsq + MathUtils.p2) * argsq + MathUtils.p1) * argsq + MathUtils.p0);
            value = value / (((((argsq + MathUtils.q4) * argsq + MathUtils.q3) * argsq + MathUtils.q2) * argsq + MathUtils.q1) * argsq + MathUtils.q0);
            return value * arg;
        }
        /*private*/ static msatan(arg) {
            if (arg < MathUtils.sq2m1)
                return MathUtils.mxatan(arg);
            if (arg > MathUtils.sq2p1)
                return MathUtils.PIO2 - MathUtils.mxatan(1 / arg);
            return MathUtils.PIO2 / 2 + MathUtils.mxatan((arg - 1) / (arg + 1));
        }
        static atan(arg) {
            if (arg > 0)
                return MathUtils.msatan(arg);
            return -MathUtils.msatan(-arg);
        }
        static atan2(arg1, arg2) {
            if (arg1 + arg2 === arg1) {
                if (arg1 >= 0)
                    return MathUtils.PIO2;
                return -MathUtils.PIO2;
            }
            arg1 = MathUtils.atan(arg1 / arg2);
            if (arg2 < 0) {
                if (arg1 <= 0)
                    return arg1 + Math.PI;
                return arg1 - Math.PI;
            }
            return arg1;
        }
        static asin(arg) {
            let temp;
            let sign;
            sign = 0;
            if (arg < 0) {
                arg = -arg;
                sign++;
            }
            if (arg > 1)
                return MathUtils.nan_$LI$();
            temp = Math.sqrt(1 - arg * arg);
            if (arg > 0.7)
                temp = MathUtils.PIO2 - MathUtils.atan(temp / arg);
            else
                temp = MathUtils.atan(arg / temp);
            if (sign > 0)
                temp = -temp;
            return temp;
        }
        static acos(arg) {
            if (arg > 1 || arg < -1)
                return MathUtils.nan_$LI$();
            return MathUtils.PIO2 - MathUtils.asin(arg);
        }
        static acosClamp(cos) {
            if (cos > 1)
                return 0;
            else if (cos < -1)
                return Math.fround(Math.PI);
            else
                return Math.fround(Math.acos(cos));
        }
        static findNumSigFihures(val) {
            const myVal = val + "";
            const sig_figs = myVal.split("(^0+(\\.?)0*|(~\\.)0+$|\\.)");
            let sum = 0;
            for (let index = 0; index < sig_figs.length; index++) {
                let fig = sig_figs[index];
                {
                    sum += fig.length;
                }
            }
            return sum;
        }
        static mostSignificantDigit(value) {
            const n = (Math.ceil(/* log10 */ (x => Math.log(x) * Math.LOG10E)(Math.abs(value))) | 0);
            const digit = ((value / Math.pow(10, n)) | 0);
            return digit;
        }
        /**
         * Returns value rounded off to decimal places as in preference
         * @param {number} value
         * @return
         * @param {number} n
         * @return {number}
         */
        static roundOffToSigFigures(value, n) {
            if (value === 0) {
                return 0;
            }
            const d = Math.ceil(/* log10 */ (x => Math.log(x) * Math.LOG10E)(value < 0 ? -value : value));
            const power = n - (d | 0);
            const magnitude = Math.pow(10, power);
            const shifted = Math.round(value * magnitude);
            return shifted / magnitude;
        }
        /**
         * Returns value rounded off to decimal places as in preference
         *
         * @param {number} value
         * @return
         * @return {number}
         */
        static roundOffToPreferredSigFigures(value) {
            const n = framework.Preferences.getMaxSignifucantFigures();
            if (Math.abs(value) < framework.Preferences.getEpsilon()) {
                return 0;
            }
            const d = Math.ceil(/* log10 */ (x => Math.log(x) * Math.LOG10E)(value < 0 ? -value : value));
            const power = n - (d | 0);
            const magnitude = Math.pow(10, power);
            const shifted = Math.round(value * magnitude);
            return shifted / magnitude;
        }
        /**
         * Returns value rounded off to decimal places as in preference
         * @param {number} value
         * @return
         * @return {number}
         */
        static roundOffTo2DecPlaces(value) {
            return Math.round(value * 100) / 100.0;
        }
        /**
         * Returns String representing Vector in form ai+bj
         * @return
         * @param {math.Vector2} v
         * @param {string} unit
         * @return {string}
         */
        static toVectorNotation(v, unit) {
            const sb = new java.lang.StringBuilder();
            v = MathUtils.createRoundOffVector(v);
            if (v.x !== 0) {
                sb.append(v.x + " " + math.Unicode.hat + "i");
            }
            if (v.y !== 0) {
                if (v.y > 0) {
                    sb.append((sb.length() > 0 ? " + " : "") + v.y + " " + math.Unicode.hat + "j");
                }
                else if (v.y < 0) {
                    sb.append(" - " + -v.y + " " + math.Unicode.hat + "j");
                }
            }
            if (sb.length() !== 0)
                sb.append(" " + unit);
            return sb.toString();
        }
        static toPointNotation$math_Vector2$java_lang_String$java_lang_String(v, xUnit, yUnit) {
            return MathUtils.toPointNotation$math_Vector2$java_lang_String$java_lang_String$boolean(v, xUnit, yUnit, true);
        }
        static toPointNotation$math_Vector2$java_lang_String$java_lang_String$boolean(v, xUnit, yUnit, roundOff) {
            const sb = new java.lang.StringBuilder();
            if (roundOff)
                v = MathUtils.createRoundOffVector(v);
            sb.append("( " + v.x + xUnit);
            sb.append(" , " + v.y + yUnit + " )");
            return sb.toString();
        }
        /**
         * Returns String representing Vector in (a,b)
         * @return
         * @param {math.Vector2} v
         * @param {string} xUnit
         * @param {string} yUnit
         * @param {boolean} roundOff
         * @return {string}
         */
        static toPointNotation(v, xUnit, yUnit, roundOff) {
            if (((v != null && v instanceof math.Vector2) || v === null) && ((typeof xUnit === 'string') || xUnit === null) && ((typeof yUnit === 'string') || yUnit === null) && ((typeof roundOff === 'boolean') || roundOff === null)) {
                return math.MathUtils.toPointNotation$math_Vector2$java_lang_String$java_lang_String$boolean(v, xUnit, yUnit, roundOff);
            }
            else if (((v != null && v instanceof math.Vector2) || v === null) && ((typeof xUnit === 'string') || xUnit === null) && ((typeof yUnit === 'string') || yUnit === null) && roundOff === undefined) {
                return math.MathUtils.toPointNotation$math_Vector2$java_lang_String$java_lang_String(v, xUnit, yUnit);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Returns Vector with both components rounded Off as per decimal format
         * @return
         * @param {math.Vector2} v
         * @return {math.Vector2}
         */
        static createRoundOffVector(v) {
            let x1;
            let y1;
            x1 = MathUtils.roundOffToPreferredSigFigures(v.x);
            y1 = MathUtils.roundOffToPreferredSigFigures(v.y);
            return new math.Vector2(x1, y1);
        }
        /**
         * Returns true if Vectors are very Close to each other
         * @param Vetor2 v1
         * @param Vetor2 v2
         * @return
         * @param {math.Vector2} v1
         * @param {math.Vector2} v2
         * @return {boolean}
         */
        static approxEqual(v1, v2) {
            return Math.abs(v1.x - v2.x) < framework.Preferences.getEpsilon() && Math.abs(v1.y - v2.y) < framework.Preferences.getEpsilon();
        }
        static clamp$short$short$short(value, min, max) {
            if (value < min)
                return min;
            if (value > max)
                return max;
            return value;
        }
        static clamp(value, min, max) {
            if (((typeof value === 'number') || value === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                return math.MathUtils.clamp$short$short$short(value, min, max);
            }
            else if (((typeof value === 'number') || value === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                return math.MathUtils.clamp$int$int$int(value, min, max);
            }
            else if (((typeof value === 'number') || value === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                return math.MathUtils.clamp$long$long$long(value, min, max);
            }
            else if (((typeof value === 'number') || value === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                return math.MathUtils.clamp$float$float$float(value, min, max);
            }
            else if (((typeof value === 'number') || value === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                return math.MathUtils.clamp$double$double$double(value, min, max);
            }
            else
                throw new Error('invalid overload');
        }
        static clamp$int$int$int(value, min, max) {
            if (value < min)
                return min;
            if (value > max)
                return max;
            return value;
        }
        static clamp$long$long$long(value, min, max) {
            if (value < min)
                return min;
            if (value > max)
                return max;
            return value;
        }
        static clamp$float$float$float(value, min, max) {
            if (value < min)
                return min;
            if (value > max)
                return max;
            return value;
        }
        static clamp$double$double$double(value, min, max) {
            if (value < min)
                return min;
            if (value > max)
                return max;
            return value;
        }
        /**
         * Returns the next power of two. Returns the specified value if the value is already a power of two.
         * @param {number} value
         * @return {number}
         */
        static nextPowerOfTwo(value) {
            if (value === 0)
                return 1;
            value--;
            value |= value >> 1;
            value |= value >> 2;
            value |= value >> 4;
            value |= value >> 8;
            value |= value >> 16;
            return value + 1;
        }
        static isPowerOfTwo(value) {
            return value !== 0 && (value & value - 1) === 0;
        }
        /**
         * Linearly interpolates between fromValue to toValue on progress position.
         * @param {number} fromValue
         * @param {number} toValue
         * @param {number} progress
         * @return {number}
         */
        static lerp(fromValue, toValue, progress) {
            return Math.fround(fromValue + Math.fround((Math.fround(toValue - fromValue)) * progress));
        }
        /**
         * Linearly interpolates between two angles in radians. Takes into account that angles wrap at two pi and always takes the
         * direction with the smallest delta angle.
         *
         * @param {number} fromRadians start angle in radians
         * @param {number} toRadians target angle in radians
         * @param {number} progress interpolation value in the range [0, 1]
         * @return {number} the interpolated angle in the range [0, PI2[
         */
        static lerpAngle(fromRadians, toRadians, progress) {
            const delta = ((Math.fround(toRadians - fromRadians) + MathUtils.PI2_$LI$() + Math.PI) % MathUtils.PI2_$LI$()) - Math.PI;
            return (fromRadians + delta * progress + MathUtils.PI2_$LI$()) % MathUtils.PI2_$LI$();
        }
        /**
         * Linearly interpolates between two angles in degrees. Takes into account that angles wrap at 360 degrees and always takes
         * the direction with the smallest delta angle.
         *
         * @param {number} fromDegrees start angle in degrees
         * @param {number} toDegrees target angle in degrees
         * @param {number} progress interpolation value in the range [0, 1]
         * @return {number} the interpolated angle in the range [0, 360[
         */
        static lerpAngleDeg(fromDegrees, toDegrees, progress) {
            const delta = Math.fround((Math.fround((Math.fround(Math.fround(Math.fround(toDegrees - fromDegrees) + 360) + 180)) % 360)) - 180);
            return (fromDegrees + delta * progress + 360) % 360;
        }
        static random$float$float(start, end) {
            return Math.fround(start + Math.fround(MathUtils.__random_$LI$().nextFloat() * (Math.fround(end - start))));
        }
        static random$int$int(start, end) {
            return start + MathUtils.__random_$LI$().nextInt(end - start + 1);
        }
        /**
         * Returns a random number between start (inclusive) and end (inclusive).
         * @param {number} start
         * @param {number} end
         * @return {number}
         */
        static random(start, end) {
            if (((typeof start === 'number') || start === null) && ((typeof end === 'number') || end === null)) {
                return math.MathUtils.random$int$int(start, end);
            }
            else if (((typeof start === 'number') || start === null) && ((typeof end === 'number') || end === null)) {
                return math.MathUtils.random$float$float(start, end);
            }
            else if (start === undefined && end === undefined) {
                return math.MathUtils.random$();
            }
            else
                throw new Error('invalid overload');
        }
        static random$() {
            return MathUtils.__random_$LI$().nextFloat();
        }
        /**
         * Returns true if a random value between 0 and 1 is less than the specified value.
         * @param {number} chance
         * @return {boolean}
         */
        static randomBoolean(chance) {
            return MathUtils.random$() < chance;
        }
        /**
         * Returns true if the value is zero (using the default tolerance as upper bound)
         * @param {number} value
         * @return {boolean}
         */
        static isZero(value) {
            return Math.abs(value) <= MathUtils.FLOAT_ROUNDING_ERROR;
        }
        /**
         * Returns String representing Vector in (a,b)
         * @return
         * @param {math.Vector2} v
         * @param {boolean} tryToUsepi
         * @return {string}
         */
        static formatPoint(v, tryToUsepi) {
            const x = MathUtils.formatValue(v.x, tryToUsepi);
            const y = MathUtils.formatValue(v.y, tryToUsepi);
            return "( " + x + " , " + y + " )";
        }
        /**
         * Returns String representing Vector in (a,b)
         * @return
         * @param {math.Vector2} v
         * @return {string}
         */
        static formatVector(v) {
            const sb = new java.lang.StringBuilder();
            if (v.x !== 0) {
                sb.append(MathUtils.formatValue(v.x, true) + " " + math.Unicode.hat + "i");
            }
            if (v.y !== 0) {
                if (v.y > 0) {
                    sb.append((sb.length() > 0 ? " + " : "") + MathUtils.formatValue(v.y, true) + " " + math.Unicode.hat + "j");
                }
                else if (v.y < 0) {
                    sb.append(" - " + MathUtils.formatValue(-v.y, true) + " " + math.Unicode.hat + "j");
                }
            }
            return sb.toString();
        }
        /**
         * formats value as String trying to reduce in form p/q in simplest form
         * or as multiple of pi/root2, root3 etc if close to it
         * @param {number} val
         * @param {boolean} tryToUsePI
         * @return
         * @return {string}
         */
        static formatValue(val, tryToUsePI) {
            if ( /* isNaN */isNaN(val))
                return "?";
            let x = MathUtils.format(Math.abs(val));
            const fv = javaemul.internal.DoubleHelper.parseDouble(x);
            if (fv === 0) {
                return "0";
            }
            let fract;
            const v = Math.abs(val);
            if (tryToUsePI) {
                fract = MathUtils.getFraction(v / Math.PI);
                if (Math.abs(((fract[0] + 0.0) / fract[1]) * Math.PI - v) < framework.Preferences.getEpsilon()) {
                    x = (fract[0] === 1 ? "" : fract[0]) + math.Unicode.PI_STRING_$LI$();
                    x += (fract[1] === 1 ? "" : ("/" + fract[1]));
                    return (val < 0 ? "-" : "") + x;
                }
            }
            if (MathUtils.chkIrrational) {
                fract = MathUtils.getFraction(v / Math.E);
                if (Math.abs(((fract[0] + 0.0) / fract[1]) * Math.E - v) < framework.Preferences.getEpsilon() * v) {
                    if (fract[1] % 2 === 0) {
                        fract[1] = (fract[1] / 2 | 0);
                        x = fract[0] + "";
                        x += "/" + (fract[1] === 1 ? "" : fract[1]) + "e";
                        return (val < 0 ? "-" : "") + x;
                    }
                    x = (fract[0] === 1 ? "" : fract[0]) + "e";
                    x += (fract[1] === 1 ? "" : ("/" + fract[1]));
                    return (val < 0 ? "-" : "") + x;
                }
                fract = MathUtils.getFraction(v / MathUtils.ROOT_2_$LI$());
                if (Math.abs(((fract[0] + 0.0) / fract[1]) * MathUtils.ROOT_2_$LI$() - v) < framework.Preferences.getEpsilon() * v) {
                    if (fract[1] % 2 === 0) {
                        fract[1] = (fract[1] / 2 | 0);
                        x = fract[0] + "";
                        x += "/" + (fract[1] === 1 ? "" : fract[1]) + MathUtils.S_ROOT_2;
                        return (val < 0 ? "-" : "") + x;
                    }
                    x = (fract[0] === 1 ? "" : fract[0]) + MathUtils.S_ROOT_2;
                    x += (fract[1] === 1 ? "" : ("/" + fract[1]));
                    return (val < 0 ? "-" : "") + x;
                }
                fract = MathUtils.getFraction(v / MathUtils.ROOT_3_$LI$());
                if (Math.abs(((fract[0] + 0.0) / fract[1]) * MathUtils.ROOT_3_$LI$() - v) < framework.Preferences.getEpsilon() * v) {
                    if (fract[1] % 3 === 0) {
                        fract[1] = (fract[1] / 3 | 0);
                        x = fract[0] + "";
                        x += "/" + (fract[1] === 1 ? "" : fract[1]) + MathUtils.S_ROOT_3;
                        return (val < 0 ? "-" : "") + x;
                    }
                    x = (fract[0] === 1 ? "" : fract[0]) + MathUtils.S_ROOT_3;
                    x += (fract[1] === 1 ? "" : ("/" + fract[1]));
                    return (val < 0 ? "-" : "") + x;
                }
                fract = MathUtils.getFraction(v / MathUtils.ROOT_5_$LI$());
                if (Math.abs(((fract[0] + 0.0) / fract[1]) * MathUtils.ROOT_5_$LI$() - v) < framework.Preferences.getEpsilon() * v) {
                    if (fract[1] % 5 === 0) {
                        fract[1] = (fract[1] / 5 | 0);
                        x = fract[0] + "";
                        x += "/" + (fract[1] === 1 ? "" : fract[1]) + MathUtils.S_ROOT_5;
                        return (val < 0 ? "-" : "") + x;
                    }
                    x = (fract[0] === 1 ? "" : fract[0]) + MathUtils.S_ROOT_5;
                    x += (fract[1] === 1 ? "" : ("/" + fract[1]));
                    return (val < 0 ? "-" : "") + x;
                }
                fract = MathUtils.getFraction(v / MathUtils.ROOT_6_$LI$());
                if (Math.abs(((fract[0] + 0.0) / fract[1]) * MathUtils.ROOT_6_$LI$() - v) < framework.Preferences.getEpsilon() * v) {
                    if (fract[1] % 6 === 0) {
                        fract[1] = (fract[1] / 6 | 0);
                        x = fract[0] + "";
                        x += "/" + (fract[1] === 1 ? "" : fract[1]) + MathUtils.S_ROOT_6;
                        return (val < 0 ? "-" : "") + x;
                    }
                    x = (fract[0] === 1 ? "" : fract[0]) + MathUtils.S_ROOT_6;
                    x += (fract[1] === 1 ? "" : ("/" + fract[1]));
                    return (val < 0 ? "-" : "") + x;
                }
                fract = MathUtils.getFraction(v / MathUtils.ROOT_7_$LI$());
                if (Math.abs(((fract[0] + 0.0) / fract[1]) * MathUtils.ROOT_7_$LI$() - v) < framework.Preferences.getEpsilon() * v) {
                    if (fract[1] % 7 === 0) {
                        fract[1] = (fract[1] / 7 | 0);
                        x = fract[0] + "";
                        x += "/" + (fract[1] === 1 ? "" : fract[1]) + MathUtils.S_ROOT_7;
                        return (val < 0 ? "-" : "") + x;
                    }
                    x = (fract[0] === 1 ? "" : fract[0]) + MathUtils.S_ROOT_7;
                    x += (fract[1] === 1 ? "" : ("/" + fract[1]));
                    return (val < 0 ? "-" : "") + x;
                }
            }
            fract = MathUtils.getFraction(v);
            if (Math.abs(((fract[0] + 0.0) / fract[1]) - v) < framework.Preferences.getEpsilon() * v) {
                x = fract[0] + (fract[1] === 1 ? "" : ("/" + fract[1]));
                return (val < 0 ? "-" : "") + x;
            }
            return MathUtils.format(val);
        }
        static formatAngle(val) {
            if ( /* isNaN */isNaN(val))
                return "?";
            let x = MathUtils.format(Math.abs(val));
            const fv = javaemul.internal.DoubleHelper.parseDouble(x);
            if (fv === 0) {
                return "0";
            }
            let fract;
            const v = Math.PI * Math.abs(val) / 180;
            fract = MathUtils.getFraction(v / Math.PI);
            if (Math.abs(((fract[0] + 0.0) / fract[1]) * Math.PI - v) < framework.Preferences.getEpsilon() * v) {
                x = (fract[0] === 1 ? "" : fract[0]) + math.Unicode.PI_STRING_$LI$();
                x += (fract[1] === 1 ? "" : ("/" + fract[1]));
                return (val < 0 ? "-" : "") + x;
            }
            return MathUtils.format(val) + "\u00b0";
        }
        static formatEqn$double_A$java_lang_String_A(c, coeff) {
            const n = c.length;
            let i;
            for (i = 0; i < n; i++) {
                {
                    if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(c[i]))
                        return "";
                }
                ;
            }
            for (i = 0; i < n; i++) {
                {
                    if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(c[i]))
                        return "";
                    if (Math.abs(c[i]) > geom.Shape2D.ACCURACY)
                        break;
                }
                ;
            }
            if (i === n)
                return "";
            i = i--;
            if (c[i] < 0)
                for (let j = i; j < n; j++) {
                    c[j] *= -1;
                }
            let hcf = true;
            for (let j = i; j < n; j++) {
                {
                    if ((Math.abs(c[j]) % Math.abs(c[i])) > geom.Shape2D.ACCURACY) {
                        hcf = false;
                    }
                }
                ;
            }
            if (Math.abs(c[i]) < 1 || hcf) {
                for (let j = i + 1; j < c.length; j++) {
                    c[j] = c[j] / c[i];
                }
                c[i] = 1;
            }
            const s = (s => { let a = []; while (s-- > 0)
                a.push(null); return a; })(c.length);
            for (i = 0; i < n; i++) {
                {
                    if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(c[i]))
                        return "";
                    if (Math.abs(c[i]) < geom.Shape2D.ACCURACY)
                        c[i] = 0;
                    s[i] = c[i] + "";
                }
                ;
            }
            return MathUtils.formatEqn$java_lang_String_A$java_lang_String_A(s, coeff);
        }
        /**
         *
         * @param {double[]} c
         * @return
         * @param {java.lang.String[]} coeff
         * @return {string}
         */
        static formatEqn(c, coeff) {
            if (((c != null && c instanceof Array && (c.length == 0 || c[0] == null || (typeof c[0] === 'number'))) || c === null) && ((coeff != null && coeff instanceof Array && (coeff.length == 0 || coeff[0] == null || (typeof coeff[0] === 'string'))) || coeff === null)) {
                return math.MathUtils.formatEqn$double_A$java_lang_String_A(c, coeff);
            }
            else if (((c != null && c instanceof Array && (c.length == 0 || c[0] == null || (typeof c[0] === 'string'))) || c === null) && ((coeff != null && coeff instanceof Array && (coeff.length == 0 || coeff[0] == null || (typeof coeff[0] === 'string'))) || coeff === null)) {
                return math.MathUtils.formatEqn$java_lang_String_A$java_lang_String_A(c, coeff);
            }
            else
                throw new Error('invalid overload');
        }
        static formatEqn$java_lang_String_A$java_lang_String_A(c, coeff) {
            let i;
            const eqn = new java.lang.StringBuilder();
            for (i = 0; i < c.length; i++) {
                {
                    try {
                        const d = javaemul.internal.DoubleHelper.parseDouble(c[i]);
                        if (eqn.length() === 0 && d < 0)
                            eqn.append("-");
                        eqn.append(MathUtils.formatTerm(Math.abs(d), coeff[i]));
                    }
                    catch (e) {
                        if (c[i].length === 1)
                            eqn.append(c[i] + coeff[i]);
                        else
                            eqn.append("(" + c[i] + ")" + coeff[i]);
                    }
                    if (i < c.length - 1) {
                        try {
                            let d = javaemul.internal.DoubleHelper.parseDouble(c[i + 1]);
                            d = javaemul.internal.DoubleHelper.parseDouble(MathUtils.format(d));
                            if (d > 0) {
                                if (eqn.length() > 0)
                                    eqn.append(" + ");
                            }
                            else if (d < 0) {
                                eqn.append(" - ");
                            }
                        }
                        catch (e) {
                            if (eqn.length() > 0)
                                eqn.append(" + ");
                        }
                    }
                }
                ;
            }
            eqn.append(" = 0");
            return eqn.toString();
        }
        static formatTerm(val, coeff) {
            if ( /* isEmpty */(coeff.length === 0)) {
                const s = MathUtils.format(Math.abs(val));
                const fv = javaemul.internal.DoubleHelper.parseDouble(s);
                if (fv === 0)
                    return "";
                return MathUtils.formatValue(val, false);
            }
            if ( /* isNaN */isNaN(val))
                return "?";
            const x = MathUtils.format(Math.abs(val));
            const fv = javaemul.internal.DoubleHelper.parseDouble(x);
            if (Math.abs(/* doubleValue */ fv) < geom.Shape2D.ACCURACY) {
                return "";
            }
            const s = MathUtils.formatValue(val, false);
            const arr = s.split("/");
            try {
                const t = javaemul.internal.DoubleHelper.parseDouble(arr[0]);
                if (Math.abs(t - 1) < geom.Shape2D.ACCURACY)
                    arr[0] = "";
                if (Math.abs(t + 1) < geom.Shape2D.ACCURACY)
                    arr[0] = "-";
                if (arr.length > 1)
                    return arr[0] + coeff + "/" + arr[1];
                return (Math.abs(t - 1) < geom.Shape2D.ACCURACY ? "" : arr[0]) + coeff;
            }
            catch (e) {
                return s + coeff;
            }
        }
        static format(v) {
            if (v === 0)
                return "0";
            let s = MathUtils.roundOffToPreferredSigFigures(v) + "";
            if (s.length < 2)
                return s;
            s = MathUtils.matcher_trail_0s_$LI$().reset(s).replaceAll("");
            if ( /* isEmpty */(s.length === 0))
                s = "0";
            return s;
        }
        /**
         * converts double to float and returns p/q as an array
         * @param {number} input
         * @return
         * @return {int[]}
         */
        static getFraction(input) {
            let p0 = 1;
            let q0 = 0;
            let p1 = (Math.floor(input) | 0);
            let q1 = 1;
            let p2;
            let q2;
            let r = input - p1;
            let next_cf;
            while ((r !== 0)) {
                {
                    r = 1.0 / r;
                    next_cf = Math.floor(r);
                    p2 = ((next_cf * p1 + p0) | 0);
                    q2 = ((next_cf * q1 + q0) | 0);
                    if (p2 > 32 || q2 > 32)
                        break;
                    p0 = p1;
                    p1 = p2;
                    q0 = q1;
                    q1 = q2;
                    r -= next_cf;
                }
            }
            ;
            input = p1 / q1;
            if (input > 32.0) {
                p1 = 32;
                q1 = 1;
            }
            else if (input < 1.0 / 32.0) {
                p1 = 1;
                q1 = 32;
            }
            return [p1, q1];
        }
        /**
         *
         * @param {number} rotation in degree
         * @return
         * @return {number}
         */
        static sinDeg(rotation) {
            return Math.fround(Math.sin(/* toRadians */ (x => x * Math.PI / 180)(rotation)));
        }
        /**
         *
         * @param {number} rotation in degree
         * @return
         * @return {number}
         */
        static cosDeg(rotation) {
            return Math.fround(Math.cos(/* toRadians */ (x => x * Math.PI / 180)(rotation)));
        }
        /**
         * Normalize an angle in a 2&pi wide interval around a center value.
         * This method has three main uses:
         * <ul>
         * <li>normalize an angle between 0 and 2&pi;:<br/>
         * <code>a = MathUtils.normalizeAngle(a, Math.PI);</code></li>
         * <li>normalize an angle between -&pi; and +&pi;<br/>
         * <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>
         * <li>compute the angle between two defining angular positions:<br>
         * <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>
         * </ul>
         * Note that due to numerical accuracy and since &pi; cannot be represented
         * exactly, the result interval is <em>closed</em>, lit cannot be half-closed
         * as would be more satisfactory in a purely mathematical view.
         * @param {number} a angle to normalize in radians
         * @param {number} center center of the desired 2&pi in radians; interval for the result
         * @return {number} a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;
         */
        static normalizeAngle(a, center) {
            return a - MathUtils.PI2_$LI$() * Math.floor((a + Math.PI - center) / MathUtils.PI2_$LI$());
        }
        static hypot(x, y) {
            return Math.sqrt(x * x + y * y);
        }
    }
    MathUtils.EPSILON = 1.0E-15;
    MathUtils.chkIrrational = true;
    MathUtils.S_ROOT_2 = "\u221a" + 2;
    MathUtils.S_ROOT_3 = "\u221a" + 3;
    MathUtils.S_ROOT_5 = "\u221a" + 5;
    MathUtils.S_ROOT_6 = "\u221a" + 6;
    MathUtils.S_ROOT_7 = "\u221a" + 7;
    MathUtils.sq2p1 = 2.414213562373095;
    MathUtils.sq2m1 = 0.41421356237309503;
    MathUtils.p4 = 16.15364129822302;
    MathUtils.p3 = 268.42548195503974;
    MathUtils.p2 = 1153.029351540485;
    MathUtils.p1 = 1780.406316433197;
    MathUtils.p0 = 896.7859740366387;
    MathUtils.q4 = 58.95697050844462;
    MathUtils.q3 = 536.2653740312153;
    MathUtils.q2 = 1666.7838148816338;
    MathUtils.q1 = 2079.33497444541;
    MathUtils.q0 = 896.7859740366387;
    MathUtils.PIO2 = 1.5707963267948966;
    MathUtils.FLOAT_ROUNDING_ERROR = 1.0E-6;
    math.MathUtils = MathUtils;
    MathUtils["__class"] = "math.MathUtils";
})(math || (math = {}));
(function (math) {
    class EquationUtils {
        constructor() {
        }
        /**
         * true if x is zero w/in tolerance
         *
         * @param {number} x
         * value to test
         * @return {boolean} true if this value is zero
         */
        static IsZero(x) {
            return (x > -EquationUtils.EQN_EPS && x < EquationUtils.EQN_EPS);
        }
        /**
         * Returns the cube root
         *
         * @param {number} x
         * the input value
         * @return {number} the cube root of the input
         */
        static cbrt(x) {
            if (x > 0)
                return Math.pow(x, 1.0 / 3.0);
            else if (x < 0)
                return -Math.pow(-x, 1.0 / 3.0);
            return 0;
        }
        static SolveQuadric$double_A$double_A(c, s) {
            const n = EquationUtils.SolveQuadric$double_A$double_A$int(c, s, 0);
            EquationUtils.sortRoots(s, n);
            return n;
        }
        static SolveQuadric$double_A$double_A$int(c, s, n) {
            if (Math.abs(c[2]) < EquationUtils.EQN_EPS) {
                if (Math.abs(c[1]) < EquationUtils.EQN_EPS) {
                    if (Math.abs(c[0]) > EquationUtils.EQN_EPS) {
                        if (EquationUtils.allowInfinityAsRoot) {
                            s[0] = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                            return 1;
                        }
                        else
                            return 0;
                    }
                    else
                        return 0;
                }
                if (EquationUtils.allowInfinityAsRoot) {
                    s[0] = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                    s[1] = -c[0] / c[1];
                    return 2;
                }
                else {
                    s[0] = -c[0] / c[1];
                    return 1;
                }
            }
            let p;
            let q;
            let D;
            p = c[1] / (2 * c[2]);
            q = c[0] / c[2];
            D = p * p - q;
            if (EquationUtils.IsZero(D)) {
                s[0 + n] = -p;
                return 1;
            }
            else if (D < 0) {
                return 0;
            }
            else if (D > 0) {
                const sqrt_D = Math.sqrt(D);
                s[0 + n] = sqrt_D - p;
                s[1 + n] = -sqrt_D - p;
                return 2;
            }
            return -1;
        }
        /**
         * Solve a quadric equation
         *
         * @param {double[]} c  array containing the coefficients of the equation coefficients are passed like this
         * c[2]*x^2 + c[1]*x + c[0]  = 0 (if  c2=0 you may get infinity as one root)
         * @param {double[]} s
         * storage for the roots of the equation
         * @param {number} n
         * offset into the result array, if non-zero
         * @return {number} the number of roots of the equation
         * @private
         */
        static SolveQuadric(c, s, n) {
            if (((c != null && c instanceof Array && (c.length == 0 || c[0] == null || (typeof c[0] === 'number'))) || c === null) && ((s != null && s instanceof Array && (s.length == 0 || s[0] == null || (typeof s[0] === 'number'))) || s === null) && ((typeof n === 'number') || n === null)) {
                return math.EquationUtils.SolveQuadric$double_A$double_A$int(c, s, n);
            }
            else if (((c != null && c instanceof Array && (c.length == 0 || c[0] == null || (typeof c[0] === 'number'))) || c === null) && ((s != null && s instanceof Array && (s.length == 0 || s[0] == null || (typeof s[0] === 'number'))) || s === null) && n === undefined) {
                return math.EquationUtils.SolveQuadric$double_A$double_A(c, s);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Solves a quadratic equation
         *
         * @param  coefficients are passed like this:
         *
         * c2*x^2 + c1*x + c0 = 0 (make sure c2!=0)
         *
         * @param {double[]} s
         * storage for results
         * @return {number} the number of roots of the equation
         * @param {number} c2
         * @param {number} c1
         * @param {number} c0
         */
        static SolveQuadratic(c2, c1, c0, s) {
            const coeff = [c0, c1, c2];
            return EquationUtils.SolveQuadric$double_A$double_A(coeff, s);
        }
        static SolveCubic$double_A$double_A(c, s) {
            if (Math.abs(c[3]) < EquationUtils.EQN_EPS) {
                const roots = [0, 0];
                const n = EquationUtils.SolveQuadric$double_A$double_A(c, roots);
                for (let i = 0; i < n; i++) {
                    {
                        s[i] = roots[i];
                    }
                    ;
                }
                if (EquationUtils.allowInfinityAsRoot) {
                    s[n] = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                    return n + 1;
                }
                else {
                    return n;
                }
            }
            let i;
            let num;
            let sub;
            let A;
            let B;
            let C;
            let sq_A;
            let p;
            let q;
            let cb_p;
            let D;
            A = c[2] / c[3];
            B = c[1] / c[3];
            C = c[0] / c[3];
            sq_A = A * A;
            p = 1.0 / 3 * (-1.0 / 3 * sq_A + B);
            q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);
            cb_p = p * p * p;
            D = q * q + cb_p;
            if (EquationUtils.IsZero(D)) {
                if (EquationUtils.IsZero(q)) {
                    s[0] = 0;
                    num = 1;
                }
                else {
                    const u = EquationUtils.cbrt(-q);
                    s[0] = 2 * u;
                    s[1] = -u;
                    num = 2;
                }
            }
            else if (D < 0) {
                const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));
                const t = 2 * Math.sqrt(-p);
                s[0] = t * Math.cos(phi);
                s[1] = -t * Math.cos(phi + Math.PI / 3);
                s[2] = -t * Math.cos(phi - Math.PI / 3);
                num = 3;
            }
            else {
                const sqrt_D = Math.sqrt(D);
                const u = EquationUtils.cbrt(sqrt_D - q);
                const v = -EquationUtils.cbrt(sqrt_D + q);
                s[0] = u + v;
                num = 1;
            }
            sub = 1.0 / 3 * A;
            for (i = 0; i < num; ++i) {
                s[i] -= sub;
            }
            return num;
        }
        static SolveCubic$double$double$double$double$double_A(c3, c2, c1, c0, s) {
            const coeff = [c0, c1, c2, c3];
            const n = EquationUtils.SolveCubic$double_A$double_A(coeff, s);
            EquationUtils.sortRoots(s, n);
            return n;
        }
        /**
         * Solves a cubic equation
         *
         * @param  coefficients are passed like this:
         *
         * c3*x^3  + c2*x^2 + c1*x + c0  = 0 (make sure c3!=0)
         *
         * @param {double[]} s
         * storage for results
         * @return {number} the number of roots of the equation
         * @param {number} c3
         * @param {number} c2
         * @param {number} c1
         * @param {number} c0
         */
        static SolveCubic(c3, c2, c1, c0, s) {
            if (((typeof c3 === 'number') || c3 === null) && ((typeof c2 === 'number') || c2 === null) && ((typeof c1 === 'number') || c1 === null) && ((typeof c0 === 'number') || c0 === null) && ((s != null && s instanceof Array && (s.length == 0 || s[0] == null || (typeof s[0] === 'number'))) || s === null)) {
                return math.EquationUtils.SolveCubic$double$double$double$double$double_A(c3, c2, c1, c0, s);
            }
            else if (((c3 != null && c3 instanceof Array && (c3.length == 0 || c3[0] == null || (typeof c3[0] === 'number'))) || c3 === null) && ((c2 != null && c2 instanceof Array && (c2.length == 0 || c2[0] == null || (typeof c2[0] === 'number'))) || c2 === null) && c1 === undefined && c0 === undefined && s === undefined) {
                return math.EquationUtils.SolveCubic$double_A$double_A(c3, c2);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Solves the equation ax^2+bx+c=0. Solutions are returned in a sorted array
         * if they exist.
         *
         * @param {number} a coefficient of x^2
         * @param {number} b coefficient of x^1
         * @param {number} c coefficient of x^0
         * @return {double[]} an array containing the two real roots, or <code>null</code> if
         * no real solutions exist
         */
        static solveQuadric(a, b, c) {
            let disc = b * b - 4 * a * c;
            if (disc < 0)
                return null;
            disc = Math.sqrt(disc);
            const q = ((b < 0) ? -0.5 * (b - disc) : -0.5 * (b + disc));
            const t0 = q / a;
            const t1 = c / q;
            return (t0 > t1) ? [t1, t0] : [t0, t1];
        }
        /**
         * Solve a quartic equation of the form ax^4+bx^3+cx^2+cx^1+d=0. The roots
         * are returned in a sorted array of doubles in increasing order.
         *
         * @param {number} a coefficient of x^4
         * @param {number} b coefficient of x^3
         * @param {number} c coefficient of x^2
         * @param {number} d coefficient of x^1
         * @param {number} e coefficient of x^0
         * @return {double[]} a sorted array of roots, or <code>null</code> if no solutions
         * exist
         */
        static solveQuartic(a, b, c, d, e) {
            const inva = 1 / a;
            const c1 = b * inva;
            const c2 = c * inva;
            const c3 = d * inva;
            const c4 = e * inva;
            const c12 = c1 * c1;
            const p = -0.375 * c12 + c2;
            const q = 0.125 * c12 * c1 - 0.5 * c1 * c2 + c3;
            const r = -0.01171875 * c12 * c12 + 0.0625 * c12 * c2 - 0.25 * c1 * c3 + c4;
            const z = EquationUtils.solveCubicForQuartic(-0.5 * p, -r, 0.5 * r * p - 0.125 * q * q);
            let d1 = 2.0 * z - p;
            if (d1 < 0) {
                if (d1 > 1.0E-10)
                    d1 = 0;
                else
                    return null;
            }
            let d2;
            if (d1 < 1.0E-10) {
                d2 = z * z - r;
                if (d2 < 0)
                    return null;
                d2 = Math.sqrt(d2);
            }
            else {
                d1 = Math.sqrt(d1);
                d2 = 0.5 * q / d1;
            }
            const q1 = d1 * d1;
            const q2 = -0.25 * c1;
            let pm = q1 - 4 * (z - d2);
            let pp = q1 - 4 * (z + d2);
            if (pm >= 0 && pp >= 0) {
                pm = Math.sqrt(pm);
                pp = Math.sqrt(pp);
                const results = [0, 0, 0, 0];
                results[0] = -0.5 * (d1 + pm) + q2;
                results[1] = -0.5 * (d1 - pm) + q2;
                results[2] = 0.5 * (d1 + pp) + q2;
                results[3] = 0.5 * (d1 - pp) + q2;
                for (let i = 1; i < 4; i++) {
                    {
                        for (let j = i; j > 0 && results[j - 1] > results[j]; j--) {
                            {
                                const t = results[j];
                                results[j] = results[j - 1];
                                results[j - 1] = t;
                            }
                            ;
                        }
                    }
                    ;
                }
                return results;
            }
            else if (pm >= 0) {
                pm = Math.sqrt(pm);
                const results = [0, 0];
                results[0] = -0.5 * (d1 + pm) + q2;
                results[1] = -0.5 * (d1 - pm) + q2;
                return results;
            }
            else if (pp >= 0) {
                pp = Math.sqrt(pp);
                const results = [0, 0];
                results[0] = 0.5 * (d1 - pp) + q2;
                results[1] = 0.5 * (d1 + pp) + q2;
                return results;
            }
            return null;
        }
        /**
         * Return only one root for the specified cubic equation. This routine is
         * only meant to be called by the quartic solver. It assumes the cubic is of
         * the form: x^3+px^2+qx+r.
         *
         * @param {number} p
         * @param {number} q
         * @param {number} r
         * @return
         * @return {number}
         * @private
         */
        static solveCubicForQuartic(p, q, r) {
            const A2 = p * p;
            const Q = (A2 - 3.0 * q) / 9.0;
            const R = (p * (A2 - 4.5 * q) + 13.5 * r) / 27.0;
            const Q3 = Q * Q * Q;
            const R2 = R * R;
            let d = Q3 - R2;
            const an = p / 3.0;
            if (d >= 0) {
                d = R / Math.sqrt(Q3);
                const theta = Math.acos(d) / 3.0;
                const sQ = -2.0 * Math.sqrt(Q);
                return sQ * Math.cos(theta) - an;
            }
            else {
                const sQ = Math.pow(Math.sqrt(R2 - Q3) + Math.abs(R), 1.0 / 3.0);
                if (R < 0)
                    return (sQ + Q / sQ) - an;
                else
                    return -(sQ + Q / sQ) - an;
            }
        }
        static SolveBiQuartic$double_A$double_A(c, s) {
            if (Math.abs(c[4]) < EquationUtils.EQN_EPS) {
                const roots = [0, 0, 0];
                const n = EquationUtils.SolveCubic$double_A$double_A(c, roots);
                for (let i = 0; i < n; i++) {
                    {
                        s[i] = roots[i];
                    }
                    ;
                }
                if (EquationUtils.allowInfinityAsRoot) {
                    s[n] = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                    return n + 1;
                }
                else {
                    return n;
                }
            }
            const coeffs = [0, 0, 0, 0];
            let z;
            let u;
            let v;
            let sub;
            let A;
            let B;
            let C;
            let D;
            let sq_A;
            let p;
            let q;
            let r;
            let i;
            let num;
            A = c[3] / c[4];
            B = c[2] / c[4];
            C = c[1] / c[4];
            D = c[0] / c[4];
            sq_A = A * A;
            p = -3.0 / 8 * sq_A + B;
            q = 1.0 / 8 * sq_A * A - 1.0 / 2 * A * B + C;
            r = -3.0 / 256 * sq_A * sq_A + 1.0 / 16 * sq_A * B - 1.0 / 4 * A * C + D;
            if (EquationUtils.IsZero(r)) {
                coeffs[0] = q;
                coeffs[1] = p;
                coeffs[2] = 0;
                coeffs[3] = 1;
                num = EquationUtils.SolveCubic$double_A$double_A(coeffs, s);
                s[num++] = 0;
            }
            else {
                coeffs[0] = 1.0 / 2 * r * p - 1.0 / 8 * q * q;
                coeffs[1] = -r;
                coeffs[2] = -1.0 / 2 * p;
                coeffs[3] = 1;
                EquationUtils.SolveCubic$double_A$double_A(coeffs, s);
                z = s[0];
                u = z * z - r;
                v = 2 * z - p;
                if (EquationUtils.IsZero(u))
                    u = 0;
                else if (u > 0)
                    u = Math.sqrt(u);
                else
                    return 0;
                if (EquationUtils.IsZero(v))
                    v = 0;
                else if (v > 0)
                    v = Math.sqrt(v);
                else
                    return 0;
                coeffs[0] = z - u;
                coeffs[1] = q < 0 ? -v : v;
                coeffs[2] = 1;
                num = EquationUtils.SolveQuadric$double_A$double_A(coeffs, s);
                coeffs[0] = z + u;
                coeffs[1] = q < 0 ? v : -v;
                coeffs[2] = 1;
                num += EquationUtils.SolveQuadric$double_A$double_A$int(coeffs, s, num);
            }
            sub = 1.0 / 4 * A;
            for (i = 0; i < num; ++i) {
                s[i] -= sub;
            }
            return num;
        }
        static SolveBiQuartic$double$double$double$double$double$double_A(c4, c3, c2, c1, c0, s) {
            const coeff = [c0, c1, c2, c3, c4];
            const n = EquationUtils.SolveBiQuartic$double_A$double_A(coeff, s);
            EquationUtils.sortRoots(s, n);
            return n;
        }
        /**
         * Solves a quartic equation
         *
         * @param  coefficients are passed like this:
         *
         * c4*x^4 + c3*x^3 + c2*x^2 + c1*x + c0 = 0 (make sure c4!=0)
         *
         * @param {double[]} s
         * storage for results
         * @return {number} the number of roots of the equation
         * @param {number} c4
         * @param {number} c3
         * @param {number} c2
         * @param {number} c1
         * @param {number} c0
         */
        static SolveBiQuartic(c4, c3, c2, c1, c0, s) {
            if (((typeof c4 === 'number') || c4 === null) && ((typeof c3 === 'number') || c3 === null) && ((typeof c2 === 'number') || c2 === null) && ((typeof c1 === 'number') || c1 === null) && ((typeof c0 === 'number') || c0 === null) && ((s != null && s instanceof Array && (s.length == 0 || s[0] == null || (typeof s[0] === 'number'))) || s === null)) {
                return math.EquationUtils.SolveBiQuartic$double$double$double$double$double$double_A(c4, c3, c2, c1, c0, s);
            }
            else if (((c4 != null && c4 instanceof Array && (c4.length == 0 || c4[0] == null || (typeof c4[0] === 'number'))) || c4 === null) && ((c3 != null && c3 instanceof Array && (c3.length == 0 || c3[0] == null || (typeof c3[0] === 'number'))) || c3 === null) && c2 === undefined && c1 === undefined && c0 === undefined && s === undefined) {
                return math.EquationUtils.SolveBiQuartic$double_A$double_A(c4, c3);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Solves the sytem of lienar equations of n variables
         * @param {double[][]} mat 2 dimensional array of n entries each as array of n coefficients representing coefficients of linear equations in order
         * @param {double[]} v array of n constants in the equation
         * <pre>
         * For example to solve 2x + 3y = 4,
         * x  - 4y = 2
         * We use solve <b> solveLinear([[2,3],[1,-4]], [4,2]) </b> which returns solution as [2,0]
         * </pre>
         * @return
         * @return {double[]}
         */
        static solveLinear(mat, v) {
            const m = new EquationUtils.Matrix(mat);
            try {
                return m.solve(v);
            }
            catch (e) {
                return null;
            }
        }
        /**
         * sorts input array elements from zeroth element to (num-1)th element
         * @param {double[]} s
         * @param {number} num
         * @private
         */
        static sortRoots(s, num) {
            const r = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(num);
            for (let i = 0; i < num; i++) {
                r[i] = s[i];
            }
            java.util.Arrays.sort(r);
            for (let i = 0; i < num; i++) {
                s[i] = r[i];
            }
        }
        static main(args) {
            const quadRes = [0, 0];
            console.info("%d Roots are %f and %f \n");
            const cubeRes = [0, 0, 0];
            console.info("%d Roots are %f and %f and %f \n");
            const quatRes = [0, 0, 0, 0];
            console.info("%d Roots are %f and %f and %f and %f \n");
            const eqn = [[2.0, 1.0], [1.0, -2.0]];
            const coeff = [4.0, -3.0];
            const res = EquationUtils.solveLinear(eqn, coeff);
            console.info("Solution of 2x + 1y = 4, x  - 4y = 2 is " + java.util.Arrays.toString(res));
        }
    }
    /**
     * flag to allow infinity as one of roots when solving equations*
     * handy when we deal with slopes which can take value infinity
     */
    EquationUtils.allowInfinityAsRoot = true;
    /**
     * epsilon value
     */
    EquationUtils.EQN_EPS = 1.0E-6;
    math.EquationUtils = EquationUtils;
    EquationUtils["__class"] = "math.EquationUtils";
    (function (EquationUtils) {
        /**
         * Initializes a new Matrix with the given number of rows and columns.
         * @param {number} nbRows
         * @param {number} nbCols
         * @class
         */
        class Matrix {
            constructor(nbRows, nbCols) {
                if (((typeof nbRows === 'number') || nbRows === null) && ((typeof nbCols === 'number') || nbCols === null)) {
                    let __args = arguments;
                    if (this.nRows === undefined) {
                        this.nRows = 0;
                    }
                    if (this.nCols === undefined) {
                        this.nCols = 0;
                    }
                    if (this.el === undefined) {
                        this.el = null;
                    }
                    this.nRows = nbRows;
                    this.nCols = nbCols;
                    this.el = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                        return 0;
                    }
                    else {
                        let array = [];
                        for (let i = 0; i < dims[0]; i++) {
                            array.push(allocate(dims.slice(1)));
                        }
                        return array;
                    } }; return allocate(dims); })([this.nRows, this.nCols]);
                    this.setToIdentity();
                }
                else if (((nbRows != null && nbRows instanceof Array && (nbRows.length == 0 || nbRows[0] == null || nbRows[0] instanceof Array)) || nbRows === null) && nbCols === undefined) {
                    let __args = arguments;
                    let coef = __args[0];
                    if (this.nRows === undefined) {
                        this.nRows = 0;
                    }
                    if (this.nCols === undefined) {
                        this.nCols = 0;
                    }
                    if (this.el === undefined) {
                        this.el = null;
                    }
                    if (coef == null) {
                        this.nRows = 1;
                        this.nCols = 1;
                        this.el = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return 0;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([this.nRows, this.nCols]);
                        this.setToIdentity();
                        return;
                    }
                    this.nRows = coef.length;
                    this.nCols = coef[0].length;
                    this.el = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                        return 0;
                    }
                    else {
                        let array = [];
                        for (let i = 0; i < dims[0]; i++) {
                            array.push(allocate(dims.slice(1)));
                        }
                        return array;
                    } }; return allocate(dims); })([this.nRows, this.nCols]);
                    for (let r = 0; r < this.nRows; r++) {
                        for (let c = 0; c < this.nCols; c++) {
                            this.el[r][c] = coef[r][c];
                        }
                        ;
                    }
                }
                else if (nbRows === undefined && nbCols === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let nbRows = 1;
                        let nbCols = 1;
                        if (this.nRows === undefined) {
                            this.nRows = 0;
                        }
                        if (this.nCols === undefined) {
                            this.nCols = 0;
                        }
                        if (this.el === undefined) {
                            this.el = null;
                        }
                        this.nRows = nbRows;
                        this.nCols = nbCols;
                        this.el = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return 0;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([this.nRows, this.nCols]);
                        this.setToIdentity();
                    }
                    if (this.nRows === undefined) {
                        this.nRows = 0;
                    }
                    if (this.nCols === undefined) {
                        this.nCols = 0;
                    }
                    if (this.el === undefined) {
                        this.el = null;
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Returns the coef. row and col are between 1 and the number of rows and
             * columns.
             * @param {number} row
             * @param {number} col
             * @return {number}
             */
            getCoef(row, col) {
                return this.el[row - 1][col - 1];
            }
            /**
             * Returns the number of rows.
             * @return {number}
             */
            getRows() {
                return this.nRows;
            }
            /**
             * Returns the number of columns.
             * @return {number}
             */
            getColumns() {
                return this.nCols;
            }
            /**
             * Returns true if the matrix is square, i.e. the number of rows equals the
             * number of columns.
             * @return {boolean}
             */
            isSquare() {
                return (this.nCols === this.nRows);
            }
            /**
             * Sets the coef to the given value. row and col are between 1 and the number
             * of rows and columns.
             * @param {number} row
             * @param {number} col
             * @param {number} coef
             */
            setCoef(row, col, coef) {
                this.el[row - 1][col - 1] = coef;
            }
            multiplyWith$math_EquationUtils_Matrix(matrix) {
                if (this.nCols !== matrix.nRows)
                    throw new java.lang.IllegalArgumentException("Matrix sizes do not match");
                let sum;
                const m = new EquationUtils.Matrix(this.nRows, matrix.nCols);
                for (let r = 0; r < m.nRows; r++) {
                    for (let c = 0; c < m.nCols; c++) {
                        {
                            sum = 0;
                            for (let i = 0; i < this.nCols; i++) {
                                sum += this.el[r][i] * matrix.el[i][c];
                            }
                            m.el[r][c] = sum;
                        }
                        ;
                    }
                    ;
                }
                return m;
            }
            multiplyWith$double_A(coefs) {
                if (coefs == null) {
                    throw new java.lang.NullPointerException();
                }
                if (coefs.length !== this.nCols)
                    throw new java.lang.IllegalArgumentException("Matrix sizes do not match");
                let sum;
                const res = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(this.nRows);
                for (let r = 0; r < this.nRows; r++) {
                    {
                        sum = 0;
                        for (let c = 0; c < this.nCols; c++) {
                            sum += this.el[r][c] * coefs[c];
                        }
                        res[r] = sum;
                    }
                    ;
                }
                return res;
            }
            multiplyWith$double_A$double_A(src, res) {
                if (src == null)
                    throw new java.lang.NullPointerException();
                if (src.length !== this.nCols)
                    throw new java.lang.IllegalArgumentException("Matrix sizes do not match");
                if (src.length !== res.length)
                    res = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(this.nRows);
                let sum;
                for (let r = 0; r < this.nRows; r++) {
                    {
                        sum = 0;
                        for (let c = 0; c < this.nCols; c++) {
                            sum += this.el[r][c] * src[c];
                        }
                        res[r] = sum;
                    }
                    ;
                }
                return res;
            }
            /**
             * Returns the result of the multiplication of the matrix with the given
             * vector. The content of the matrix is not modified.
             * @throws NullPointerException if input vector is null
             * @throws IllegalArgumentException if size of vector and of matrix do not match
             * @param {double[]} src
             * @param {double[]} res
             * @return {double[]}
             */
            multiplyWith(src, res) {
                if (((src != null && src instanceof Array && (src.length == 0 || src[0] == null || (typeof src[0] === 'number'))) || src === null) && ((res != null && res instanceof Array && (res.length == 0 || res[0] == null || (typeof res[0] === 'number'))) || res === null)) {
                    return this.multiplyWith$double_A$double_A(src, res);
                }
                else if (((src != null && src instanceof math.EquationUtils.Matrix) || src === null) && res === undefined) {
                    return this.multiplyWith$math_EquationUtils_Matrix(src);
                }
                else if (((src != null && src instanceof Array && (src.length == 0 || src[0] == null || (typeof src[0] === 'number'))) || src === null) && res === undefined) {
                    return this.multiplyWith$double_A(src);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Transposes the matrix, changing the inner coefficients.
             */
            transpose() {
                const tmp = this.nCols;
                this.nCols = this.nRows;
                this.nRows = tmp;
                const oldData = this.el;
                this.el = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                    return 0;
                }
                else {
                    let array = [];
                    for (let i = 0; i < dims[0]; i++) {
                        array.push(allocate(dims.slice(1)));
                    }
                    return array;
                } }; return allocate(dims); })([this.nRows, this.nCols]);
                for (let r = 0; r < this.nRows; r++) {
                    for (let c = 0; c < this.nCols; c++) {
                        this.el[r][c] = oldData[c][r];
                    }
                    ;
                }
            }
            /**
             * Returns the transposed matrix, without changing the inner coefficients
             * of the original matrix.
             * @return {math.EquationUtils.Matrix}
             */
            getTranspose() {
                const mat = new EquationUtils.Matrix(this.nCols, this.nRows);
                for (let r = 0; r < this.nRows; r++) {
                    for (let c = 0; c < this.nCols; c++) {
                        mat.el[c][r] = this.el[r][c];
                    }
                    ;
                }
                return mat;
            }
            /**
             * Computes the solution of a linear system, using the Gauss-Jordan
             * algorithm. The inner coefficients of the matrix are not modified.
             * @throws NullPointerException if input vector is null
             * @throws IllegalArgumentException if size of vector and of matrix do not match
             * @throws UnsupportedOperationException if the matrix is not square
             * @throws ArithmeticException if the algorithm could not find pivot greater than tolerance
             * @param {double[]} vector
             * @return {double[]}
             */
            solve(vector) {
                if (vector == null)
                    throw new java.lang.NullPointerException();
                if (vector.length !== this.nRows)
                    throw new java.lang.IllegalArgumentException("Matrix and vector dimensions do not match");
                if (this.nCols !== this.nRows)
                    throw new java.lang.UnsupportedOperationException("Try to invert non square Matrix");
                const res = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(vector.length);
                for (let i = 0; i < this.nRows; i++) {
                    res[i] = vector[i];
                }
                const mat = new EquationUtils.Matrix(this.el);
                let r;
                let c;
                let p;
                let r2;
                let pivot;
                let tmp;
                for (r = 0; r < this.nRows; r++) {
                    {
                        p = r;
                        while (((Math.abs(mat.el[p][r]) < EquationUtils.Matrix.tolerance) && (p < this.nRows))) {
                            p++;
                        }
                        ;
                        if (p === this.nRows)
                            throw new java.lang.ArithmeticException("Degenerated linear system");
                        for (c = 0; c < this.nRows; c++) {
                            {
                                tmp = mat.el[r][c];
                                mat.el[r][c] = mat.el[p][c];
                                mat.el[p][c] = tmp;
                            }
                            ;
                        }
                        tmp = res[r];
                        res[r] = res[p];
                        res[p] = tmp;
                        pivot = mat.el[r][r];
                        for (c = r + 1; c < this.nRows; c++) {
                            mat.el[r][c] /= pivot;
                        }
                        res[r] /= pivot;
                        mat.el[r][r] = 1;
                        for (r2 = 0; r2 < r; r2++) {
                            {
                                pivot = mat.el[r2][r];
                                for (c = r + 1; c < this.nRows; c++) {
                                    mat.el[r2][c] -= pivot * mat.el[r][c];
                                }
                                res[r2] -= pivot * res[r];
                                mat.el[r2][r] = 0;
                            }
                            ;
                        }
                        for (r2 = r + 1; r2 < this.nRows; r2++) {
                            {
                                pivot = mat.el[r2][r];
                                for (c = r + 1; c < this.nRows; c++) {
                                    mat.el[r2][c] -= pivot * mat.el[r][c];
                                }
                                res[r2] -= pivot * res[r];
                                mat.el[r2][r] = 0;
                            }
                            ;
                        }
                    }
                    ;
                }
                return res;
            }
            /**
             * Fills the matrix with zeros everywhere, except on the main diagonal,
             * filled with ones.
             */
            setToIdentity() {
                for (let r = 0; r < this.nRows; r++) {
                    for (let c = 0; c < this.nCols; c++) {
                        this.el[r][c] = 0;
                    }
                    ;
                }
                for (let i = Math.min(this.nRows, this.nCols) - 1; i >= 0; i--) {
                    this.el[i][i] = 1;
                }
            }
            /**
             * Returns a String representation of the elements of the Matrix
             * @return {string}
             */
            toString() {
                let res = new String("");
                res = res.concat("Matrix size : " + /* toString */ ('' + (this.nRows)) + " rows and " + /* toString */ ('' + (this.nCols)) + " columns.\n");
                for (let r = 0; r < this.nRows; r++) {
                    {
                        for (let c = 0; c < this.nCols; c++) {
                            res = res.concat(/* toString */ ('' + (this.el[r][c]))).concat(" ");
                        }
                        res = res.concat(new String("\n"));
                    }
                    ;
                }
                return res;
            }
        }
        /**
         * The tolerance used for solving linear equations. Equal to 1e-14 by default.
         */
        Matrix.tolerance = 1.0E-14;
        EquationUtils.Matrix = Matrix;
        Matrix["__class"] = "math.EquationUtils.Matrix";
    })(EquationUtils = math.EquationUtils || (math.EquationUtils = {}));
})(math || (math = {}));
(function (math) {
    class Unicode {
        static play_$LI$() { if (Unicode.play == null) {
            Unicode.play = javaemul.internal.CharacterHelper.toString('\u25b6');
        } return Unicode.play; }
        static pause_$LI$() { if (Unicode.pause == null) {
            Unicode.pause = javaemul.internal.CharacterHelper.toString('\u23f8');
        } return Unicode.pause; }
        static reset_$LI$() { if (Unicode.reset == null) {
            Unicode.reset = javaemul.internal.CharacterHelper.toString('\u21ba');
        } return Unicode.reset; }
        static stop_$LI$() { if (Unicode.stop == null) {
            Unicode.stop = javaemul.internal.CharacterHelper.toString('\u25fb');
        } return Unicode.stop; }
        static circle_$LI$() { if (Unicode.circle == null) {
            Unicode.circle = javaemul.internal.CharacterHelper.toString('\u25cb');
        } return Unicode.circle; }
        static triangle_$LI$() { if (Unicode.triangle == null) {
            Unicode.triangle = javaemul.internal.CharacterHelper.toString('\u25bc');
        } return Unicode.triangle; }
        static reload_$LI$() { if (Unicode.reload == null) {
            Unicode.reload = javaemul.internal.CharacterHelper.toString('\u27f3');
        } return Unicode.reload; }
        static measuredAngleSpace_$LI$() { if (Unicode.measuredAngleSpace == null) {
            Unicode.measuredAngleSpace = Unicode.angle + " ";
        } return Unicode.measuredAngleSpace; }
        static degree_$LI$() { if (Unicode.degree == null) {
            Unicode.degree = javaemul.internal.CharacterHelper.toString(Unicode.degreeChar);
        } return Unicode.degree; }
        static EULER_STRING_$LI$() { if (Unicode.EULER_STRING == null) {
            Unicode.EULER_STRING = Unicode.eulerChar + "";
        } return Unicode.EULER_STRING; }
        static PI_STRING_$LI$() { if (Unicode.PI_STRING == null) {
            Unicode.PI_STRING = javaemul.internal.CharacterHelper.toString(Unicode.piChar);
        } return Unicode.PI_STRING; }
        static numberToIndex(i) {
            const sb = new java.lang.StringBuilder();
            if (i < 0) {
                sb.append(Unicode.Superscript_Minus);
                i = -i;
            }
            if (i === 0) {
                sb.append(Unicode.Superscript_0);
            }
            else {
                while ((i > 0)) {
                    {
                        switch ((i % 10)) {
                            case 0:
                                sb.insert(0, Unicode.Superscript_0);
                                break;
                            case 1:
                                sb.insert(0, Unicode.Superscript_1);
                                break;
                            case 2:
                                sb.insert(0, Unicode.Superscript_2);
                                break;
                            case 3:
                                sb.insert(0, Unicode.Superscript_3);
                                break;
                            case 4:
                                sb.insert(0, Unicode.Superscript_4);
                                break;
                            case 5:
                                sb.insert(0, Unicode.Superscript_5);
                                break;
                            case 6:
                                sb.insert(0, Unicode.Superscript_6);
                                break;
                            case 7:
                                sb.insert(0, Unicode.Superscript_7);
                                break;
                            case 8:
                                sb.insert(0, Unicode.Superscript_8);
                                break;
                            case 9:
                                sb.insert(0, Unicode.Superscript_9);
                                break;
                        }
                        i = (i / 10 | 0);
                    }
                }
                ;
            }
            return sb.toString();
        }
        static isSuperscriptDigit(c) {
            return (((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) >= (c => c.charCodeAt == null ? c : c.charCodeAt(0))(Unicode.Superscript_0)) && ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) <= (c => c.charCodeAt == null ? c : c.charCodeAt(0))(Unicode.Superscript_9))) || ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) == (c => c.charCodeAt == null ? c : c.charCodeAt(0))(Unicode.Superscript_1)) || ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) == (c => c.charCodeAt == null ? c : c.charCodeAt(0))(Unicode.Superscript_2)) || ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) == (c => c.charCodeAt == null ? c : c.charCodeAt(0))(Unicode.Superscript_3));
        }
        static getSetOfSymbols(symbolsStartValue, symbolsNumber) {
            const symbols = (s => { let a = []; while (s-- > 0)
                a.push(null); return a; })(symbolsNumber);
            for (let i = 0; i < symbolsNumber; i++) {
                {
                    symbols[i] = "" + String.fromCharCode((symbolsStartValue + i));
                }
                ;
            }
            return symbols;
        }
    }
    Unicode.vector = '\u20d7';
    Unicode.hat = '\u0302';
    Unicode.angle = '\u2220';
    Unicode.measuredAngle = '\u2221';
    Unicode.perpendicular = "perpendicular";
    Unicode.parallel = "\u2225";
    Unicode.minus = '\u2212';
    Unicode.LESS_EQUAL = '\u2264';
    Unicode.GREATER_EQUAL = '\u2265';
    Unicode.Infinity = '\u221e';
    Unicode.MinusInfinity = "-\u221e";
    Unicode.Superscript_Minus = '\u207b';
    Unicode.Superscript_0 = '\u2070';
    Unicode.Superscript_1 = '\u00b9';
    Unicode.Superscript_2 = '\u00b2';
    Unicode.Superscript_3 = '\u00b3';
    Unicode.Superscript_4 = '\u2074';
    Unicode.Superscript_5 = '\u2075';
    Unicode.Superscript_6 = '\u2076';
    Unicode.Superscript_7 = '\u2077';
    Unicode.Superscript_8 = '\u2078';
    Unicode.Superscript_9 = '\u2079';
    Unicode.SubScript_0 = '\u2070';
    Unicode.SubScript_1 = '\u00b9';
    Unicode.SubScript_2 = '\u00b2';
    Unicode.SubScript_3 = '\u00b3';
    Unicode.SubScript_4 = '\u2074';
    Unicode.SubScript_5 = '\u2075';
    Unicode.SubScript_6 = '\u2076';
    Unicode.SubScript_7 = '\u2077';
    Unicode.SubScript_8 = '\u2078';
    Unicode.SubScript_9 = '\u2079';
    Unicode.Subscript_x = 'x';
    Unicode.Subscript_y = 'y';
    Unicode.RightToLeftMark = '\u200f';
    Unicode.RightToLeftUnaryMinusSign = "\u200f-\u200f";
    Unicode.LeftToRightMark = '\u200e';
    Unicode.superscriptMinusOneBracket = "\u207b\u00b9(";
    Unicode.degreeChar = '\u00b0';
    Unicode.eGrave = '\u00e8';
    Unicode.eAcute = '\u00e9';
    /**
     * Unicode symbol for e
     */
    Unicode.eulerChar = '\u212f';
    Unicode.EULER_GAMMA_STRING = "\u212f_\u03b3";
    /**
     * Unicode symbol for pi
     */
    Unicode.piChar = '\u03c0';
    Unicode.alphaBetaGamma = "\u03b1\u03b2\u03b3";
    Unicode.alpha = '\u03b1';
    Unicode.beta = '\u03b2';
    Unicode.gamma = '\u03b3';
    Unicode.delta = '\u03b4';
    Unicode.epsilon = '\u03b5';
    Unicode.zeta = '\u03b6';
    Unicode.eta = '\u03b7';
    Unicode.theta = '\u03b8';
    Unicode.iota = '\u03b9';
    Unicode.kappa = '\u03ba';
    Unicode.lambda = '\u03bb';
    Unicode.mu = '\u03bc';
    Unicode.nu = '\u03bd';
    Unicode.xi = '\u03be';
    Unicode.omicron = '\u03bf';
    Unicode.pi = '\u03c0';
    Unicode.rho = '\u03c1';
    Unicode.sigmaf = '\u03c2';
    Unicode.sigma = '\u03c3';
    Unicode.tau = '\u03c4';
    Unicode.upsilon = '\u03c5';
    Unicode.phi = '\u03c6';
    Unicode.phi_symbol = '\u03d5';
    Unicode.chi = '\u03c7';
    Unicode.psi = '\u03c8';
    Unicode.omega = '\u03c9';
    Unicode.Alpha = '\u0391';
    Unicode.Beta = '\u0392';
    Unicode.Gamma = '\u0393';
    Unicode.Delta = '\u0394';
    Unicode.Epsilon = '\u0395';
    Unicode.Zeta = '\u0396';
    Unicode.Eta = '\u0397';
    Unicode.Theta = '\u0398';
    Unicode.Iota = '\u0399';
    Unicode.Kappa = '\u039a';
    Unicode.Lambda = '\u039b';
    Unicode.Mu = '\u039c';
    Unicode.Nu = '\u039d';
    Unicode.Xi = '\u039e';
    Unicode.Omicron = '\u039f';
    Unicode.Pi = '\u03a0';
    Unicode.Rho = '\u03a1';
    Unicode.Sigma = '\u03a3';
    Unicode.Tau = '\u03a4';
    Unicode.Upsilon = '\u03a5';
    Unicode.Phi = '\u03a6';
    Unicode.Chi = '\u03a7';
    Unicode.Psi = '\u03a8';
    Unicode.Omega = '\u03a9';
    Unicode.Integral = '\u222b';
    Unicode.SQUARE_ROOT = "\u221a";
    Unicode.PLUSMINUS = "\u00b1";
    Unicode.NOTEQUAL = "\u2260";
    Unicode.QUESTEQ = "\u225f";
    Unicode.FEMININE_ORDINAL_INDICATOR = '\u00aa';
    Unicode.IMAGINARY = "\u03af";
    Unicode.NBSP = "\u00a0";
    Unicode.translationFixHu_endE1 = "bcde\u00e9fgi\u00edjlmnprstvwxz1479\'";
    Unicode.translationFixHu_endO1 = "ahko\u00f3qu\u00fay368";
    Unicode.translationFixHu_endOE1 = "\u00f6\u0151\u00fc\u017125";
    Unicode.translationFixHu_oe = "\u00f6";
    Unicode.translationFixHu_hoez = "h\u00f6z";
    Unicode.fraction1_8 = "\u215b";
    Unicode.fraction1_4 = "\u00bc";
    Unicode.fraction3_8 = "\u215c";
    Unicode.fraction1_2 = "\u00bd";
    Unicode.fraction5_8 = "\u215d";
    Unicode.fraction3_4 = "\u00be";
    Unicode.fraction7_8 = "\u215e";
    Unicode.multiply = '\u00d7';
    Unicode.divide = "\u00f7";
    Unicode.charactersWithDescenders = "\u00b5\u1ef3\u0177\u0135\u0157\u0163\u0137\u015f\u0137\u013c\u00e7\u0146\u1ef9\u011f\u011d\u0123\u00fdgjy\u03be\u03b2\u03c8\u03b3\u03b7\u03c2\u0444\u0449\u0446\u0d71\u0d6c\u0d6b\u0d33\u0d67\u0630\u0648\u0635\u0628\u0631\u064d\u0633\u062e\u064a\u064d";
    Unicode.nDash = '\u2013';
    Unicode.ArabicComma = '\u066b';
    Unicode.ellipsis = '\u2026';
    Unicode.VECTOR_PRODUCT = '\u2297';
    Unicode.OPEN_DOUBLE_QUOTE = '\u201c';
    Unicode.CLOSE_DOUBLE_QUOTE = '\u201d';
    Unicode.CAS_OUTPUT_PREFIX = "\u2192";
    Unicode.CAS_OUTPUT_KEEPINPUT = "\u2713";
    Unicode.CAS_OUTPUT_NUMERIC = "\u2248";
    math.Unicode = Unicode;
    Unicode["__class"] = "math.Unicode";
})(math || (math = {}));
(function (math) {
    /**
     * Creates a {@link Vector2} from the first point to the second point.
     * @param {number} x1 the x coordinate of the first point
     * @param {number} y1 the y coordinate of the first point
     * @param {number} x2 the x coordinate of the second point
     * @param {number} y2 the y coordinate of the second point
     * @class
     * @author Mahesh Kurmi
     */
    class Vector2 {
        constructor(x1, y1, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                let __args = arguments;
                if (this.x === undefined) {
                    this.x = 0;
                }
                if (this.y === undefined) {
                    this.y = 0;
                }
                this.x = x2 - x1;
                this.y = y2 - y1;
            }
            else if (((x1 != null && x1 instanceof math.Vector2) || x1 === null) && ((y1 != null && y1 instanceof math.Vector2) || y1 === null) && x2 === undefined && y2 === undefined) {
                let __args = arguments;
                let p1 = __args[0];
                let p2 = __args[1];
                if (this.x === undefined) {
                    this.x = 0;
                }
                if (this.y === undefined) {
                    this.y = 0;
                }
                this.x = p2.x - p1.x;
                this.y = p2.y - p1.y;
            }
            else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && x2 === undefined && y2 === undefined) {
                let __args = arguments;
                let x = __args[0];
                let y = __args[1];
                if (this.x === undefined) {
                    this.x = 0;
                }
                if (this.y === undefined) {
                    this.y = 0;
                }
                this.x = x;
                this.y = y;
            }
            else if (((x1 != null && x1 instanceof math.Vector2) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                let __args = arguments;
                let vector = __args[0];
                if (this.x === undefined) {
                    this.x = 0;
                }
                if (this.y === undefined) {
                    this.y = 0;
                }
                this.x = vector.x;
                this.y = vector.y;
            }
            else if (((typeof x1 === 'number') || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                let __args = arguments;
                let direction = __args[0];
                if (this.x === undefined) {
                    this.x = 0;
                }
                if (this.y === undefined) {
                    this.y = 0;
                }
                this.x = Math.cos(direction);
                this.y = Math.sin(direction);
            }
            else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                let __args = arguments;
                if (this.x === undefined) {
                    this.x = 0;
                }
                if (this.y === undefined) {
                    this.y = 0;
                }
            }
            else
                throw new Error('invalid overload');
        }
        static X_AXIS_$LI$() { if (Vector2.X_AXIS == null) {
            Vector2.X_AXIS = new Vector2(1.0, 0.0);
        } return Vector2.X_AXIS; }
        static Y_AXIS_$LI$() { if (Vector2.Y_AXIS == null) {
            Vector2.Y_AXIS = new Vector2(0.0, 1.0);
        } return Vector2.Y_AXIS; }
        static INV_X_AXIS_$LI$() { if (Vector2.INV_X_AXIS == null) {
            Vector2.INV_X_AXIS = new Vector2(-1.0, 0.0);
        } return Vector2.INV_X_AXIS; }
        static INV_Y_AXIS_$LI$() { if (Vector2.INV_Y_AXIS == null) {
            Vector2.INV_Y_AXIS = new Vector2(0.0, -1.0);
        } return Vector2.INV_Y_AXIS; }
        /**
         * Returns true if Vectors are very Close to each other
         * @param Vetor2 v
         * @return
         * @param {math.Vector2} v
         * @return {boolean}
         */
        approxEqual(v) {
            return Math.abs(this.x - v.x) < math.MathUtils.EPSILON && Math.abs(this.y - v.y) < math.MathUtils.EPSILON;
        }
        /**
         * Returns true if Vector is very Close to specified coordinates
         * @param {number} x
         * @param {number} y
         * @return
         * @return {boolean}
         */
        approxEquals(x, y) {
            return Math.abs(this.x - x) < math.MathUtils.EPSILON && Math.abs(this.y - y) < math.MathUtils.EPSILON;
        }
        /**
         * Returns a new {@link Vector2} given the magnitude and direction.
         * @param {number} magnitude the magnitude of the {@link Vector2}
         * @param {number} direction the direction of the {@link Vector2} in radians
         * @return {math.Vector2} {@link Vector2}
         */
        static create(magnitude, direction) {
            const x = magnitude * Math.cos(direction);
            const y = magnitude * Math.sin(direction);
            return new Vector2(x, y);
        }
        /**
         * Returns a copy of this {@link Vector2}.
         * @return {math.Vector2} {@link Vector2}
         */
        copy() {
            return new Vector2(this.x, this.y);
        }
        distance$double$double(x, y) {
            const dx = this.x - x;
            const dy = this.y - y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        /**
         * Returns the distance from this point to the given point.
         * @param {number} x the x coordinate of the point
         * @param {number} y the y coordinate of the point
         * @return {number} double
         */
        distance(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.distance$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.distance$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        distance$math_Vector2(point) {
            const dx = this.x - point.x;
            const dy = this.y - point.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        distanceSquared$double$double(x, y) {
            const dx = this.x - x;
            const dy = this.y - y;
            return dx * dx + dy * dy;
        }
        /**
         * Returns the distance from this point to the given point squared.
         * @param {number} x the x coordinate of the point
         * @param {number} y the y coordinate of the point
         * @return {number} double
         */
        distanceSquared(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.distanceSquared$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.distanceSquared$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        distanceSquared$math_Vector2(point) {
            const dx = this.x - point.x;
            const dy = this.y - point.y;
            return dx * dx + dy * dy;
        }
        /**
         * The triple product of {@link Vector2}s is defined as:
         * <pre>
         * a x (b x c)
         * </pre>
         * However, this method performs the following triple product:
         * <pre>
         * (a x b) x c
         * </pre>
         * this can be simplified to:
         * <pre>
         * -a * (b &middot; c) + b * (a &middot; c)
         * </pre>
         * or:
         * <pre>
         * b * (a &middot; c) - a * (b &middot; c)
         * </pre>
         * @param {math.Vector2} a the a {@link Vector2} in the above equation
         * @param {math.Vector2} b the b {@link Vector2} in the above equation
         * @param {math.Vector2} c the c {@link Vector2} in the above equation
         * @return {math.Vector2} {@link Vector2}
         */
        static tripleProduct(a, b, c) {
            const r = new Vector2();
            const ac = a.x * c.x + a.y * c.y;
            const bc = b.x * c.x + b.y * c.y;
            r.x = b.x * ac - a.x * bc;
            r.y = b.y * ac - a.y * bc;
            return r;
        }
        /**
         *
         * @return {number}
         */
        hashCode() {
            const prime = 31;
            let result = 1;
            let temp;
            temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.x);
            result = prime * result + ((temp ^ (temp >>> 32)) | 0);
            temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.y);
            result = prime * result + ((temp ^ (temp >>> 32)) | 0);
            return result;
        }
        equals$java_lang_Object(obj) {
            if (obj == null)
                return false;
            if (obj === this)
                return true;
            if (obj != null && obj instanceof math.Vector2) {
                const vector = obj;
                return this.x === vector.x && this.y === vector.y;
            }
            return false;
        }
        equals$math_Vector2(vector) {
            if (vector == null)
                return false;
            if (this === vector) {
                return true;
            }
            else {
                return this.x === vector.x && this.y === vector.y;
            }
        }
        equals$double$double(x, y) {
            return this.x === x && this.y === y;
        }
        /**
         * Returns true if the x and y components of this {@link Vector2}
         * are the same as the given x and y components.
         * @param {number} x the x coordinate of the {@link Vector2} to compare to
         * @param {number} y the y coordinate of the {@link Vector2} to compare to
         * @return {boolean} boolean
         */
        equals(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.equals$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.equals$math_Vector2(x);
            }
            else if (((x != null) || x === null) && y === undefined) {
                return this.equals$java_lang_Object(x);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @return {string}
         */
        toString() {
            const sb = new java.lang.StringBuilder();
            sb.append("(").append(this.x).append(", ").append(this.y).append(")");
            return sb.toString();
        }
        set$math_Vector2(vector) {
            this.x = vector.x;
            this.y = vector.y;
            return this;
        }
        set$double$double(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        /**
         * Sets this {@link Vector2} to the given {@link Vector2}.
         * @param {number} x the x component of the {@link Vector2} to set this {@link Vector2} to
         * @param {number} y the y component of the {@link Vector2} to set this {@link Vector2} to
         * @return {math.Vector2} {@link Vector2} this vector
         */
        set(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.set$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.set$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Returns the x component of this {@link Vector2}.
         * @return {math.Vector2} {@link Vector2}
         */
        getXComponent() {
            return new Vector2(this.x, 0.0);
        }
        /**
         * Returns the y component of this {@link Vector2}.
         * @return {math.Vector2} {@link Vector2}
         */
        getYComponent() {
            return new Vector2(0.0, this.y);
        }
        /**
         * Returns the magnitude of this {@link Vector2}.
         * @return {number} double
         */
        getMagnitude() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        /**
         * Returns the magnitude of this {@link Vector2} squared.
         * @return {number} double
         */
        getMagnitudeSquared() {
            return this.x * this.x + this.y * this.y;
        }
        /**
         * Sets the magnitude of the {@link Vector2}.
         * @param {number} magnitude the magnitude
         * @return {math.Vector2} {@link Vector2} this vector
         */
        setMagnitude(magnitude) {
            if (Math.abs(magnitude) <= math.MathUtils.EPSILON) {
                this.x = 0.0;
                this.y = 0.0;
                return this;
            }
            if (this.isZero()) {
                return this;
            }
            let mag = Math.sqrt(this.x * this.x + this.y * this.y);
            mag = magnitude / mag;
            this.x *= mag;
            this.y *= mag;
            return this;
        }
        /**
         * Returns the angle of this {@link Vector2} with +ve x axis
         * as an angle in radians.
         * @return {number} double angle in radians [0, 2*&pi;]
         */
        getAngleWithPositiveXAxis() {
            let theta = Math.atan2(this.y, this.x);
            if (theta < 0)
                theta += Math.PI * 2;
            return theta;
        }
        /**
         * Returns the direction of this {@link Vector2}
         * as an angle in radians.
         * @return {number} double angle in radians [-&pi;, &pi;]
         */
        getDirection() {
            return Math.atan2(this.y, this.x);
        }
        /**
         * Sets the direction of this {@link Vector2}.
         * @param {number} angle angle in radians
         * @return {math.Vector2} {@link Vector2} this vector
         */
        setDirection(angle) {
            const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
            this.x = magnitude * Math.cos(angle);
            this.y = magnitude * Math.sin(angle);
            return this;
        }
        add$math_Vector2(vector) {
            this.x += vector.x;
            this.y += vector.y;
            return this;
        }
        add$double$double(x, y) {
            this.x += x;
            this.y += y;
            return this;
        }
        /**
         * Adds the given {@link Vector2} to this {@link Vector2}.
         * @param {number} x the x component of the {@link Vector2}
         * @param {number} y the y component of the {@link Vector2}
         * @return {math.Vector2} {@link Vector2} this vector
         */
        add(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.add$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.add$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        sum$math_Vector2(vector) {
            return new Vector2(this.x + vector.x, this.y + vector.y);
        }
        sum$double$double(x, y) {
            return new Vector2(this.x + x, this.y + y);
        }
        /**
         * Adds this {@link Vector2} and the given {@link Vector2} returning
         * a new {@link Vector2} containing the result.
         * @param {number} x the x component of the {@link Vector2}
         * @param {number} y the y component of the {@link Vector2}
         * @return {math.Vector2} {@link Vector2}
         */
        sum(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.sum$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.sum$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        subtract$math_Vector2(vector) {
            this.x -= vector.x;
            this.y -= vector.y;
            return this;
        }
        subtract$double$double(x, y) {
            this.x -= x;
            this.y -= y;
            return this;
        }
        /**
         * Subtracts the given {@link Vector2} from this {@link Vector2}.
         * @param {number} x the x component of the {@link Vector2}
         * @param {number} y the y component of the {@link Vector2}
         * @return {math.Vector2} {@link Vector2} this vector
         */
        subtract(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.subtract$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.subtract$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        difference$math_Vector2(vector) {
            return new Vector2(this.x - vector.x, this.y - vector.y);
        }
        difference$double$double(x, y) {
            return new Vector2(this.x - x, this.y - y);
        }
        /**
         * Subtracts the given {@link Vector2} from this {@link Vector2} returning
         * a new {@link Vector2} containing the result.
         * @param {number} x the x component of the {@link Vector2}
         * @param {number} y the y component of the {@link Vector2}
         * @return {math.Vector2} {@link Vector2}
         */
        difference(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.difference$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.difference$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        to$math_Vector2(vector) {
            return new Vector2(vector.x - this.x, vector.y - this.y);
        }
        to$double$double(x, y) {
            return new Vector2(x - this.x, y - this.y);
        }
        /**
         * Creates a {@link Vector2} from this {@link Vector2} to the given {@link Vector2}.
         * @param {number} x the x component of the {@link Vector2}
         * @param {number} y the y component of the {@link Vector2}
         * @return {math.Vector2} {@link Vector2}
         */
        to(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.to$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.to$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Multiplies this {@link Vector2} by the given scalar.
         * @param {number} scalar the scalar
         * @return {math.Vector2} {@link Vector2} this vector
         */
        multiply(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            return this;
        }
        /**
         * Divides this {@link Vector2} by the given scalar.
         * @param {number} scalar the scalar
         * @return {math.Vector2} {@link Vector2} this vector
         * @since 3.4.0
         */
        divide(scalar) {
            this.x /= scalar;
            this.y /= scalar;
            return this;
        }
        /**
         * Multiplies this {@link Vector2} by the given scalar returning
         * a new {@link Vector2} containing the result.
         * @param {number} scalar the scalar
         * @return {math.Vector2} {@link Vector2}
         */
        product(scalar) {
            return new Vector2(this.x * scalar, this.y * scalar);
        }
        /**
         * Divides this {@link Vector2} by the given scalar returning
         * a new {@link Vector2} containing the result.
         * @param {number} scalar the scalar
         * @return {math.Vector2} {@link Vector2}
         * @since 3.4.0
         */
        quotient(scalar) {
            return new Vector2(this.x / scalar, this.y / scalar);
        }
        /**
         * Adds scale times specified vector to this vector
         * @param {number} scale
         * @param {math.Vector2} vec Vector to add after scaling
         * @return {math.Vector2} this Vector
         */
        addScaled(scale, vec) {
            this.x += scale * vec.x;
            this.y += scale * vec.y;
            return this;
        }
        dot$math_Vector2(vector) {
            return this.x * vector.x + this.y * vector.y;
        }
        dot$double$double(x, y) {
            return this.x * x + this.y * y;
        }
        /**
         * Returns the dot product of the given {@link Vector2}
         * and this {@link Vector2}.
         * @param {number} x the x component of the {@link Vector2}
         * @param {number} y the y component of the {@link Vector2}
         * @return {number} double
         */
        dot(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.dot$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.dot$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        cross$math_Vector2(vector) {
            return this.x * vector.y - this.y * vector.x;
        }
        cross$double$double(x, y) {
            return this.x * y - this.y * x;
        }
        /**
         * Returns the cross product of the this {@link Vector2} and the given {@link Vector2}.
         * @param {number} x the x component of the {@link Vector2}
         * @param {number} y the y component of the {@link Vector2}
         * @return {number} double
         */
        cross(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.cross$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.cross$math_Vector2(x);
            }
            else if (((typeof x === 'number') || x === null) && y === undefined) {
                return this.cross$double(x);
            }
            else
                throw new Error('invalid overload');
        }
        cross$double(z) {
            return new Vector2(-this.y * z, this.x * z);
        }
        isOrthogonal$math_Vector2(vector) {
            return Math.abs(this.x * vector.x + this.y * vector.y) <= math.MathUtils.EPSILON ? true : false;
        }
        isOrthogonal$double$double(x, y) {
            return Math.abs(this.x * x + this.y * y) <= math.MathUtils.EPSILON ? true : false;
        }
        /**
         * Returns true if the given {@link Vector2} is orthogonal (perpendicular)
         * to this {@link Vector2}.
         * <p>
         * If the dot product of this vector and the given vector is
         * zero then we know that they are perpendicular
         * @param {number} x the x component of the {@link Vector2}
         * @param {number} y the y component of the {@link Vector2}
         * @return {boolean} boolean
         */
        isOrthogonal(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.isOrthogonal$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.isOrthogonal$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Returns true if this {@link Vector2} is the zero {@link Vector2}.
         * @return {boolean} boolean
         */
        isZero() {
            return Math.abs(this.x) <= math.MathUtils.EPSILON && Math.abs(this.y) <= math.MathUtils.EPSILON;
        }
        /**
         *
         * Negates this {@link Vector2}.
         * @return {math.Vector2} {@link Vector2} this vector
         */
        negate() {
            this.x *= -1.0;
            this.y *= -1.0;
            return this;
        }
        /**
         * Returns a {@link Vector2} which is the negative of this {@link Vector2}.
         * @return {math.Vector2} {@link Vector2}
         */
        getNegative() {
            return new Vector2(-this.x, -this.y);
        }
        /**
         *
         * Sets the {@link Vector2} to the zero {@link Vector2}
         * @return {math.Vector2} {@link Vector2} this vector
         */
        zero() {
            this.x = 0.0;
            this.y = 0.0;
            return this;
        }
        /**
         * returns new vector by Rotating this veector about the origin
         * @param {number} theta the rotation angle in radians
         * @return {math.Vector2} {@link Vector2} new vector
         */
        getRotated(theta) {
            const cos = Math.cos(theta);
            const sin = Math.sin(theta);
            const x = this.x;
            const y = this.y;
            return new Vector2(x * cos - y * sin, x * sin + y * cos);
        }
        rotate$double(theta) {
            const cos = Math.cos(theta);
            const sin = Math.sin(theta);
            const x = this.x;
            const y = this.y;
            this.x = x * cos - y * sin;
            this.y = x * sin + y * cos;
            return this;
        }
        rotate$double$double$double(theta, x, y) {
            this.x -= x;
            this.y -= y;
            this.rotate$double(theta);
            this.x += x;
            this.y += y;
            return this;
        }
        rotate$double$double(cos, sin) {
            const x = this.x;
            const y = this.y;
            this.x = x * cos - y * sin;
            this.y = x * sin + y * cos;
            return this;
        }
        inverseRotate$double(theta) {
            return this.rotate$double$double(Math.cos(theta), -Math.sin(theta));
        }
        rotate$double$double$double$double(cos, sin, x, y) {
            const tx = (this.x - x);
            const ty = (this.y - y);
            this.x = tx * cos - ty * sin + x;
            this.y = tx * sin + ty * cos + y;
            return this;
        }
        /**
         * Internal helper method that rotates about the given coordinates by an angle &theta;.
         * @param {number} cos cos(&theta;)
         * @param {number} sin sin(&theta;)
         * @param {number} x the x coordinate to rotate about
         * @param {number} y the y coordinate to rotate about
         * @return {math.Vector2} {@link Vector2} this vector
         * @since 3.4.0
         */
        rotate(cos, sin, x, y) {
            if (((typeof cos === 'number') || cos === null) && ((typeof sin === 'number') || sin === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.rotate$double$double$double$double(cos, sin, x, y);
            }
            else if (((typeof cos === 'number') || cos === null) && ((typeof sin === 'number') || sin === null) && ((typeof x === 'number') || x === null) && y === undefined) {
                return this.rotate$double$double$double(cos, sin, x);
            }
            else if (((typeof cos === 'number') || cos === null) && ((sin != null && sin instanceof math.Vector2) || sin === null) && x === undefined && y === undefined) {
                return this.rotate$double$math_Vector2(cos, sin);
            }
            else if (((typeof cos === 'number') || cos === null) && ((typeof sin === 'number') || sin === null) && x === undefined && y === undefined) {
                return this.rotate$double$double(cos, sin);
            }
            else if (((typeof cos === 'number') || cos === null) && sin === undefined && x === undefined && y === undefined) {
                return this.rotate$double(cos);
            }
            else
                throw new Error('invalid overload');
        }
        inverseRotate$double$double$double(theta, x, y) {
            return this.rotate$double$double$double$double(Math.cos(theta), -Math.sin(theta), x, y);
        }
        /**
         * Rotates about the given coordinates by the inverse angle -&thetasym;.
         * @param {number} theta the rotation angle in radians
         * @param {number} x the x coordinate to rotate about
         * @param {number} y the y coordinate to rotate about
         * @return {math.Vector2} {@link Vector2} this vector
         * @since 3.4.0
         */
        inverseRotate(theta, x, y) {
            if (((typeof theta === 'number') || theta === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.inverseRotate$double$double$double(theta, x, y);
            }
            else if (((typeof theta === 'number') || theta === null) && ((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.inverseRotate$double$math_Vector2(theta, x);
            }
            else if (((typeof theta === 'number') || theta === null) && x === undefined && y === undefined) {
                return this.inverseRotate$double(theta);
            }
            else
                throw new Error('invalid overload');
        }
        rotate$double$math_Vector2(theta, point) {
            return this.rotate$double$double$double(theta, point.x, point.y);
        }
        inverseRotate$double$math_Vector2(theta, point) {
            return this.inverseRotate$double$double$double(theta, point.x, point.y);
        }
        /**
         * Projects this {@link Vector2} onto the given {@link Vector2}.
         * @param {math.Vector2} vector the {@link Vector2}
         * @return {math.Vector2} {@link Vector2} the projected {@link Vector2}
         */
        project(vector) {
            const dotProd = this.dot$math_Vector2(vector);
            let denominator = vector.dot$math_Vector2(vector);
            if (denominator <= math.MathUtils.EPSILON)
                return new Vector2();
            denominator = dotProd / denominator;
            return new Vector2(denominator * vector.x, denominator * vector.y);
        }
        /**
         * Returns the right-handed normal of this vector.
         * @return {math.Vector2} {@link Vector2} the right hand orthogonal {@link Vector2}
         */
        getRightHandOrthogonalVector() {
            return new Vector2(-this.y, this.x);
        }
        /**
         * Sets this vector to the right-handed normal of this vector.
         * @return {math.Vector2} {@link Vector2} this vector
         * @see #getRightHandOrthogonalVector()
         */
        right() {
            const temp = this.x;
            this.x = -this.y;
            this.y = temp;
            return this;
        }
        /**
         * Returns the left-handed normal of this vector.
         * @return {math.Vector2} {@link Vector2} the left hand orthogonal {@link Vector2}
         */
        getLeftHandOrthogonalVector() {
            return new Vector2(this.y, -this.x);
        }
        /**
         * Sets this vector to the left-handed normal of this vector.
         * @return {math.Vector2} {@link Vector2} this vector
         * @see #getLeftHandOrthogonalVector()
         */
        left() {
            const temp = this.x;
            this.x = this.y;
            this.y = -temp;
            return this;
        }
        /**
         * Returns a unit {@link Vector2} of this {@link Vector2}.
         * <p>
         * This method requires the length of this {@link Vector2} is not zero.
         * @return {math.Vector2} {@link Vector2}
         */
        getNormalized() {
            let magnitude = this.getMagnitude();
            if (magnitude <= math.MathUtils.EPSILON)
                return new Vector2();
            magnitude = 1.0 / magnitude;
            return new Vector2(this.x * magnitude, this.y * magnitude);
        }
        /**
         * Converts this {@link Vector2} into a unit {@link Vector2} and returns
         * the magnitude before normalization.
         * <p>
         * This method requires the length of this {@link Vector2} is not zero.
         * @return {number} double
         */
        normalize() {
            const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
            if (magnitude <= math.MathUtils.EPSILON)
                return 0;
            const m = 1.0 / magnitude;
            this.x *= m;
            this.y *= m;
            return magnitude;
        }
        getAngleBetween$math_Vector2(vector) {
            const a = Math.atan2(vector.y, vector.x) - Math.atan2(this.y, this.x);
            if (a > Math.PI)
                return a - math.MathUtils.TWO_PI_$LI$();
            if (a < -Math.PI)
                return a + math.MathUtils.TWO_PI_$LI$();
            return a;
        }
        /**
         * Returns the smallest angle between the given {@link Vector2}s.
         * <p>
         * Returns the angle in radians in the range -&pi; to &pi;.
         * @param {math.Vector2} vector the {@link Vector2}
         * @return {number} angle in radians [-&pi;, &pi;]
         */
        getAngleBetween(vector) {
            if (((vector != null && vector instanceof math.Vector2) || vector === null)) {
                return this.getAngleBetween$math_Vector2(vector);
            }
            else if (((typeof vector === 'number') || vector === null)) {
                return this.getAngleBetween$double(vector);
            }
            else
                throw new Error('invalid overload');
        }
        getAngleBetween$double(otherAngle) {
            const a = otherAngle - Math.atan2(this.y, this.x);
            if (a > Math.PI)
                return a - math.MathUtils.TWO_PI_$LI$();
            if (a < -Math.PI)
                return a + math.MathUtils.TWO_PI_$LI$();
            return a;
        }
        /**
         * returns Vector2 with minimum coordinates (bottom left of surrounding rect)
         * @param {math.Vector2} a
         * @param {math.Vector2} b
         * @param {math.Vector2} out
         */
        static minToOut(a, b, out) {
            out.x = a.x < b.x ? a.x : b.x;
            out.y = a.y < b.y ? a.y : b.y;
        }
        /**
         * returns Vector2 with maximum coordinates(top right of surrounding rect)
         * @param {math.Vector2} a
         * @param {math.Vector2} b
         * @param {math.Vector2} out
         */
        static maxToOut(a, b, out) {
            out.x = a.x > b.x ? a.x : b.x;
            out.y = a.y > b.y ? a.y : b.y;
        }
        /**
         * Returns mid point of 2 points
         * @param {math.Vector2} v1
         * @param {math.Vector2} v2
         * @return
         * @return {math.Vector2}
         */
        static midPoint(v1, v2) {
            return new Vector2(0.5 * (v1.x + v2.x), 0.5 * (v1.y + v2.y));
        }
        /**
         * Tests if the three points are colinear.
         *
         * @return {boolean} true if three points lie on the same line.
         * @param {math.Vector2} p1
         * @param {math.Vector2} p2
         * @param {math.Vector2} p3
         */
        static isCollinear(p1, p2, p3) {
            let dx1;
            let dx2;
            let dy1;
            let dy2;
            dx1 = p2.x - p1.x;
            dy1 = p2.y - p1.y;
            dx2 = p3.x - p1.x;
            dy2 = p3.y - p1.y;
            return Math.abs(dx1 * dy2 - dy1 * dx2) < math.MathUtils.EPSILON;
        }
        /**
         * Computes the orientation of the 3 points: returns +1 is the path
         * P0->P1->P2 turns Counter-Clockwise, -1 if the path turns Clockwise, and 0
         * if the point P2 is located on the line segment [P0 P1]. Algorithm taken
         * from Sedgewick.
         *
         * @param {math.Vector2} p0 the initial point
         * @param {math.Vector2} p1 the middle point
         * @param {math.Vector2} p2 the last point
         * @return {number} +1, 0 or -1, depending on the relative position of the points
         */
        static ccw(p0, p1, p2) {
            const x0 = p0.x;
            const y0 = p0.y;
            const dx1 = p1.x - x0;
            const dy1 = p1.y - y0;
            const dx2 = p2.x - x0;
            const dy2 = p2.y - y0;
            if (dx1 * dy2 > dy1 * dx2)
                return +1;
            if (dx1 * dy2 < dy1 * dx2)
                return -1;
            if ((dx1 * dx2 < 0) || (dy1 * dy2 < 0))
                return -1;
            if (math.MathUtils.hypot(dx1, dy1) < math.MathUtils.hypot(dx2, dy2))
                return +1;
            return 0;
        }
        static centroid$math_Vector2_A(points) {
            const n = points.length;
            let sx = 0;
            let sy = 0;
            for (let i = 0; i < n; i++) {
                {
                    sx += points[i].x;
                    sy += points[i].y;
                }
                ;
            }
            return new Vector2(sx / n, sy / n);
        }
        static centroid$math_Vector2_A$double_A(points, weights) {
            const n = points.length;
            if (n !== weights.length) {
                throw new java.lang.RuntimeException("Arrays must have the same size");
            }
            let sx = 0;
            let sy = 0;
            let sw = 0;
            let w;
            for (let i = 0; i < n; i++) {
                {
                    w = weights[i];
                    sx += points[i].x * w;
                    sy += points[i].y * w;
                    sw += w;
                }
                ;
            }
            return new Vector2(sx / sw, sy / sw);
        }
        /**
         * Computes the weighted centroid, or center of mass, of an array of points.
         *
         * @param {math.Vector2[]} points an array of points
         * @param {double[]} weights an array of weights the same size as points
         * @return {math.Vector2} the centroid of the points
         */
        static centroid(points, weights) {
            if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof math.Vector2))) || points === null) && ((weights != null && weights instanceof Array && (weights.length == 0 || weights[0] == null || (typeof weights[0] === 'number'))) || weights === null)) {
                return math.Vector2.centroid$math_Vector2_A$double_A(points, weights);
            }
            else if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof math.Vector2))) || points === null) && weights === undefined) {
                return math.Vector2.centroid$math_Vector2_A(points);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * returns closest point among parameters
         * @param {math.Vector2[]} pts Points to be checked for
         * @return {math.Vector2} closest point
         */
        closestPoint(...pts) {
            let result = pts[0];
            let dist = (this.x - result.x) * (this.x - result.x) + (this.y - result.y) * (this.y - result.y);
            for (let index = 0; index < pts.length; index++) {
                let p = pts[index];
                {
                    if (p === result)
                        continue;
                    const d = this.x * p.x + this.y * p.y;
                    if (d < dist) {
                        dist = d;
                        result = p;
                    }
                }
            }
            return result;
        }
        /**
         * Returns interpolated point
         * @param {math.Vector2} p1 first point
         * @param {math.Vector2} p2 second point
         * @param {number} k
         * @return {math.Vector2} new point divided p1 and p2 in ratio k:1
         */
        static interpolate(p1, p2, k) {
            if (k === javaemul.internal.DoubleHelper.POSITIVE_INFINITY)
                return p2.copy();
            return new Vector2((p2.x * k + p1.x) / (k + 1), (p2.y * k + p1.y) / (k + 1));
        }
    }
    math.Vector2 = Vector2;
    Vector2["__class"] = "math.Vector2";
})(math || (math = {}));
(function (math) {
    /**
     * Full constructor.
     * @param {number} minX the minimum x extent
     * @param {number} minY the minimum y extent
     * @param {number} maxX the maximum x extent
     * @param {number} maxY the maximum y extent
     * @class
     */
    class AABB {
        constructor(minX, minY, maxX, maxY) {
            if (((typeof minX === 'number') || minX === null) && ((typeof minY === 'number') || minY === null) && ((typeof maxX === 'number') || maxX === null) && ((typeof maxY === 'number') || maxY === null)) {
                let __args = arguments;
                if (this.minX === undefined) {
                    this.minX = 0;
                }
                if (this.minY === undefined) {
                    this.minY = 0;
                }
                if (this.maxX === undefined) {
                    this.maxX = 0;
                }
                if (this.maxY === undefined) {
                    this.maxY = 0;
                }
                if (minX > maxX || minY > maxY)
                    return;
                this.minX = minX;
                this.minY = minY;
                this.maxX = maxX;
                this.maxY = maxY;
            }
            else if (((minX != null && minX instanceof math.Vector2) || minX === null) && ((minY != null && minY instanceof math.Vector2) || minY === null) && maxX === undefined && maxY === undefined) {
                let __args = arguments;
                let min = __args[0];
                let max = __args[1];
                {
                    let __args = arguments;
                    let minX = min.x;
                    let minY = min.y;
                    let maxX = max.x;
                    let maxY = max.y;
                    if (this.minX === undefined) {
                        this.minX = 0;
                    }
                    if (this.minY === undefined) {
                        this.minY = 0;
                    }
                    if (this.maxX === undefined) {
                        this.maxX = 0;
                    }
                    if (this.maxY === undefined) {
                        this.maxY = 0;
                    }
                    if (minX > maxX || minY > maxY)
                        return;
                    this.minX = minX;
                    this.minY = minY;
                    this.maxX = maxX;
                    this.maxY = maxY;
                }
                if (this.minX === undefined) {
                    this.minX = 0;
                }
                if (this.minY === undefined) {
                    this.minY = 0;
                }
                if (this.maxX === undefined) {
                    this.maxX = 0;
                }
                if (this.maxY === undefined) {
                    this.maxY = 0;
                }
            }
            else if (((minX != null && minX instanceof math.Vector2) || minX === null) && ((typeof minY === 'number') || minY === null) && maxX === undefined && maxY === undefined) {
                let __args = arguments;
                let center = __args[0];
                let radius = __args[1];
                if (this.minX === undefined) {
                    this.minX = 0;
                }
                if (this.minY === undefined) {
                    this.minY = 0;
                }
                if (this.maxX === undefined) {
                    this.maxX = 0;
                }
                if (this.maxY === undefined) {
                    this.maxY = 0;
                }
                if (radius < 0)
                    return;
                if (center == null) {
                    this.minX = -radius;
                    this.minY = -radius;
                    this.maxX = radius;
                    this.maxY = radius;
                }
                else {
                    this.minX = center.x - radius;
                    this.minY = center.y - radius;
                    this.maxX = center.x + radius;
                    this.maxY = center.y + radius;
                }
            }
            else if (((minX != null && minX instanceof math.AABB) || minX === null) && minY === undefined && maxX === undefined && maxY === undefined) {
                let __args = arguments;
                let aabb = __args[0];
                if (this.minX === undefined) {
                    this.minX = 0;
                }
                if (this.minY === undefined) {
                    this.minY = 0;
                }
                if (this.maxX === undefined) {
                    this.maxX = 0;
                }
                if (this.maxY === undefined) {
                    this.maxY = 0;
                }
                this.minX = aabb.minX;
                this.minY = aabb.minY;
                this.maxX = aabb.maxX;
                this.maxY = aabb.maxY;
            }
            else if (((typeof minX === 'number') || minX === null) && minY === undefined && maxX === undefined && maxY === undefined) {
                let __args = arguments;
                let radius = __args[0];
                {
                    let __args = arguments;
                    let center = null;
                    if (this.minX === undefined) {
                        this.minX = 0;
                    }
                    if (this.minY === undefined) {
                        this.minY = 0;
                    }
                    if (this.maxX === undefined) {
                        this.maxX = 0;
                    }
                    if (this.maxY === undefined) {
                        this.maxY = 0;
                    }
                    if (radius < 0)
                        return;
                    if (center == null) {
                        this.minX = -radius;
                        this.minY = -radius;
                        this.maxX = radius;
                        this.maxY = radius;
                    }
                    else {
                        this.minX = center.x - radius;
                        this.minY = center.y - radius;
                        this.maxX = center.x + radius;
                        this.maxY = center.y + radius;
                    }
                }
                if (this.minX === undefined) {
                    this.minX = 0;
                }
                if (this.minY === undefined) {
                    this.minY = 0;
                }
                if (this.maxX === undefined) {
                    this.maxX = 0;
                }
                if (this.maxY === undefined) {
                    this.maxY = 0;
                }
            }
            else
                throw new Error('invalid overload');
        }
        static createAABBFromPoints$math_Vector2$math_Vector2(point1, point2) {
            return AABB.createAABBFromPoints$double$double$double$double(point1.x, point1.y, point2.x, point2.y);
        }
        static createAABBFromPoints$double$double$double$double(point1x, point1y, point2x, point2y) {
            if (point2x < point1x) {
                const temp = point1x;
                point1x = point2x;
                point2x = temp;
            }
            if (point2y < point1y) {
                const temp = point1y;
                point1y = point2y;
                point2y = temp;
            }
            return new AABB(point1x, point1y, point2x, point2y);
        }
        /**
         * Method to create the valid AABB defined by the two points A(point1x, point1y) and B(point2x, point2y).
         *
         * @param {number} point1x The x coordinate of point A
         * @param {number} point1y The y coordinate of point A
         * @param {number} point2x The x coordinate of point B
         * @param {number} point2y The y coordinate of point B
         * @return {math.AABB} The one and only one valid AABB formed by A and B
         */
        static createAABBFromPoints(point1x, point1y, point2x, point2y) {
            if (((typeof point1x === 'number') || point1x === null) && ((typeof point1y === 'number') || point1y === null) && ((typeof point2x === 'number') || point2x === null) && ((typeof point2y === 'number') || point2y === null)) {
                return math.AABB.createAABBFromPoints$double$double$double$double(point1x, point1y, point2x, point2y);
            }
            else if (((point1x != null && point1x instanceof math.Vector2) || point1x === null) && ((point1y != null && point1y instanceof math.Vector2) || point1y === null) && point2x === undefined && point2y === undefined) {
                return math.AABB.createAABBFromPoints$math_Vector2$math_Vector2(point1x, point1y);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Returns a copy of this {@link AABB}.
         * @return {math.AABB} {@link AABB}
         * @since 3.4.0
         */
        copy() {
            return new AABB(this);
        }
        set$math_AABB(aabb) {
            this.minX = aabb.minX;
            this.minY = aabb.minY;
            this.maxX = aabb.maxX;
            this.maxY = aabb.maxY;
            return this;
        }
        set$double$double$double$double(minx, miny, maxx, maxy) {
            this.minX = minx;
            this.minY = miny;
            this.maxX = maxx;
            this.maxY = maxy;
            return this;
        }
        /**
         * Sets this aabb to the given aabb's value and returns
         * this AABB.
         * @param {number} minx
         * @param {number} miny
         * @param {number} maxx
         * @param {number} maxy
         *
         * @return {math.AABB} {@link AABB}
         * @since 4.0
         */
        set(minx, miny, maxx, maxy) {
            if (((typeof minx === 'number') || minx === null) && ((typeof miny === 'number') || miny === null) && ((typeof maxx === 'number') || maxx === null) && ((typeof maxy === 'number') || maxy === null)) {
                return this.set$double$double$double$double(minx, miny, maxx, maxy);
            }
            else if (((minx != null && minx instanceof math.AABB) || minx === null) && miny === undefined && maxx === undefined && maxy === undefined) {
                return this.set$math_AABB(minx);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * resets this AABB to degenerate one, which has negative volume
         * @return {math.AABB} this AABB
         */
        reset() {
            this.minX = javaemul.internal.DoubleHelper.MAX_VALUE;
            this.minY = javaemul.internal.DoubleHelper.MAX_VALUE;
            this.maxX = -javaemul.internal.DoubleHelper.MAX_VALUE;
            this.maxY = -javaemul.internal.DoubleHelper.MAX_VALUE;
            return this;
        }
        /**
         *
         * @return {string}
         */
        toString() {
            const sb = new java.lang.StringBuilder();
            sb.append("AABB[Min=").append("(").append(this.minX).append(", ").append(this.minY).append(")").append("|Max=").append("(").append(this.maxX).append(", ").append(this.maxY).append(")").append("]");
            return sb.toString();
        }
        translate$double$double(x, y) {
            this.minX += x;
            this.minY += y;
            this.maxX += x;
            this.maxY += y;
        }
        translate(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.translate$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.translate$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        translate$math_Vector2(translation) {
            this.translate$double$double(translation.x, translation.y);
        }
        /**
         * Returns a new AABB of this AABB translated by the
         * given translation amount.
         * @param {math.Vector2} translation the translation
         * @return {math.AABB} AABB
         * @since 3.1.1
         */
        getTranslated(translation) {
            return new AABB(this.minX + translation.x, this.minY + translation.y, this.maxX + translation.x, this.maxY + translation.y);
        }
        /**
         * Returns the width of this {@link AABB}.
         * @return {number} double
         * @since 3.0.1
         */
        getWidth() {
            return this.maxX - this.minX;
        }
        /**
         * Returns the height of this {@link AABB}.
         * @return {number} double
         * @since 3.0.1
         */
        getHeight() {
            return this.maxY - this.minY;
        }
        /**
         * Returns the perimeter of this {@link AABB}.
         * @return {number} double
         */
        getPerimeter() {
            return 2 * (this.maxX - this.minX + this.maxY - this.minY);
        }
        /**
         * Returns the area of this {@link AABB};.
         * @return {number} double
         */
        getArea() {
            return (this.maxX - this.minX) * (this.maxY - this.minY);
        }
        /**
         * Automatically expands this AABB so that specified point lies inside it.
         * Does nothing if point already lies inside this.
         * @param {number} x x coordinate of the Point to contain
         * @param {number} y y coordinate of the Point to contain
         * @return
         * @return {math.AABB}
         */
        expandToFit(x, y) {
            if (!this.contains$double$double(x, y)) {
                this.minX = Math.min(this.minX, x);
                this.minY = Math.min(this.minY, y);
                this.maxX = Math.max(this.maxX, x);
                this.maxY = Math.max(this.maxY, y);
            }
            return this;
        }
        /**
         * Performs a union of this {@link AABB} and the given {@link AABB} placing
         * the result of the union into this {@link AABB} and then returns
         * this {@link AABB}
         * @param {math.AABB} aabb the {@link AABB} to union
         * @return {math.AABB} {@link AABB}
         */
        union(aabb) {
            this.minX = Math.min(this.minX, aabb.minX);
            this.minY = Math.min(this.minY, aabb.minY);
            this.maxX = Math.max(this.maxX, aabb.maxX);
            this.maxY = Math.max(this.maxY, aabb.maxY);
            return this;
        }
        /**
         * Performs a union of this {@link AABB} and the given {@link AABB} returning
         * a new {@link AABB} containing the result.
         * @param {math.AABB} aabb the {@link AABB} to union
         * @return {math.AABB} {@link AABB} the resulting union
         */
        getUnion(aabb) {
            return this.copy().union(aabb);
        }
        /**
         * Performs the intersection of this {@link AABB} and the given {@link AABB} placing
         * the result into this {@link AABB} and then returns this {@link AABB}.
         * <p>
         * If the given {@link AABB} does not overlap this {@link AABB}, this {@link AABB} is
         * set to a zero {@link AABB}.
         * @param {math.AABB} aabb the {@link AABB} to intersect
         * @return {math.AABB} {@link AABB}
         * @since 3.1.1
         */
        intersection(aabb) {
            this.minX = Math.max(this.minX, aabb.minX);
            this.minY = Math.max(this.minY, aabb.minY);
            this.maxX = Math.min(this.maxX, aabb.maxX);
            this.maxY = Math.min(this.maxY, aabb.maxY);
            if (this.minX > this.maxX || this.minY > this.maxY) {
                this.minX = 0.0;
                this.minY = 0.0;
                this.maxX = 0.0;
                this.maxY = 0.0;
            }
            return this;
        }
        /**
         * Performs the intersection of this {@link AABB} and the given {@link AABB} returning
         * the result in a new {@link AABB}.
         * <p>
         * If the given {@link AABB} does not overlap this {@link AABB}, a zero {@link AABB} is
         * returned.
         * @param {math.AABB} aabb the {@link AABB} to intersect
         * @return {math.AABB} {@link AABB}
         * @since 3.1.1
         */
        getIntersection(aabb) {
            return this.copy().intersection(aabb);
        }
        /**
         * Expands this {@link AABB} by half the given expansion in each direction and
         * then returns this {@link AABB}.
         * <p>
         * The expansion can be negative to shrink the {@link AABB}.  However, if the expansion is
         * greater than the current width/height, the {@link AABB} can become invalid.  In this
         * case, the AABB will become a degenerate AABB at the mid point of the min and max for
         * the respective coordinates.
         * @param {number} expansion the expansion amount
         * @return {math.AABB} {@link AABB}
         */
        expand(expansion) {
            const e = expansion * 0.5;
            this.minX -= e;
            this.minY -= e;
            this.maxX += e;
            this.maxY += e;
            if (expansion < 0.0) {
                if (this.minX > this.maxX) {
                    const mid = (this.minX + this.maxX) * 0.5;
                    this.minX = mid;
                    this.maxX = mid;
                }
                if (this.minY > this.maxY) {
                    const mid = (this.minY + this.maxY) * 0.5;
                    this.minY = mid;
                    this.maxY = mid;
                }
            }
            return this;
        }
        /**
         * Returns a new {@link AABB} of this AABB expanded by half the given expansion
         * in both the x and y directions.
         * <p>
         * The expansion can be negative to shrink the {@link AABB}.  However, if the expansion is
         * greater than the current width/height, the {@link AABB} can become invalid.  In this
         * case, the AABB will become a degenerate AABB at the mid point of the min and max for
         * the respective coordinates.
         * @param {number} expansion the expansion amount
         * @return {math.AABB} {@link AABB}
         * @since 3.1.1
         */
        getExpanded(expansion) {
            return this.copy().expand(expansion);
        }
        /**
         * Returns true if the given {@link AABB} and this {@link AABB} overlap.
         * @param {math.AABB} aabb the {@link AABB} to test
         * @return {boolean} boolean true if the {@link AABB}s overlap
         */
        overlaps(aabb) {
            return this.minX <= aabb.maxX && this.maxX >= aabb.minX && this.minY <= aabb.maxY && this.maxY >= aabb.minY;
        }
        contains$math_AABB(aabb) {
            return this.minX <= aabb.minX && this.maxX >= aabb.maxX && this.minY <= aabb.minY && this.maxY >= aabb.maxY;
        }
        contains$math_Vector2(point) {
            return this.contains$double$double(point.x, point.y);
        }
        contains$double$double(x, y) {
            return this.minX <= x && this.maxX >= x && this.minY <= y && this.maxY >= y;
        }
        /**
         * Returns true if the given point's coordinates are contained within this {@link AABB}.
         * @param {number} x the x coordinate of the point
         * @param {number} y the y coordinate of the point
         * @return {boolean} boolean
         * @since 3.1.1
         */
        contains(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.contains$double$double(x, y);
            }
            else if (((x != null && x instanceof math.AABB) || x === null) && y === undefined) {
                return this.contains$math_AABB(x);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.contains$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        isDegenerate$() {
            return this.minX === this.maxX || this.minY === this.maxY;
        }
        isDegenerate$double(error) {
            return Math.abs(this.maxX - this.minX) <= error || Math.abs(this.maxY - this.minY) <= error;
        }
        /**
         * Returns true if this {@link AABB} is degenerate given
         * the specified error.
         * <p>
         * An {@link AABB} is degenerate given some error if
         * max - min &lt;= error for either the x or y coordinate.
         * @param {number} error the allowed error
         * @return {boolean} boolean
         * @since 3.1.1
         * @see #isDegenerate()
         */
        isDegenerate(error) {
            if (((typeof error === 'number') || error === null)) {
                return this.isDegenerate$double(error);
            }
            else if (error === undefined) {
                return this.isDegenerate$();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Returns the minimum x extent.
         * @return {number} double
         */
        getMinX() {
            return this.minX;
        }
        /**
         * Returns the maximum x extent.
         * @return {number} double
         */
        getMaxX() {
            return this.maxX;
        }
        /**
         * Returns the maximum y extent.
         * @return {number} double
         */
        getMaxY() {
            return this.maxY;
        }
        /**
         * Returns the minimum y extent.
         * @return {number} double
         */
        getMinY() {
            return this.minY;
        }
    }
    math.AABB = AABB;
    AABB["__class"] = "math.AABB";
})(math || (math = {}));
var geom;
(function (geom) {
    class Function2D {
    }
    geom.Function2D = Function2D;
    Function2D["__class"] = "geom.Function2D";
})(geom || (geom = {}));
(function (geom) {
    class AngleUtils {
        static M_PI_$LI$() { if (AngleUtils.M_PI == null) {
            AngleUtils.M_PI = Math.PI;
        } return AngleUtils.M_PI; }
        static M_2PI_$LI$() { if (AngleUtils.M_2PI == null) {
            AngleUtils.M_2PI = Math.PI * 2;
        } return AngleUtils.M_2PI; }
        static M_PI_2_$LI$() { if (AngleUtils.M_PI_2 == null) {
            AngleUtils.M_PI_2 = Math.PI / 2;
        } return AngleUtils.M_PI_2; }
        static M_3PI_2_$LI$() { if (AngleUtils.M_3PI_2 == null) {
            AngleUtils.M_3PI_2 = 3 * Math.PI / 2;
        } return AngleUtils.M_3PI_2; }
        static M_PI_4_$LI$() { if (AngleUtils.M_PI_4 == null) {
            AngleUtils.M_PI_4 = Math.PI / 4;
        } return AngleUtils.M_PI_4; }
        /**
         * Formats an angle between 0 and 2*PI.
         *
         * @param {number} angle
         * the angle before formatting
         * @return {number} the same angle, between 0 and 2*PI.
         */
        static formatAngle(angle) {
            angle = angle % AngleUtils.M_2PI_$LI$();
            if (angle < 0)
                angle += AngleUtils.M_2PI_$LI$();
            return angle;
        }
        static horizontalAngle$double$double(x, y) {
            return (Math.atan2(y, x) + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
        }
        static horizontalAngle$math_Vector2(vect) {
            return (Math.atan2(vect.y, vect.x) + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
        }
        static horizontalAngle$geom_Line2D(line) {
            const vect = line.getDirection();
            return (Math.atan2(vect.y, vect.x) + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
        }
        static horizontalAngle$math_Vector2$math_Vector2(p1, p2) {
            return (Math.atan2(p2.y - p1.y, p2.x - p1.x) + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
        }
        static horizontalAngle$double$double$double$double(x1, y1, x2, y2) {
            return (Math.atan2(y2 - y1, x2 - x1) + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
        }
        /**
         * Returns the horizontal angle formed by the line joining the two given
         * points.
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @return {number}
         */
        static horizontalAngle(x1, y1, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return geom.AngleUtils.horizontalAngle$double$double$double$double(x1, y1, x2, y2);
            }
            else if (((x1 != null && x1 instanceof math.Vector2) || x1 === null) && ((y1 != null && y1 instanceof math.Vector2) || y1 === null) && x2 === undefined && y2 === undefined) {
                return geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(x1, y1);
            }
            else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && x2 === undefined && y2 === undefined) {
                return geom.AngleUtils.horizontalAngle$double$double(x1, y1);
            }
            else if (((x1 != null && x1 instanceof math.Vector2) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                return geom.AngleUtils.horizontalAngle$math_Vector2(x1);
            }
            else if (((x1 != null && x1 instanceof geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                return geom.AngleUtils.horizontalAngle$geom_Line2D(x1);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * <p>
         * Computes the pseudo-angle of a line joining the 2 points. The
         * pseudo-angle has same ordering property has natural angle, but is
         * expected to be computed faster. The result is given between 0 and 360.
         * </p>
         *
         * @param {math.Vector2} p1
         * the initial point
         * @param {math.Vector2} p2
         * the final point
         * @return {number} the pseudo angle of line joining p1 to p2
         */
        static pseudoAngle(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const s = Math.abs(dx) + Math.abs(dy);
            let t = (s === 0) ? 0.0 : dy / s;
            if (dx < 0) {
                t = 2 - t;
            }
            else if (dy < 0) {
                t += 4;
            }
            return t * 90;
        }
        static angle$geom_Line2D$geom_Line2D(obj1, obj2) {
            const angle1 = obj1.getDirection().getAngleWithPositiveXAxis();
            const angle2 = obj2.getDirection().getAngleWithPositiveXAxis();
            return (angle2 - angle1 + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
        }
        static angle$math_Vector2$math_Vector2(vect1, vect2) {
            const angle1 = AngleUtils.horizontalAngle$math_Vector2(vect1);
            const angle2 = AngleUtils.horizontalAngle$math_Vector2(vect2);
            return (angle2 - angle1 + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
        }
        static angle$math_Vector2$math_Vector2$math_Vector2(p1, p2, p3) {
            const angle1 = AngleUtils.horizontalAngle$math_Vector2$math_Vector2(p2, p1);
            const angle2 = AngleUtils.horizontalAngle$math_Vector2$math_Vector2(p2, p3);
            return (angle2 - angle1 + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
        }
        static angle$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3) {
            const angle1 = AngleUtils.horizontalAngle$double$double$double$double(x2, y2, x1, y1);
            const angle2 = AngleUtils.horizontalAngle$double$double$double$double(x2, y2, x3, y3);
            return (angle2 - angle1 + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
        }
        /**
         * Returns the oriented angle between the ray formed by (p2, p1)
         * and the ray formed by (p2, p3), where pi = (xi,yi), i=1,2,3.
         * Result is given in radians, between 0 and 2*PI.
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @param {number} x3
         * @param {number} y3
         * @return {number}
         */
        static angle(x1, y1, x2, y2, x3, y3) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                return geom.AngleUtils.angle$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
            }
            else if (((x1 != null && x1 instanceof math.Vector2) || x1 === null) && ((y1 != null && y1 instanceof math.Vector2) || y1 === null) && ((x2 != null && x2 instanceof math.Vector2) || x2 === null) && y2 === undefined && x3 === undefined && y3 === undefined) {
                return geom.AngleUtils.angle$math_Vector2$math_Vector2$math_Vector2(x1, y1, x2);
            }
            else if (((x1 != null && x1 instanceof geom.Line2D) || x1 === null) && ((y1 != null && y1 instanceof geom.Line2D) || y1 === null) && x2 === undefined && y2 === undefined && x3 === undefined && y3 === undefined) {
                return geom.AngleUtils.angle$geom_Line2D$geom_Line2D(x1, y1);
            }
            else if (((x1 != null && x1 instanceof math.Vector2) || x1 === null) && ((y1 != null && y1 instanceof math.Vector2) || y1 === null) && x2 === undefined && y2 === undefined && x3 === undefined && y3 === undefined) {
                return geom.AngleUtils.angle$math_Vector2$math_Vector2(x1, y1);
            }
            else
                throw new Error('invalid overload');
        }
        static absoluteAngle$math_Vector2$math_Vector2$math_Vector2(p1, p2, p3) {
            let angle1 = AngleUtils.horizontalAngle$math_Vector2(new math.Vector2(p2, p1));
            const angle2 = AngleUtils.horizontalAngle$math_Vector2(new math.Vector2(p2, p3));
            angle1 = (angle2 - angle1 + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
            if (angle1 < Math.PI)
                return angle1;
            else
                return AngleUtils.M_2PI_$LI$() - angle1;
        }
        static absoluteAngle$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3) {
            let angle1 = AngleUtils.horizontalAngle$double$double$double$double(x2, y2, x1, y1);
            const angle2 = AngleUtils.horizontalAngle$double$double$double$double(x2, y2, x3, y3);
            angle1 = (angle2 - angle1 + AngleUtils.M_2PI_$LI$()) % (AngleUtils.M_2PI_$LI$());
            if (angle1 < Math.PI)
                return angle1;
            else
                return AngleUtils.M_2PI_$LI$() - angle1;
        }
        /**
         * Returns the absolute angle between the ray formed by (p2, p1)
         * and the ray formed by (p2, p3), where pi = (xi,yi), i=1,2,3.
         * Result is given in radians, between 0 and PI.
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @param {number} x3
         * @param {number} y3
         * @return {number}
         */
        static absoluteAngle(x1, y1, x2, y2, x3, y3) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                return geom.AngleUtils.absoluteAngle$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
            }
            else if (((x1 != null && x1 instanceof math.Vector2) || x1 === null) && ((y1 != null && y1 instanceof math.Vector2) || y1 === null) && ((x2 != null && x2 instanceof math.Vector2) || x2 === null) && y2 === undefined && x3 === undefined && y3 === undefined) {
                return geom.AngleUtils.absoluteAngle$math_Vector2$math_Vector2$math_Vector2(x1, y1, x2);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Checks whether two angles are equal, with respect to the given error
         * bound.
         *
         * @param {number} angle1
         * first angle to compare
         * @param {number} angle2
         * second angle to compare
         * @param {number} eps
         * the threshold value for comparison
         * @return {boolean} true if the two angle are equal modulo 2*PI
         */
        static almostEquals(angle1, angle2, eps) {
            angle1 = AngleUtils.formatAngle(angle1);
            angle2 = AngleUtils.formatAngle(angle2);
            const diff = AngleUtils.formatAngle(angle1 - angle2);
            if (diff < eps)
                return true;
            if (Math.abs(diff - Math.PI * 2) < eps)
                return true;
            return false;
        }
        /**
         * Checks whether two angles are equal, given a default threshold value.
         *
         * @param {number} angle1
         * first angle to compare
         * @param {number} angle2
         * second angle to compare
         * @return {boolean} true if the two angle are equal modulo 2*PI
         */
        static equals(angle1, angle2) {
            angle1 = AngleUtils.formatAngle(angle1);
            angle2 = AngleUtils.formatAngle(angle2);
            const diff = AngleUtils.formatAngle(angle1 - angle2);
            if (diff < geom.Shape2D.ACCURACY)
                return true;
            if (Math.abs(diff - Math.PI * 2) < geom.Shape2D.ACCURACY)
                return true;
            return false;
        }
        static containsAngle$double$double$double(startAngle, endAngle, angle) {
            startAngle = AngleUtils.formatAngle(startAngle);
            endAngle = AngleUtils.formatAngle(endAngle);
            angle = AngleUtils.formatAngle(angle);
            if (startAngle < endAngle)
                return angle >= startAngle && angle <= endAngle;
            else
                return angle <= endAngle || angle >= startAngle;
        }
        static containsAngle$double$double$double$boolean(startAngle, endAngle, angle, direct) {
            startAngle = AngleUtils.formatAngle(startAngle);
            endAngle = AngleUtils.formatAngle(endAngle);
            angle = AngleUtils.formatAngle(angle);
            if (direct) {
                if (startAngle < endAngle)
                    return angle >= startAngle && angle <= endAngle;
                else
                    return angle <= endAngle || angle >= startAngle;
            }
            else {
                if (startAngle < endAngle)
                    return angle <= startAngle || angle >= endAngle;
                else
                    return angle >= endAngle && angle <= startAngle;
            }
        }
        /**
         * Tests if an angle belongs to an angular interval, defined by two limit
         * angles, and an orientation flag.
         *
         * @param {number} startAngle
         * the beginning of the angular domain
         * @param {number} endAngle
         * the end of the angular domain
         * @param {number} angle
         * the angle to test
         * @param {boolean} direct
         * is true if angular domain is oriented Counter clockwise, and
         * false if angular domain is oriented clockwise.
         * @return {boolean} true if angle is between the 2 limits
         */
        static containsAngle(startAngle, endAngle, angle, direct) {
            if (((typeof startAngle === 'number') || startAngle === null) && ((typeof endAngle === 'number') || endAngle === null) && ((typeof angle === 'number') || angle === null) && ((typeof direct === 'boolean') || direct === null)) {
                return geom.AngleUtils.containsAngle$double$double$double$boolean(startAngle, endAngle, angle, direct);
            }
            else if (((typeof startAngle === 'number') || startAngle === null) && ((typeof endAngle === 'number') || endAngle === null) && ((typeof angle === 'number') || angle === null) && direct === undefined) {
                return geom.AngleUtils.containsAngle$double$double$double(startAngle, endAngle, angle);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} angle in radians
         * @return {string} String representing
         */
        static angleDegrees(angle) {
            return /* toDegrees */ (x => x * 180 / Math.PI)(angle) + "\u00b0";
        }
    }
    geom.AngleUtils = AngleUtils;
    AngleUtils["__class"] = "geom.AngleUtils";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Generic class providing utilities for manipulating conics. Provides in
     * particular methods for reducing a conic.
     *
     * @author mahesh kurmi
     * @class
     */
    class Conics2D {
        static reduceConic$double$double$double$double$double$double(a, b, c, d, e, f) {
            return Conics2D.reduceConic$double_A([a, b, c, d, e, f]);
        }
        static reduceConic(a, b, c, d, e, f) {
            if (((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null) && ((typeof c === 'number') || c === null) && ((typeof d === 'number') || d === null) && ((typeof e === 'number') || e === null) && ((typeof f === 'number') || f === null)) {
                return geom.Conics2D.reduceConic$double$double$double$double$double$double(a, b, c, d, e, f);
            }
            else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && b === undefined && c === undefined && d === undefined && e === undefined && f === undefined) {
                return geom.Conics2D.reduceConic$double_A(a);
            }
            else
                throw new Error('invalid overload');
        }
        static reduceConic$double_A(coefs) {
            if (coefs.length < 6) {
                console.error("Conic2DUtils.reduceConic: must provide 6 coefficients");
                return null;
            }
            const debug = false;
            const a = coefs[0];
            const b = coefs[1];
            const c = coefs[2];
            const d = coefs[3];
            const e = coefs[4];
            const f = coefs[5];
            let a1;
            let b1;
            let c1;
            let d1;
            let e1;
            let f1;
            if (Math.abs(a) < Conics2D.eps && Math.abs(b) < Conics2D.eps && Math.abs(c) < Conics2D.eps) {
                return new geom.ConicTwoLines2D(d, e, f);
            }
            const D = a * c * f + e * d * b / 4 - a * e * e / 4 - c * d * d / 4 - f * b * b / 4;
            if (Math.abs(D) < Conics2D.eps) {
                return Conics2D.tryToCreatePairOfLines(coefs);
            }
            const conic = Conics2D.tryToCreateCircle(coefs);
            if (conic != null)
                return conic;
            let theta0 = 0;
            if (Math.abs(b) < Conics2D.eps) {
                a1 = a;
                b1 = b;
                c1 = c;
                d1 = d;
                e1 = e;
                f1 = f;
                theta0 = 0;
                if (Math.abs(a) < Conics2D.eps && Math.abs(c) < Conics2D.eps) {
                    if (Math.abs(d) > Conics2D.eps || Math.abs(e) > Conics2D.eps)
                        return new geom.ConicTwoLines2D(d, e, f);
                    else
                        return null;
                }
            }
            else {
                if (Math.abs(a - c) < Conics2D.eps)
                    theta0 = Math.PI / 4;
                else
                    theta0 = geom.AngleUtils.formatAngle(Math.atan2(b, a - c) / 2);
                if (debug)
                    console.info("conic main angle: " + /* toDegrees */ (x => x * 180 / Math.PI)(theta0));
                const cot = Math.cos(theta0);
                const sit = Math.sin(theta0);
                const co2t = Math.cos(2 * theta0);
                const si2t = Math.sin(2 * theta0);
                const cot2 = cot * cot;
                const sit2 = sit * sit;
                a1 = a * cot2 + b * sit * cot + c * sit2;
                b1 = si2t * (c - a) + b * co2t;
                c1 = a * sit2 - b * sit * cot + c * cot2;
                d1 = d * cot + e * sit;
                e1 = -d * sit + e * cot;
                f1 = f;
            }
            if (Math.abs(b1) > Conics2D.eps) {
                console.error("Conic2DUtils.reduceConic: conic was not correctly transformed");
            }
            if (Math.abs(a1) < Conics2D.eps) {
                if (debug)
                    console.info("horizontal parabola");
                if (Math.abs(d1) < Conics2D.eps) {
                    const delta = e1 * e1 - 4 * c1 * f1;
                    if (delta >= 0) {
                        const ys = -e1 / 2.0 / c1;
                        const dist = Math.sqrt(delta) / 2.0 / c1;
                        const center = new math.Vector2(0, ys).rotate$double(theta0);
                        return new geom.ConicTwoLines2D(center.x, center.y, dist, theta0);
                    }
                    else
                        return null;
                }
                const d2 = -d1 / c1;
                const e2 = -e1 / c1;
                const f2 = -f1 / c1;
                return new geom.Parabola2D(-(f2 + e2 * e2 / 4) / d2, e2 / 2, Math.abs(d2) / 4, d2 > 0 ? theta0 : theta0 + Math.PI);
            }
            else if (Math.abs(c1) < Conics2D.eps) {
                if (debug)
                    console.info("vertical parabola");
                if (Math.abs(e1) < Conics2D.eps) {
                    const delta = d1 * d1 - 4 * a1 * f1;
                    if (delta >= 0) {
                        const xs = -d1 / 2.0 / a1;
                        const dist = Math.sqrt(delta) / 2.0 / a1;
                        const center = new math.Vector2(0, xs).rotate$double(theta0);
                        return new geom.ConicTwoLines2D(center.x, center.y, dist, theta0);
                    }
                    else
                        return null;
                }
                const d2 = -d1 / a1;
                const e2 = -e1 / a1;
                const f2 = -f1 / a1;
                return new geom.Parabola2D(d2 / 2, -(f2 + d2 * d2 / 4) / e2, Math.abs(e2 / 4), e2 > 0 ? theta0 + Math.PI / 2 : theta0 - Math.PI / 2);
            }
            const center = new math.Vector2(-d1 / (2 * a1), -e1 / (2 * c1));
            center.rotate$double(theta0);
            const num = (c1 * d1 * d1 + a1 * e1 * e1 - 4 * a1 * c1 * f1) / (4 * a1 * c1);
            const at = num / a1;
            const bt = num / c1;
            if (at < 0 && bt < 0) {
                console.error("Conic2DUtils.reduceConic(): found A<0 and C<0");
                return null;
            }
            if (at > 0 && bt > 0) {
                if (debug)
                    console.info("ellipse");
                if (at > bt)
                    return new geom.Ellipse2D(center.x, center.y, Math.sqrt(at), Math.sqrt(bt), theta0);
                else
                    return new geom.Ellipse2D(center.x, center.y, Math.sqrt(bt), Math.sqrt(at), geom.AngleUtils.formatAngle(theta0 + Math.PI / 2));
            }
            if (at > 0) {
                if (debug)
                    console.info("east-west hyperbola");
                return new geom.Hyperbola2D(center.x, center.y, Math.sqrt(at), Math.sqrt(-bt), theta0);
            }
            else {
                if (debug)
                    console.info("north-south hyperbola");
                return new geom.Hyperbola2D(center.x, center.y, Math.sqrt(bt), Math.sqrt(-at), theta0 + Math.PI / 2);
            }
        }
        /*private*/ static tryToCreateCircle(coefs) {
            const eps = geom.Shape2D.ACCURACY;
            const a = coefs[0];
            let b = coefs[1];
            const c = coefs[2];
            let d = coefs[3];
            let e = coefs[4];
            let f = coefs[5];
            if (Math.abs(b) > eps)
                return null;
            b = 0;
            if (a === c) {
                d = d / a;
                e = e / a;
                f = f / a;
                const r = d * d / 4 + e * e / 4 - f;
                if (r < 0)
                    return null;
                return new geom.Circle2D(-d / 2, -e / 2, Math.sqrt(r));
            }
            return null;
        }
        /*private*/ static tryToCreatePairOfLines(coefs) {
            const a = coefs[0];
            const h = coefs[1] / 2;
            const b = coefs[2];
            let g = coefs[3] / 2;
            let f = coefs[4] / 2;
            const c = coefs[5];
            const m = [0, 0];
            math.EquationUtils.allowInfinityAsRoot = true;
            const n = math.EquationUtils.SolveQuadratic(b, 2 * h, a, m);
            math.EquationUtils.allowInfinityAsRoot = false;
            if (n === 0)
                return null;
            if (n === 1) {
                if ( /* isInfinite */((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(m[0])) {
                    const roots = [0, 0];
                    const k = math.EquationUtils.SolveQuadratic(1, 2 * g / a, c / a, roots);
                    if (k < 2)
                        return null;
                    return new geom.ConicTwoLines2D(1, 0, -roots[0], 1, 0, -roots[1]);
                }
                else if (Math.abs(m[0]) < Conics2D.eps) {
                    const roots = [0, 0];
                    const k = math.EquationUtils.SolveQuadratic(1, 2 * f / b, c / b, roots);
                    if (k < 2)
                        return null;
                    return new geom.ConicTwoLines2D(0, 1, -roots[0], 0, 1, -roots[1]);
                }
                else {
                    const roots = [0, 0];
                    const k = math.EquationUtils.SolveQuadratic(1, 2 * f / b, c / b, roots);
                    if (k < 2)
                        return null;
                    return new geom.ConicTwoLines2D(-m[0], 1, -roots[0], -m[0], 1, -roots[1]);
                }
            }
            else if (n === 2) {
                if ( /* isInfinite */((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(m[0])) {
                    const roots = [0, 0];
                    const k = math.EquationUtils.SolveQuadratic(1, 2 * g / a, c / a, roots);
                    if (k < 2)
                        return null;
                    return new geom.ConicTwoLines2D(1, 0, -roots[0], 1, 0, -roots[1]);
                }
                else if ( /* isInfinite */((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(m[1])) {
                    f = f * (-m[0]) / a;
                    g = g * (-m[0]) / a;
                    return new geom.ConicTwoLines2D(1, 0, 2 * f, -m[0], 1, 2 * f * m[0] + 2 * g);
                }
                else if (m[0] === 0) {
                    f = f / (b);
                    g = g / (b);
                    return new geom.ConicTwoLines2D(0, 1, -2 * g / m[1], -m[1], 1, 2 * f + 2 * g / m[1]);
                }
                else if (m[1] === 0) {
                    f = f / (b);
                    g = g / (b);
                    return new geom.ConicTwoLines2D(0, 1, -2 * g / m[0], -m[0], 1, 2 * f + 2 * g / m[0]);
                }
                else {
                    let m1;
                    let m2;
                    let c1;
                    let c2;
                    m1 = m[0];
                    m2 = m[1];
                    f = f / b;
                    g = g / b;
                    c2 = (2 * f * m2 + 2 * g) / (m1 - m2);
                    c1 = -2 * f - c2;
                    return new geom.ConicTwoLines2D(-m[0], 1, -c1, -m[1], 1, -c2);
                }
            }
            return null;
        }
        /**
         * Transforms a conic centered around the origin, by dropping the
         * translation part of the transform. The array must be contains at least
         * 3 elements. If it contains 6 elements, the 3 remaining elements are
         * supposed to be 0, 0, and -1 in that order.
         *
         * @param {double[]} coefs an array of double with at least 3 coefficients
         * @param trans an affine transform
         * @return {double[]} an array of double with as many elements as the input array
         * @param {math.Transform} mat
         */
        static transformCentered(coefs, mat) {
            const a = mat.m11;
            const b = mat.m21;
            const c = mat.m12;
            const d = mat.m22;
            const A = coefs[0];
            const B = coefs[1];
            const C = coefs[2];
            let delta = a * d - b * c;
            delta = delta * delta;
            const A2 = (A * d * d + C * b * b - B * b * d) / delta;
            const B2 = (B * (a * d + b * c) - 2 * (A * c * d + C * a * b)) / delta;
            const C2 = (A * c * c + C * a * a - B * a * c) / delta;
            if (coefs.length === 3)
                return [A2, B2, C2];
            const D = coefs[3];
            const E = coefs[4];
            const F = coefs[5];
            const D2 = D * d - E * b;
            const E2 = E * a - D * c;
            return [A2, B2, C2, D2, E2, F];
        }
        /**
         * Transforms a conic by an affine transform.
         *
         * @param {double[]} coefs an array of double with 6 coefficients
         * @param trans an affine transform
         * @return {double[]} the coefficients of the transformed conic
         * @param {math.Transform} mat
         */
        static transform(coefs, mat) {
            const a = mat.m11;
            const b = mat.m21;
            const c = mat.m12;
            const d = mat.m22;
            const e = mat.m13;
            const f = mat.m23;
            const A = coefs[0];
            const B = coefs[1];
            const C = coefs[2];
            const D = coefs[3];
            const E = coefs[4];
            const F = coefs[5];
            const A2 = A * a * a + B * a * b + C * b * b;
            const B2 = 2 * (A * a * c + C * b * d) + B * (a * d + b * c);
            const C2 = A * c * c + B * c * d + C * d * d;
            const D2 = 2 * (A * a * e + C * b * f) + B * (a * f + b * e) + D * a + E * b;
            const E2 = 2 * (A * c * e + C * d * f) + B * (c * f + d * e) + D * c + E * d;
            const F2 = A * e * e + B * e * f + C * f * f + D * e + E * f + F;
            return [A2, B2, C2, D2, E2, F2];
        }
        createCommonTangents(conic1, conic2) {
            const tangents = (new java.util.ArrayList());
            const conic = Conics2D.getDualConic(conic1, conic2);
            if (conic == null)
                return tangents;
            const ts = conic.getIntersections(conic2);
            for (let i = 0; i < ts.length; i++) {
                {
                    const t = ts[i];
                    const dir = conic.tangent(t);
                    if (dir == null) {
                        continue;
                    }
                    tangents.add(new geom.Line2D(conic.point(ts[i]), dir));
                }
                ;
            }
            return tangents;
        }
        static getDualConic(conic, conicRef) {
            const pts = [null, null, null, null, null];
            let i = 0;
            const x = [0, 0, 0, 0, 0];
            const y = [0, 0, 0, 0, 0];
            const polar = new geom.Line2D();
            const conicCoeff = conicRef.conicCoefficients();
            let p;
            let T;
            for (let t = 1; t < 6; t++) {
                {
                    p = conic.point(t);
                    T = conic.tangent(t);
                    if (p == null || T == null)
                        return null;
                    polar.set$double$double$double$double(p.x, p.y, T.x, T.y);
                    const pt = (conicRef != null && conicRef instanceof geom.Circle2D) ? conicRef.getPole(polar) : Conics2D.getPole(conicCoeff, polar);
                    if (pt == null)
                        return null;
                    pts[i] = pt;
                    x[i] = pt.x;
                    y[i] = pt.y;
                    i++;
                }
                ;
            }
            const coefs = Conics2D.findConic(pts);
            if (coefs == null)
                return null;
            return Conics2D.reduceConic$double_A(coefs);
        }
        static findConic(P) {
            const A = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                return 0;
            }
            else {
                let array = [];
                for (let i = 0; i < dims[0]; i++) {
                    array.push(allocate(dims.slice(1)));
                }
                return array;
            } }; return allocate(dims); })([5, 6]);
            for (let i = 0; i < P.length; i++) {
                {
                    const x = P[i].x;
                    const y = (P[i]).y;
                    A[i][0] = x * x;
                    A[i][1] = y * y;
                    A[i][2] = x;
                    A[i][3] = y;
                    A[i][4] = x * y;
                    A[i][5] = 1;
                    let sum = 0;
                    for (let j = 0; j < 6; j++) {
                        sum += A[i][j] * A[i][j];
                    }
                    sum = Math.sqrt(sum);
                    for (let j = 0; j < 6; j++) {
                        A[i][j] /= sum;
                    }
                }
                ;
            }
            let r = 0;
            const colindex = [0, 0, 0, 0, 0, 0];
            for (let c = 0; c < 6; c++) {
                {
                    if (r >= 5) {
                        colindex[c] = -1;
                        continue;
                    }
                    let max = Math.abs(A[r][c]);
                    let imax = r;
                    for (let i = r + 1; i < 5; i++) {
                        {
                            const h = Math.abs(A[i][c]);
                            if (h > max) {
                                max = h;
                                imax = i;
                            }
                        }
                        ;
                    }
                    if (max > 1.0E-13) {
                        if (imax !== r) {
                            const h = A[imax];
                            A[imax] = A[r];
                            A[r] = h;
                        }
                        for (let i = r + 1; i < 5; i++) {
                            {
                                const lambda = A[i][c] / A[r][c];
                                for (let j = c + 1; j < 6; j++) {
                                    A[i][j] -= lambda * A[r][j];
                                }
                            }
                            ;
                        }
                        colindex[c] = r;
                        r++;
                    }
                    else {
                        colindex[c] = -1;
                    }
                }
                ;
            }
            const X = [0, 0, 0, 0, 0, 0];
            for (let j = 5; j >= 0; j--) {
                {
                    if (colindex[j] < 0) {
                        X[j] = 1;
                    }
                    else {
                        let h = 0;
                        const i = colindex[j];
                        for (let k = j + 1; k < 6; k++) {
                            h += A[i][k] * X[k];
                        }
                        X[j] = -h / A[i][j];
                    }
                }
                ;
            }
            let sum = 0;
            for (let i = 0; i <= 5; i++) {
                sum += Math.abs(X[i]);
            }
            if (sum < 1.0E-10)
                return null;
            const coeff = [0, 0, 0, 0, 0, 0];
            coeff[0] = X[0];
            coeff[1] = X[4];
            coeff[2] = X[1];
            coeff[3] = X[2];
            coeff[4] = X[3];
            coeff[5] = X[5];
            return coeff;
        }
        static findConicCoeff(x, y) {
            const res = [0, 0, 0, 0, 0, 0];
            for (let i = 1; i < 5; i++) {
                {
                    for (let j = 0; j < i; j++) {
                        {
                            if ((x[i] === x[j]) && (y[i] === y[j])) {
                                return null;
                            }
                        }
                        ;
                    }
                }
                ;
            }
            const mat = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                return 0;
            }
            else {
                let array = [];
                for (let i = 0; i < dims[0]; i++) {
                    array.push(allocate(dims.slice(1)));
                }
                return array;
            } }; return allocate(dims); })([5, 6]);
            for (let i = 0; i < 5; i++) {
                {
                    mat[i][0] = x[i] * x[i];
                    mat[i][1] = x[i] * y[i];
                    mat[i][2] = y[i] * y[i];
                    mat[i][3] = x[i];
                    mat[i][4] = y[i];
                    mat[i][5] = 1;
                }
                ;
            }
            const iter = 5;
            const m = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                return 0;
            }
            else {
                let array = [];
                for (let i = 0; i < dims[0]; i++) {
                    array.push(allocate(dims.slice(1)));
                }
                return array;
            } }; return allocate(dims); })([5, 5]);
            const v = [0, 0, 0, 0, 0];
            for (let i = 0; i < 5; i++) {
                {
                    for (let j = 0; j < iter - 1; j++) {
                        m[i][j] = mat[i][j];
                    }
                    for (let j = iter - 1; j < 5; j++) {
                        m[i][j] = mat[i][j];
                    }
                    v[i] = -mat[i][iter];
                }
                ;
            }
            const coefs = math.EquationUtils.solveLinear(m, v);
            for (let i = 0; i < iter; i++) {
                res[i] = coefs[i];
            }
            res[iter] = 1;
            for (let i = iter + 1; i <= 5; i++) {
                res[i] = coefs[i - 1];
            }
            return res;
        }
        /**
         * Pole of the line joining p1 and p2 (called as polar) wrt the conic
         * @param conic
         * @param p1 First point on polar
         * @param p2 Second point on polar
         * @return
         * @param {double[]} conicCoeff
         * @param {geom.Line2D} line
         * @return {math.Vector2}
         */
        static getPole(conicCoeff, line) {
            const c = conicCoeff;
            const L = line.coeff();
            const matrixA = [[c[0] * L[1] - c[1] * L[0] / 2, c[1] * L[1] / 2 - c[2] * L[0]], [c[1] * L[2] / 2 - c[3] * L[1] / 2, c[2] * L[2] - c[4] * L[1] / 2]];
            const matrixB = [-c[3] * L[1] / 2 + c[4] * L[0] / 2, -c[4] * L[2] / 2 + c[5] * L[1]];
            const res = math.EquationUtils.solveLinear(matrixA, matrixB);
            return res == null ? null : new math.Vector2(res[0], res[1]);
        }
    }
    Conics2D.eps = 1.0E-9;
    geom.Conics2D = Conics2D;
    Conics2D["__class"] = "geom.Conics2D";
})(geom || (geom = {}));
(function (geom) {
    class ShapesManager {
        constructor(app) {
            this.shapes = (new java.util.ArrayList());
            this.paint_shapes = (new java.util.ArrayList());
            this.updateNeeded = false;
            this.X_AXIS = new geom.Line2D(new math.Vector2(1, 0));
            this.Y_AXIS = new geom.Line2D(new math.Vector2(0, 1));
            this.tempShape = null;
            this.previewShape = null;
            if (this.globalVariables === undefined) {
                this.globalVariables = null;
            }
            if (this.globalFunctions === undefined) {
                this.globalFunctions = null;
            }
            if (this.worldBounds === undefined) {
                this.worldBounds = null;
            }
            if (this.surfaceMergingObjects === undefined) {
                this.surfaceMergingObjects = null;
            }
            if (this.toolTipText === undefined) {
                this.toolTipText = null;
            }
            this.tooltipPosition = new math.Vector2();
            if (this.app === undefined) {
                this.app = null;
            }
            if (this.preferences === undefined) {
                this.preferences = null;
            }
            this.time = 0;
            this.selectedShape = null;
            this.prevDragPt = null;
            this.paintStrokeWidth = 1.5;
            if (this.eventsListener === undefined) {
                this.eventsListener = null;
            }
            this.shiftKey = false;
            this.controlKey = false;
            this.leftKey = false;
            this.rightKey = false;
            this.upKey = false;
            this.downKey = false;
            this.app = app;
            this.preferences = app.preferences;
            this.globalVariables = (new java.util.HashMap());
            this.globalFunctions = (new java.util.HashMap());
            this.surfaceMergingObjects = (new java.util.ArrayList());
            this.worldBounds = [0, 0, 1, 1];
            this.clearAll();
        }
        clearAll() {
            this.shapes.clear();
            this.globalVariables.clear();
            this.globalFunctions.clear();
            this.surfaceMergingObjects.clear();
            this.globalVariables.put("T", this.time);
            geom.Shape2D.ACCURACY = 1.0E-6;
            geom.Shape2D.SNAP_DISTANCE = geom.Shape2D.ACCURACY_PIXEL / 100;
            this.X_AXIS.name = "X-axis";
            this.Y_AXIS.name = "Y-axis";
            this.X_AXIS.setVisible(false);
            this.Y_AXIS.setVisible(false);
            this.X_AXIS.showEqn = true;
            this.Y_AXIS.showEqn = true;
            this.X_AXIS.set$double$double$double$double(0, 0, 1, 0);
            this.Y_AXIS.set$double$double$double$double(0, 0, 0, 1);
            this.X_AXIS.drawColor = this.preferences.textColor;
            this.Y_AXIS.drawColor = this.preferences.textColor;
            this.updateNeeded = true;
            this.selectedShape = null;
            this.paint_shapes.clear();
            this.previewShape = null;
            this.tempShape = null;
        }
        removeAllPaintShapes() {
            this.paint_shapes.clear();
            this.previewShape = null;
            this.tempShape = null;
        }
        removePaintShapeAtPoint(worldPt) {
            let s = null;
            for (let index = this.paint_shapes.iterator(); index.hasNext();) {
                let br = index.next();
                {
                    if (br.isSnapped(worldPt)) {
                        s = br;
                        break;
                    }
                }
            }
            return this.paint_shapes.remove(s);
        }
        addPaintShape(shape) {
            this.paint_shapes.add(shape);
            this.previewShape = null;
            this.tempShape = null;
        }
        removePaintShape() {
            this.paint_shapes.remove(this.shapes);
        }
        /**
         * return true if Gui has atleast one visible widget
         *
         * @return
         * @return {boolean}
         */
        isActive() {
            return this.shapes.size() > 0;
        }
        /**
         * @return {java.util.ArrayList} the List of animations associated with simulation
         */
        getAllShapes() {
            return this.shapes;
        }
        /**
         * Returns first shape identified with specified name, returns null if no shape is found
         * @return {geom.Shape2D}
         * @param {string} name
         */
        getShape(name) {
            if (name == null)
                return null;
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let s = index.next();
                if (name === s.getName())
                    return s;
            }
            return null;
        }
        /**
         * Returns true if ShapeManager contains the specified shape
         * @param {geom.Shape2D} shape
         * @return
         * @return {boolean}
         */
        containsShape(shape) {
            return this.shapes.contains(shape);
        }
        /**
         * @return {void} adds Animation
         * @param {geom.Shape2D} b
         */
        addShape(b) {
            if (b == null)
                return;
            this.shapes.add(b);
            if ((b != null && b instanceof geom.Point2D)) {
                b.fillColor = framework.Preferences.getRandomColor();
                b.drawColor = this.preferences.textColor;
                b.showName = true;
            }
            else {
                b.drawColor = framework.Preferences.getRandomColor();
            }
            b.setName(this.createShapeName(b));
            b.onAddShapeToSimulation(this);
            if (this.eventsListener != null)
                this.eventsListener.onShapeAdd(b);
        }
        /**
         * All list of shapes, may overwrite existing if of same name
         * @param {*} shapes
         */
        addAllShapes(shapes) {
            shapes.addAll(shapes);
            this.update(0);
            for (let index = shapes.iterator(); index.hasNext();) {
                let br = index.next();
                {
                    br.onAddShapeToSimulation(this);
                    if (this.eventsListener != null)
                        this.eventsListener.onShapeAdd(br);
                }
            }
        }
        getDependentShapes(b, dependentShapes) {
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let br = index.next();
                {
                    if (br.parents != null) {
                        for (let index = 0; index < br.parents.length; index++) {
                            let p = br.parents[index];
                            {
                                if (p === b) {
                                    dependentShapes.add(br);
                                    this.getDependentShapes(br, dependentShapes);
                                }
                            }
                        }
                    }
                }
            }
            if (b != null && b instanceof geom.ParentShapeArray2D) {
                const p = b;
                let i = 0;
                while ((true)) {
                    {
                        const s = p.getChild(i);
                        if (s == null)
                            break;
                        i++;
                        this.getDependentShapes(s, dependentShapes);
                    }
                }
                ;
            }
        }
        /**
         * Remove animation
         * @param {geom.Shape2D} b
         */
        removeShape(b) {
            if (b == null)
                return;
            const removedshapes = (new java.util.ArrayList());
            removedshapes.add(b);
            this.getDependentShapes(b, removedshapes);
            for (let index = removedshapes.iterator(); index.hasNext();) {
                let s = index.next();
                {
                    if (this.shapes.remove(s)) {
                        s.dispose();
                    }
                    if (this.selectedShape === s)
                        this.selectedShape = null;
                }
            }
            removedshapes.clear();
            if (this.selectedShape === b)
                this.selectedShape = null;
            if (this.eventsListener != null)
                this.eventsListener.onShapeDelete(b);
        }
        forceUpdateAll() {
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let br = index.next();
                {
                    br.update();
                }
            }
            this.updateNeeded = false;
            this.X_AXIS.update();
            this.Y_AXIS.update();
        }
        /**
         * Sets world bounds
         * @param {number} minX
         * @param {number} minY
         * @param {number} maxX
         * @param {number} maxY
         */
        setWorldBounds(minX, minY, maxX, maxY) {
            this.worldBounds[0] = minX;
            this.worldBounds[1] = minY;
            this.worldBounds[2] = maxX;
            this.worldBounds[3] = maxY;
        }
        /**
         * Returns world bounds
         * @return  {double[]} array [minX,minY,maxX,maxY], Note that array is mutable
         */
        getWorldBounds() {
            return this.worldBounds;
        }
        /**
         * Updates shapes
         * @param time elapsed in millisecons
         * @param {number} dt
         */
        update(dt) {
            this.time += dt / 1000;
            this.setTime(this.time);
            if (this.leftKey || this.rightKey || this.upKey || this.downKey) {
                let delta = this.app.camera.getScale() * this.app.preferences.gridSize / 5;
                if (this.shiftKey)
                    delta = delta / 5;
                let dx = 0;
                let dy = 0;
                if (this.leftKey)
                    dx -= delta;
                if (this.rightKey)
                    dx += delta;
                if (this.downKey)
                    dy -= delta;
                if (this.upKey)
                    dy += delta;
                this.app.camera.translate(dx, dy);
            }
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let br = index.next();
                {
                    if (br != null && (br.constructor != null && br.constructor["__interfaces"] != null && br.constructor["__interfaces"].indexOf("geom.optics.OpticalObserver") >= 0))
                        br.beginObserve();
                }
            }
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let br = index.next();
                {
                    br.update();
                }
            }
            this.updateNeeded = false;
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let br = index.next();
                {
                    if (br != null && (br.constructor != null && br.constructor["__interfaces"] != null && br.constructor["__interfaces"].indexOf("geom.optics.OpticalSource") >= 0))
                        br.shootRays();
                }
            }
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let br = index.next();
                {
                    if ((br != null && (br.constructor != null && br.constructor["__interfaces"] != null && br.constructor["__interfaces"].indexOf("geom.optics.OpticalObserver") >= 0)) && br.__isDefined)
                        br.endObserve();
                }
            }
        }
        /**
         * Returns simulation time in seconds
         * @return
         * @return {number}
         */
        getTime() {
            return this.time;
        }
        /**
         * Sets simulation time in seconds
         * @param {number} time
         */
        setTime(time) {
            this.globalVariables.put("T", time);
            this.time = time;
        }
        getSelectedShape() {
            return this.selectedShape;
        }
        setSelectedShape(shape) {
            if (this.selectedShape === shape)
                return;
            if (this.selectedShape !== shape) {
                this.prevDragPt = null;
                ShapesManager.mousepressed = false;
            }
            if (this.selectedShape != null) {
                this.selectedShape.selected = false;
                if (this.eventsListener != null)
                    this.eventsListener.onShapeDeSelect(this.selectedShape);
            }
            this.selectedShape = shape;
            if (shape != null) {
                shape.selected = true;
                if (this.eventsListener != null)
                    this.eventsListener.onShapeSelect(this.selectedShape);
            }
        }
        /**
         *
         * @param {number} event 1=pressed, 2==released
         * @param worldPt
         * @return
         * @param {number} keyCode
         * @param {string} key
         * @return {boolean}
         */
        handlekeyBoard(event, keyCode, key) {
            if (event === 1) {
                switch ((key)) {
                    case "Shift":
                        this.shiftKey = true;
                        break;
                    case "Control":
                        this.controlKey = true;
                        break;
                    case "ArrowLeft":
                        this.leftKey = true;
                        break;
                    case "ArrowRight":
                        this.rightKey = true;
                        break;
                    case "ArrowUp":
                        this.upKey = true;
                        break;
                    case "ArrowDown":
                        this.downKey = true;
                        break;
                    case "q":
                        this.app.camera.zoomIn();
                        break;
                    case "w":
                        this.app.camera.zoomOut();
                        break;
                    case "Delete":
                        this.deleteSelected();
                }
            }
            else {
                switch ((key)) {
                    case "Shift":
                        this.shiftKey = false;
                        break;
                    case "Control":
                        this.controlKey = false;
                        break;
                    case "ArrowLeft":
                        this.leftKey = false;
                        break;
                    case "ArrowRight":
                        this.rightKey = false;
                        break;
                    case "ArrowUp":
                        this.upKey = false;
                        break;
                    case "ArrowDown":
                        this.downKey = false;
                        break;
                }
            }
            return true;
        }
        /**
         *
         * @param {number} event 1=press, 2==release, 3==clicked, 4=moved/dragged
         * @param x
         * @param y
         * @param {math.Vector2} worldPt
         * @return
         * @return {boolean}
         */
        handleMouse(event, worldPt) {
            let consumed = false;
            if (this.eventsListener != null)
                this.eventsListener.onCursorUpdate(worldPt);
            if (event === 3) {
                if (this.selectedShape != null)
                    this.selectedShape.selected = false;
                this.selectedShape = this.getShapeAtPoint(worldPt, false, false);
                if (this.selectedShape != null)
                    this.selectedShape.selected = true;
                this.prevDragPt = null;
                ShapesManager.mousepressed = false;
                return this.selectedShape != null;
            }
            else if (event === 1) {
                if (this.prevDragPt == null && ShapesManager.mousepressed === false) {
                    this.setToolTip(null, worldPt);
                    if (this.selectedShape != null)
                        this.selectedShape.selected = false;
                    this.selectedShape = this.getShapeAtPoint(worldPt, false, false);
                    if (this.selectedShape != null) {
                        this.selectedShape.selected = true;
                        this.selectedShape.mousePressed(worldPt);
                        ShapesManager.mousepressed = true;
                        this.prevDragPt = worldPt;
                        ShapesManager.prevMousePressedPoint = worldPt.copy();
                        return true;
                    }
                    else {
                        ShapesManager.mousepressed = false;
                        this.prevDragPt = null;
                    }
                    return false;
                }
                if (this.selectedShape != null && this.selectedShape.isFreeToMove()) {
                    this.setCursor("pointer");
                    if (this.prevDragPt != null) {
                        const delta = worldPt.difference$math_Vector2(this.prevDragPt);
                        this.prevDragPt = worldPt;
                        if (this.shiftKey && ShapesManager.prevMousePressedPoint != null) {
                            if (Math.abs(worldPt.x - ShapesManager.prevMousePressedPoint.x) <= Math.abs(worldPt.y - ShapesManager.prevMousePressedPoint.y)) {
                                delta.x = 0;
                            }
                            else {
                                delta.y = 0;
                            }
                            this.prevDragPt.set$math_Vector2(worldPt);
                        }
                        else {
                            this.prevDragPt = worldPt;
                        }
                        this.selectedShape.mouseDragged(delta, worldPt, true);
                        this.updateNeeded = true;
                    }
                }
                consumed = this.selectedShape != null;
            }
            else if (event === 2) {
                ShapesManager.mousepressed = false;
                this.prevDragPt = null;
                ShapesManager.prevMousePressedPoint = null;
                this.setToolTip(null, worldPt);
                if (this.selectedShape != null)
                    this.selectedShape.mousePressed(worldPt);
            }
            else if (event === 4 && ShapesManager.mousepressed === false && this.prevDragPt == null) {
                const s = this.getShapeAtPoint(worldPt, true, true);
                if (s == null) {
                    this.setToolTip(null, worldPt);
                    this.setCursor("default");
                    return false;
                }
                const allowMove = s.isFreeToMove();
                if (allowMove) {
                    this.setCursor("pointer");
                    let shapeName;
                    if (s.parents == null) {
                        shapeName = this.getShapeString(s);
                    }
                    else {
                        shapeName = s.getShapeInfo();
                    }
                    this.setToolTip("move this " + shapeName, worldPt);
                }
                else {
                    this.setCursor("default");
                    const shapeInfo = s.getShapeInfo();
                    this.setToolTip(shapeInfo, worldPt);
                }
                return false;
            }
            return consumed;
        }
        setToolTip(text, pos) {
            this.toolTipText = text;
            if (pos != null)
                this.tooltipPosition.set$math_Vector2(pos);
        }
        setCursor(cursor) {
            this.app.setCursor(cursor);
        }
        renderShape(g, s) {
            g.setColors(s.fillColor, s.drawColor);
            g.setLineWidth(s.strokeWidth);
            s.render(g);
        }
        render(gl) {
            geom.Shape2D.SNAP_DISTANCE = geom.Shape2D.ACCURACY_PIXEL / gl.METER_TO_PIXEL;
            if (this.shapes.size() > 0) {
                for (let index = this.shapes.iterator(); index.hasNext();) {
                    let br = index.next();
                    {
                        if (!(br != null && br instanceof geom.Point2D) && br.isVisible()) {
                            this.renderShape(gl, br);
                        }
                    }
                }
                for (let index = this.shapes.iterator(); index.hasNext();) {
                    let br = index.next();
                    {
                        if ((br != null && br instanceof geom.Point2D) && br.isVisible()) {
                            this.renderShape(gl, br);
                        }
                    }
                }
            }
            if (this.selectedShape != null && this.selectedShape.isVisible()) {
                const strokewidth = this.selectedShape.strokeWidth;
                const color = this.selectedShape.drawColor;
                const fillColor = this.selectedShape.fillColor;
                this.selectedShape.setDrawColor(this.preferences.selectedColor);
                if (this.selectedShape != null && this.selectedShape instanceof geom.Point2D) {
                    this.selectedShape.strokeWidth = strokewidth * 1.3;
                    this.selectedShape.fillColor = this.preferences.selectedColor;
                }
                else {
                    this.selectedShape.strokeWidth = strokewidth * 1.5;
                    this.selectedShape.fillColor = null;
                }
                this.renderShape(gl, this.selectedShape);
                this.selectedShape.setDrawColor(color);
                this.selectedShape.strokeWidth = strokewidth;
                this.selectedShape.fillColor = fillColor;
                this.renderShape(gl, this.selectedShape);
            }
            if (this.tempShape != null)
                this.renderShape(gl, this.tempShape);
            if (this.toolTipText != null) {
                gl.setColors(this.preferences.tooltipColor, this.preferences.textColor);
                gl.drawText$java_lang_String$double$double(this.toolTipText, this.tooltipPosition.x, this.tooltipPosition.y);
            }
            this.renderPaintShapes(gl);
        }
        renderPaintShapes(g) {
            for (let index = this.paint_shapes.iterator(); index.hasNext();) {
                let br = index.next();
                {
                    br.render(g);
                }
            }
            if (this.previewShape != null)
                this.previewShape.render(g);
        }
        /**
         * Used for intersection of curves only
         * Returns a new free point, or creates a points from existing shapes. If
         * two curves intersect close to the point, return a new
         * PointIntersection2Curves2D object. If distance to closest curve is 'small
         * enough', create a PointOnCurve object, initialized with position given as
         * parameter. Otherwise, return a new Free point.
         *
         * @param {math.Vector2} point
         * a clicked point
         * @return {geom.Shape2D} a new dynamic point, either free or constrained
         */
        createNewDynamicPoint(point) {
            const pointSets = this.getCloseShapes(point, geom.Point2D);
            if (pointSets.size() > 0) {
                let dist;
                let minDist = javaemul.internal.DoubleHelper.MAX_VALUE;
                let i = 0;
                let index = 0;
                for (let index1 = pointSets.iterator(); index1.hasNext();) {
                    let setPoint = index1.next();
                    {
                        dist = setPoint.distance(point);
                        if (dist < minDist) {
                            index = i;
                            minDist = dist;
                        }
                        i++;
                    }
                }
                return pointSets.get(index);
            }
            const curves = this.getCloseShapes(point, geom.Curve2D);
            if (curves.size() > 1) {
                const curve1 = curves.get(0);
                const curve2 = curves.get(1);
                const pt = new geom.PointIntersection2Curves2D(curve1, curve2, point);
                if (pt != null)
                    return pt;
            }
            const curveShape = this.getSnappedShape(point, geom.Curve2D);
            point = this.preferences.snapToGrid(point);
            if (curveShape != null) {
                if (curveShape != null && curveShape instanceof geom.FunctionExplicit2D) {
                    const pt = new geom.CriticalPointFunction2D(curveShape, point.x);
                    if (pt.__isDefined)
                        return pt;
                }
                return new geom.PointOnCurve2D(curveShape, curveShape.t(point));
            }
            return new geom.FreePoint2D(point);
        }
        /**
         * Returns shape closest to the point, used for construction and mouse info
         * Used in construction at AddShapeAction#findParentShape
         * @param {math.Vector2} pt
         * @param {java.lang.Class} shapeClass
         * a class which inherits Shape2D
         * @return {geom.Shape2D} snapped Object if any else null
         */
        getSnappedShape(pt, shapeClass) {
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let br = index.next();
                {
                    if (!br.__isDefined || !br.visible || !br.touchable)
                        continue;
                    if (br != null && br instanceof geom.ParentShapeArray2D) {
                        br = br.getSnappedShape(pt, shapeClass);
                        if (br != null)
                            return br;
                        continue;
                    }
                    if (framework.ClassUtils.isInstanceof(br, shapeClass) && br.isSnapped(pt)) {
                        return br;
                    }
                }
            }
            if (this.preferences.showAxis && framework.ClassUtils.isInstanceof(this.X_AXIS, shapeClass) && this.X_AXIS.isSnapped(pt))
                return this.X_AXIS;
            if (this.preferences.showAxis && framework.ClassUtils.isInstanceof(this.Y_AXIS, shapeClass) && this.Y_AXIS.isSnapped(pt))
                return this.Y_AXIS;
            return null;
        }
        /**
         * Returns a collection of elements whose distance to the given point is
         * less than the specified distance, and whose class extends the specified
         * class.
         * Used in {@link ShapesManager#createNewDynamicPoint(Vector2)}
         * @param {math.Vector2} point
         * a location
         * @param {java.lang.Class} geometry
         * a class which inherits Shape2D
         * @param minDist
         * the minimum distance between a shape and the point
         * @return {java.util.ArrayList} a set of Shape2D whose shapes are instances of geometry
         */
        getCloseShapes(point, geometry) {
            const returnedShapes = (new java.util.ArrayList());
            let dist;
            for (let i = this.shapes.size() - 1; i >= 0; i--) {
                {
                    const shape = this.shapes.get(i);
                    if (!shape.__isDefined || !shape.touchable || !shape.visible)
                        continue;
                    if (shape != null && shape instanceof geom.ParentShapeArray2D) {
                        shape.getCloseShapes(point, geometry, returnedShapes);
                        continue;
                    }
                    if (!framework.ClassUtils.isInstanceof(shape, geometry))
                        continue;
                    dist = shape.distance(point);
                    if (shape.isSnapped(point))
                        returnedShapes.add(shape);
                }
                ;
            }
            if (this.preferences.showAxis && framework.ClassUtils.isInstanceof(this.X_AXIS, geometry) && Math.abs(point.y) < geom.Shape2D.SNAP_DISTANCE)
                returnedShapes.add(this.X_AXIS);
            if (this.preferences.showAxis && framework.ClassUtils.isInstanceof(this.Y_AXIS, geometry) && Math.abs(point.x) < geom.Shape2D.SNAP_DISTANCE)
                returnedShapes.add(this.Y_AXIS);
            return returnedShapes;
        }
        /**
         * Returns shape at mouse position
         * Used in viewing shape info and deleting shape at mouse location
         * @param {math.Vector2} worldPt
         * @param {boolean} includeAxes
         * @param {boolean} includeChildren if true children of parents are also searched
         * @return
         * @return {geom.Shape2D}
         */
        getShapeAtPoint(worldPt, includeAxes, includeChildren) {
            if (this.selectedShape != null && (this.selectedShape != null && this.selectedShape instanceof geom.Point2D) && this.selectedShape.isSnapped(worldPt))
                return this.selectedShape;
            for (let i = this.shapes.size() - 1; i >= 0; i--) {
                {
                    const br = this.shapes.get(i);
                    if (!br.__isDefined || !br.visible || !br.touchable)
                        continue;
                    if ((br != null && br instanceof geom.Point2D)) {
                        if (br.isSnapped(worldPt)) {
                            return br;
                        }
                    }
                }
                ;
            }
            if (includeAxes && this.preferences.showAxis) {
                if (this.X_AXIS.isSnapped(worldPt))
                    return this.X_AXIS;
                if (this.Y_AXIS.isSnapped(worldPt))
                    return this.Y_AXIS;
            }
            for (let i = this.shapes.size() - 1; i >= 0; i--) {
                {
                    let br = this.shapes.get(i);
                    if (!br.__isDefined || !br.visible || !br.touchable)
                        continue;
                    if (!(br != null && br instanceof geom.Point2D)) {
                        if (br.isSnapped(worldPt)) {
                            if (includeChildren && (br != null && br instanceof geom.ParentShapeArray2D)) {
                                const parent = br;
                                const s = parent.getSnappedShape(worldPt, geom.Shape2D);
                                if (s != null)
                                    br = s;
                            }
                            return br;
                        }
                    }
                }
                ;
            }
            return null;
        }
        /**
         * check if name is already occupied or not
         *
         * @param {string} name
         * @return
         * @param {java.lang.Class} clazz
         * @return {boolean}
         */
        isValidShapeName(name, clazz) {
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let s = index.next();
                if (framework.ClassUtils.isInstanceof(s, clazz) && (name === s.name))
                    return false;
            }
            return true;
        }
        /**
         * check if name is already occupied or not
         *
         * @param {string} name
         * @return
         * @return {boolean}
         */
        isValidFunctionName(name) {
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let s = index.next();
                if (s.name === name)
                    return false;
            }
            return true;
        }
        /**
         * Returns a default name for a shape, according to shape class, and to
         * already stored shapes.
         * @param {geom.Shape2D} geometry
         * @return {string}
         */
        createShapeName(geometry) {
            let baseName = "S";
            if (geometry != null && geometry instanceof geom.Slider2D) {
                baseName = "a";
                let j = 0;
                while ((true)) {
                    {
                        for (let i = 0; i < 26; i++) {
                            {
                                baseName = String.fromCharCode(('a'.charCodeAt(0) + i)) + ((j === 0) ? "" : j + "");
                                if (this.isValidShapeName(baseName, geom.Slider2D))
                                    return baseName;
                            }
                            ;
                        }
                        j++;
                    }
                }
                ;
            }
            if (geometry != null && geometry instanceof geom.Point2D) {
                baseName = "A";
                let j = 0;
                while ((true)) {
                    {
                        for (let i = 0; i < 26; i++) {
                            {
                                baseName = String.fromCharCode(('A'.charCodeAt(0) + i)) + ((j === 0) ? "" : j + "");
                                if (this.isValidShapeName(baseName, geom.Point2D))
                                    return baseName;
                            }
                            ;
                        }
                        j++;
                    }
                }
                ;
            }
            if (geometry != null && geometry instanceof geom.AngleMeasure2D) {
                baseName = math.Unicode.alpha + "";
                let j = 0;
                while ((true)) {
                    {
                        for (let i = 0; i < 26; i++) {
                            {
                                baseName = String.fromCharCode(((c => c.charCodeAt == null ? c : c.charCodeAt(0))(math.Unicode.alpha) + i)) + ((j === 0) ? "" : j + "");
                                if (this.isValidShapeName(baseName, geom.Measure2D))
                                    return baseName;
                            }
                            ;
                        }
                        j++;
                    }
                }
                ;
            }
            if (geometry != null && geometry instanceof geom.LengthMeasure2D) {
                return this.createNewVariableName("L");
            }
            if (geometry != null && geometry instanceof geom.FunctionExplicit2D) {
                baseName = "f";
                let j = 0;
                while ((true)) {
                    {
                        for (let i = 0; i < 3; i++) {
                            {
                                baseName = String.fromCharCode(('f'.charCodeAt(0) + i)) + ((j === 0) ? "" : j + "");
                                if (this.isValidFunctionName(baseName))
                                    return baseName;
                            }
                            ;
                        }
                        j++;
                    }
                }
                ;
            }
            if (geometry != null && geometry instanceof geom.optics.OpticalIdealLens2D) {
                return "lens";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalIdealMirror2D) {
                return "mirror";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalPlaneMirror2D) {
                return "mirror";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalPlane2D) {
                return "plane";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalPathShape2D) {
                return "surface";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalBlocker2D) {
                return "blocker";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalArc2D) {
                return "arc";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalObserver2D) {
                return "observer";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalBeam2D) {
                return "beam";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalSource2D) {
                return "src";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalRay2Points2D) {
                return "ray";
            }
            else if (geometry != null && geometry instanceof geom.optics.OpticalWhiteLight2D) {
                return "white-ray";
            }
            else if (geometry != null && geometry instanceof geom.Circle2D) {
                baseName = "Cir";
            }
            else if (geometry != null && geometry instanceof geom.Vector2D) {
                baseName = "Vec";
            }
            else if (geometry != null && geometry instanceof geom.Ray2D) {
                baseName = "Ray";
            }
            else if (geometry != null && geometry instanceof geom.Segment2D) {
                baseName = "Seg";
            }
            else if (geometry != null && geometry instanceof geom.Line2D) {
                baseName = "Line";
            }
            else if (geometry != null && geometry instanceof geom.AngleMeasure2D) {
                baseName = "Angle";
            }
            else if (geometry != null && geometry instanceof geom.LengthMeasure2D) {
                baseName = "Length";
            }
            else if (geometry != null && geometry instanceof geom.PointMeasure2D) {
                baseName = "Coord";
            }
            else if (geometry != null && geometry instanceof geom.ExpressionMeasure2D) {
                baseName = "Expr";
            }
            else if (geometry != null && geometry instanceof geom.Label2D) {
                baseName = "Label";
            }
            else if (geometry != null && geometry instanceof geom.ParametricCurve2D) {
                baseName = "Curve";
            }
            else if (geometry != null && geometry instanceof geom.PolarCurve2D) {
                baseName = "Curve";
            }
            else if (geometry != null && geometry instanceof geom.Bezier3Points2D) {
                baseName = "quad-curve";
            }
            else if (geometry != null && geometry instanceof geom.Bezier4Points2D) {
                baseName = "cubic-curve";
            }
            else if (geometry != null && geometry instanceof geom.DynamicCurve2D) {
                baseName = "locus";
            }
            else if (geometry != null && geometry instanceof geom.Parabola2D) {
                baseName = "Para";
            }
            else if (geometry != null && geometry instanceof geom.Ellipse2D) {
                baseName = "Ell";
            }
            else if (geometry != null && geometry instanceof geom.Hyperbola2D) {
                baseName = "Hyp";
            }
            else if (geometry != null && geometry instanceof geom.ConicTwoLines2D) {
                baseName = "Lines-pair";
            }
            else if (geometry != null && geometry instanceof geom.Conic2D) {
                baseName = "Conic";
            }
            else if (geometry != null && geometry instanceof geom.PathNpoints2D) {
                baseName = "Path";
            }
            return "shape";
        }
        /**
         * Computes the mouse label when creating the given figure. This label
         * depends on the class of the geometry of the created shape.
         *
         * @param figure
         * the figure which will be created
         * @return {string} the mouse label to display
         * @param {geom.Shape2D} dynamic
         */
        getMouseLabel(dynamic) {
            if (dynamic != null && dynamic instanceof geom.PointOnCurve2D) {
                const parent = dynamic.getParents()[0];
                return "new point in this " + parent.getName();
            }
            if (dynamic != null && dynamic instanceof geom.PointIntersection2Curves2D) {
                return "new intersection";
            }
            if (dynamic != null && dynamic instanceof geom.CriticalPointFunction2D) {
                return "new critical point";
            }
            return "";
        }
        /**
         * Returns a string associated with an EuclideShape. The string is composed
         * of a shape identifier ("line", "ellipse", "point set"...) and eventually
         * the name of the shape between parents.
         * @param {geom.Shape2D} dynamic
         * @return {string}
         */
        getShapeString(dynamic) {
            let baseName = "shape";
            if (dynamic.isDefined()) {
                const shape = dynamic;
                if (shape != null)
                    baseName = ShapesManager.getShapeName(shape.constructor);
            }
            const name = dynamic.getName();
            if (name != null)
                if (!(name.length === 0)) {
                    baseName = baseName + " (" + name + ")";
                }
            return baseName;
        }
        /**
         * Returns the name of the shape, from its class and possibly depending on
         * the Locale. For example, Point2D class will return string "point", Line2D
         * will return "line".... If the shape is not recognized, return the string
         * "shape".
         * @param {java.lang.Class} shapeClass
         * @return {string}
         */
        static getShapeName(shapeClass) {
            if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalImageWrapper2D, shapeClass)) {
                return "image";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalIdealLens2D, shapeClass)) {
                return "lens";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalIdealMirror2D, shapeClass)) {
                return "mirror";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalPlane2D, shapeClass)) {
                return "plane";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalPathShape2D, shapeClass)) {
                return "surface";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalBlocker2D, shapeClass)) {
                return "blocker";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalObserver2D, shapeClass)) {
                return "observer";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalBeam2D, shapeClass)) {
                return "beam";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalSource2D, shapeClass)) {
                return "light source";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalRay2Points2D, shapeClass)) {
                return "light ray";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalWhiteLight2D, shapeClass)) {
                return "white light";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalArc2D, shapeClass)) {
                return "arc mirror";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalObserver2D, shapeClass)) {
                return "observer";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Point2D, shapeClass)) {
                return "point";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Vector2D, shapeClass)) {
                return "vector";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Ray2D, shapeClass)) {
                return "ray";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Slider2D, shapeClass)) {
                return "slider";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Segment2D, shapeClass)) {
                return "segment";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Line2D, shapeClass)) {
                return "line";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Circle2D, shapeClass)) {
                return "circle";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Parabola2D, shapeClass)) {
                return "parabola";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Ellipse2D, shapeClass)) {
                return "ellipse";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Hyperbola2D, shapeClass)) {
                return "hyperbola";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.ConicTwoLines2D, shapeClass)) {
                return "lines-pair";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Conic2D, shapeClass)) {
                return "conic";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.FunctionExplicit2D, shapeClass)) {
                return "function";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.ParametricCurve2D, shapeClass)) {
                return "curve";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Bezier3Points2D, shapeClass)) {
                return "quad-curve";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.Bezier4Points2D, shapeClass)) {
                return "cubic-curve";
            }
            else if (framework.ClassUtils.isAssignableFrom(geom.DynamicCurve2D, shapeClass)) {
                return "locus";
            }
            return /* getSimpleName */ (c => typeof c === 'string' ? c.substring(c.lastIndexOf('.') + 1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(shapeClass);
        }
        deleteSelected() {
            if (this.selectedShape != null) {
                this.removeShape(this.selectedShape);
                if (this.eventsListener != null)
                    this.eventsListener.onShapeDelete(this.selectedShape);
            }
        }
        deleteShapeAt(v) {
            this.removeShape(this.getShapeAtPoint(v, false, false));
        }
        deleteShapesInside(tmpAABB) {
            const removedshapes = (new java.util.ArrayList());
            for (let index = this.shapes.iterator(); index.hasNext();) {
                let p = index.next();
                {
                    if (p != null && p instanceof geom.Point2D) {
                        const v = p.pt;
                        if (tmpAABB.contains$math_Vector2(v))
                            removedshapes.add(p);
                    }
                }
            }
            for (let index = removedshapes.iterator(); index.hasNext();) {
                let s = index.next();
                {
                    this.removeShape(s);
                    if (this.eventsListener != null)
                        this.eventsListener.onShapeDelete(s);
                }
            }
        }
        isRenderable() {
            return this.previewShape != null || this.tempShape != null || this.shapes.size() > 0 || this.paint_shapes.size() > 0;
        }
        /**
         * Returns settings separated by ";" , USed in serialization and deserialization
         * @return
         * @return {string}
         */
        getSettings() {
            const sb = new java.lang.StringBuilder();
            sb.append(geom.Shape2D.ACCURACY + ";");
            sb.append(geom.Shape2D.ACCURACY_PIXEL + ";");
            sb.append(this.preferences.MAX_RAY_INTERACTIONS + ";");
            sb.append(this.preferences.ImageColor.toString() + ";");
            sb.append(this.preferences.virtualRaysColor.toString() + ";");
            return sb.toString();
        }
        /**
         * Updates settings during deserialization
         * @param {string} settings
         */
        setSettings(settings) {
            if (settings == null || /* isEmpty */ (settings.length === 0))
                return;
            const arr = settings.split(";");
            try {
                geom.Shape2D.ACCURACY = javaemul.internal.DoubleHelper.parseDouble(arr[0]);
                geom.Shape2D.ACCURACY_PIXEL = javaemul.internal.DoubleHelper.parseDouble(arr[1]);
                this.preferences.MAX_RAY_INTERACTIONS = javaemul.internal.IntegerHelper.parseInt(arr[2]);
            }
            catch (e) {
                console.error(e.message, e);
            }
        }
        /**
         * Creates unique variable name
         *
         * @param name
         * @param {string} baseName
         * @return {string}
         */
        createNewVariableName(baseName) {
            if (baseName == null) {
                return null;
            }
            else {
                let num = 1;
                let ok = false;
                let name = baseName;
                while ((!ok)) {
                    {
                        ok = true;
                        if (this.globalVariables.containsKey(name) === true || this.globalFunctions.containsKey(name) === true) {
                            ok = false;
                            name = javaemul.internal.StringHelper.format("%1$s%2$d", baseName, num);
                            num++;
                        }
                    }
                }
                ;
                return name;
            }
        }
    }
    ShapesManager.prevMousePressedPoint = null;
    ShapesManager.mousepressed = false;
    geom.ShapesManager = ShapesManager;
    ShapesManager["__class"] = "geom.ShapesManager";
})(geom || (geom = {}));
(function (geom) {
    /**
     * constructor
     *
     * @param {object} settings
     * @param {number} settings.radius The radius for the lazy area
     * @param {boolean} settings.enabled
     * @param {number} radius
     * @param {boolean} enabled
     * @param {math.Vector2} initialPoint
     * @class
     */
    class LazyBrush {
        constructor(radius, enabled, initialPoint) {
            if (((typeof radius === 'number') || radius === null) && ((typeof enabled === 'boolean') || enabled === null) && ((initialPoint != null && initialPoint instanceof math.Vector2) || initialPoint === null)) {
                let __args = arguments;
                if (this.pointer === undefined) {
                    this.pointer = null;
                }
                if (this.brush === undefined) {
                    this.brush = null;
                }
                if (this.angle === undefined) {
                    this.angle = 0;
                }
                if (this.distance === undefined) {
                    this.distance = 0;
                }
                if (this._hasMoved === undefined) {
                    this._hasMoved = false;
                }
                this.radius = 30;
                this._isEnabled = false;
                this.radius = radius;
                this._isEnabled = enabled;
                this.pointer = new geom.LazyPoint(initialPoint.x, initialPoint.y);
                this.brush = new geom.LazyPoint(initialPoint.x, initialPoint.y);
                this.angle = 0;
                this.distance = 0;
                this._hasMoved = false;
            }
            else if (radius === undefined && enabled === undefined && initialPoint === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let radius = 30;
                    let enabled = true;
                    let initialPoint = new math.Vector2();
                    if (this.pointer === undefined) {
                        this.pointer = null;
                    }
                    if (this.brush === undefined) {
                        this.brush = null;
                    }
                    if (this.angle === undefined) {
                        this.angle = 0;
                    }
                    if (this.distance === undefined) {
                        this.distance = 0;
                    }
                    if (this._hasMoved === undefined) {
                        this._hasMoved = false;
                    }
                    this.radius = 30;
                    this._isEnabled = false;
                    this.radius = radius;
                    this._isEnabled = enabled;
                    this.pointer = new geom.LazyPoint(initialPoint.x, initialPoint.y);
                    this.brush = new geom.LazyPoint(initialPoint.x, initialPoint.y);
                    this.angle = 0;
                    this.distance = 0;
                    this._hasMoved = false;
                }
                if (this.pointer === undefined) {
                    this.pointer = null;
                }
                if (this.brush === undefined) {
                    this.brush = null;
                }
                if (this.angle === undefined) {
                    this.angle = 0;
                }
                if (this.distance === undefined) {
                    this.distance = 0;
                }
                if (this._hasMoved === undefined) {
                    this._hasMoved = false;
                }
                this.radius = 30;
                this._isEnabled = false;
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Enable lazy brush calculations.
         */
        enable() {
            this._isEnabled = true;
        }
        /**
         * Disable lazy brush calculations.
         */
        disable() {
            this._isEnabled = false;
        }
        /**
         * @returns {boolean}
         * @return {boolean}
         */
        isEnabled() {
            return this._isEnabled;
        }
        /**
         * Update the radius
         *
         * @param {number} radius
         * @param {number} radius
         */
        setRadius(radius) {
            this.radius = radius;
        }
        /**
         * Return the current radius
         *
         * @returns {number}
         * @return {number}
         */
        getRadius() {
            return this.radius;
        }
        /**
         * Return the brush coordinates as a simple object
         *
         * @returns {object}
         * @return {math.Vector2}
         */
        getBrushCoordinates() {
            return this.brush.toVector2();
        }
        /**
         * Return the pointer coordinates as a simple object
         *
         * @returns {object}
         * @return {math.Vector2}
         */
        getPointerCoordinates() {
            return this.pointer.toVector2();
        }
        /**
         * Return the brush as a LazyPoint
         *
         * @returns {LazyPoint}
         * @return {geom.LazyPoint}
         */
        getBrush() {
            return this.brush;
        }
        /**
         * Return the pointer as a LazyPoint
         *
         * @returns {LazyPoint}
         * @return {geom.LazyPoint}
         */
        getPointer() {
            return this.pointer;
        }
        /**
         * Return the angle between pointer and brush
         *
         * @returns {number} Angle in radians
         * @return {number}
         */
        getAngle() {
            return this.angle;
        }
        /**
         * Return the distance between pointer and brush
         *
         * @returns {number} Distance in pixels
         * @return {number}
         */
        getDistance() {
            return this.distance;
        }
        /**
         * Return if the previous update has moved the brush.
         *
         * @returns {boolean} Whether the brush moved previously.
         * @return {boolean}
         */
        brushHasMoved() {
            return this._hasMoved;
        }
        /**
         * Updates the pointer point and calculates the new brush point.
         *
         * @param {Point} newPointerPoint
         * @param {Object} options
         * @param {Boolean} options.both Force update pointer and brush
         * @returns {Boolean} Whether any of the two points changed
         * @param {math.Vector2} newPointerPoint
         * @param {boolean} both
         * @return {boolean}
         */
        update(newPointerPoint, both) {
            this._hasMoved = false;
            if (this.pointer.equalsTo(newPointerPoint) && !both) {
                return false;
            }
            this.pointer.update(newPointerPoint);
            if (both) {
                this._hasMoved = true;
                this.brush.update(newPointerPoint);
                return true;
            }
            if (this._isEnabled) {
                this.distance = this.pointer.getDistanceTo(this.brush);
                this.angle = this.pointer.getAngleTo(this.brush);
                if (this.distance > this.radius) {
                    this.brush.moveByAngle(this.angle, this.distance - this.radius);
                    this._hasMoved = true;
                }
            }
            else {
                this.distance = 0;
                this.angle = 0;
                this.brush.update(newPointerPoint);
                this._hasMoved = true;
            }
            return true;
        }
    }
    geom.LazyBrush = LazyBrush;
    LazyBrush["__class"] = "geom.LazyBrush";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Constructor that initializes the bounding box to the specified bounding values passed in as individual x,y,z
     * points
     *
     * @param {number} x1
     * The x coordinate of the minimum boundary point
     * @param {number} y1
     * The y coordinate of the minimum boundary point
     * @param {number} x2
     * The x coordinate of the maximum boundary point
     * @param {number} y2
     * The y coordinate of the maximum boundary point
     * @class
     */
    class Bounds2D {
        constructor(x1, y1, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                let __args = arguments;
                this.min = new math.Vector2(Bounds2D.LARGE_$LI$(), Bounds2D.LARGE_$LI$());
                this.max = new math.Vector2(-Bounds2D.LARGE_$LI$(), -Bounds2D.LARGE_$LI$());
                this.set(x1, y1, x2, y2);
            }
            else if (((x1 != null && x1 instanceof math.Vector2) || x1 === null) && ((y1 != null && y1 instanceof math.Vector2) || y1 === null) && x2 === undefined && y2 === undefined) {
                let __args = arguments;
                let v1 = __args[0];
                let v2 = __args[1];
                this.min = new math.Vector2(Bounds2D.LARGE_$LI$(), Bounds2D.LARGE_$LI$());
                this.max = new math.Vector2(-Bounds2D.LARGE_$LI$(), -Bounds2D.LARGE_$LI$());
                this.set(v1.x, v1.y, v2.x, v2.y);
            }
            else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                let __args = arguments;
                this.min = new math.Vector2(Bounds2D.LARGE_$LI$(), Bounds2D.LARGE_$LI$());
                this.max = new math.Vector2(-Bounds2D.LARGE_$LI$(), -Bounds2D.LARGE_$LI$());
            }
            else
                throw new Error('invalid overload');
        }
        static LARGE_$LI$() { if (Bounds2D.LARGE == null) {
            Bounds2D.LARGE = javaemul.internal.DoubleHelper.MAX_VALUE;
        } return Bounds2D.LARGE; }
        /**
         * reset bounds to empty
         */
        reset() {
            this.min.set$double$double(Bounds2D.LARGE_$LI$(), Bounds2D.LARGE_$LI$());
            this.max.set$double$double(-Bounds2D.LARGE_$LI$(), -Bounds2D.LARGE_$LI$());
        }
        update$double$double(x, y) {
            if (x > this.max.x) {
                this.max.x = x;
            }
            if (x < this.min.x) {
                this.min.x = x;
            }
            if (y > this.max.y) {
                this.max.y = y;
            }
            if (y < this.min.y) {
                this.min.y = y;
            }
        }
        /**
         * Recalculates the boundary limits based on the coordinates of a point passed into it. If any of the coordinates of
         * the passed in point are beyond the current bounding box limits then the bounding box is expanded.
         *
         * @param {number} x
         * The x coordinate of a point used to adjust the boundary box
         * @param {number} y
         * The y coordinate of a point used to adjust the boundary box
         * @param z
         * The z coordinate of a point used to adjust the boundary box
         */
        update(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.update$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.update$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Constructor that initializes the bounding box to the specified bounding values passed in as individual x,y,z
         * points
         *
         * @param {number} x1
         * The x coordinate of the minimum boundary point
         * @param {number} y1
         * The y coordinate of the minimum boundary point
         * @param {number} x2
         * The x coordinate of the maximum boundary point
         * @param {number} y2
         * The y coordinate of the maximum boundary point
         */
        set(x1, y1, x2, y2) {
            this.min.x = Math.min(x1, x2);
            this.min.y = Math.min(y1, y2);
            this.max.x = Math.max(x1, x2);
            this.max.y = Math.max(y1, y2);
        }
        update$math_Vector2(v) {
            this.update$double$double(v.x, v.y);
        }
        /**
         * Returns bounding radius
         *
         * @return
         * @return {number}
         */
        getRadius() {
            return 0.5 * Math.sqrt(Math.pow(this.max.x - this.min.x, 2) + Math.pow(this.max.y - this.min.y, 2));
        }
        /**
         * Return center of bounds
         * @return {math.Vector2}
         */
        getCenter() {
            return new math.Vector2((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2);
        }
        /**
         * Returns width of this bounding box
         * @return
         * @return {number}
         */
        getWidth() {
            return this.max.x - this.min.x;
        }
        /**
         * Returns height of this bounding box
         * @return
         * @return {number}
         */
        getHeight() {
            return this.max.y - this.min.y;
        }
        /**
         * Returns true if bounds are valid
         *
         * @return
         * @return {boolean}
         */
        isValid() {
            return (this.min.x < this.max.x && this.min.y < this.max.y);
        }
        contains$geom_Bounds2D(aabb) {
            if (this.min.x <= aabb.min.x && this.max.x >= aabb.max.x) {
                if (this.min.y <= aabb.min.y && this.max.y >= aabb.max.y) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Returns true if the given {@link AABB} is contained within this {@link AABB}.
         * @param {geom.Bounds2D} aabb the {@link AABB} to test
         * @return {boolean} boolean
         */
        intersects(aabb) {
            return !(this.max.x <= aabb.min.x || aabb.max.x <= this.min.x || this.max.y <= aabb.min.y || aabb.max.y <= this.min.y);
        }
        contains$math_Vector2(point) {
            return this.contains$double$double(point.x, point.y);
        }
        contains$double$double(x, y) {
            if (this.min.x <= x && this.max.x >= x) {
                if (this.min.y <= y && this.max.y >= y) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Returns true if the given point's coordinates are contained within this {@link AABB}.
         * @param {number} x the x coordinate of the point
         * @param {number} y the y coordinate of the point
         * @return {boolean} boolean
         * @since 3.1.1
         */
        contains(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.contains$double$double(x, y);
            }
            else if (((x != null && x instanceof geom.Bounds2D) || x === null) && y === undefined) {
                return this.contains$geom_Bounds2D(x);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.contains$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Generates the String to represent a Bounds object in a nice format for output purposes.
         *
         * @return {string} The String representation of a Bounds object
         */
        toString() {
            return "minimum: (" + this.min.x + ", " + this.min.y + ") maximum: (" + this.max.x + ", " + this.max.y + ")";
        }
        /**
         * Merges bounds
         *
         * @param {geom.Bounds2D} b
         */
        Merge(b) {
            this.min.x = Math.min(this.min.x, b.min.x);
            this.min.y = Math.min(this.min.y, b.min.y);
            this.max.x = Math.max(this.max.x, b.max.x);
            this.max.y = Math.max(this.max.y, b.max.y);
        }
        /**
         * Translates bounds
         * @param {number} dx
         * @param {number} dy
         */
        move(dx, dy) {
            this.min.add$double$double(dx, dy);
            this.max.add$double$double(dx, dy);
        }
    }
    geom.Bounds2D = Bounds2D;
    Bounds2D["__class"] = "geom.Bounds2D";
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        /**
         * Class to handle value with associated expression
         * @author maheshkurmi
         * @param {number} value
         * @param {number} min
         * @param {number} max
         * @class
         */
        class DynamicValue {
            constructor(expr, min, max) {
                if (((typeof expr === 'string') || expr === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                    let __args = arguments;
                    if (this.shapesManager === undefined) {
                        this.shapesManager = null;
                    }
                    this.expr = null;
                    this.parserNeeded = false;
                    this.value = javaemul.internal.DoubleHelper.NaN;
                    this.multiplier = 1;
                    this.min = javaemul.internal.DoubleHelper.MIN_VALUE;
                    this.max = javaemul.internal.DoubleHelper.MAX_VALUE;
                    this.unitsEnabled = false;
                    this.max = max;
                    this.min = min;
                    this.set$java_lang_String(expr);
                }
                else if (((typeof expr === 'number') || expr === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                    let __args = arguments;
                    let value = __args[0];
                    if (this.shapesManager === undefined) {
                        this.shapesManager = null;
                    }
                    this.expr = null;
                    this.parserNeeded = false;
                    this.value = javaemul.internal.DoubleHelper.NaN;
                    this.multiplier = 1;
                    this.min = javaemul.internal.DoubleHelper.MIN_VALUE;
                    this.max = javaemul.internal.DoubleHelper.MAX_VALUE;
                    this.unitsEnabled = false;
                    this.max = max;
                    this.min = min;
                    this.set$double(value);
                }
                else if (((typeof expr === 'string') || expr === null) && min === undefined && max === undefined) {
                    let __args = arguments;
                    if (this.shapesManager === undefined) {
                        this.shapesManager = null;
                    }
                    this.expr = null;
                    this.parserNeeded = false;
                    this.value = javaemul.internal.DoubleHelper.NaN;
                    this.multiplier = 1;
                    this.min = javaemul.internal.DoubleHelper.MIN_VALUE;
                    this.max = javaemul.internal.DoubleHelper.MAX_VALUE;
                    this.unitsEnabled = false;
                    this.set$java_lang_String(expr);
                }
                else
                    throw new Error('invalid overload');
            }
            set$double(value) {
                this.value = math.MathUtils.clamp$double$double$double(value, this.min, this.max);
                this.expr = null;
                this.parserNeeded = false;
                this.multiplier = 1;
            }
            set$java_lang_String(expr) {
                this.expr = expr;
                this.multiplier = 1;
                this.parseUnit();
                try {
                    this.value = /* doubleValue */ new Number(this.expr);
                    this.set$double(this.value * this.multiplier);
                    return;
                }
                catch (e) {
                    this.parserNeeded = true;
                }
                this.update();
            }
            set(expr) {
                if (((typeof expr === 'string') || expr === null)) {
                    return this.set$java_lang_String(expr);
                }
                else if (((typeof expr === 'number') || expr === null)) {
                    return this.set$double(expr);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * returns true if expression is not constant
             * @return
             * @return {boolean}
             */
            isVariable() {
                return this.parserNeeded;
            }
            /**
             * reevaluates expression, must be called before getting value
             * @return {boolean} true if value has changed
             */
            update() {
                if (!this.parserNeeded)
                    return false;
                try {
                    let r = math.MathUtils.evaluateExpression(this.expr, null, null);
                    r *= this.multiplier;
                    if (r < this.min || r > this.max)
                        return false;
                    if (r !== this.value) {
                        this.value = r;
                        return true;
                    }
                }
                catch (e) {
                }
                return false;
            }
            /**
             * Returns instantaneous value (last value successfully parsed) of expression
             * @return {number}
             */
            getValue() {
                return this.value;
            }
            /**
             * returns expression of
             * @return
             * @return {string}
             */
            getExpr() {
                return this.parserNeeded ? (this.expr + this.getUnit()) : (this.value + "");
            }
            /**
             * returns unit representation of multiplier
             * @return {string} empty string if multiplier is 1
             * @private
             */
            /*private*/ getUnit() {
                if (this.multiplier === 1.0E-12)
                    return "p";
                if (this.multiplier === 1.0E-9)
                    return "n";
                if (this.multiplier === 1.0E-6)
                    return "u";
                if (this.multiplier === 0.001)
                    return "m";
                if (this.multiplier === 1000.0)
                    return "k";
                if (this.multiplier === 1000000.0)
                    return "M";
                if (this.multiplier === 1.0E9)
                    return "G";
                return "";
            }
            /**
             * Enables units for the expression
             * @param {boolean} unit
             */
            setUnitsEnabled(unit) {
                this.unitsEnabled = unit;
            }
            /**
             * parses unit from text in format like 1k, 23m, 32u
             *
             * @param value
             * @return {void} 1 if no unit is found at the end of string
             * @private
             */
            /*private*/ parseUnit() {
                if (this.unitsEnabled === false)
                    return;
                let s = this.expr;
                s = s.trim();
                const len = s.length;
                const uc = s.charAt(len - 1);
                let mult = 1;
                switch ((uc).charCodeAt(0)) {
                    case 112 /* 'p' */:
                    case 80 /* 'P' */:
                        mult = 1.0E-12;
                        break;
                    case 110 /* 'n' */:
                    case 78 /* 'N' */:
                        mult = 1.0E-9;
                        break;
                    case 117 /* 'u' */:
                    case 85 /* 'U' */:
                        mult = 1.0E-6;
                        break;
                    case 109 /* 'm' */:
                        mult = 0.001;
                        break;
                    case 77 /* 'M' */:
                        mult = 1000000.0;
                        break;
                    case 107 /* 'k' */:
                    case 75 /* 'K' */:
                        mult = 1000.0;
                        break;
                    case 71 /* 'G' */:
                    case 103 /* 'g' */:
                        mult = 1.0E9;
                        break;
                }
                if (mult !== 1)
                    this.expr = s.substring(0, len - 1).trim();
                this.multiplier = mult;
            }
            setShapesManager(shapesManager) {
                this.shapesManager = shapesManager;
            }
        }
        optics.DynamicValue = DynamicValue;
        DynamicValue["__class"] = "geom.optics.DynamicValue";
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class ShotData {
            constructor() {
                this.pt = new math.Vector2();
                this.normal = new math.Vector2();
                this.shotType = 0;
            }
            set(pt, normal, shotType) {
                if (pt == null) {
                    this.shotType = -1;
                    return this;
                }
                this.pt.set$math_Vector2(pt);
                this.normal = normal;
                this.shotType = shotType;
                return this;
            }
        }
        optics.ShotData = ShotData;
        ShotData["__class"] = "geom.optics.ShotData";
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var tokenizer;
            (function (tokenizer) {
                /**
                 * Create a new instance
                 * @param {string} name the name of the setVariable
                 * @class
                 * @extends net.objecthunter.exp4j.tokenizer.Token
                 */
                class VariableToken extends net.objecthunter.exp4j.tokenizer.Token {
                    constructor(name) {
                        super(net.objecthunter.exp4j.tokenizer.Token.TOKEN_VARIABLE);
                        if (this.name === undefined) {
                            this.name = null;
                        }
                        this.name = name;
                    }
                    /**
                     * Get the name of the setVariable
                     * @return {string} the name
                     */
                    getName() {
                        return this.name;
                    }
                }
                tokenizer.VariableToken = VariableToken;
                VariableToken["__class"] = "net.objecthunter.exp4j.tokenizer.VariableToken";
            })(tokenizer = exp4j.tokenizer || (exp4j.tokenizer = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var tokenizer;
            (function (tokenizer) {
                /**
                 * Create a new instance
                 * @param {number} value the value of the number
                 * @class
                 * @extends net.objecthunter.exp4j.tokenizer.Token
                 */
                class NumberToken extends net.objecthunter.exp4j.tokenizer.Token {
                    constructor(expression, offset, len) {
                        if (((expression != null && expression instanceof Array && (expression.length == 0 || expression[0] == null || (typeof expression[0] === 'string'))) || expression === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let value = javaemul.internal.DoubleHelper.parseDouble(/* valueOf */ ((str, index, len) => str.join('').substring(index, index + len))(expression, offset, len));
                                super(net.objecthunter.exp4j.tokenizer.Token.TOKEN_NUMBER);
                                if (this.value === undefined) {
                                    this.value = 0;
                                }
                                this.value = value;
                            }
                            if (this.value === undefined) {
                                this.value = 0;
                            }
                        }
                        else if (((typeof expression === 'number') || expression === null) && offset === undefined && len === undefined) {
                            let __args = arguments;
                            let value = __args[0];
                            super(net.objecthunter.exp4j.tokenizer.Token.TOKEN_NUMBER);
                            if (this.value === undefined) {
                                this.value = 0;
                            }
                            this.value = value;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Get the value of the number
                     * @return {number} the value
                     */
                    getValue() {
                        return this.value;
                    }
                }
                tokenizer.NumberToken = NumberToken;
                NumberToken["__class"] = "net.objecthunter.exp4j.tokenizer.NumberToken";
            })(tokenizer = exp4j.tokenizer || (exp4j.tokenizer = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var tokenizer;
            (function (tokenizer) {
                /**
                 * Create a new instance
                 * @param {net.objecthunter.exp4j.operator.Operator} op the operator
                 * @class
                 * @extends net.objecthunter.exp4j.tokenizer.Token
                 */
                class OperatorToken extends net.objecthunter.exp4j.tokenizer.Token {
                    constructor(op) {
                        super(net.objecthunter.exp4j.tokenizer.Token.TOKEN_OPERATOR);
                        if (this.operator === undefined) {
                            this.operator = null;
                        }
                        if (op == null) {
                            throw new java.lang.IllegalArgumentException("Operator is unknown for token.");
                        }
                        this.operator = op;
                    }
                    /**
                     * Get the operator for that token
                     * @return {net.objecthunter.exp4j.operator.Operator} the operator
                     */
                    getOperator() {
                        return this.operator;
                    }
                }
                tokenizer.OperatorToken = OperatorToken;
                OperatorToken["__class"] = "net.objecthunter.exp4j.tokenizer.OperatorToken";
            })(tokenizer = exp4j.tokenizer || (exp4j.tokenizer = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var tokenizer;
            (function (tokenizer) {
                class OpenParenthesesToken extends net.objecthunter.exp4j.tokenizer.Token {
                    constructor() {
                        super(net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_OPEN);
                    }
                }
                tokenizer.OpenParenthesesToken = OpenParenthesesToken;
                OpenParenthesesToken["__class"] = "net.objecthunter.exp4j.tokenizer.OpenParenthesesToken";
            })(tokenizer = exp4j.tokenizer || (exp4j.tokenizer = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var tokenizer;
            (function (tokenizer) {
                class FunctionToken extends net.objecthunter.exp4j.tokenizer.Token {
                    constructor(_function) {
                        super(net.objecthunter.exp4j.tokenizer.Token.TOKEN_FUNCTION);
                        if (this._function === undefined) {
                            this._function = null;
                        }
                        this._function = _function;
                    }
                    getFunction() {
                        return this._function;
                    }
                }
                tokenizer.FunctionToken = FunctionToken;
                FunctionToken["__class"] = "net.objecthunter.exp4j.tokenizer.FunctionToken";
            })(tokenizer = exp4j.tokenizer || (exp4j.tokenizer = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var tokenizer;
            (function (tokenizer) {
                /**
                 * Represents an argument separator in functions i.e: ','
                 * @extends net.objecthunter.exp4j.tokenizer.Token
                 * @class
                 */
                class ArgumentSeparatorToken extends net.objecthunter.exp4j.tokenizer.Token {
                    constructor() {
                        super(net.objecthunter.exp4j.tokenizer.Token.TOKEN_SEPARATOR);
                    }
                }
                tokenizer.ArgumentSeparatorToken = ArgumentSeparatorToken;
                ArgumentSeparatorToken["__class"] = "net.objecthunter.exp4j.tokenizer.ArgumentSeparatorToken";
            })(tokenizer = exp4j.tokenizer || (exp4j.tokenizer = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var tokenizer;
            (function (tokenizer) {
                /**
                 * represents closed parentheses
                 * @extends net.objecthunter.exp4j.tokenizer.Token
                 * @class
                 */
                class CloseParenthesesToken extends net.objecthunter.exp4j.tokenizer.Token {
                    constructor() {
                        super(net.objecthunter.exp4j.tokenizer.Token.TOKEN_PARENTHESES_CLOSE);
                    }
                }
                tokenizer.CloseParenthesesToken = CloseParenthesesToken;
                CloseParenthesesToken["__class"] = "net.objecthunter.exp4j.tokenizer.CloseParenthesesToken";
            })(tokenizer = exp4j.tokenizer || (exp4j.tokenizer = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var __function;
            (function (__function) {
                /**
                 * Class representing the builtin functions available for use in expressions
                 * @class
                 */
                class Functions {
                    static __static_initialize() { if (!Functions.__static_initialized) {
                        Functions.__static_initialized = true;
                        Functions.__static_initializer_0();
                    } }
                    static builtinFunctions_$LI$() { Functions.__static_initialize(); if (Functions.builtinFunctions == null) {
                        Functions.builtinFunctions = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(23);
                    } return Functions.builtinFunctions; }
                    static __static_initializer_0() {
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_SIN] = new Functions.Functions$0("sin");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_COS] = new Functions.Functions$1("cos");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_TAN] = new Functions.Functions$2("tan");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_COT] = new Functions.Functions$3("cot");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_LOG] = new Functions.Functions$4("log");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_LOG2] = new Functions.Functions$5("log2");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_LOG10] = new Functions.Functions$6("log10");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_LOG1P] = new Functions.Functions$7("log1p");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_ABS] = new Functions.Functions$8("abs");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_ACOS] = new Functions.Functions$9("acos");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_ASIN] = new Functions.Functions$10("asin");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_ATAN] = new Functions.Functions$11("atan");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_CBRT] = new Functions.Functions$12("cbrt");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_FLOOR] = new Functions.Functions$13("floor");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_SINH] = new Functions.Functions$14("sinh");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_SQRT] = new Functions.Functions$15("sqrt");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_COSH] = new Functions.Functions$16("cosh");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_CEIL] = new Functions.Functions$17("ceil");
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_POW] = new Functions.Functions$18("pow", 2);
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_EXP] = new Functions.Functions$19("exp", 1);
                        Functions.builtinFunctions_$LI$()[Functions.INDEX_SGN] = new Functions.Functions$20("signum", 1);
                    }
                    /**
                     * Get the builtin function for a given name
                     * @param {string} name te name of the function
                     * @return {net.objecthunter.exp4j.__function._Function} a Function instance
                     */
                    static getBuiltinFunction(name) {
                        if (name === ("sin")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_SIN];
                        }
                        else if (name === ("cos")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_COS];
                        }
                        else if (name === ("tan")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_TAN];
                        }
                        else if (name === ("cot")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_COT];
                        }
                        else if (name === ("asin")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_ASIN];
                        }
                        else if (name === ("acos")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_ACOS];
                        }
                        else if (name === ("atan")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_ATAN];
                        }
                        else if (name === ("sinh")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_SINH];
                        }
                        else if (name === ("cosh")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_COSH];
                        }
                        else if (name === ("tanh")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_TANH];
                        }
                        else if (name === ("abs")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_ABS];
                        }
                        else if (name === ("log")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_LOG];
                        }
                        else if (name === ("log10")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_LOG10];
                        }
                        else if (name === ("log2")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_LOG2];
                        }
                        else if (name === ("log1p")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_LOG1P];
                        }
                        else if (name === ("ceil")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_CEIL];
                        }
                        else if (name === ("floor")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_FLOOR];
                        }
                        else if (name === ("sqrt")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_SQRT];
                        }
                        else if (name === ("cbrt")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_CBRT];
                        }
                        else if (name === ("pow")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_POW];
                        }
                        else if (name === ("exp")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_EXP];
                        }
                        else if (name === ("expm1")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_EXPM1];
                        }
                        else if (name === ("signum")) {
                            return Functions.builtinFunctions_$LI$()[Functions.INDEX_SGN];
                        }
                        else {
                            return null;
                        }
                    }
                }
                Functions.__static_initialized = false;
                Functions.INDEX_SIN = 0;
                Functions.INDEX_COS = 1;
                Functions.INDEX_TAN = 2;
                Functions.INDEX_COT = 3;
                Functions.INDEX_LOG = 4;
                Functions.INDEX_LOG1P = 5;
                Functions.INDEX_ABS = 6;
                Functions.INDEX_ACOS = 7;
                Functions.INDEX_ASIN = 8;
                Functions.INDEX_ATAN = 9;
                Functions.INDEX_CBRT = 10;
                Functions.INDEX_CEIL = 11;
                Functions.INDEX_FLOOR = 12;
                Functions.INDEX_SINH = 13;
                Functions.INDEX_SQRT = 14;
                Functions.INDEX_TANH = 15;
                Functions.INDEX_COSH = 16;
                Functions.INDEX_POW = 17;
                Functions.INDEX_EXP = 18;
                Functions.INDEX_EXPM1 = 19;
                Functions.INDEX_LOG10 = 20;
                Functions.INDEX_LOG2 = 21;
                Functions.INDEX_SGN = 22;
                __function.Functions = Functions;
                Functions["__class"] = "net.objecthunter.exp4j.function.Functions";
                (function (Functions) {
                    class Functions$0 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.sin(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$0 = Functions$0;
                    class Functions$1 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.cos(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$1 = Functions$1;
                    class Functions$2 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.tan(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$2 = Functions$2;
                    class Functions$3 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            const tan = Math.tan(args[0]);
                            if (tan === 0.0) {
                                throw new java.lang.ArithmeticException("Division by zero in cotangent!");
                            }
                            return 1.0 / Math.tan(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$3 = Functions$3;
                    class Functions$4 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.log(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$4 = Functions$4;
                    class Functions$5 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.log(args[0]) / Math.log(2.0);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$5 = Functions$5;
                    class Functions$6 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return /* log10 */ (x => Math.log(x) * Math.LOG10E)(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$6 = Functions$6;
                    class Functions$7 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return /* log1p */ (x => Math.log(x + 1))(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$7 = Functions$7;
                    class Functions$8 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.abs(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$8 = Functions$8;
                    class Functions$9 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.acos(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$9 = Functions$9;
                    class Functions$10 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.asin(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$10 = Functions$10;
                    class Functions$11 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.atan(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$11 = Functions$11;
                    class Functions$12 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return /* cbrt */ Math.pow(args[0], 1 / 3);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$12 = Functions$12;
                    class Functions$13 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.floor(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$13 = Functions$13;
                    class Functions$14 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return /* sinh */ (x => (Math.exp(x) - Math.exp(-x)) / 2)(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$14 = Functions$14;
                    class Functions$15 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.sqrt(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$15 = Functions$15;
                    class Functions$16 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return /* cosh */ (x => (Math.exp(x) + Math.exp(-x)) / 2)(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$16 = Functions$16;
                    class Functions$17 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.ceil(args[0]);
                        }
                        constructor(__arg0) {
                            super(__arg0);
                        }
                    }
                    Functions.Functions$17 = Functions$17;
                    class Functions$18 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.pow(args[0], args[1]);
                        }
                        constructor(__arg0, __arg1) {
                            super(__arg0, __arg1);
                        }
                    }
                    Functions.Functions$18 = Functions$18;
                    class Functions$19 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.exp(args[0]);
                        }
                        constructor(__arg0, __arg1) {
                            super(__arg0, __arg1);
                        }
                    }
                    Functions.Functions$19 = Functions$19;
                    class Functions$20 extends net.objecthunter.exp4j.__function._Function {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            if (args[0] > 0) {
                                return 1;
                            }
                            else if (args[0] < 0) {
                                return -1;
                            }
                            else {
                                return 0;
                            }
                        }
                        constructor(__arg0, __arg1) {
                            super(__arg0, __arg1);
                        }
                    }
                    Functions.Functions$20 = Functions$20;
                })(Functions = __function.Functions || (__function.Functions = {}));
            })(__function = exp4j.__function || (exp4j.__function = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (net) {
    var objecthunter;
    (function (objecthunter) {
        var exp4j;
        (function (exp4j) {
            var operator;
            (function (operator) {
                class Operators {
                    static __static_initialize() { if (!Operators.__static_initialized) {
                        Operators.__static_initialized = true;
                        Operators.__static_initializer_0();
                    } }
                    static builtinOperators_$LI$() { Operators.__static_initialize(); if (Operators.builtinOperators == null) {
                        Operators.builtinOperators = [null, null, null, null, null, null, null, null];
                    } return Operators.builtinOperators; }
                    static __static_initializer_0() {
                        Operators.builtinOperators_$LI$()[Operators.INDEX_ADDITION] = new Operators.Operators$0("+", 2, true, net.objecthunter.exp4j.operator.Operator.PRECEDENCE_ADDITION);
                        Operators.builtinOperators_$LI$()[Operators.INDEX_SUBTRACTION] = new Operators.Operators$1("-", 2, true, net.objecthunter.exp4j.operator.Operator.PRECEDENCE_ADDITION);
                        Operators.builtinOperators_$LI$()[Operators.INDEX_UNARYMINUS] = new Operators.Operators$2("-", 1, false, net.objecthunter.exp4j.operator.Operator.PRECEDENCE_UNARY_MINUS);
                        Operators.builtinOperators_$LI$()[Operators.INDEX_UNARYPLUS] = new Operators.Operators$3("+", 1, false, net.objecthunter.exp4j.operator.Operator.PRECEDENCE_UNARY_PLUS_$LI$());
                        Operators.builtinOperators_$LI$()[Operators.INDEX_MUTLIPLICATION] = new Operators.Operators$4("*", 2, true, net.objecthunter.exp4j.operator.Operator.PRECEDENCE_MULTIPLICATION);
                        Operators.builtinOperators_$LI$()[Operators.INDEX_DIVISION] = new Operators.Operators$5("/", 2, true, net.objecthunter.exp4j.operator.Operator.PRECEDENCE_DIVISION_$LI$());
                        Operators.builtinOperators_$LI$()[Operators.INDEX_POWER] = new Operators.Operators$6("^", 2, false, net.objecthunter.exp4j.operator.Operator.PRECEDENCE_POWER);
                        Operators.builtinOperators_$LI$()[Operators.INDEX_MODULO] = new Operators.Operators$7("%", 2, true, net.objecthunter.exp4j.operator.Operator.PRECEDENCE_MODULO_$LI$());
                    }
                    static getBuiltinOperator(symbol, numArguments) {
                        switch ((symbol).charCodeAt(0)) {
                            case 43 /* '+' */:
                                if (numArguments !== 1) {
                                    return Operators.builtinOperators_$LI$()[Operators.INDEX_ADDITION];
                                }
                                else {
                                    return Operators.builtinOperators_$LI$()[Operators.INDEX_UNARYPLUS];
                                }
                            case 45 /* '-' */:
                                if (numArguments !== 1) {
                                    return Operators.builtinOperators_$LI$()[Operators.INDEX_SUBTRACTION];
                                }
                                else {
                                    return Operators.builtinOperators_$LI$()[Operators.INDEX_UNARYMINUS];
                                }
                            case 42 /* '*' */:
                                return Operators.builtinOperators_$LI$()[Operators.INDEX_MUTLIPLICATION];
                            case 47 /* '/' */:
                                return Operators.builtinOperators_$LI$()[Operators.INDEX_DIVISION];
                            case 94 /* '^' */:
                                return Operators.builtinOperators_$LI$()[Operators.INDEX_POWER];
                            case 37 /* '%' */:
                                return Operators.builtinOperators_$LI$()[Operators.INDEX_MODULO];
                            default:
                                return null;
                        }
                    }
                }
                Operators.__static_initialized = false;
                Operators.INDEX_ADDITION = 0;
                Operators.INDEX_SUBTRACTION = 1;
                Operators.INDEX_MUTLIPLICATION = 2;
                Operators.INDEX_DIVISION = 3;
                Operators.INDEX_POWER = 4;
                Operators.INDEX_MODULO = 5;
                Operators.INDEX_UNARYMINUS = 6;
                Operators.INDEX_UNARYPLUS = 7;
                operator.Operators = Operators;
                Operators["__class"] = "net.objecthunter.exp4j.operator.Operators";
                (function (Operators) {
                    class Operators$0 extends net.objecthunter.exp4j.operator.Operator {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return args[0] + args[1];
                        }
                        constructor(__arg0, __arg1, __arg2, __arg3) {
                            super(__arg0, __arg1, __arg2, __arg3);
                        }
                    }
                    Operators.Operators$0 = Operators$0;
                    class Operators$1 extends net.objecthunter.exp4j.operator.Operator {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return args[0] - args[1];
                        }
                        constructor(__arg0, __arg1, __arg2, __arg3) {
                            super(__arg0, __arg1, __arg2, __arg3);
                        }
                    }
                    Operators.Operators$1 = Operators$1;
                    class Operators$2 extends net.objecthunter.exp4j.operator.Operator {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return -args[0];
                        }
                        constructor(__arg0, __arg1, __arg2, __arg3) {
                            super(__arg0, __arg1, __arg2, __arg3);
                        }
                    }
                    Operators.Operators$2 = Operators$2;
                    class Operators$3 extends net.objecthunter.exp4j.operator.Operator {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return args[0];
                        }
                        constructor(__arg0, __arg1, __arg2, __arg3) {
                            super(__arg0, __arg1, __arg2, __arg3);
                        }
                    }
                    Operators.Operators$3 = Operators$3;
                    class Operators$4 extends net.objecthunter.exp4j.operator.Operator {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return args[0] * args[1];
                        }
                        constructor(__arg0, __arg1, __arg2, __arg3) {
                            super(__arg0, __arg1, __arg2, __arg3);
                        }
                    }
                    Operators.Operators$4 = Operators$4;
                    class Operators$5 extends net.objecthunter.exp4j.operator.Operator {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            if (args[1] === 0.0) {
                                throw new java.lang.ArithmeticException("Division by zero!");
                            }
                            return args[0] / args[1];
                        }
                        constructor(__arg0, __arg1, __arg2, __arg3) {
                            super(__arg0, __arg1, __arg2, __arg3);
                        }
                    }
                    Operators.Operators$5 = Operators$5;
                    class Operators$6 extends net.objecthunter.exp4j.operator.Operator {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            return Math.pow(args[0], args[1]);
                        }
                        constructor(__arg0, __arg1, __arg2, __arg3) {
                            super(__arg0, __arg1, __arg2, __arg3);
                        }
                    }
                    Operators.Operators$6 = Operators$6;
                    class Operators$7 extends net.objecthunter.exp4j.operator.Operator {
                        /**
                         *
                         * @param {double[]} args
                         * @return {number}
                         */
                        apply(...args) {
                            if (args[1] === 0.0) {
                                throw new java.lang.ArithmeticException("Division by zero!");
                            }
                            return args[0] % args[1];
                        }
                        constructor(__arg0, __arg1, __arg2, __arg3) {
                            super(__arg0, __arg1, __arg2, __arg3);
                        }
                    }
                    Operators.Operators$7 = Operators$7;
                })(Operators = operator.Operators || (operator.Operators = {}));
            })(operator = exp4j.operator || (exp4j.operator = {}));
        })(exp4j = objecthunter.exp4j || (objecthunter.exp4j = {}));
    })(objecthunter = net.objecthunter || (net.objecthunter = {}));
})(net || (net = {}));
(function (framework) {
    var input;
    (function (input) {
        class AbstractKeyboardInputHandler extends framework.input.AbstractInputHandler {
            constructor(app) {
                super();
                if (this.component === undefined) {
                    this.component = null;
                }
                if (this.camera === undefined) {
                    this.camera = null;
                }
                if (this.app === undefined) {
                    this.app = null;
                }
                this.app = app;
                this.component = app.canvas;
                this.camera = app.camera;
            }
            /**
             *
             */
            install() {
                window.addEventListener("keydown", (event) => {
                    if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                        this.onKeyPressed((event.keyCode | 0), event.key);
                        event.preventDefault();
                    }
                    return null;
                }, true);
                window.addEventListener("keyup", (event) => {
                    if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                        this.onKeyReleased((event.keyCode | 0), event.key);
                        event.preventDefault();
                    }
                    return null;
                }, true);
            }
            /**
             *
             */
            uninstall() {
            }
            onKeyPressed(keyCode, key) {
            }
            onKeyReleased(keyCode, key) {
            }
        }
        input.AbstractKeyboardInputHandler = AbstractKeyboardInputHandler;
        AbstractKeyboardInputHandler["__class"] = "framework.input.AbstractKeyboardInputHandler";
        AbstractKeyboardInputHandler["__interfaces"] = ["framework.input.InputHandler"];
    })(input = framework.input || (framework.input = {}));
})(framework || (framework = {}));
(function (framework) {
    var input;
    (function (input) {
        class AbstractMouseInputHandler extends framework.input.AbstractInputHandler {
            constructor(app) {
                super();
                if (this.app === undefined) {
                    this.app = null;
                }
                if (this.component === undefined) {
                    this.component = null;
                }
                if (this.camera === undefined) {
                    this.camera = null;
                }
                this.TMP_VEC = new math.Vector2();
                if (this.dragCurrent === undefined) {
                    this.dragCurrent = null;
                }
                if (this.dragStart === undefined) {
                    this.dragStart = null;
                }
                if (this.wheelRotation === undefined) {
                    this.wheelRotation = 0;
                }
                this.app = app;
                this.component = app.canvas;
                this.camera = app.camera;
            }
            /*private*/ pageToCanvas(x, y) {
                return new math.Vector2(x - this.component.offsetLeft, y - this.component.offsetTop);
            }
            /*private*/ getButton(e) {
                let btn = e.button;
                if (btn === 0)
                    btn = e.which;
                return btn;
            }
            /**
             *
             */
            install() {
                this.component.addEventListener("mousedown", (event) => {
                    this.dragCurrent = this.pageToCanvas(event.pageX, event.pageY);
                    this.dragStart = this.dragCurrent;
                    if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                        this.onMousePressed(this.getButton(event), this.dragStart);
                    }
                    return null;
                }, true);
                this.component.addEventListener("mousemove", (event) => {
                    if (event.buttons > 0) {
                        this.dragCurrent = this.pageToCanvas(event.pageX, event.pageY);
                        if (this.isEnabled() && !this.isDependentBehaviorActive() && this.dragStart != null) {
                            this.onMouseDrag(this.getButton(event), this.dragStart, this.dragCurrent);
                        }
                    }
                    else {
                        if (this.isEnabled() && !this.isDependentBehaviorActive())
                            this.onMouseMove(0, this.pageToCanvas(event.pageX, event.pageY));
                    }
                    return null;
                }, true);
                this.component.addEventListener("mouseup", (event) => {
                    const v = this.pageToCanvas(event.pageX, event.pageY);
                    if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                        this.onMouseRelease(this.getButton(event), v);
                    }
                    this.dragCurrent = null;
                    this.dragStart = null;
                    return null;
                }, true);
                this.component.addEventListener("click", (event) => {
                    if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                        this.onMouseClick(this.getButton(event), this.pageToCanvas(event.pageX, event.pageY));
                    }
                    return null;
                }, true);
                this.component.addEventListener("contextmenu", (event) => {
                    event.preventDefault();
                    if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                        this.onMouseClick(2, this.pageToCanvas(event.pageX, event.pageY));
                    }
                    return null;
                }, true);
                this.component.addEventListener("touchstart", (event) => {
                    if (event.touches.length === 1) {
                        const touch = event.changedTouches.item(0);
                        this.dragCurrent = this.pageToCanvas(touch.pageX, touch.pageY);
                        this.dragStart = this.dragCurrent;
                        if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                            this.onMousePressed(1, this.dragStart);
                        }
                    }
                    event.preventDefault();
                    return null;
                }, true);
                this.component.addEventListener("touchmove", (event) => {
                    if (event.changedTouches.length === 1) {
                        const touch = event.changedTouches.item(0);
                        this.dragCurrent = this.pageToCanvas(touch.pageX, touch.pageY);
                        if (this.isEnabled() && !this.isDependentBehaviorActive() && this.dragStart != null) {
                            this.onMouseDrag(1, this.dragStart, this.dragCurrent);
                        }
                    }
                    event.preventDefault();
                    return null;
                }, true);
                this.component.addEventListener("touchend", (event) => {
                    if (event.changedTouches.length === 1) {
                        const touch = event.changedTouches.item(0);
                        this.dragCurrent = this.pageToCanvas(touch.pageX, touch.pageY);
                        if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                            this.onMouseClick(1, this.dragCurrent);
                            this.onMouseRelease(1, this.dragCurrent);
                        }
                        this.dragCurrent = null;
                        this.dragStart = null;
                    }
                    event.preventDefault();
                    return null;
                }, true);
                this.component.addEventListener("mousewheel", (event) => {
                    if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                        event.preventDefault();
                        this.onMouseWheel(event.wheelDelta, this.pageToCanvas(event.pageX, event.pageY));
                    }
                    return null;
                }, true);
            }
            /**
             *
             */
            uninstall() {
            }
            /**
             *
             * @param {boolean} flag
             */
            setEnabled(flag) {
                super.setEnabled(flag);
                if (!flag) {
                    this.dragCurrent = null;
                    this.dragStart = null;
                    this.wheelRotation = 0.0;
                }
            }
            onMousePressed(button, point) {
            }
            onMouseDrag(button, start, current) {
            }
            onMouseMove(button, point) {
            }
            onMouseClick(button, point) {
            }
            onMouseRelease(button, point) {
            }
            onMouseWheel(rotation, point) {
            }
        }
        input.AbstractMouseInputHandler = AbstractMouseInputHandler;
        AbstractMouseInputHandler["__class"] = "framework.input.AbstractMouseInputHandler";
        AbstractMouseInputHandler["__interfaces"] = ["framework.input.InputHandler"];
    })(input = framework.input || (framework.input = {}));
})(framework || (framework = {}));
(function (math) {
    /**
     * Full constructor for Matrix <pre>
     * |m11  m12  m13|
     * |m21  m22  m23|
     * |m31  m32  m33|</pre>
     * @param {number} m11 first row  , first column
     * @param {number} m12 first row  , second column
     * @param {number} m13 first row  , third column
     * @param {number} m21 second row , first column
     * @param {number} m22 second row , second column
     * @param {number} m23 second row , third column
     * @param {number} m31 third row  , first column
     * @param {number} m32 third row  , second column
     * @param {number} m33 third row  , third column
     * Note that third row is ignored, it is always set as 0, 0, 1
     * @class
     * @author mahesh
     */
    class Transform {
        constructor(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
            if (((typeof m11 === 'number') || m11 === null) && ((typeof m12 === 'number') || m12 === null) && ((typeof m13 === 'number') || m13 === null) && ((typeof m21 === 'number') || m21 === null) && ((typeof m22 === 'number') || m22 === null) && ((typeof m23 === 'number') || m23 === null) && ((typeof m31 === 'number') || m31 === null) && ((typeof m32 === 'number') || m32 === null) && ((typeof m33 === 'number') || m33 === null)) {
                let __args = arguments;
                this.m11 = 1;
                this.m12 = 0;
                this.m13 = 0;
                this.m21 = 0;
                this.m22 = 1;
                this.m23 = 0;
                this.m11 = m11;
                this.m12 = m12;
                this.m13 = m13;
                this.m21 = m21;
                this.m22 = m22;
                this.m23 = m23;
            }
            else if (((typeof m11 === 'number') || m11 === null) && ((typeof m12 === 'number') || m12 === null) && ((typeof m13 === 'number') || m13 === null) && ((typeof m21 === 'number') || m21 === null) && ((typeof m22 === 'number') || m22 === null) && ((typeof m23 === 'number') || m23 === null) && m31 === undefined && m32 === undefined && m33 === undefined) {
                let __args = arguments;
                let a = __args[0];
                let b = __args[1];
                let c = __args[2];
                let d = __args[3];
                let e = __args[4];
                let f = __args[5];
                this.m11 = 1;
                this.m12 = 0;
                this.m13 = 0;
                this.m21 = 0;
                this.m22 = 1;
                this.m23 = 0;
                this.m11 = a;
                this.m21 = b;
                this.m12 = c;
                this.m22 = d;
                this.m13 = e;
                this.m23 = f;
            }
            else if (m11 === undefined && m12 === undefined && m13 === undefined && m21 === undefined && m22 === undefined && m23 === undefined && m31 === undefined && m32 === undefined && m33 === undefined) {
                let __args = arguments;
                this.m11 = 1;
                this.m12 = 0;
                this.m13 = 0;
                this.m21 = 0;
                this.m22 = 1;
                this.m23 = 0;
            }
            else
                throw new Error('invalid overload');
        }
        static tmp_Transform_$LI$() { if (Transform.tmp_Transform == null) {
            Transform.tmp_Transform = new Transform();
        } return Transform.tmp_Transform; }
        static tmpVector_$LI$() { if (Transform.tmpVector == null) {
            Transform.tmpVector = new math.Vector2();
        } return Transform.tmpVector; }
        /**
         * Returns string representation of matrix
         * @return {string}
         */
        toString() {
            return javaemul.internal.StringHelper.format("[%f,%f,%f\n %f,%f,%f\n %f,%f,%f]", this.m11, this.m12, this.m13, this.m21, this.m22, this.m23, Transform.m31, Transform.m32, Transform.m33);
        }
        /**
         * returns true if this transform is Identity
         *
         * @return {boolean} {boolean}
         */
        isIdentity() {
            return (this.m11 === 1 && this.m12 === 0 && this.m13 === 0 && this.m21 === 0 && this.m22 === 1 && this.m23 === 0);
        }
        /**
         * Returns true if transform is equal to this transform
         * @return
         * @param {*} transform
         * @return {boolean}
         */
        equals(transform) {
            if (transform === this)
                return true;
            if (transform == null || !(transform != null && transform instanceof math.Transform))
                return false;
            Transform.tmp_Transform_$LI$().set$math_Transform(transform);
            return (this.m11 === Transform.tmp_Transform_$LI$().m11 && this.m11 === Transform.tmp_Transform_$LI$().m11 && this.m12 === Transform.tmp_Transform_$LI$().m12 && this.m13 === Transform.tmp_Transform_$LI$().m13 && this.m21 === Transform.tmp_Transform_$LI$().m21 && this.m22 === Transform.tmp_Transform_$LI$().m22 && this.m23 === Transform.tmp_Transform_$LI$().m23);
        }
        set$double$double$double$double$double$double$double$double$double(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
            this.m11 = m11;
            this.m12 = m12;
            this.m13 = m13;
            this.m21 = m21;
            this.m22 = m22;
            this.m23 = m23;
            return this;
        }
        /**
         * Sets the matrix entries as <pre>
         * |m11  m12  m13|
         * |m21  m22  m23|
         * |m31  m32  m33|</pre>
         * @param {number} m11 first row  , first column
         * @param {number} m12 first row  , second column
         * @param {number} m13 first row  , third column
         * @param {number} m21 second row , first column
         * @param {number} m22 second row , second column
         * @param {number} m23 second row , third column
         * @param {number} m31 third row  , first column
         * @param {number} m32 third row  , second column
         * @param {number} m33 third row  , third column
         * Note that third row is ignored, it is always set as 0, 0, 1
         * @return {math.Transform}
         */
        set(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
            if (((typeof m11 === 'number') || m11 === null) && ((typeof m12 === 'number') || m12 === null) && ((typeof m13 === 'number') || m13 === null) && ((typeof m21 === 'number') || m21 === null) && ((typeof m22 === 'number') || m22 === null) && ((typeof m23 === 'number') || m23 === null) && ((typeof m31 === 'number') || m31 === null) && ((typeof m32 === 'number') || m32 === null) && ((typeof m33 === 'number') || m33 === null)) {
                return this.set$double$double$double$double$double$double$double$double$double(m11, m12, m13, m21, m22, m23, m31, m32, m33);
            }
            else if (((typeof m11 === 'number') || m11 === null) && ((typeof m12 === 'number') || m12 === null) && ((typeof m13 === 'number') || m13 === null) && ((typeof m21 === 'number') || m21 === null) && ((typeof m22 === 'number') || m22 === null) && ((typeof m23 === 'number') || m23 === null) && m31 === undefined && m32 === undefined && m33 === undefined) {
                return this.set$double$double$double$double$double$double(m11, m12, m13, m21, m22, m23);
            }
            else if (((m11 != null && m11 instanceof math.Transform) || m11 === null) && m12 === undefined && m13 === undefined && m21 === undefined && m22 === undefined && m23 === undefined && m31 === undefined && m32 === undefined && m33 === undefined) {
                return this.set$math_Transform(m11);
            }
            else
                throw new Error('invalid overload');
        }
        set$double$double$double$double$double$double(a, b, c, d, e, f) {
            this.m11 = a;
            this.m21 = b;
            this.m12 = c;
            this.m22 = d;
            this.m13 = e;
            this.m23 = f;
            return this;
        }
        set$math_Transform(transform) {
            this.m11 = transform.m11;
            this.m21 = transform.m21;
            this.m12 = transform.m12;
            this.m22 = transform.m22;
            this.m13 = transform.m13;
            this.m23 = transform.m23;
            return this;
        }
        /**
         * Returns a copy of this matrix. If a target matrix is specified then the
         * matrix is copied into this target matrix. If it is null then a new
         * fresh matrix is created.
         *
         * @param {Transform} target
         * Optional target matrix, can be null
         * @return {math.Transform} {Transform} A copy of this matrix
         * @param {math.Transform} target
         */
        copy(target) {
            return (target != null ? target : new Transform()).set$math_Transform(this);
        }
        /**
         * Sets the entries of this matrix to an identity matrix.
         *
         * @return {math.Transform} {Transform} this matrix
         */
        setToIdentity() {
            return this.set$double$double$double$double$double$double$double$double$double(1, 0, 0, 0, 1, 0, 0, 0, 1);
        }
        /**
         * Sets the entries of this matrix to a rotation matrix.
         *
         * @param {number} angle
         * The rotation angle in anti-clockwise RAD
         * @return {math.Transform} {Transform}
         * This matrix
         * @param {number} angle
         */
        setToRotate(angle) {
            let s;
            let c;
            s = Math.fround(Math.sin(angle));
            c = Math.fround(Math.cos(angle));
            return this.set$double$double$double$double$double$double$double$double$double(c, -s, 0, s, c, 0, 0, 0, 1);
        }
        /**
         * Returns the rotation angle in anti-clockwise RAD.
         *
         * @return {number} {number} The rotation angle in anti-clockwise RAD
         */
        getRotationAngle() {
            return Math.fround(Math.atan2(this.m21, this.m11));
        }
        setToScale$double$double(fx, fy) {
            return this.set$double$double$double$double$double$double$double$double$double(fx, 0, 0, 0, fy, 0, 0, 0, 1);
        }
        /**
         * Sets the entries of this matrix to a scaling matrix.
         *
         * @param {number} fx
         * The X scale factor
         * @param {number=} fy
         * The Y scale factor
         * @return {math.Transform} {Transform}
         * This matrix
         * @param {number} fx
         * @param {number} fy
         */
        setToScale(fx, fy) {
            if (((typeof fx === 'number') || fx === null) && ((typeof fy === 'number') || fy === null)) {
                return this.setToScale$double$double(fx, fy);
            }
            else if (((typeof fx === 'number') || fx === null) && fy === undefined) {
                return this.setToScale$double(fx);
            }
            else
                throw new Error('invalid overload');
        }
        setToScale$double(f) {
            return this.set$double$double$double$double$double$double$double$double$double(f, 0, 0, 0, f, 0, 0, 0, 1);
        }
        /**
         * Returns The scale vector of the current matrix. Attention! This
         * vector is reused internally. So you may want to clone the vector if you need it for
         * a longer time.
         *
         * @return {math.Vector2} {Vector} The scale vector of the matrix (x: scaleX, y:scaleY)
         */
        getScale() {
            Transform.tmpVector_$LI$().set$double$double(1, 1);
            this.transformDir$math_Vector2(Transform.tmpVector_$LI$());
            return Transform.tmpVector_$LI$();
        }
        /**
         * Sets the entries of this matrix to a translation matrix.
         *
         * @param {number} dx
         * The X delta
         * @param {number} dy
         * The Y delta.
         * @return {math.Transform} {Transform}
         * This matrix
         * @param {number} dx
         * @param {number} dy
         */
        setToTranslate(dx, dy) {
            return this.set$double$double$double$double$double$double$double$double$double(1, 0, dx, 0, 1, dy, 0, 0, 1);
        }
        /**
         * Returns The translation vector of the current matrix. Attention! This
         * vector is reused and updated to the current translation whenever this
         * method is called. So you may want to clone the vector if you need it for
         * a longer time.
         *
         * @return {math.Vector2} {Vector} The translation vector of the matrix
         */
        getTranslation() {
            return Transform.tmpVector_$LI$().set$double$double(this.m13, this.m23);
        }
        setToTrnRotScl$double$double$double$double$double(x, y, radians, scaleX, scaleY) {
            this.m13 = x;
            this.m23 = y;
            if (radians === 0) {
                this.m11 = scaleX;
                this.m12 = 0;
                this.m21 = 0;
                this.m22 = scaleY;
            }
            else {
                const sin = Math.fround(Math.sin(radians));
                const cos = Math.fround(Math.cos(radians));
                this.m11 = cos * scaleX;
                this.m12 = -sin * scaleY;
                this.m21 = sin * scaleX;
                this.m22 = cos * scaleY;
            }
            return this;
        }
        /**
         * Sets this matrix to a concatenation of translation, rotation and scale. It is a more efficient form for:
         * <code>idt().translate(x, y).rotateRad(radians).scale(scaleX, scaleY)</code>
         * @param {number} x The translation in x.
         * @param {number} y The translation in y.
         * @param {number} radians The angle in radians.
         * @param {number} scaleX The scale in y.
         * @param {number} scaleY The scale in x.
         * @return {math.Transform} This matrix for the purpose of chaining operations.
         */
        setToTrnRotScl(x, y, radians, scaleX, scaleY) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof radians === 'number') || radians === null) && ((typeof scaleX === 'number') || scaleX === null) && ((typeof scaleY === 'number') || scaleY === null)) {
                return this.setToTrnRotScl$double$double$double$double$double(x, y, radians, scaleX, scaleY);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && ((typeof y === 'number') || y === null) && ((radians != null && radians instanceof math.Vector2) || radians === null) && scaleX === undefined && scaleY === undefined) {
                return this.setToTrnRotScl$math_Vector2$double$math_Vector2(x, y, radians);
            }
            else
                throw new Error('invalid overload');
        }
        setToTrnRotScl$math_Vector2$double$math_Vector2(trn, radians, scale) {
            return this.setToTrnRotScl$double$double$double$double$double(Math.fround(trn.x), Math.fround(trn.y), radians, Math.fround(scale.x), Math.fround(scale.y));
        }
        transform$math_Transform(m) {
            return this.set$double$double$double$double$double$double$double$double$double(this.m11 * m.m11 + this.m12 * m.m21 + 0, this.m11 * m.m12 + this.m12 * m.m22 + 0, this.m11 * m.m13 + this.m12 * m.m23 + this.m13, this.m21 * m.m11 + this.m22 * m.m21 + 0, this.m21 * m.m12 + this.m22 * m.m22 + 0, this.m21 * m.m13 + this.m22 * m.m23 + this.m23, 0, 0, 1);
        }
        /**
         * Premultiplies this matrix with the provided matrix and stores the result in this matrix. For example:
         *
         * <pre>
         * A.preMul(B) results in A := BA
         * </pre>
         * @param other The other Matrix to multiply by
         * @return {math.Transform} This matrix for the purpose of chaining operations.
         * @param {math.Transform} m
         */
        preMul(m) {
            return this.set$double$double$double$double$double$double$double$double$double(m.m11 * this.m11 + m.m12 * this.m21 + 0, m.m11 * this.m12 + m.m12 * this.m22 + 0, m.m11 * this.m13 + m.m12 * this.m23 + m.m13, m.m21 * this.m11 + m.m22 * this.m21 + 0, m.m21 * this.m12 + m.m22 * this.m22 + 0, m.m21 * this.m13 + m.m22 * this.m23 + m.m23, 0, 0, 1);
        }
        /**
         * Multiplies this matrix with the specified factor.
         *
         * @param {number} f
         * The factor
         * @return {math.Transform} {Transform}
         * This matrix
         * @param {number} f
         */
        multiply(f) {
            this.m11 *= f;
            this.m12 *= f;
            this.m13 *= f;
            this.m21 *= f;
            this.m22 *= f;
            this.m23 *= f;
            return this;
        }
        /**
         * Divides this matrix by the specified factor.
         *
         * @param {number} f
         * The factor
         * @return {math.Transform} {Transform}
         * This matrix
         * @param {number} f
         */
        divide(f) {
            this.m11 /= f;
            this.m12 /= f;
            this.m13 /= f;
            this.m21 /= f;
            this.m22 /= f;
            this.m23 /= f;
            return this;
        }
        /**
         * Translates this matrix by the specified deltas
         *
         * @param {number} dx
         * The X delta
         * @param {number} dy
         * The Y delta
         * @return {math.Transform} {Transform}
         * This matrix
         * @param {number} dx
         * @param {number} dy
         */
        translate(dx, dy) {
            return this.transform$math_Transform(Transform.tmp_Transform_$LI$().setToTranslate(dx, dy));
        }
        scale$double$double(fx, fy) {
            return this.transform$math_Transform(Transform.tmp_Transform_$LI$().setToScale$double$double(fx, fy));
        }
        /**
         * Scales this matrix by the specified factors
         *
         * @param {number} fx
         * The X factor
         * @param {number=} fy
         * The Y factor.
         * @return {math.Transform} {Transform}
         * This matrix
         * @param {number} fx
         * @param {number} fy
         */
        scale(fx, fy) {
            if (((typeof fx === 'number') || fx === null) && ((typeof fy === 'number') || fy === null)) {
                return this.scale$double$double(fx, fy);
            }
            else if (((typeof fx === 'number') || fx === null) && fy === undefined) {
                return this.scale$double(fx);
            }
            else
                throw new Error('invalid overload');
        }
        scale$double(f) {
            return this.transform$math_Transform(Transform.tmp_Transform_$LI$().setToScale$double$double(f, f));
        }
        /**
         * Rotates this matrix by the specified angle
         *
         * @param {number} r
         * The angle in anti-clockwise RAD
         * @return {math.Transform} {Transform}
         * This matrix
         * @param {number} r
         */
        rotate(r) {
            return this.transform$math_Transform(Transform.tmp_Transform_$LI$().setToRotate(r));
        }
        /**
         * Returns the determinant of the matrix.
         *
         * @return {number} {number} The determinant of the matrix
         */
        getDeterminant() {
            return this.m11 * this.m22 - this.m21 * this.m12;
        }
        /**
         * Returns inverse of this matrix.
         * <br><b>Attention!</B> The returned transform is reused internally. So you may want to {@link #clone()} it if you need it for
         * a longer time.
         *
         * @return {math.Transform} {Transform}
         */
        getInverse() {
            Transform.tmp_Transform_$LI$().set$math_Transform(this);
            return Transform.tmp_Transform_$LI$().invert();
        }
        /**
         * Inverts this matrix.
         *
         * @return {math.Transform} {Transform}
         * This matrix
         */
        invert() {
            let d;
            d = this.getDeterminant();
            return this.set$double$double$double$double$double$double$double$double$double(this.m22 * Transform.m33 - this.m23 * Transform.m32, this.m13 * Transform.m32 - this.m12 * Transform.m33, this.m12 * this.m23 - this.m13 * this.m22, this.m23 * Transform.m31 - this.m21 * Transform.m33, this.m11 * Transform.m33 - this.m13 * Transform.m31, this.m13 * this.m21 - this.m11 * this.m23, 0, 0, 1).divide(d);
        }
        transform$math_Vector2(v) {
            const x = Math.fround(v.x);
            v.x = this.m11 * x + this.m12 * v.y + this.m13;
            v.y = this.m21 * x + this.m22 * v.y + this.m23;
            return v;
        }
        transform$double$double(x, y) {
            return Transform.tmpVector_$LI$().set$double$double(this.m11 * x + this.m12 * y + this.m13, this.m21 * x + this.m22 * y + this.m23);
        }
        /**
         * returns new transformed Point
         *
         * @param {number} x
         * @param {number} y
         * @return
         * @return {math.Vector2}
         */
        transform(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.transform$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Transform) || x === null) && y === undefined) {
                return this.transform$math_Transform(x);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.transform$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        transformDir$math_Vector2(v) {
            const x = v.x;
            v.x = this.m11 * x + this.m12 * v.y;
            v.y = this.m21 * x + this.m22 * v.y;
            return v;
        }
        transformDir$double$double(x, y) {
            return Transform.tmpVector_$LI$().set$double$double(this.m11 * x + this.m12 * y, this.m21 * x + this.m22 * y);
        }
        /**
         * returns new transformed Direction(not translated)
         * <br><b>Attention!</B> The returned vector is reused internally. So you may want to {@link #Vector2.clone()} it if you need it for
         * a longer time.
         *
         * @param {number} x
         * @param {number} y
         * @return
         * @return {math.Vector2}
         */
        transformDir(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.transformDir$double$double(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                return this.transformDir$math_Vector2(x);
            }
            else
                throw new Error('invalid overload');
        }
        static main(args) {
            console.info("Mat3 I =\n" + new Transform(1, 0, 0, 1, 0, 0));
            console.info("Mat3 I =\n" + new Transform());
            console.info("Mat3 T =\n" + new Transform().setToTranslate(5, 5));
            console.info("Mat3 S =\n" + new Transform().setToScale$double$double(5, 5));
            console.info("Mat3 R =\n" + new Transform().setToRotate(Math.fround((Math.PI / 3))));
            console.info("Vec2 v" + new math.Vector2(1, 0));
            console.info("Vec2 vT" + new Transform().setToTranslate(5, 5).transform$double$double(1, 0));
            console.info("Vec2 vS" + new Transform().setToScale$double$double(5, 5).transform$double$double(1, 1));
            console.info("Vec2 vR" + new Transform().setToRotate(Math.fround((Math.PI / 3))).transform$double$double(1, 0));
        }
    }
    /**
     * element at third row, first column
     */
    Transform.m31 = 0;
    /**
     * element at third row, second column
     */
    Transform.m32 = 0;
    /**
     * element at third row, third column
     */
    Transform.m33 = 1;
    math.Transform = Transform;
    Transform["__class"] = "math.Transform";
})(math || (math = {}));
(function (geom) {
    class LazyPoint extends math.Vector2 {
        constructor(x, y) {
            super();
            this.x = x;
            this.y = y;
        }
        /**
         * Update the x and y values
         *
         * @param {Point} point
         * @param {math.Vector2} point
         */
        update(point) {
            this.x = point.x;
            this.y = point.y;
        }
        /**
         * Move the point to another position using an angle and distance
         *
         * @param {number} angle The angle in radians
         * @param {number} distance How much the point should be moved
         * @param {number} angle
         * @param {number} distance
         */
        moveByAngle(angle, distance) {
            const angleRotated = angle + (Math.PI / 2);
            this.x = this.x + (Math.sin(angleRotated) * distance);
            this.y = this.y - (Math.cos(angleRotated) * distance);
        }
        /**
         * Check if this point is the same as another point
         *
         * @param {Point} point
         * @returns {boolean}
         * @param {math.Vector2} point
         * @return {boolean}
         */
        equalsTo(point) {
            return this.x === point.x && this.y === point.y;
        }
        /**
         * Get the difference for x and y axis to another point
         *
         * @param {Point} point
         * @returns {Point}
         * @param {math.Vector2} point
         * @return {geom.LazyPoint}
         */
        getDifferenceTo(point) {
            return new LazyPoint(this.x - point.x, this.y - point.y);
        }
        /**
         * Calculate distance to another point
         *
         * @param {Point} point
         * @returns {Point}
         * @param {math.Vector2} point
         * @return {number}
         */
        getDistanceTo(point) {
            const diff = this.getDifferenceTo(point);
            return Math.sqrt(Math.pow(diff.x, 2) + Math.pow(diff.y, 2));
        }
        /**
         * Calculate the angle to another point
         *
         * @param {Point} point
         * @returns {Point}
         * @param {math.Vector2} point
         * @return {number}
         */
        getAngleTo(point) {
            const diff = this.getDifferenceTo(point);
            return Math.atan2(diff.y, diff.x);
        }
        /**
         * Return a simple object with x and y properties
         *
         * @returns {object}
         * @return {math.Vector2}
         */
        toVector2() {
            return new math.Vector2(this.x, this.y);
        }
    }
    geom.LazyPoint = LazyPoint;
    LazyPoint["__class"] = "geom.LazyPoint";
})(geom || (geom = {}));
(function (geom) {
    class CurveUtils {
        static conicTerms_$LI$() { if (CurveUtils.conicTerms == null) {
            CurveUtils.conicTerms = ["x" + math.Unicode.Superscript_2, "xy", "y" + math.Unicode.Superscript_2, "x", "y", ""];
        } return CurveUtils.conicTerms; }
        static circleTerms_$LI$() { if (CurveUtils.circleTerms == null) {
            CurveUtils.circleTerms = ["x" + math.Unicode.Superscript_2, "xy", "y" + math.Unicode.Superscript_2, "x", "y", ""];
        } return CurveUtils.circleTerms; }
        static lineTerms_$LI$() { if (CurveUtils.lineTerms == null) {
            CurveUtils.lineTerms = ["x", "y", ""];
        } return CurveUtils.lineTerms; }
        static GOLDEN_SECTION_$LI$() { if (CurveUtils.GOLDEN_SECTION == null) {
            CurveUtils.GOLDEN_SECTION = 0.5 * (3 - Math.sqrt(5));
        } return CurveUtils.GOLDEN_SECTION; }
        /**
         * retunrs non null array conatining points of intersection of two curves
         *
         * @param {geom.Curve2D} curve1
         * @param {geom.Curve2D} curve2
         * @return {math.Vector2[]} null or array containing ppoints of intersections
         * @param {math.Vector2} point
         */
        static getIntersections(curve1, curve2, point) {
            if (!curve1.isDefined() || !curve2.isDefined())
                return null;
            if ((curve1 != null && curve1 instanceof geom.Line2D) && (curve2 != null && curve2 instanceof geom.Line2D)) {
                return CurveUtils.LineLineIntersection$geom_Line2D$geom_Line2D(curve1, curve2);
            }
            if ((curve1 != null && curve1 instanceof geom.Circle2D) && (curve2 != null && curve2 instanceof geom.Circle2D)) {
                return CurveUtils.CircleCircleIntersection(curve1, curve2);
            }
            if ((curve1 != null && curve1 instanceof geom.Line2D) && (curve2 != null && curve2 instanceof geom.Circle2D)) {
                return CurveUtils.LineCircleIntersection(curve1, curve2);
            }
            if ((curve2 != null && curve2 instanceof geom.Line2D) && (curve1 != null && curve1 instanceof geom.Circle2D)) {
                return CurveUtils.LineCircleIntersection(curve2, curve1);
            }
            if ((curve1 != null && curve1 instanceof geom.FunctionExplicit2D) && (curve2 != null && curve2 instanceof geom.FunctionExplicit2D)) {
                return CurveUtils.FunctionFunctionIntersection(curve2, curve1, point);
            }
            if ((curve1 != null && curve1 instanceof geom.Curve2D) && (curve2 != null && curve2 instanceof geom.FunctionExplicit2D)) {
                return CurveUtils.CurveFunctionIntersection(curve1, curve2, point);
            }
            if ((curve2 != null && curve2 instanceof geom.Curve2D) && (curve1 != null && curve1 instanceof geom.FunctionExplicit2D)) {
                return CurveUtils.CurveFunctionIntersection(curve2, curve1, point);
            }
            if ((curve1 != null && curve1 instanceof geom.Conic2D) && (curve2 != null && curve2 instanceof geom.Conic2D)) {
                const c1 = curve1;
                const ts = c1.getIntersections(curve2);
                if (ts.length === 0)
                    return null;
                const pts = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(ts.length);
                for (let i = 0; i < ts.length; i++) {
                    pts[i] = c1.point(ts[i]);
                }
                return pts;
            }
            if ((curve1 != null && curve1 instanceof geom.Conic2D) && (curve2 != null && curve2 instanceof geom.Line2D)) {
                const c1 = curve1;
                const ts = c1.intersections(curve2);
                if (ts.length === 0)
                    return null;
                const pts = (new java.util.ArrayList());
                for (let i = 0; i < ts.length; i++) {
                    {
                        const p = c1.point(ts[i]);
                        if (curve2.isSnapped(p))
                            pts.add(p);
                    }
                    ;
                }
                if (pts.size() === 0)
                    return null;
                return pts.toArray([]);
            }
            if ((curve1 != null && curve1 instanceof geom.Line2D) && (curve2 != null && curve2 instanceof geom.Conic2D)) {
                const c1 = curve2;
                const ts = c1.intersections(curve1);
                if (ts.length === 0)
                    return null;
                const pts = (new java.util.ArrayList());
                for (let i = 0; i < ts.length; i++) {
                    {
                        const p = c1.point(ts[i]);
                        if (curve1.contains(p))
                            pts.add(p);
                    }
                    ;
                }
                if (pts.size() === 0)
                    return null;
                return pts.toArray([]);
            }
            if ((curve2 != null && curve2 instanceof geom.Curve2D) && (curve1 != null && curve1 instanceof geom.Curve2D)) {
                CurveUtils.point_$LI$().set$math_Vector2(point);
                return CurveUtils.curveCurveIntersection(curve2, curve1);
            }
            return null;
        }
        static LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(A, B, C, D) {
            const a = B.x * A.y - A.x * B.y;
            const b = D.x * C.y - C.x * D.y;
            const xa = B.x - A.x;
            const xb = D.x - C.x;
            const ya = B.y - A.y;
            const yb = D.y - C.y;
            const delta = (xa * yb - xb * ya);
            if (Math.abs(delta) < geom.Shape2D.ACCURACY)
                return null;
            return new math.Vector2((a * xb - b * xa) / delta, (a * yb - b * ya) / delta);
        }
        static LineLineIntersection(A, B, C, D) {
            if (((A != null && A instanceof math.Vector2) || A === null) && ((B != null && B instanceof math.Vector2) || B === null) && ((C != null && C instanceof math.Vector2) || C === null) && ((D != null && D instanceof math.Vector2) || D === null)) {
                return geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(A, B, C, D);
            }
            else if (((A != null && A instanceof geom.Line2D) || A === null) && ((B != null && B instanceof geom.Line2D) || B === null) && C === undefined && D === undefined) {
                return geom.CurveUtils.LineLineIntersection$geom_Line2D$geom_Line2D(A, B);
            }
            else
                throw new Error('invalid overload');
        }
        static LineLineIntersection$geom_Line2D$geom_Line2D(line1, line2) {
            const denom = line1.dx * line2.dy - line1.dy * line2.dx;
            if (Math.abs(denom) < 1.0E-9)
                return null;
            const t = ((line1.y0 - line2.y0) * line2.dx - (line1.x0 - line2.x0) * line2.dy) / denom;
            const pt = new math.Vector2(line1.x0 + t * line1.dx, line1.y0 + t * line1.dy);
            if (!line1.isSnapped(pt) || !line2.isSnapped(pt))
                return null;
            return [pt];
        }
        static CircleCircleIntersection(circle1, circle2) {
            const center1 = circle1.center();
            const center2 = circle2.center();
            const r1 = circle1.radius();
            const r2 = circle2.radius();
            const d = center1.distance$math_Vector2(center2);
            if (d < Math.abs(r1 - r2) || d > (r1 + r2))
                return null;
            const angle = center1.to$math_Vector2(center2).getAngleWithPositiveXAxis();
            const d1 = d / 2 + (r1 * r1 - r2 * r2) / (2 * d);
            const tmp = center1.sum$math_Vector2(math.Vector2.create(d1, angle));
            const h = Math.sqrt(r1 * r1 - d1 * d1);
            const intersections = [null, null];
            const p1 = tmp.sum$math_Vector2(math.Vector2.create(h, angle + Math.PI / 2));
            intersections[0] = circle1.isSnapped(p1) && circle1.isSnapped(p1) ? p1 : null;
            const p2 = tmp.sum$math_Vector2(math.Vector2.create(h, angle - Math.PI / 2));
            intersections[1] = circle1.isSnapped(p2) && circle1.isSnapped(p2) ? p2 : null;
            return intersections;
        }
        static LineCircleIntersection(line, circle) {
            const center = circle.center();
            const radius = circle.radius();
            if (CurveUtils.TMP_LINE == null)
                CurveUtils.TMP_LINE = new geom.Line2D();
            const fullline = CurveUtils.TMP_LINE;
            fullline.set$math_Vector2$math_Vector2(line.p1, line.p2);
            const t = fullline.t(center);
            const p = fullline.point(t);
            if (p == null)
                return null;
            const dist = p.distance$math_Vector2(center);
            if (Math.abs(dist - radius) < geom.Shape2D.ACCURACY) {
                return (line.contains(p) && circle.contains(p)) ? [p] : null;
            }
            else if (dist > radius) {
                return null;
            }
            else if (dist === radius) {
                return [p];
            }
            else {
                const angle = new math.Vector2(fullline.dx, fullline.dy).getAngleWithPositiveXAxis();
                const d2 = Math.sqrt(radius * radius - dist * dist);
                const p1 = p.sum$math_Vector2(math.Vector2.create(d2, angle + Math.PI));
                const p2 = p.sum$math_Vector2(math.Vector2.create(d2, angle));
                const pts = [null, null];
                pts[0] = (line.contains(p1) && circle.contains(p1)) ? p1 : null;
                pts[1] = (line.contains(p2) && circle.contains(p2)) ? p2 : null;
                return pts;
            }
        }
        static LineFunctionIntersection(line, _function, point) {
            return null;
        }
        static CircleFunctionIntersection(curve, _function, point) {
            return null;
        }
        static CurveFunctionIntersection(curve, _function, point) {
            const snap = 2 * geom.Shape2D.SNAP_DISTANCE;
            if (curve != null && curve instanceof geom.Line2D) {
                let x = javaemul.internal.DoubleHelper.NaN;
                const line = curve;
                const c = line.coeff();
                let f;
                if (c[1] === 0) {
                    x = line.x0;
                    CurveUtils.y = _function.getY(x);
                    if ( /* isNaN */isNaN(CurveUtils.y))
                        return null;
                    return [new math.Vector2(x, CurveUtils.y)];
                }
                else if (c[0] === 0 && c[2] === 0) {
                    f = _function;
                }
                else if (c[0] === 0) {
                    f = new geom.FunctionExplicit2D(_function.getExpression() + "+" + (c[2] / c[1]));
                }
                else {
                    f = new geom.FunctionExplicit2D(_function.getExpression() + "+" + (c[0] / c[1]) + "x+" + (c[2] / c[1]));
                }
                let y = Math.abs(f.getY(point.x)) / geom.Shape2D.ACCURACY;
                if (y < 0.01)
                    return [point];
                const range = Math.min(1, y / 100) * snap;
                let bracket;
                try {
                    bracket = CurveUtils.bracketForRoot(f, point.x, point.x - range, point.x + range, 1, 1, 20);
                    x = CurveUtils.getRootBrent(f, bracket[0], bracket[1]);
                }
                catch (e1) {
                    x = f.getCriticalPoint(point.x);
                }
                y = f.getY(x);
                if ( /* isNaN */isNaN(x) || /* isNaN */ isNaN(y) || Math.abs(y) > geom.Shape2D.ACCURACY * 100)
                    return null;
                return [new math.Vector2(x, _function.getY(x))];
            }
            let t = curve.t(point);
            let range = snap;
            if (curve != null && curve instanceof geom.Circle2D) {
                range = snap / curve.radius();
            }
            else if (curve != null && curve instanceof geom.Line2D) {
            }
            else {
                range = snap;
            }
            let i = 0;
            let b = t + range;
            if (b > curve.t1())
                b = curve.t1();
            let a = t - range;
            if (a < curve.t0())
                a = curve.t0();
            let dx = b - a;
            let dy = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
            let pa = curve.point(a);
            let px = curve.point(t);
            const maxIteration = 50;
            while ((i < maxIteration)) {
                {
                    if (dy < 1.0E-5 || dx < 1.0E-5) {
                        if (dy < 1.0E-9) {
                            return [px];
                        }
                    }
                    t = (a + b) / 2;
                    pa = curve.point(a);
                    px = curve.point(t);
                    if ((pa.y - _function.getY(pa.x)) * (px.y - _function.getY(px.x)) < 0) {
                        b = t;
                        dx = b - a;
                    }
                    else {
                        a = t;
                        dx = b - a;
                    }
                    dy = Math.abs(px.y - _function.getY(px.x));
                    i++;
                }
            }
            ;
            return null;
        }
        static FunctionFunctionIntersection(f1, f2, pt) {
            let y = Math.abs(f1.getY(pt.x) - f2.getY(pt.x)) / geom.Shape2D.ACCURACY;
            if (y < 0.01)
                return [pt];
            const f = new geom.FunctionExplicit2D(f1.getExpression() + "-(" + f2.getExpression() + ")");
            const range = Math.min(1, y / 100) * 2 * geom.Shape2D.SNAP_DISTANCE;
            let bracket;
            let x;
            try {
                bracket = CurveUtils.bracketForRoot(f, pt.x, pt.x - range, pt.x + range, 1, 1, 20);
                x = CurveUtils.getRootBrent(f, bracket[0], bracket[1]);
            }
            catch (e1) {
                x = f.getCriticalPoint(pt.x);
            }
            y = f.getY(x);
            if ( /* isNaN */isNaN(x) || /* isNaN */ isNaN(y) || Math.abs(y) > geom.Shape2D.ACCURACY * 100)
                return null;
            pt = new math.Vector2(x, f1.getY(x));
            return [pt];
        }
        static getRoot_Bisection(f, guess, range) {
            let x = guess;
            let b = guess + range;
            let a = guess - range;
            let dx = b - a;
            let sign1 = f.getY(a);
            let sign2 = f.getY(b);
            const accuracy = geom.Shape2D.ACCURACY / 10;
            if (Math.abs(sign1) < accuracy) {
                x = a;
            }
            else if (Math.abs(sign2) < accuracy) {
                x = b;
            }
            else if (sign1 * sign2 > 0) {
                x = CurveUtils.getRoot_Newton(f, x, b - a, false);
            }
            else {
                let i = 0;
                const maxIteration = 100;
                while ((i < maxIteration)) {
                    {
                        if (Math.abs(dx) < accuracy) {
                            x = (a + b) / 2;
                            break;
                        }
                        x = (a + b) / 2;
                        sign1 = f.getY(a);
                        sign2 = f.getY(x);
                        if (Math.abs(sign1) < accuracy) {
                            x = a;
                            break;
                        }
                        if (Math.abs(sign2) < accuracy) {
                            break;
                        }
                        if (sign1 * sign2 < 0) {
                            b = x;
                            dx = b - a;
                        }
                        else {
                            a = x;
                            dx = b - a;
                        }
                        i++;
                    }
                }
                ;
            }
            return x;
        }
        /**
         * Returns root or minima in neighbourhood of guess, Must check if returned value is a root
         * @param {geom.FunctionExplicit2D} f
         * @param {number} guess
         * @param {number} range
         * @return
         * @return {number}
         */
        static getRoot_RegulaFalsi(f, guess, range) {
            let X;
            let fX;
            let dX;
            let A;
            let fA;
            let dA;
            let B;
            let fB;
            let dB;
            A = guess - range;
            B = guess + range;
            let n = 200;
            let j = 0;
            fA = f.getY(A);
            fB = f.getY(B);
            X = guess;
            let accuracy = geom.Shape2D.ACCURACY / 100;
            if (fA * fB > 0) {
                accuracy = 1.0E-12;
                n = 500;
            }
            const h = accuracy;
            while ((B - A > accuracy && j < n)) {
                {
                    j++;
                    fA = f.getY(A);
                    dA = (f.getY(A + h) - f.getY(A)) / h;
                    if (Math.abs(fA) < accuracy && Math.abs(dA) < accuracy)
                        return A;
                    fB = f.getY(B);
                    dB = (f.getY(B) - f.getY(B - h)) / h;
                    if (Math.abs(fB) < accuracy || Math.abs(dB) < accuracy)
                        return B;
                    X = A + (B - A) * Math.abs(fA) / (Math.abs(fA) + Math.abs(fB));
                    fX = f.getY(X);
                    dX = (f.getY(X + h) - f.getY(X)) / h;
                    if (Math.abs(fX) < accuracy || Math.abs(dX) < accuracy)
                        return X;
                    if (fA * fX < 0 || dA * dX < 0) {
                        B = X;
                    }
                    else if (fX * fB < 0 || dX * dB < 0) {
                        A = X;
                    }
                }
            }
            ;
            return X;
        }
        static getRoot_Newton(f, guess, range, shifted) {
            if (!f.isValidExpr)
                return javaemul.internal.DoubleHelper.NaN;
            if ((guess > -0.2 && guess < 0.2) && shifted !== true) {
                const answer = CurveUtils.getRoot_Newton(f, (guess - 5), range, true);
                if ( /* isNaN */isNaN(answer))
                    return answer;
                else
                    return answer + 5;
            }
            const accuracy = 1.0E-15;
            if (range < 0.2)
                range = 1;
            const center = guess;
            let prev = guess;
            let j = 0;
            while ((prev > center - range && prev < center + range && j < 200)) {
                {
                    const xval = prev;
                    const answer = f.getY(shifted ? xval + 5 : xval);
                    if (answer > -accuracy && answer < accuracy) {
                        return prev;
                    }
                    const derivative = f.derivative(shifted ? xval + 5 : xval);
                    if ( /* isNaN */isNaN(derivative))
                        break;
                    prev = prev - answer / derivative;
                    j++;
                }
            }
            ;
            return javaemul.internal.DoubleHelper.NaN;
        }
        /**
         * Troublesome function to intersect two objects. This is done by projecting the intersection point to each of the
         * objects in turn.
         *
         * To speed up the convergence, a line intersection is computed, where the lines approximate the objects.
         * @param {geom.Curve2D} c1
         * @param {geom.Curve2D} c2
         * @return {math.Vector2[]}
         */
        static curveCurveIntersection(c1, c2) {
            let distold = CurveUtils.projectOnce(c1, c2);
            for (let k = 1; k < 3; k++) {
                {
                    for (let i = 0; i < 10; i++) {
                        {
                            const dist1 = CurveUtils.projectOnce(c1, c2);
                            if (dist1 >= distold && dist1 < 1.0E-4 && Math.abs(CurveUtils.point_$LI$().x) < 1.0E10 && Math.abs(CurveUtils.point_$LI$().y) < 1.0E10)
                                return [CurveUtils.point_$LI$()];
                            distold = dist1;
                            let a = (CurveUtils.x1 - CurveUtils.x);
                            let b = (CurveUtils.y1 - CurveUtils.y);
                            let s = Math.max(Math.abs(a), Math.abs(b));
                            if (Math.abs(s) > 1.0E-13)
                                a /= s;
                            b /= s;
                            let c = (CurveUtils.point_$LI$().x - CurveUtils.x1);
                            let d = (CurveUtils.point_$LI$().y - CurveUtils.y1);
                            s = Math.max(Math.abs(c), Math.abs(d));
                            if (Math.abs(s) > 1.0E-13)
                                c /= s;
                            d /= s;
                            const e = a * CurveUtils.x1 + b * CurveUtils.y1;
                            const f = c * CurveUtils.point_$LI$().x + d * CurveUtils.point_$LI$().y;
                            const det = a * d - c * b;
                            if (Math.abs(det) > 1.0E-13) {
                                const xn = (e * d - f * b) / det;
                                const yn = (a * f - c * e) / det;
                                const xold = CurveUtils.point_$LI$().x;
                                const yold = CurveUtils.point_$LI$().y;
                                CurveUtils.point_$LI$().set$double$double(xn, yn);
                                const dist2 = CurveUtils.projectOnce(c1, c2);
                                if (dist2 > dist1) {
                                    CurveUtils.point_$LI$().set$double$double(xold, yold);
                                }
                                else
                                    distold = dist2;
                            }
                        }
                        ;
                    }
                }
                ;
            }
            return null;
        }
        /**
         * Search for a zero inside the provided interval.
         * This implementation is based on the algorithm described at page 58 of
         * the book
         * <blockquote>
         * <b>Algorithms for Minimization Without Derivatives</b>,
         * <it>Richard P. Brent</it>,
         * Dover 0-486-41998-3
         * </blockquote>
         *
         * @param {number} lo Lower bound of the search interval.
         * @param {number} hi Higher bound of the search interval.
         * @param fLo Function value at the lower bound of the search interval.
         * @param fHi Function value at the higher bound of the search interval.
         * @return {number} the value where the function is zero.
         * @param {geom.FunctionExplicit2D} f
         * @private
         */
        static getRootBrent(f, lo, hi) {
            let a = lo;
            let fa = f.getY(a);
            let b = hi;
            let fb = f.getY(b);
            let c = a;
            let fc = fa;
            let d = b - a;
            let e = d;
            const t = geom.Shape2D.ACCURACY;
            const eps = geom.Shape2D.ACCURACY;
            while ((true)) {
                {
                    if (Math.abs(fc) < Math.abs(fb)) {
                        a = b;
                        b = c;
                        c = a;
                        fa = fb;
                        fb = fc;
                        fc = fa;
                    }
                    const tol = 2 * eps * Math.abs(b) + t;
                    const m = 0.5 * (c - b);
                    if (Math.abs(m) <= tol || Math.abs(fb) < 0) {
                        return b;
                    }
                    if (Math.abs(e) < tol || Math.abs(fa) <= Math.abs(fb)) {
                        d = m;
                        e = d;
                    }
                    else {
                        let s = fb / fa;
                        let p;
                        let q;
                        if (a === c) {
                            p = 2 * m * s;
                            q = 1 - s;
                        }
                        else {
                            q = fa / fc;
                            const r = fb / fc;
                            p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));
                            q = (q - 1) * (r - 1) * (s - 1);
                        }
                        if (p > 0) {
                            q = -q;
                        }
                        else {
                            p = -p;
                        }
                        s = e;
                        e = d;
                        if (p >= 1.5 * m * q - Math.abs(tol * q) || p >= Math.abs(0.5 * s * q)) {
                            d = m;
                            e = d;
                        }
                        else {
                            d = p / q;
                        }
                    }
                    a = b;
                    fa = fb;
                    if (Math.abs(d) > tol) {
                        b += d;
                    }
                    else if (m > 0) {
                        b += tol;
                    }
                    else {
                        b -= tol;
                    }
                    fb = f.getY(b);
                    if ((fb > 0 && fc > 0) || (fb <= 0 && fc <= 0)) {
                        c = a;
                        fc = fa;
                        d = b - a;
                        e = d;
                    }
                }
            }
            ;
        }
        /**
         * This method attempts to find two values a and b satisfying <ul>
         * <li> {@code lowerBound <= a < initial < b <= upperBound} </li>
         * <li> {@code f(a) * f(b) <= 0} </li>
         * </ul>
         * If {@code f} is continuous on {@code [a,b]}, this means that {@code a}
         * and {@code b} bracket a root of {@code f}.
         * <p>
         * The algorithm checks the sign of \( f(l_k) \) and \( f(u_k) \) for increasing
         * values of k, where \( l_k = max(lower, initial - \delta_k) \),
         * \( u_k = min(upper, initial + \delta_k) \), using recurrence
         * \( \delta_{k+1} = r \delta_k + q, \delta_0 = 0\) and starting search with \( k=1 \).
         * The algorithm stops when one of the following happens: <ul>
         * <li> at least one positive and one negative value have been found --  success!</li>
         * <li> both endpoints have reached their respective limits -- NoBracketingException </li>
         * <li> {@code maximumIterations} iterations elapse -- NoBracketingException </li></ul>
         * <p>
         * If different signs are found at first iteration ({@code k=1}), then the returned
         * interval will be \( [a, b] = [l_1, u_1] \). If different signs are found at a later
         * iteration {@code k>1}, then the returned interval will be either
         * \( [a, b] = [l_{k+1}, l_{k}] \) or \( [a, b] = [u_{k}, u_{k+1}] \). A root solver called
         * with these parameters will therefore start with the smallest bracketing interval known
         * at this step.
         * </p>
         * <p>
         * Interval expansion rate is tuned by changing the recurrence parameters {@code r} and
         * {@code q}. When the multiplicative factor {@code r} is set to 1, the sequence is a
         * simple arithmetic sequence with linear increase. When the multiplicative factor {@code r}
         * is larger than 1, the sequence has an asymptotically exponential rate. Note than the
         * additive parameter {@code q} should never be set to zero, otherwise the interval would
         * degenerate to the single initial point for all values of {@code k}.
         * </p>
         * <p>
         * As a rule of thumb, when the location of the root is expected to be approximately known
         * within some error margin, {@code r} should be set to 1 and {@code q} should be set to the
         * order of magnitude of the error margin. When the location of the root is really a wild guess,
         * then {@code r} should be set to a value larger than 1 (typically 2 to double the interval
         * length at each iteration) and {@code q} should be set according to half the initial
         * search interval length.
         * </p>
         * <p>
         * As an example, if we consider the trivial function {@code f(x) = 1 - x} and use
         * {@code initial = 4}, {@code r = 1}, {@code q = 2}, the algorithm will compute
         * {@code f(4-2) = f(2) = -1} and {@code f(4+2) = f(6) = -5} for {@code k = 1}, then
         * {@code f(4-4) = f(0) = +1} and {@code f(4+4) = f(8) = -7} for {@code k = 2}. Then it will
         * return the interval {@code [0, 2]} as the smallest one known to be bracketing the root.
         * As shown by this example, the initial value (here {@code 4}) may lie outside of the returned
         * bracketing interval.
         * </p>
         * @param function function to check
         * @param {number} initial Initial midpoint of interval being expanded to
         * bracket a root.
         * @param {number} lowerBound Lower bound (a is never lower than this value).
         * @param {number} upperBound Upper bound (b never is greater than this
         * value).
         * @param {number} q additive offset used to compute bounds sequence (must be strictly positive)
         * @param {number} r multiplicative factor used to compute bounds sequence
         * @param {number} maximumIterations Maximum number of iterations to perform
         * @return {double[]} a two element array holding the bracketing values.
         * @exception NoBracketingException if function cannot be bracketed in the search interval
         * @param {geom.FunctionExplicit2D} _function
         */
        static bracketForRoot(_function, initial, lowerBound, upperBound, q, r, maximumIterations) {
            let a = initial;
            let b = initial;
            let fa = javaemul.internal.DoubleHelper.NaN;
            let fb = javaemul.internal.DoubleHelper.NaN;
            let delta = 0;
            for (let numIterations = 0; (numIterations < maximumIterations) && (a > lowerBound || b < upperBound); ++numIterations) {
                {
                    const previousA = a;
                    const previousFa = fa;
                    const previousB = b;
                    const previousFb = fb;
                    delta = r * delta + q;
                    a = Math.max(initial - delta, lowerBound);
                    b = Math.min(initial + delta, upperBound);
                    fa = _function.getY(a);
                    fb = _function.getY(b);
                    if (numIterations === 0) {
                        if (fa * fb <= 0) {
                            return [a, b];
                        }
                    }
                    else {
                        if (fa * previousFa <= 0) {
                            return [a, previousA];
                        }
                        else if (fb * previousFb <= 0) {
                            return [previousB, b];
                        }
                    }
                }
                ;
            }
            throw new CurveUtils.NoBracketingException(a, b, fa, fb);
        }
        /**
         * Search new points that bracket a local optimum of the function.
         *
         * @param {geom.FunctionExplicit2D} func Function whose optimum should be bracketed.
         * @param goal {@link GoalType}.
         * @param {number} xA Initial point.
         * @param {number} xB Initial point.
         * @throws TooManyEvaluationsException if the maximum number of evaluations
         * is exceeded.
         * @param {boolean} isMinim
         */
        search(func, isMinim, xA, xB) {
            let lo;
            let hi;
            let mid;
            let fLo;
            let fHi;
            let fMid;
            const growLimit = 1;
            let fA = func.getY(xA);
            let fB = func.getY(xB);
            if (isMinim ? fA < fB : fA > fB) {
                let tmp = xA;
                xA = xB;
                xB = tmp;
                tmp = fA;
                fA = fB;
                fB = tmp;
            }
            let xC = xB + CurveUtils.GOLD * (xB - xA);
            let fC = func.getY(xC);
            while ((isMinim ? fC < fB : fC > fB)) {
                {
                    const tmp1 = (xB - xA) * (fB - fC);
                    const tmp2 = (xB - xC) * (fB - fA);
                    const val = tmp2 - tmp1;
                    const denom = Math.abs(val) < CurveUtils.EPS_MIN ? 2 * CurveUtils.EPS_MIN : 2 * val;
                    let w = xB - ((xB - xC) * tmp2 - (xB - xA) * tmp1) / denom;
                    const wLim = xB + growLimit * (xC - xB);
                    let fW;
                    if ((w - xC) * (xB - w) > 0) {
                        fW = func.getY(w);
                        if (isMinim ? fW < fC : fW > fC) {
                            xA = xB;
                            xB = w;
                            fA = fB;
                            fB = fW;
                            break;
                        }
                        else if (isMinim ? fW > fB : fW < fB) {
                            xC = w;
                            fC = fW;
                            break;
                        }
                        w = xC + CurveUtils.GOLD * (xC - xB);
                        fW = func.getY(w);
                    }
                    else if ((w - wLim) * (wLim - xC) >= 0) {
                        w = wLim;
                        fW = func.getY(w);
                    }
                    else if ((w - wLim) * (xC - w) > 0) {
                        fW = func.getY(w);
                        if (isMinim ? fW < fC : fW > fC) {
                            xB = xC;
                            xC = w;
                            w = xC + CurveUtils.GOLD * (xC - xB);
                            fB = fC;
                            fC = fW;
                            fW = func.getY(w);
                        }
                    }
                    else {
                        w = xC + CurveUtils.GOLD * (xC - xB);
                        fW = func.getY(w);
                    }
                    xA = xB;
                    fA = fB;
                    xB = xC;
                    fB = fC;
                    xC = w;
                    fC = fW;
                }
            }
            ;
            lo = xA;
            fLo = fA;
            mid = xB;
            fMid = fB;
            hi = xC;
            fHi = fC;
            if (lo > hi) {
                let tmp = lo;
                lo = hi;
                hi = tmp;
                tmp = fLo;
                fLo = fHi;
                fHi = tmp;
            }
        }
        static findMinimaBrent(f, isMinim, lo, hi) {
            const mid = 0.5 * (lo + hi);
            let a;
            let b;
            if (lo < hi) {
                a = lo;
                b = hi;
            }
            else {
                a = hi;
                b = lo;
            }
            let x = mid;
            let v = x;
            let w = x;
            let d = 0;
            let e = 0;
            let fx = f.getY(x);
            if (!isMinim) {
                fx = -fx;
            }
            let fv = fx;
            let fw = fx;
            let previous = null;
            let current = new math.Vector2(x, isMinim ? fx : -fx);
            let best = current;
            const ACCURACY = geom.Shape2D.ACCURACY / 1000;
            let iter = 0;
            while ((true)) {
                {
                    const m = 0.5 * (a + b);
                    const tol1 = ACCURACY * Math.abs(x) + ACCURACY;
                    const tol2 = 2 * tol1;
                    const stop = Math.abs(x - m) <= tol2 - 0.5 * (b - a);
                    if (!stop) {
                        let p = 0;
                        let q = 0;
                        let r = 0;
                        let u = 0;
                        if (Math.abs(e) > tol1) {
                            r = (x - w) * (fx - fv);
                            q = (x - v) * (fx - fw);
                            p = (x - v) * q - (x - w) * r;
                            q = 2 * (q - r);
                            if (q > 0) {
                                p = -p;
                            }
                            else {
                                q = -q;
                            }
                            r = e;
                            e = d;
                            if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {
                                d = p / q;
                                u = x + d;
                                if (u - a < tol2 || b - u < tol2) {
                                    if (x <= m) {
                                        d = tol1;
                                    }
                                    else {
                                        d = -tol1;
                                    }
                                }
                            }
                            else {
                                if (x < m) {
                                    e = b - x;
                                }
                                else {
                                    e = a - x;
                                }
                                d = CurveUtils.GOLDEN_SECTION_$LI$() * e;
                            }
                        }
                        else {
                            if (x < m) {
                                e = b - x;
                            }
                            else {
                                e = a - x;
                            }
                            d = CurveUtils.GOLDEN_SECTION_$LI$() * e;
                        }
                        if (Math.abs(d) < tol1) {
                            if (d >= 0) {
                                u = x + tol1;
                            }
                            else {
                                u = x - tol1;
                            }
                        }
                        else {
                            u = x + d;
                        }
                        let fu = f.getY(u);
                        if (!isMinim) {
                            fu = -fu;
                        }
                        previous = current;
                        current = new math.Vector2(u, isMinim ? fu : -fu);
                        best = CurveUtils.best(best, CurveUtils.best(previous, current, isMinim), isMinim);
                        if (fu <= fx) {
                            if (u < x) {
                                b = x;
                            }
                            else {
                                a = x;
                            }
                            v = w;
                            fv = fw;
                            w = x;
                            fw = fx;
                            x = u;
                            fx = fu;
                        }
                        else {
                            if (u < x) {
                                a = u;
                            }
                            else {
                                b = u;
                            }
                            if (fu <= fw || Math.abs(w - x) < ACCURACY) {
                                v = w;
                                fv = fw;
                                w = u;
                                fw = fu;
                            }
                            else if (fu <= fv || Math.abs(v - x) < ACCURACY || Math.abs(v - w) < ACCURACY) {
                                v = u;
                                fv = fu;
                            }
                        }
                    }
                    else {
                        return CurveUtils.best(best, CurveUtils.best(previous, current, isMinim), isMinim);
                    }
                    ++iter;
                }
            }
            ;
        }
        /**
         * Selects the best of two points.
         *
         * @param {math.Vector2} a Point and value.
         * @param {math.Vector2} b Point and value.
         * @param {boolean} isMinim {@code true} if the selected point must be the one with
         * the lowest value.
         * @return {math.Vector2} the best point, or {@code null} if {@code a} and {@code b} are
         * both {@code null}. When {@code a} and {@code b} have the same function
         * value, {@code a} is returned.
         * @private
         */
        static best(a, b, isMinim) {
            if (a == null) {
                return b;
            }
            if (b == null) {
                return a;
            }
            if (isMinim) {
                return a.y <= b.y ? a : b;
            }
            else {
                return a.y >= b.y ? a : b;
            }
        }
        /**
         * Check whether the interval bounds bracket a root. That is, if the
         * values at the endpoints are not equal to zero, then the function takes
         * opposite signs at the endpoints.
         *
         * @param FunctionExplicit2D Function.
         * @param {number} lower Lower endpoint.
         * @param {number} upper Upper endpoint.
         * @return {boolean} {@code true} if the function values have opposite signs at the
         * given points.
         * @param {geom.FunctionExplicit2D} _function
         */
        static isBracketing(_function, lower, upper) {
            const fLo = _function.getY(lower);
            const fHi = _function.getY(upper);
            return (fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0);
        }
        static point_$LI$() { if (CurveUtils.point == null) {
            CurveUtils.point = new math.Vector2();
        } return CurveUtils.point; }
        static projectOnce(c1, c2) {
            let pt;
            CurveUtils.x = CurveUtils.point_$LI$().x;
            CurveUtils.y = CurveUtils.point_$LI$().y;
            pt = CurveUtils.project(c1, CurveUtils.point_$LI$());
            if (pt != null)
                CurveUtils.point_$LI$().set$math_Vector2(pt);
            const dist = Math.max(Math.abs(CurveUtils.point_$LI$().x - CurveUtils.x), Math.abs(CurveUtils.point_$LI$().y - CurveUtils.y));
            CurveUtils.x1 = CurveUtils.point_$LI$().x;
            CurveUtils.y1 = CurveUtils.point_$LI$().y;
            pt = CurveUtils.project(c2, CurveUtils.point_$LI$());
            if (pt != null)
                CurveUtils.point_$LI$().set$math_Vector2(pt);
            const dist1 = Math.max(Math.abs(CurveUtils.point_$LI$().x - CurveUtils.x1), Math.abs(CurveUtils.point_$LI$().y - CurveUtils.y1));
            return Math.max(dist, dist1);
        }
        static project(c, p) {
            const t = c.t(p);
            return c.point(t);
        }
        /**
         *
         * @param {number} edgeLeft Define the x/y clipping values for the border.
         * @param {number} edgeRight
         * @param {number} edgeBottom
         * @param {number} edgeTop
         * @param {number} x0src Define the start point of the line.
         * @param {number} y0src
         * @param {number} x1src Define the end point of the line.
         * @param {number} y1src
         * @param {math.Vector2} clipP1 Output for first clippedPoint
         * @param {math.Vector2} clipP2 Output for second clippedPoint
         * @return {boolean} true if line is clipped
         */
        static clipLineWithRect(edgeLeft, edgeRight, edgeBottom, edgeTop, x0src, y0src, x1src, y1src, clipP1, clipP2) {
            let t0 = 0.0;
            let t1 = 1.0;
            const xdelta = x1src - x0src;
            const ydelta = y1src - y0src;
            let p = 0;
            let q = 0;
            let r = 0;
            for (let edge = 0; edge < 4; edge++) {
                {
                    if (edge === 0) {
                        p = -xdelta;
                        q = -(edgeLeft - x0src);
                    }
                    if (edge === 1) {
                        p = xdelta;
                        q = (edgeRight - x0src);
                    }
                    if (edge === 2) {
                        p = -ydelta;
                        q = -(edgeBottom - y0src);
                    }
                    if (edge === 3) {
                        p = ydelta;
                        q = (edgeTop - y0src);
                    }
                    r = q / p;
                    if (p === 0 && q < 0)
                        return false;
                    if (p < 0) {
                        if (r > t1)
                            return false;
                        else if (r > t0)
                            t0 = r;
                    }
                    else if (p > 0) {
                        if (r < t0)
                            return false;
                        else if (r < t1)
                            t1 = r;
                    }
                }
                ;
            }
            clipP1.set$double$double(x0src + t0 * xdelta, y0src + t0 * ydelta);
            clipP2.set$double$double(x0src + t1 * xdelta, y0src + t1 * ydelta);
            return true;
        }
        /**
         * Returns the point on the given line segment closest to the given point.
         * <p>
         * If the point closest to the given point is on the line created by the
         * given line segment, but is not on the line segment then either of the segments
         * end points will be returned.
         * <p>
         * Assumes all points are in world space.
         * @param {math.Vector2} point the point
         * @param {math.Vector2} linePoint1 the first point of the line
         * @param {math.Vector2} linePoint2 the second point of the line
         * @return {math.Vector2} {@link Vector2}
         * @throws NullPointerException if point, linePoint1, or linePoint2 is null
         */
        static getPointOnSegmentClosestToPoint(point, linePoint1, linePoint2) {
            const p1ToP = point.difference$math_Vector2(linePoint1);
            const line = linePoint2.difference$math_Vector2(linePoint1);
            const ab2 = line.dot$math_Vector2(line);
            const ap_ab = p1ToP.dot$math_Vector2(line);
            if (ab2 <= framework.Preferences.EPSILON)
                return linePoint1.copy();
            let t = ap_ab / ab2;
            t = math.MathUtils.clamp$double$double$double(t, 0.0, 1.0);
            return line.multiply(t).add$math_Vector2(linePoint1);
        }
    }
    /**
     * Golden section.
     */
    CurveUtils.GOLD = 1.618034;
    /**
     * Tolerance to avoid division by zero.
     */
    CurveUtils.EPS_MIN = 1.0E-21;
    CurveUtils.TMP_LINE = null;
    CurveUtils.x = 0;
    CurveUtils.y = 0;
    CurveUtils.x1 = 0;
    CurveUtils.y1 = 0;
    geom.CurveUtils = CurveUtils;
    CurveUtils["__class"] = "geom.CurveUtils";
    (function (CurveUtils) {
        /**
         * Construct the exception.
         *
         * @param {number} lo Lower end of the interval.
         * @param {number} hi Higher end of the interval.
         * @param {number} fLo Value at lower end of the interval.
         * @param {number} fHi Value at higher end of the interval.
         * @class
         * @extends java.lang.Exception
         */
        class NoBracketingException extends Error {
            constructor(lo, hi, fLo, fHi) {
                super();
                Object.setPrototypeOf(this, NoBracketingException.prototype);
                if (this.lo === undefined) {
                    this.lo = 0;
                }
                if (this.hi === undefined) {
                    this.hi = 0;
                }
                if (this.fLo === undefined) {
                    this.fLo = 0;
                }
                if (this.fHi === undefined) {
                    this.fHi = 0;
                }
                this.lo = lo;
                this.hi = hi;
                this.fLo = fLo;
                this.fHi = fHi;
            }
            /**
             * Get the lower end of the interval.
             *
             * @return {number} the lower end.
             */
            getLo() {
                return this.lo;
            }
            /**
             * Get the higher end of the interval.
             *
             * @return {number} the higher end.
             */
            getHi() {
                return this.hi;
            }
            /**
             * Get the value at the lower end of the interval.
             *
             * @return {number} the value at the lower end.
             */
            getFLo() {
                return this.fLo;
            }
            /**
             * Get the value at the higher end of the interval.
             *
             * @return {number} the value at the higher end.
             */
            getFHi() {
                return this.fHi;
            }
        }
        /**
         * Serializable version Id.
         */
        NoBracketingException.serialVersionUID = -3629324471511904459;
        CurveUtils.NoBracketingException = NoBracketingException;
        NoBracketingException["__class"] = "geom.CurveUtils.NoBracketingException";
        NoBracketingException["__interfaces"] = ["java.io.Serializable"];
    })(CurveUtils = geom.CurveUtils || (geom.CurveUtils = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalImage extends math.Vector2 {
            constructor(device, source, pt, brightness, real) {
                super();
                if (this.device === undefined) {
                    this.device = null;
                }
                if (this.source === undefined) {
                    this.source = null;
                }
                this.rayCount = 0;
                if (this.real === undefined) {
                    this.real = false;
                }
                this.brightness = 0;
                this.device = device;
                this.source = source;
                this.brightness = Math.fround(brightness);
                this.real = real;
                this.rayCount = 1;
                this.set$math_Vector2(pt);
            }
            reset() {
                this.device = null;
                this.source = null;
                this.rayCount = 0;
                this.brightness = 0;
            }
            updatePoint(brightness) {
                this.brightness += brightness;
                this.brightness = math.MathUtils.clamp$float$float$float(this.brightness, 0, 1);
                this.rayCount++;
            }
        }
        optics.OpticalImage = OpticalImage;
        OpticalImage["__class"] = "geom.optics.OpticalImage";
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (framework) {
    var input;
    (function (input) {
        class KeyBoardControlsHandler extends framework.input.AbstractKeyboardInputHandler {
            constructor(app) {
                super(app);
            }
            /**
             *
             * @return {boolean}
             */
            isActive() {
                return true;
            }
            onKeyPressed(keyCode, key) {
                switch ((key)) {
                    case "a":
                        break;
                    case "s":
                        break;
                    case "d":
                        break;
                    case "f":
                        break;
                    case "g":
                    case "q":
                        break;
                }
                if (keyCode === 32) {
                    if (this.app.isPaused()) {
                        this.app.resume();
                    }
                    else {
                        this.app.pause();
                    }
                }
            }
            onKeyReleased(keyCode, key) {
            }
        }
        input.KeyBoardControlsHandler = KeyBoardControlsHandler;
        KeyBoardControlsHandler["__class"] = "framework.input.KeyBoardControlsHandler";
        KeyBoardControlsHandler["__interfaces"] = ["framework.input.InputHandler"];
    })(input = framework.input || (framework.input = {}));
})(framework || (framework = {}));
(function (framework) {
    var input;
    (function (input) {
        class KeyBoardCameraHandler extends framework.input.AbstractKeyboardInputHandler {
            constructor(app) {
                super(app);
                this.delta = 1;
            }
            /**
             *
             * @return {boolean}
             */
            isActive() {
                return true;
            }
            onKeyPressed(keyCode, key) {
                this.app.shapesManager.handlekeyBoard(1, keyCode, key);
            }
            onKeyReleased(keyCode, key) {
                this.app.shapesManager.handlekeyBoard(2, keyCode, key);
            }
        }
        input.KeyBoardCameraHandler = KeyBoardCameraHandler;
        KeyBoardCameraHandler["__class"] = "framework.input.KeyBoardCameraHandler";
        KeyBoardCameraHandler["__interfaces"] = ["framework.input.InputHandler"];
    })(input = framework.input || (framework.input = {}));
})(framework || (framework = {}));
(function (framework) {
    var input;
    (function (input) {
        class MousePickingInputHandler extends framework.input.AbstractMouseInputHandler {
            constructor(app) {
                super(app);
                if (this.shapesManager === undefined) {
                    this.shapesManager = null;
                }
                this.active = false;
                this.shapesManager = app.shapesManager;
            }
            /**
             *
             * @param {number} button
             * @param {math.Vector2} point
             */
            onMousePressed(button, point) {
                super.onMousePressed(button, point);
                const p = this.camera.toWorldCoordinates(point.x, point.y);
                this.shapesManager.handleMouse(1, p);
            }
            /**
             *
             * @param {number} button
             * @param {math.Vector2} start
             * @param {math.Vector2} current
             */
            onMouseDrag(button, start, current) {
                super.onMouseDrag(button, start, current);
                const p = this.camera.toWorldCoordinates(current.x, current.y);
                this.shapesManager.handleMouse(1, p);
            }
            onMouseClick(button, point) {
                super.onMouseClick(button, point);
                const p = this.camera.toWorldCoordinates(point.x, point.y);
                this.shapesManager.handleMouse(3, p);
            }
            onMouseMove(button, point) {
                super.onMouseMove(button, point);
                const p = this.camera.toWorldCoordinates(point.x, point.y);
                this.shapesManager.handleMouse(4, p);
            }
            /**
             *
             * @param {number} button
             * @param {math.Vector2} point
             */
            onMouseRelease(button, point) {
                super.onMouseRelease(button, point);
                const p = this.camera.toWorldCoordinates(point.x, point.y);
                this.shapesManager.handleMouse(2, p);
            }
            /**
             *
             * @param {boolean} flag
             */
            setEnabled(flag) {
                super.setEnabled(flag);
            }
            /**
             *
             * @return {boolean}
             */
            isActive() {
                return this.shapesManager.getSelectedShape() != null;
            }
            /**
             *
             */
            uninstall() {
                super.uninstall();
            }
            onMouseWheel(rotation, pt) {
                pt = this.camera.toWorldCoordinates(pt.x, pt.y);
                this.camera.zoomToAboutPoint(this.camera.getZoom() * Math.pow(1.001, rotation), pt);
            }
        }
        input.MousePickingInputHandler = MousePickingInputHandler;
        MousePickingInputHandler["__class"] = "framework.input.MousePickingInputHandler";
        MousePickingInputHandler["__interfaces"] = ["framework.input.InputHandler"];
    })(input = framework.input || (framework.input = {}));
})(framework || (framework = {}));
(function (framework) {
    var input;
    (function (input) {
        class MousePanningInputHandler extends framework.input.AbstractMouseInputHandler {
            constructor(app) {
                super(app);
                if (this.panning === undefined) {
                    this.panning = false;
                }
                if (this.start === undefined) {
                    this.start = null;
                }
                this.panning = false;
            }
            /**
             *
             * @param {number} button
             * @param {math.Vector2} point
             */
            onMousePressed(button, point) {
                super.onMousePressed(button, point);
                this.handleMouseStart(point);
            }
            /**
             *
             * @param {number} button
             * @param {math.Vector2} start
             * @param {math.Vector2} current
             */
            onMouseDrag(button, start, current) {
                super.onMouseDrag(button, start, current);
                this.handleMouseDrag(current);
            }
            /**
             *
             * @param {number} button
             * @param {math.Vector2} current
             */
            onMouseRelease(button, current) {
                super.onMouseRelease(button, current);
                this.clearPanningState();
            }
            onMouseWheel(rotation, pt) {
                pt = this.camera.toWorldCoordinates(pt.x, pt.y);
                this.camera.zoomToAboutPoint(this.camera.getZoom() * Math.pow(1.001, rotation), pt);
            }
            /**
             *
             * @param {boolean} flag
             */
            setEnabled(flag) {
                super.setEnabled(flag);
                if (!flag) {
                    this.clearPanningState();
                }
            }
            /**
             *
             * @return {boolean}
             */
            isActive() {
                return this.panning;
            }
            /**
             *
             */
            uninstall() {
                super.uninstall();
                this.clearPanningState();
            }
            /*private*/ handleMouseStart(start) {
                this.panning = true;
                this.start = start;
                return true;
            }
            /*private*/ handleMouseDrag(current) {
                this.panning = true;
                const dx = current.x - this.start.x;
                const dy = current.y - this.start.y;
                this.camera.translate(dx, -dy);
                this.start = current;
                return true;
            }
            /*private*/ clearPanningState() {
                this.panning = false;
                this.start = null;
            }
        }
        input.MousePanningInputHandler = MousePanningInputHandler;
        MousePanningInputHandler["__class"] = "framework.input.MousePanningInputHandler";
        MousePanningInputHandler["__interfaces"] = ["framework.input.InputHandler"];
    })(input = framework.input || (framework.input = {}));
})(framework || (framework = {}));
(function (geom) {
    /**
     * Action to store information about moving (translating) the world.
     * @param {framework.App} app
     * @class
     * @extends framework.input.AbstractMouseInputHandler
     */
    class AddShapeAction extends framework.input.AbstractMouseInputHandler {
        constructor(app) {
            super(app);
            if (this.elementClass === undefined) {
                this.elementClass = null;
            }
            this.parentClasses = null;
            if (this.arrayObjects === undefined) {
                this.arrayObjects = null;
            }
            if (this.paramClasses === undefined) {
                this.paramClasses = null;
            }
            if (this.param === undefined) {
                this.param = null;
            }
            if (this.pathInfo === undefined) {
                this.pathInfo = null;
            }
            this.step = 1;
            this.instructions = ["no instruction"];
            this.vertices = (new java.util.ArrayList());
            if (this.name === undefined) {
                this.name = null;
            }
            if (this.shapesManager === undefined) {
                this.shapesManager = null;
            }
            this.cursor = "default";
            if (this.active === undefined) {
                this.active = false;
            }
            this.mousePressedPoint = null;
            this.prevMousepos = null;
            this.shapesManager = app.shapesManager;
            AddShapeAction.tmpColor = framework.Preferences.getRandomColor();
            this.active = false;
        }
        begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_String_A(name, elementClass, parentClasses, instructions) {
            this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A(name, elementClass, parentClasses, [], []);
        }
        begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A(name, elementClass, parentClasses, options, instructions) {
            this.end();
            this.name = name;
            this.elementClass = elementClass;
            this.parentClasses = parentClasses;
            this.instructions = instructions;
            if (options == null)
                options = [];
            const parentNumber = parentClasses.length;
            const optionNumber = options.length;
            this.param = (s => { let a = []; while (s-- > 0)
                a.push(null); return a; })(parentNumber + optionNumber);
            this.paramClasses = (s => { let a = []; while (s-- > 0)
                a.push(null); return a; })(parentNumber + optionNumber);
            for (let i = 0; i < parentNumber; i++) {
                this.paramClasses[i] = AddShapeAction.typeClass(parentClasses[i]);
            }
            for (let i = 0; i < optionNumber; i++) {
                {
                    this.param[parentNumber + i] = options[i];
                    this.paramClasses[parentNumber + i] = AddShapeAction.typeClass(options[i].constructor);
                }
                ;
            }
            if (parentClasses.length > 0)
                this.arrayObjects = (new java.util.ArrayList());
            this.begin$();
        }
        /**
         * @param {string} name the key to retrieve this tool
         * @param {java.lang.Class} elementClass class of the object to create
         * @param classes classes of objects which define the created object
         * @param parameters optional parameters for created object
         * @param {java.lang.Class<? extends geom.Shape2D>[]} parentClasses
         * @param {java.lang.Object[]} options
         * @param {java.lang.String[]} instructions
         */
        begin(name, elementClass, parentClasses, options, instructions) {
            if (((typeof name === 'string') || name === null) && ((elementClass != null && (elementClass["__class"] != null || ((t) => { try {
                new t;
                return true;
            }
            catch (_a) {
                return false;
            } })(elementClass))) || elementClass === null) && ((parentClasses != null && parentClasses instanceof Array && (parentClasses.length == 0 || parentClasses[0] == null || (parentClasses[0] != null && (parentClasses[0]["__class"] != null || ((t) => { try {
                new t;
                return true;
            }
            catch (_a) {
                return false;
            } })(parentClasses[0]))))) || parentClasses === null) && ((options != null && options instanceof Array && (options.length == 0 || options[0] == null || (options[0] != null))) || options === null) && ((instructions != null && instructions instanceof Array && (instructions.length == 0 || instructions[0] == null || (typeof instructions[0] === 'string'))) || instructions === null)) {
                return this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A(name, elementClass, parentClasses, options, instructions);
            }
            else if (((typeof name === 'string') || name === null) && ((elementClass != null && (elementClass["__class"] != null || ((t) => { try {
                new t;
                return true;
            }
            catch (_a) {
                return false;
            } })(elementClass))) || elementClass === null) && ((parentClasses != null && parentClasses instanceof Array && (parentClasses.length == 0 || parentClasses[0] == null || (parentClasses[0] != null && (parentClasses[0]["__class"] != null || ((t) => { try {
                new t;
                return true;
            }
            catch (_a) {
                return false;
            } })(parentClasses[0]))))) || parentClasses === null) && ((options != null && options instanceof Array && (options.length == 0 || options[0] == null || (typeof options[0] === 'string'))) || options === null) && instructions === undefined) {
                return this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_String_A(name, elementClass, parentClasses, options);
            }
            else if (name === undefined && elementClass === undefined && parentClasses === undefined && options === undefined && instructions === undefined) {
                return this.begin$();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Transform a class such as Integer.class into the class of the
         * corresponding primitive type: int.class.
         *
         * @param {java.lang.Class} aClass
         * @return
         * @return {java.lang.Class}
         * @private
         */
        /*private*/ static typeClass(aClass) {
            let theClass = aClass;
            if (theClass === Number)
                theClass = Number;
            if (theClass === Number)
                theClass = Number;
            if (theClass === Boolean)
                theClass = Boolean;
            return theClass;
        }
        begin$() {
            this.active = true;
            this.step = 1;
            this.vertices.clear();
            this.pathInfo = "";
            if (this.arrayObjects != null)
                this.arrayObjects.clear();
            if (this.paramClasses != null)
                this.param = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(this.paramClasses.length);
            this.shapesManager.previewShape = null;
            this.shapesManager.tempShape = null;
            this.shapesManager.setToolTip(null, null);
            this.app.setStatusLine(this.getInstruction());
            AddShapeAction.tmpColor = framework.Preferences.getRandomColor();
        }
        /**
         *
         * @param {number} button
         * @param {math.Vector2} point
         */
        onMousePressed(button, point) {
            super.onMousePressed(button, point);
            const p = this.camera.toWorldCoordinates(point.x, point.y);
            if (this.isActive())
                this.mouseMoved(p, button === 1, false);
        }
        /**
         *
         * @param {number} button
         * @param {math.Vector2} start
         * @param {math.Vector2} current
         */
        onMouseDrag(button, start, current) {
            super.onMouseDrag(button, start, current);
            const p = this.camera.toWorldCoordinates(current.x, current.y);
            if (this.isActive())
                this.mouseMoved(p, button === 1, false);
        }
        onMouseClick(button, point) {
            super.onMouseClick(button, point);
            const p = this.camera.toWorldCoordinates(point.x, point.y);
            if (this.isActive())
                this.mouseClicked(p, button === 1, false);
        }
        onMouseMove(button, point) {
            super.onMouseMove(button, point);
            const p = this.camera.toWorldCoordinates(point.x, point.y);
            if (this.isActive())
                this.mouseMoved(p, button === 1, false);
        }
        /**
         *
         * @param {number} button
         * @param {math.Vector2} point
         */
        onMouseRelease(button, point) {
            super.onMouseRelease(button, point);
            const p = this.camera.toWorldCoordinates(point.x, point.y);
        }
        /**
         *
         * @param {boolean} flag
         */
        setEnabled(flag) {
            super.setEnabled(flag);
        }
        /**
         *
         * @return {boolean}
         */
        isActive() {
            return this.active && this.paramClasses != null;
        }
        /**
         * Updates the action whenever mouse moves with the new begin position in world coordinates.
         * <p>
         * This is used if the action is carried out over a time period in which the
         * user would like visual feedback.
         * @param {math.Vector2} mousePosition the new begin position in world coordinates
         * @param {boolean} shiftPressed
         * @param true if mouse d pressed during move
         * @param {boolean} pressed
         */
        mouseMoved(mousePosition, pressed, shiftPressed) {
            let dynamic = null;
            let class1 = this.paramClasses[this.step - 1];
            if (class1 === geom.ShapeArray)
                class1 = geom.ShapeArray.clazz_$LI$();
            if (!framework.ClassUtils.isAssignableFrom(geom.Shape2D, class1))
                return;
            const shapeClass = class1;
            const snappedShape = this.shapesManager.getSnappedShape(mousePosition, shapeClass);
            if (snappedShape != null) {
                this.shapesManager.setToolTip("this " + snappedShape.getName(), mousePosition);
                this.shapesManager.previewShape = null;
                dynamic = snappedShape;
            }
            else {
                if (AddShapeAction.canCreateNewFreePoint(shapeClass)) {
                    if (shiftPressed) {
                        if (this.prevMousepos != null) {
                            const dv = mousePosition.difference$math_Vector2(this.prevMousepos);
                            if (Math.abs(dv.x) > Math.abs(dv.y)) {
                                dv.y = 0;
                            }
                            else {
                                dv.x = 0;
                            }
                            mousePosition.set$double$double(this.prevMousepos.x + dv.x, this.prevMousepos.y + dv.y);
                        }
                    }
                    dynamic = this.shapesManager.createNewDynamicPoint(mousePosition);
                    this.shapesManager.previewShape = dynamic;
                    if (this.shapesManager.previewShape.drawColor == null)
                        this.shapesManager.previewShape.drawColor = AddShapeAction.tmpColor.copy();
                    this.shapesManager.setToolTip(this.shapesManager.getMouseLabel(dynamic), mousePosition);
                }
                else {
                    this.shapesManager.setToolTip("", mousePosition);
                }
            }
            if (this.step === this.parentClasses.length && framework.ClassUtils.isAssignableFrom(geom.Shape2D, this.elementClass) && dynamic != null) {
                if (this.parentClasses[this.step - 1] === geom.ShapeArray) {
                    if (pressed && this.arrayObjects.size() > 0) {
                        if (this.mousePressedPoint == null) {
                            this.mousePressedPoint = mousePosition;
                        }
                        else if (!isNaN(this.mousePressedPoint.x)) {
                            const p = dynamic.pt;
                            if (p.distance$math_Vector2(this.mousePressedPoint) > geom.Shape2D.SNAP_DISTANCE) {
                                const pt = this.shapesManager.createNewDynamicPoint(this.mousePressedPoint);
                                this.mousePressedPoint = new math.Vector2(javaemul.internal.DoubleHelper.NaN, 0);
                                this.pathInfo += "1";
                                this.arrayObjects.add(pt);
                                this.shapesManager.addShape(pt);
                                return;
                            }
                        }
                    }
                    for (let i = 0; i < this.param.length - 1; i++) {
                        {
                            if ( /* equals */((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(this.param[i], dynamic))
                                return;
                        }
                        ;
                    }
                    const n = this.arrayObjects.size();
                    const newArray = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(n + 1);
                    for (let i = 0; i < n; i++) {
                        newArray[i] = this.arrayObjects.get(i);
                    }
                    newArray[n] = dynamic;
                    this.param[this.step - 1] = newArray;
                }
                else {
                    for (let i = 0; i < this.param.length - 1; i++) {
                        {
                            if ( /* equals */((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(this.param[i], dynamic))
                                return;
                        }
                        ;
                    }
                    this.param[this.step - 1] = dynamic;
                }
                if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalPathShape2D, this.elementClass)) {
                    this.shapesManager.tempShape = new geom.optics.OpticalPathShape2D(this.param[this.step - 1], [this.pathInfo + "0"]);
                }
                else if (framework.ClassUtils.isAssignableFrom(geom.PathNpoints2D, this.elementClass)) {
                    this.shapesManager.tempShape = new geom.PathNpoints2D(this.param[this.step - 1], [this.pathInfo + "0"]);
                }
                else {
                    this.shapesManager.tempShape = this.createObject(this.elementClass, this.paramClasses, this.param, pressed);
                }
                if (this.shapesManager.tempShape != null) {
                    if (this.shapesManager.tempShape.drawColor == null)
                        this.shapesManager.tempShape.drawColor = AddShapeAction.tmpColor.copy();
                    this.shapesManager.tempShape.onAddShapeToSimulation(this.shapesManager);
                }
            }
        }
        mouseClicked(position, leftButton, shiftPressed) {
            this.mousePressedPoint = null;
            if (this.step > this.paramClasses.length)
                this.step = 1;
            let parentClass = this.paramClasses[this.step - 1];
            let isSingleParent = true;
            if (parentClass === geom.ShapeArray) {
                isSingleParent = false;
                parentClass = geom.ShapeArray.clazz_$LI$();
            }
            if (!framework.ClassUtils.isAssignableFrom(geom.Shape2D, parentClass)) {
                console.info("Error: Variable class1 should be a subclass of Shape2D");
            }
            if (leftButton) {
                if (this.step === 1)
                    this.app.setCursor(null);
                if (framework.ClassUtils.isAssignableFrom(geom.Shape2D, parentClass)) {
                    if (shiftPressed && framework.ClassUtils.isAssignableFrom(geom.Point2D, parentClass)) {
                        if (this.prevMousepos != null) {
                            const dv = position.difference$math_Vector2(this.prevMousepos);
                            if (Math.abs(dv.x) > Math.abs(dv.y)) {
                                dv.y = 0;
                            }
                            else {
                                dv.x = 0;
                            }
                            console.info("dv set to " + dv);
                            position.set$double$double(this.prevMousepos.x + dv.x, this.prevMousepos.y + dv.y);
                        }
                    }
                    this.prevMousepos = position;
                    const ancestor = this.findParentShape(parentClass, position);
                    if (ancestor == null)
                        return;
                    if (ancestor != null && ancestor instanceof geom.Point2D)
                        this.prevMousepos = position;
                    if (this.arrayObjects != null && this.arrayObjects.size() !== 0 && this.arrayObjects.get(0).equals(ancestor)) {
                        this.createParentsArray(parentClass);
                        this.step++;
                    }
                    else {
                        for (let i = 0; i < this.step - 1; i++) {
                            {
                                if ( /* equals */((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(this.param[i], ancestor))
                                    return;
                            }
                            ;
                        }
                        if (isSingleParent) {
                            this.param[this.step - 1] = ancestor;
                            this.step++;
                        }
                        else {
                            this.addParentShapeToArray(ancestor);
                            if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalPathShape2D, this.elementClass) || framework.ClassUtils.isAssignableFrom(geom.PathNpoints2D, this.elementClass))
                                this.pathInfo += "0";
                            return;
                        }
                    }
                }
            }
            else {
                if (isSingleParent) {
                    this.restart();
                    this.step = 1;
                    this.app.setStatusLine(this.getInstruction());
                    return;
                }
                else {
                    if (this.arrayObjects.size() === 0) {
                        this.step = 1;
                        return;
                    }
                    this.createParentsArray(parentClass);
                    this.step++;
                }
            }
            this.app.setStatusLine(this.getInstruction());
            while ((this.step < this.parentClasses.length + 1)) {
                {
                    parentClass = this.paramClasses[this.step - 1];
                    if (framework.ClassUtils.isAssignableFrom(Number, parentClass)) {
                        const value = framework.UserInput.getDouble(this.getInstruction(), 0, javaemul.internal.DoubleHelper.MAX_VALUE);
                        this.param[this.step - 1] = value;
                        this.step++;
                    }
                    else if (framework.ClassUtils.isAssignableFrom(String, parentClass)) {
                        const string = framework.UserInput.getExpression("Enter Expression or value", this.getInstruction(), null, (this.elementClass === geom.FunctionExplicit2D) ? ["x"] : (this.elementClass === geom.PolarCurve2D || this.elementClass === geom.ParametricCurve2D) ? ["t"] : null);
                        if (string == null || /* isEmpty */ (string.length === 0)) {
                            this.restart();
                            this.app.setStatusLine(this.getInstruction());
                            return;
                        }
                        this.param[this.step - 1] = string;
                        this.step++;
                    }
                    else {
                        if (framework.ClassUtils.isAssignableFrom(geom.Shape2D, parentClass))
                            return;
                    }
                }
            }
            ;
            if (this.step === this.parentClasses.length + 1) {
                let newObject;
                if (framework.ClassUtils.isAssignableFrom(geom.optics.OpticalPathShape2D, this.elementClass)) {
                    newObject = new geom.optics.OpticalPathShape2D(this.param[this.param.length - 1], [this.pathInfo]);
                }
                else if (framework.ClassUtils.isAssignableFrom(geom.PathNpoints2D, this.elementClass)) {
                    newObject = new geom.PathNpoints2D(this.param[this.param.length - 1], [this.pathInfo]);
                }
                else {
                    newObject = this.createObject(this.elementClass, this.paramClasses, this.param, false);
                }
                if (newObject == null) {
                    this.step = 1;
                    this.app.setStatusLine(this.getInstruction());
                    return;
                }
                this.shapesManager.previewShape = null;
                this.shapesManager.tempShape = null;
                if (newObject.isDefined()) {
                    this.shapesManager.addShape(newObject);
                }
                this.step = 1;
                this.param = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(this.param.length);
                this.app.setStatusLine(this.getInstruction());
                this.restart();
            }
        }
        /**
         * Conditions for creating new free point:
         * (1) parent class extends Point2D or Shape2D, and
         * (2) and creation of new point is allowed by application
         * @param {java.lang.Class} shapeClass
         * @return {boolean}
         * @private
         */
        /*private*/ static canCreateNewFreePoint(shapeClass) {
            if (framework.ClassUtils.isAssignableFrom(geom.Point2D, shapeClass))
                return true;
            if (geom.Shape2D === shapeClass)
                return true;
            return false;
        }
        /**
         * Ends the move body action.
         * @param component the component
         */
        end() {
            if (this.active)
                this.app.setCursor(this.cursor);
            this.active = false;
            this.step = 1;
            if (this.arrayObjects != null)
                this.arrayObjects.clear();
            this.shapesManager.previewShape = null;
            this.shapesManager.tempShape = null;
            if (this.paramClasses != null)
                this.param = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(this.paramClasses.length);
            this.shapesManager.setToolTip(null, null);
            this.app.setStatusLine("");
            this.vertices.clear();
        }
        /**
         * Ends the move body action.
         * @param component the component
         */
        restart() {
            this.begin$();
            this.app.setCursor(this.cursor);
        }
        /**
         * Returns the vertices of polygon
         * <p>
         * Returns null if the action is inactive.
         * @return {java.util.ArrayList} Vector2
         * @see #isActive()
         */
        getvertices() {
            if (!this.isActive())
                return null;
            return this.vertices;
        }
        /**
         * Creates a new construction/Dynamic object.
         * @param {java.lang.Class} elementClass the class of the construction, inherits
         * DynamicObject2D
         * @param {java.lang.Class<?>[]} paramClasses the array of classes for each argument of
         * constructor
         * @param {java.lang.Object[]} param the array of arguments for the constructor, should be the
         * same size as paramClass
         * @return {geom.Shape2D} a new construction (DynamicObject2D) initialized with given
         * parameters
         * @param {boolean} isPressed
         * @private
         */
        /*private*/ createObject(elementClass, paramClasses, param, isPressed) {
            let newObject;
            const buildClasses = (s => { let a = []; while (s-- > 0)
                a.push(null); return a; })(paramClasses.length);
            for (let i = 0; i < paramClasses.length; i++) {
                {
                    buildClasses[i] = paramClasses[i];
                }
                ;
            }
            newObject = framework.ClassUtils.createInstance(elementClass, param);
            if (newObject != null) {
                newObject.drawColor = AddShapeAction.tmpColor.copy();
                newObject.shapesManager = this.shapesManager;
                newObject.update();
            }
            return newObject;
        }
        /*private*/ addParentShapeToArray(ancestor) {
            if (ancestor == null)
                return;
            for (let index = this.arrayObjects.iterator(); index.hasNext();) {
                let s = index.next();
                {
                    if (s === ancestor)
                        return;
                }
            }
            this.arrayObjects.add(ancestor);
        }
        /*private*/ findParentShape(class1, point) {
            const shapeClass = class1;
            let shape = this.shapesManager.getSnappedShape(point, shapeClass);
            if (shape != null)
                return shape;
            if (!AddShapeAction.canCreateNewFreePoint(shapeClass))
                return null;
            shape = this.shapesManager.createNewDynamicPoint(point);
            this.shapesManager.addShape(shape);
            return shape;
        }
        /**
         * USed for ShapeArray class only
         * Create array of objects from arraylist and set param[] variable
         * @param {java.lang.Class} class1
         * @private
         */
        /*private*/ createParentsArray(class1) {
            const l = this.arrayObjects.size();
            const array = (s => { let a = []; while (s-- > 0)
                a.push(null); return a; })(l);
            for (let i = 0; i < l; i++) {
                array[i] = this.arrayObjects.get(i);
            }
            this.param[this.step - 1] = array;
            this.arrayObjects.clear();
        }
        /**
         * Give instruction corresponding to current step of the tool.
         * @return {string} an instruction string for this tool
         */
        getInstruction() {
            if (this.step > this.instructions.length) {
                if (this.step < this.paramClasses.length + 1) {
                    return "Choose " + /* getName */ (c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])(this.paramClasses[this.step - 1]);
                }
                return "no instruction";
            }
            else {
                return this.instructions[this.step - 1];
            }
        }
        actionPerformed(command) {
            if (command === ("point-free")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("FreePoint2D", geom.FreePoint2D, [geom.Point2D], null, ["Click to choose Point"]);
            }
            else if (command === ("point-coord")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PointsCoord2D", geom.PointExpr2D, [String, String], null, ["Enter X coordinate", "Enter Y coordinate"]);
            }
            else if (command === ("point-proj")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PointProjection2D", geom.PointProjection2D, [geom.Curve2D, geom.Point2D], null, ["Click on Curve or Line", "Click to choose Point"]);
            }
            else if (command === ("point-reflection")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PointReflectionLine2D", geom.PointReflectionLine2D, [geom.Line2D, geom.Point2D], null, ["Click to Choose Reflecting line ", "Click to choose Point to be reflected"]);
            }
            else if (command === ("point-ratio")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PointRatio2D", geom.PointRatio2D, [geom.Point2D, geom.Point2D, String], null, ["Click to choose First Point", "Click to choose Second Point", "Enter value k (divides points in k:1)"]);
            }
            else if (command === ("point-circle-center")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PointCircleCenter2D", geom.PointConicCenter, [geom.Conic2D], null, ["Click to choose Circle"]);
            }
            else if (command === ("line-2pts")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Line2Points2D", geom.Line2Points2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("line-segments")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Segment2Points2D", geom.Segment2Points2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("line-ray")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Ray2Points2D", geom.Ray2Points2D, [geom.Point2D, geom.Point2D], null, ["Click to choose Starting Point of ray", "Click to choose Second Point"]);
            }
            else if (command === ("line-parallel")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("LinePointParallel2D", geom.LinePointParallelLine2D, [geom.Line2D, geom.Point2D], null, ["Click to choose Line", "Click to choose Point"]);
            }
            else if (command === ("line-perpendicular")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("LinePointPerpenducular2D", geom.LinePointPerpendicularLine2D, [geom.Line2D, geom.Point2D], null, ["Click to choose Line", "Click to choose Point"]);
            }
            else if (command === ("line-angle-x-axis")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("LinePointAngle2D", geom.LinePointAngle2D, [geom.Point2D, String], null, ["Click to choose Point", "Enter expression for angle in radians"]);
            }
            else if (command === ("line-angle-line")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("LineLineAnglePoint2D", geom.LineLineAnglePoint2D, [geom.Line2D, geom.Point2D, String], null, ["Click to choose Line", "Click to choose Point", "Enter expression for angle in radians"]);
            }
            else if (command === ("line-tangent")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("LineTangent2D", geom.LineTangent2D, [geom.Curve2D, geom.Point2D], null, ["Click to choose curve ", "Click to choose Point"]);
            }
            else if (command === ("line-normal")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("LineNormal2D", geom.LineNormal2D, [geom.Curve2D, geom.Point2D], null, ["Click to choose curve ", "Click to choose Point"]);
            }
            else if (command === ("line-bisector")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("LineAngleBisector2D", geom.LineAngleBisectorPair2D, [geom.Line2D, geom.Line2D], null, ["Click to choose first line", "Click to choose second Line"]);
            }
            else if (command === ("ray-reflect")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("RayReflect2PointsCurve2D", geom.RayReflect2PointsCurve2D, [geom.Point2D, geom.Point2D, geom.Curve2D], null, ["Click to choose first point on incident ray", "Click to choose second point on Ray", "Click to choose curve"]);
            }
            else if (command === ("ray-refract")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("OpticalRay2D", geom.optics.OpticalRay2Points2D, [geom.Point2D, geom.Point2D], null, ["Click to choose first point on incident ray", "Click to choose second point on incident ray", "Click to choose Curve", "Enter refractive index of emrgent medium wrt incident"]);
            }
            else if (command === ("circle-2pts")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Circle2Points2D", geom.Circle2Points2D, [geom.Point2D, geom.Point2D], null, ["Click to choose center", "Click to choose Point on circle"]);
            }
            else if (command === ("circle-3pts")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Circle3Points2D", geom.Circle3Points2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point", "Click to choose Third Point"]);
            }
            else if (command === ("arc-3pts")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("CircleArc3Points2D", geom.CircleArc3Points2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point", "Click to choose Third Point"]);
            }
            else if (command === ("arc-center-2pts")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("CircleArcCenter2Points2D", geom.CircleArcCenter2Points2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose Center of Arc", "Click to choose Second Point", "Click to choose Third Point"]);
            }
            else if (command === ("circle-diameter")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("CircleDiameter2D", geom.CircleDiameter2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Diameter Point", "Click to choose Second Diameter Point"]);
            }
            else if (command === ("parabola-2pts")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Parabola2Points2D", geom.Parabola2Points2D, [geom.Point2D, geom.Point2D], null, ["Click to choose vertex ", "Click to choose Focus"]);
            }
            else if (command === ("parabola-line-pt")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("ParabolaLinePoint2D", geom.ParabolaLinePoint2D, [geom.Line2D, geom.Point2D], null, ["Click to choose directrix", "Click to choose focus"]);
            }
            else if (command === ("ellipse-foci-point")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Ellipse2FocusPoint2D", geom.Ellipse2FocusPoint2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose choose first focus", "Click to choose second focus", "Click to choose point on ellipse"]);
            }
            else if (command === ("ellipse-center-point")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("EllipseCenter2Points2D", geom.EllipseCenter2Points2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose center", "Click to choose vertex", "Click to choose second axis length"]);
            }
            else if (command === ("hyperbola-foci-point")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Hyperbola2FocusPoint2D", geom.Hyperbola2FocusPoint2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose choose first focus", "Click to choose second focus", "Click to choose point on ellipse"]);
            }
            else if (command === ("hyperbola-center-point")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("HyperbolaCenter2Points2D", geom.HyperbolaCenter2Points2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose center", "Click to choose vertex", "Click to choose second axis length"]);
            }
            else if (command === ("conic-5points")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Conic5Points2D", geom.Conic5Points2D, [geom.Point2D, geom.Point2D, geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose first point", "Click to choose second point", "Click to choose third point", "Click to choose forth point", "Click to choose fifth point", "Click to choose sixth point"]);
            }
            else if (command === ("conic-line-point")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("ConicLinePointE2D", geom.ConicLinePointE2D, [geom.Line2D, geom.Point2D, String], null, ["Click to choose directrix", "Click to choose focus", "Click to enter eccentricity"]);
            }
            else if (command === ("conic-eqn")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("ConicEqn2D", geom.ConicEqnShape2D, [String, String, String, String, String, String], null, ["Click to enter a (coeff of x^2)", "Click to enter b(coeff of xy)", "Click to enter c (coeff of y^2)", "Click to enter d(coeff of x)", "Click to enter e (coeff of y)", "Click to enter f (constant term)"]);
            }
            else if (command === ("circle-center-radius")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("CircleCenterRadius2D", geom.CircleCenterRadius2D, [geom.Point2D, String], null, ["Click to choose center", "Enter expression for radius of circle"]);
            }
            else if (command === ("osculating-circle")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("OsculatingCircle2D", geom.OsculatingCircle2D, [geom.Curve2D, geom.Point2D], null, ["Click to choose curve", "Click to choose point"]);
            }
            else if (command === ("vector-2pts")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Vector2Points2D", geom.Vector2Points2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("vector-parallel")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("VectorParallel2D", geom.VectorPointParallelLine2D, [geom.Line2D, geom.Point2D, geom.Point2D], null, ["Click to choose parallel Line or vector", "Click to choose initial Point", "Click to choose final Point"]);
            }
            else if (command === ("vector-perpendicular")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_String_A("VectorPerpendicular2D", geom.VectorPointPerpendicularLine2D, [geom.Line2D, geom.Point2D], ["Click to choose perpendicular Line or vector", "Click to choose Point"]);
            }
            else if (command === ("vector-resultant")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_String_A("VectorSum2D", geom.VectorSum2D, [geom.Vector2D, geom.Vector2D, geom.Point2D], ["Click to choose first vector", "Click to choose second Point", "Click to choose initial Point"]);
            }
            else if (command === ("vector-difference")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("VectorDifference2D", geom.VectorDifference2D, [geom.Vector2D, geom.Vector2D, geom.Point2D], null, ["Click to choose first vector", "Click to choose second Point", "Click to choose initial Point"]);
            }
            else if (command === ("vector-unit")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("VectorUnit2D", geom.VectorUnit2D, [geom.Line2D, geom.Point2D], null, ["Click to choose line of vector"]);
            }
            else if (command === ("measure-info")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("ShapeInfo2D", geom.ShapeInfo2D, [geom.Curve2D, geom.Point2D], null, ["Click to choose Curve/Line", "Click to choose Point"]);
            }
            else if (command === ("measure-angle")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("AngleMeasure", geom.AngleMeasure2D, [geom.Line2D, geom.Line2D], null, ["Click to choose First Line", "Click to choose Second Line"]);
            }
            else if (command === ("measure-length")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("LenthMeasure", geom.LengthMeasure2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("measure-point")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PointMeasure", geom.PointMeasure2D, [geom.Point2D], null, ["Click to choose Point, to create variable"]);
            }
            else if (command === ("function-explicit")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("FunctionExplicit2D", geom.FunctionExplicit2D, [String], null, ["Enter Expression as an explicit function of x"]);
            }
            else if (command === ("measure-expr")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("ExpressionMeasure", geom.ExpressionMeasure2D, [geom.Point2D, String], null, ["Click to choose Point", "Enter expression to evaluate"]);
            }
            else if (command === ("measure-ruler")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Ruler2Points2D", geom.Ruler2Points2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("measure-protractor")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Protractor3Points2D", geom.Protractor3Points2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose Center", "Click to choose initial point of arc", "Click to choose final point of arc"]);
            }
            else if (command === ("point-locus")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Dynamic-locus", geom.DynamicCurve2D, [geom.Point2D], null, ["Click to choose point whole locus is to be created"]);
            }
            else if (command === ("parametric-curve")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Parametric-Curve", geom.ParametricCurve2D, [String, String], null, ["Enter x Expression as a function of t(-1<=t<=1)", "Enter y Expression as a function of t(-1<=t<=1)"]);
            }
            else if (command === ("polar-curve")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("polar-Curve", geom.PolarCurve2D, [String], null, ["Enter Expression for r as a function of t (0<t<2*pi)"]);
            }
            else if (command === ("text-2pts")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Text2Points2D", geom.Text2Points2D, [geom.Point2D, geom.Point2D], null, ["Choose first Point", "Choose second Point"]);
            }
            else if (command === ("line-eqn")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("LineEqn2D", geom.LineEqn2D, [String, String, String], null, ["Enter \'a\' for equation ax+by+c=0", "Enter \'b\' for equation ax+by+c=0", "Enter \'c\' for equation ax+by+c=0"]);
            }
            else if (command === ("vector-eqn")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("VectorEqn2D", geom.VectorEqn2D, [geom.Point2D, String, String], null, ["Choose initial point of Vector", "Enter \'a\' for Vector ai" + math.Unicode.hat + " + bj" + math.Unicode.hat, "Enter \'b\' for Vector ai" + math.Unicode.hat + " + bj" + math.Unicode.hat]);
            }
            else if (command === ("point-relative")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PointRelativePoint2D", geom.PointRelativePoint2D, [geom.Point2D, geom.Point2D], null, ["Choose reference point", "Choose new Position Point"]);
            }
            else if (command === ("quad-curve")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Bezier3points2D", geom.Bezier3Points2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Choose first point", "Choose control point", "Choose secondn Point"]);
            }
            else if (command === ("cubic-curve")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Bezier4points2D", geom.Bezier4Points2D, [geom.Point2D, geom.Point2D, geom.Point2D, geom.Point2D], null, ["Choose first point", "Choose first control point", "Choose second control point", "Choose secondn Point"]);
            }
            else if (command === ("PathNpoints")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PathNpoints", geom.PathNpoints2D, [geom.ShapeArray], null, ["Choose Point on path, press and drag to create arc"]);
            }
            else if (command === ("conic-center")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PointConicCenter", geom.PointConicCenter, [geom.Conic2D], null, ["Choose Conic"]);
            }
            else if (command === ("conic-foci")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("FociConic2D", geom.FociConic2D, [geom.Conic2D], null, ["Choose Conic"]);
            }
            else if (command === ("conic-intersections")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("Intersection2Conics2D", geom.Intersection2Conics2D, [geom.Conic2D, geom.Conic2D], null, ["Choose First Conic", "Choose Second Conic"]);
            }
            else if (command === ("conic-pole")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PoleConicLine2D", geom.PoleConicLine2D, [geom.Conic2D, geom.Line2D], null, ["Choose Conic", "Choose polar line"]);
            }
            else if (command === ("conic-polar")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("PolarConicPoint2D", geom.PolarConicPoint2D, [geom.Conic2D, geom.Point2D], null, ["Choose Conic", "Choose pole Point"]);
            }
            else if (command === ("conic-midpointchord")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("MidPointChordConicPoint2D", geom.MidPointChordConicPoint2D, [geom.Conic2D, geom.Point2D], null, ["Choose Conic", "Choose MidPoint of chord"]);
            }
            else if (command === ("conic-parallel-tangents")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("TangentsConicLine2D", geom.TangentsConicLine2D, [geom.Conic2D, geom.Line2D], null, ["Choose conic", "Choose line parallel to which tangents are drawn"]);
            }
            else if (command === ("conic-ext-tangents")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("TangentsConicPoint2D", geom.TangentsConicPoint2D, [geom.Conic2D, geom.Point2D], null, ["Choose conic", "Choose point from where tangents are to be drawn"]);
            }
            else if (command === ("conic-common-tangents")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("CommonTangents2Conics2D", geom.CommonTangents2Conics2D, [geom.Conic2D, geom.Conic2D], null, ["Choose first conic", "Choose second conic"]);
            }
            else if (command === ("conic-parallel-normals")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("NormalsConicLine2D", geom.NormalsConicLine2D, [geom.Conic2D, geom.Line2D], null, ["Choose conic", "Choose line parallel to which normals are drawn"]);
            }
            else if (command === ("conic-ext-normals")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("NormalsConicPoint2D", geom.NormalsConicPoint2D, [geom.Conic2D, geom.Point2D], null, ["Choose conic", "Choose point from where normals are to be drawn"]);
            }
            else if (command === ("optics-ray")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-ray", geom.optics.OpticalRay2Points2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("optics-white-ray")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-white-ray", geom.optics.OpticalWhiteLight2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("optics-lens")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-lens", geom.optics.OpticalIdealLens2D, [geom.Point2D, geom.Point2D], null, ["Click to choose Pole", "Click to choose End Point"]);
            }
            else if (command === ("optics-planemirror")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-mirror", geom.optics.OpticalPlaneMirror2D, [geom.Point2D, geom.Point2D], null, ["Click to choose Pole", "Click to choose end Point"]);
            }
            else if (command === ("optics-observer")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-observer", geom.optics.OpticalObserver2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("optics-beam")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-beam", geom.optics.OpticalBeam2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("optics-blocker")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-blocker", geom.optics.OpticalBlocker2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("optics-src")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-src", geom.optics.OpticalSource2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point", "Click to choose Third Point"]);
            }
            else if (command === ("optics-parabolicmirror")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-arcmirror", geom.optics.OpticalParabolicArc2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point", "Click to choose Third Point"]);
            }
            else if (command === ("optics-arcmirror")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-arcmirror", geom.optics.OpticalArc2D, [geom.Point2D, geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point", "Click to choose Third Point"]);
            }
            else if (command === ("optics-idealmirror")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-idealmirror", geom.optics.OpticalIdealMirror2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("optics-plane")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-plane", geom.optics.OpticalPlane2D, [geom.Point2D, geom.Point2D], null, ["Click to choose First Point", "Click to choose Second Point"]);
            }
            else if (command === ("optics-path")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("optics-path", geom.optics.OpticalPathShape2D, [geom.ShapeArray], null, ["Choose Point on path, press and drag to create arc"]);
            }
            else if (command === ("slider")) {
                this.begin$java_lang_String$java_lang_Class$java_lang_Class_A$java_lang_Object_A$java_lang_String_A("slider", geom.Slider2D, [geom.Point2D, geom.Point2D], null, ["Choose Point 1, Choose Point 2"]);
            }
        }
    }
    AddShapeAction.tmpColor = null;
    geom.AddShapeAction = AddShapeAction;
    AddShapeAction["__class"] = "geom.AddShapeAction";
    AddShapeAction["__interfaces"] = ["framework.input.InputHandler"];
})(geom || (geom = {}));
(function (geom) {
    /**
     *
     * @author mahesh
     * @class
     */
    class Shape2D {
        constructor() {
            if (this.id === undefined) {
                this.id = null;
            }
            this.name = "";
            this.parents = null;
            this.params = null;
            this.drawPattern = Shape2D.DrawMode.SOLID;
            this.fillColor = null;
            this.drawColor = null;
            this.visibilityCondition = null;
            this.strokeWidth = Shape2D.DEFAULT_STROKE_WIDTH;
            this.touchable = true;
            if (this.shapesManager === undefined) {
                this.shapesManager = null;
            }
            this.selected = false;
            this.visible = true;
            this.showEqn = false;
            this.showName = false;
            this.__isDefined = false;
            this.id = Shape2D.CURRENT_ID++ + "";
        }
        static TMP_VEC_$LI$() { if (Shape2D.TMP_VEC == null) {
            Shape2D.TMP_VEC = new math.Vector2();
        } return Shape2D.TMP_VEC; }
        static TMP_TRANSFORM_$LI$() { if (Shape2D.TMP_TRANSFORM == null) {
            Shape2D.TMP_TRANSFORM = new math.Transform();
        } return Shape2D.TMP_TRANSFORM; }
        static editInfo_$LI$() { if (Shape2D.editInfo == null) {
            Shape2D.editInfo = new framework.EditInfo();
        } return Shape2D.editInfo; }
        /**
         * Returns the extra shape data that provides additional info about shape  (Used for serialisation)
         * @return
         * @return {string}
         */
        getExtraShapeData() {
            return null;
        }
        /**
         * Sets the shapeData (provides additional info for shape (Used for deserialisation)
         * @param {string} data
         */
        setExtraShapeData(data) {
            return;
        }
        /**
         * Returns strokeWidth used in drawing shape outline
         * @return
         * @return {number}
         */
        getLineWidth() {
            return this.strokeWidth;
        }
        /**
         * Sets strokeWidth used in drawing shape outline
         * @param {number} strokeWidth must be >0
         */
        setLineWidth(strokeWidth) {
            if (strokeWidth > 0)
                this.strokeWidth = strokeWidth;
        }
        /**
         * Returns color used to fill shape
         * @return
         * @return {framework.Color}
         */
        getFillColor() {
            return this.fillColor;
        }
        /**
         * Sets Color used to draw shape outline
         * @param {framework.Color} fillColor
         */
        setFillColor(fillColor) {
            this.fillColor = fillColor;
        }
        /**
         * Returns color used to fill shape
         * @return
         * @return {framework.Color}
         */
        getDrawColor() {
            return this.drawColor;
        }
        /**
         * Sets Color used to draw shape outline
         * @param tintColor {Color}
         * @param {framework.Color} drawColor
         */
        setDrawColor(drawColor) {
            this.drawColor = drawColor;
        }
        getDrawPattern() {
            return this.drawPattern;
        }
        setDrawPattern(drawPattern) {
            this.drawPattern = drawPattern;
        }
        /**
         * Returns the identifier name of shape
         * @return {string} the name
         */
        getName() {
            return this.name;
        }
        /**
         * Sets the identifier name of shape
         * @param {string} name
         * the name to set
         */
        setName(name) {
            this.name = name;
        }
        /**
         * returns array of Parents needed for construction of this shape for the shape if any, else returns null
         *
         * @return
         * @return {geom.Shape2D[]}
         */
        getParents() {
            return this.parents;
        }
        /**
         * returns arrays of parameters needed for construction of this shape for shape if any, else returns null
         * @return
         * @return {java.lang.String[]}
         */
        getParams() {
            return this.params;
        }
        /**
         * Sets value of parameter at specified index
         * @param {number} index
         * @param {string} value the value to set
         */
        setParam(index, value) {
            if (this.params == null || this.params.length < index - 1)
                return;
            this.params[index] = value;
        }
        /**
         * Returns Parameter Info to be edited at specified index, returns null if no parameter is found at the index
         * @param {number} index
         * @return
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            return null;
        }
        /**
         * Sets value of parameter at specified index
         * @param {number} index
         * @param {*} value the value to set
         */
        setEditValue(index, value) {
        }
        /**
         * Returns true if element can be selected or dragged by mouse or touch events
         * @return
         * @return {boolean}
         */
        isTouchable() {
            return this.touchable;
        }
        /**
         * Sets element selectable and draggable by mouse or touch events
         * @return
         * @param {boolean} touchable
         */
        setTouchable(touchable) {
            this.touchable = touchable;
        }
        /**
         * @return {boolean} the visible
         */
        isVisible() {
            if (this.visibilityCondition != null) {
                try {
                    this.visible = math.MathUtils.evaluateExpression(this.visibilityCondition, this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables) !== 0;
                }
                catch (e) {
                }
            }
            return this.visible;
        }
        /**
         * @param {boolean} visible
         * the visible to set
         */
        setVisible(visible) {
            this.visible = visible;
            this.visibilityCondition = null;
        }
        /**
         * Sets the expression evaluated to check visibility condition
         * shape is visible if expression returns non zero value
         * @param expression
         * @param {string} expr
         */
        setVisiblilityExpression(expr) {
            if (expr == null || /* isEmpty */ (expr.length === 0)) {
                this.visibilityCondition = null;
                return;
            }
            expr = expr.trim();
            if ( /* equalsIgnoreCase */((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(expr, "true")) {
                this.setVisible(true);
            }
            else if ( /* equalsIgnoreCase */((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(expr, "false")) {
                this.setVisible(false);
            }
            else {
                this.visibilityCondition = expr;
                this.visible = this.isVisible();
            }
        }
        /**
         * Returns the expression evaluated to check visibility condition
         * shape is visible if expression returns non zero value
         * @return {string}
         */
        getVisiblilityExpression() {
            return this.visibilityCondition == null ? this.visible + "" : this.visibilityCondition;
        }
        /**
         * Update shape (fired when something has changed that may affect shape)
         */
        update() {
        }
        /**
         * Recreate shape from its parameters, mainly intended to reparse expression and adding global vars in shapes if any
         * @param {geom.ShapesManager} manager
         */
        onAddShapeToSimulation(manager) {
            this.shapesManager = manager;
            this.update();
        }
        /**
         * Returns true if the specified point  lies on the boundary of shape
         * @param {math.Vector2} pt {Vector2 }
         * @return {boolean} {Boolean}
         */
        contains(pt) {
            if (!this.__isDefined)
                return false;
            return this.distance(pt) < Shape2D.ACCURACY;
        }
        /**
         *
         * @return {string}
         */
        toString() {
            return this.name + " : " + /* getSimpleName */ (c => typeof c === 'string' ? c.substring(c.lastIndexOf('.') + 1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(this.constructor);
        }
        /**
         * returns info for the shape
         *
         * @return
         * @return {string}
         */
        getInfo() {
            let s = this.showName ? this.name : "";
            if (this.showEqn)
                s += (this.showName ? ": " : "") + this.getEquation();
            return s;
        }
        renderInfo(g, v1, v2) {
            g.drawText$java_lang_String$math_Vector2$math_Vector2(this.getInfo(), v1, v2);
        }
        /**
         * Renders info center aligned along line joining v1 and v2
         *
         * @param gl
         * @param {math.Vector2} v1
         * @param {math.Vector2} v2
         * @param {number} xAlign
         * 0=left, 1=center, 2=right
         * @param {number} yAlign
         * 0=top, 1=center, 2=bottom
         * @param {framework.Renderer} g
         * @param {string} info
         * @param {framework.Color} color
         * @param {framework.Color} backColor
         */
        static renderInfo(g, info, v1, v2, xAlign, yAlign, color, backColor) {
            if (info == null || /* isEmpty */ (info.length === 0))
                return;
            g.drawText$java_lang_String$math_Vector2$math_Vector2(info, v1, v2);
        }
        /**
         * Returns true if shape is valid
         * @return
         * @return {boolean}
         */
        isDefined() {
            return this.__isDefined;
        }
        /**
         * returns true if shape can be moved freely by mouse drag or arrow keys
         * @return
         * @return {boolean}
         */
        isFreeToMove() {
            if (this.parents == null)
                return false;
            let b = false;
            for (let index = 0; index < this.parents.length; index++) {
                let s = this.parents[index];
                {
                    if (s != null && (s != null && s instanceof geom.Point2D)) {
                        if ((s != null && s instanceof geom.FreePoint2D) || (s != null && s instanceof geom.PointOnCurve2D)) {
                            b = true;
                        }
                        else {
                            b = false;
                            break;
                        }
                    }
                }
            }
            return b;
        }
        mousePressed(pt) {
        }
        mouseReleased(pt) {
        }
        /**
         * Fired when shape is dragged
         *
         * @param {math.Vector2} delta
         * @param {math.Vector2} pt
         * @param {boolean} manually
         */
        mouseDragged(delta, pt, manually) {
            if (this.parents == null)
                return;
            for (let index = 0; index < this.parents.length; index++) {
                let s = this.parents[index];
                {
                    if (s != null)
                        s.mouseDragged(delta, pt, false);
                }
            }
            this.update();
        }
        /**
         *
         * @param {*} obj
         * @return {boolean}
         */
        equals(obj) {
            if (obj == null)
                return false;
            if (obj === this)
                return true;
            if (obj != null && obj instanceof geom.Shape2D) {
                return this.id === obj.id;
            }
            return false;
        }
        /**
         * Returns the unique identifier for this shape instance.
         * @return {string} String
         */
        getId() {
            return this.id;
        }
        /**
         * perform some action if needed (like resource release, reset global variables etc) when the shape is removed
         */
        dispose() {
        }
        /**
         * Sets outline pattern of shape
         * @param {string} pattern {String} can be any of "solid","dotted","dashed","dash-dot"
         */
        setStrokePattern(pattern) {
            if (pattern == null)
                return;
            const drawPattern = Shape2D.DrawMode[pattern.toUpperCase() + ""];
            if (drawPattern != null)
                this.drawPattern = drawPattern;
        }
        /**
         * Returns outline pattern of shape
         * @return {string}
         * @return  {string} {String} can be any of "solid","dotted","dashed","dash-dot"
         */
        getStrokePattern() {
            return /* Enum.name */ geom.Shape2D.DrawMode[this.drawPattern].toLowerCase();
        }
        isShowEqn() {
            return this.showEqn;
        }
        setShowEqn(showEqn) {
            this.showEqn = showEqn;
        }
        isShowName() {
            return this.showName;
        }
        setShowName(showName) {
            this.showName = showName;
        }
    }
    Shape2D.DEFAULT_STROKE_WIDTH = 1.5;
    Shape2D.CURRENT_ID = 0;
    /**
     * The constant used for picking shapes, it specifies maximum distance in pixel to which shape can be picked
     */
    Shape2D.ACCURACY_PIXEL = 10;
    Shape2D.SNAP_DISTANCE = 0.1;
    /**
     * Accuracy in Geometry module (this much error is permitted in calculations)
     */
    Shape2D.ACCURACY = 1.0E-6;
    geom.Shape2D = Shape2D;
    Shape2D["__class"] = "geom.Shape2D";
    (function (Shape2D) {
        let DrawMode;
        (function (DrawMode) {
            DrawMode[DrawMode["SOLID"] = 0] = "SOLID";
            DrawMode[DrawMode["DOTTED"] = 1] = "DOTTED";
            DrawMode[DrawMode["DASHED"] = 2] = "DASHED";
            DrawMode[DrawMode["DASH_DOT"] = 3] = "DASH_DOT";
        })(DrawMode = Shape2D.DrawMode || (Shape2D.DrawMode = {}));
        /** @ignore */
        class DrawMode_$WRAPPER {
            constructor(_$ordinal, _$name, pattern) {
                this._$ordinal = _$ordinal;
                this._$name = _$name;
                if (this.pattern === undefined) {
                    this.pattern = 0;
                }
                this.pattern = (pattern | 0);
            }
            name() { return this._$name; }
            ordinal() { return this._$ordinal; }
            compareTo(other) { return this._$ordinal - (isNaN(other) ? other._$ordinal : other); }
        }
        Shape2D.DrawMode_$WRAPPER = DrawMode_$WRAPPER;
        DrawMode["__class"] = "geom.Shape2D.DrawMode";
        DrawMode["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
        DrawMode["_$wrappers"] = { 0: new DrawMode_$WRAPPER(0, "SOLID", 0), 1: new DrawMode_$WRAPPER(1, "DOTTED", 52428), 2: new DrawMode_$WRAPPER(2, "DASHED", 255), 3: new DrawMode_$WRAPPER(3, "DASH_DOT", 7423) };
    })(Shape2D = geom.Shape2D || (geom.Shape2D = {}));
})(geom || (geom = {}));
(function (geom) {
    /**
     * Create free Point
     * @param {number} x
     * @param {number} y
     * @class
     * @extends geom.Shape2D
     * @author Mahesh
     */
    class Point2D extends geom.Shape2D {
        constructor(x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                let __args = arguments;
                super();
                if (this.pt === undefined) {
                    this.pt = null;
                }
                if (this.r === undefined) {
                    this.r = 0;
                }
                this.delta = new math.Vector2();
                this.pt = new math.Vector2(x, y);
                this.__isDefined = true;
                this.showName = true;
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                let __args = arguments;
                let v = __args[0];
                {
                    let __args = arguments;
                    let x = v.x;
                    let y = v.y;
                    super();
                    if (this.pt === undefined) {
                        this.pt = null;
                    }
                    if (this.r === undefined) {
                        this.r = 0;
                    }
                    this.delta = new math.Vector2();
                    this.pt = new math.Vector2(x, y);
                    this.__isDefined = true;
                    this.showName = true;
                }
                if (this.pt === undefined) {
                    this.pt = null;
                }
                if (this.r === undefined) {
                    this.r = 0;
                }
                this.delta = new math.Vector2();
            }
            else if (x === undefined && y === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let x = 0;
                    let y = 0;
                    super();
                    if (this.pt === undefined) {
                        this.pt = null;
                    }
                    if (this.r === undefined) {
                        this.r = 0;
                    }
                    this.delta = new math.Vector2();
                    this.pt = new math.Vector2(x, y);
                    this.__isDefined = true;
                    this.showName = true;
                }
                if (this.pt === undefined) {
                    this.pt = null;
                }
                if (this.r === undefined) {
                    this.r = 0;
                }
                this.delta = new math.Vector2();
                (() => {
                    this.fillColor = new framework.Color(100, 220, 100);
                })();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Sets position of point at specified coordinates <br>
         * Note that position may not be exactly same as (x,y) for constrained points
         * @param {number} x {Number}
         * @param {number} y {Number}
         */
        set(x, y) {
            this.pt = new math.Vector2(x, y);
            this.__isDefined = true;
        }
        /**
         * Sets x coordinate of point
         * @see {@link #set(double, double)}
         * @param {number} x
         */
        setX(x) {
            this.set(x, this.pt.y);
        }
        /**
         * Sets y coordinate of point
         * @see {@link #set(double, double)}
         * @param {number} y
         */
        setY(y) {
            this.set(this.pt.x, y);
        }
        /**
         * returns x coordinate of point
         * @return {number}
         */
        getX() {
            return this.pt == null ? javaemul.internal.DoubleHelper.NaN : this.pt.x;
        }
        /**
         * returns y coordinate of point
         * @return {number}
         */
        getY() {
            return this.pt == null ? javaemul.internal.DoubleHelper.NaN : this.pt.y;
        }
        getPosition() {
            return this.pt;
        }
        /**
         *
         */
        update() {
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            if (this.pt == null)
                return "??";
            return math.MathUtils.formatPoint(this.pt, true);
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.isDefined() || this.pt == null)
                return;
            this.r = this.strokeWidth * 3 / g.METER_TO_PIXEL;
            g.drawCircle(this.pt.x, this.pt.y, this.r, this.fillColor != null, this.drawColor != null);
            if (this.showEqn || this.showName) {
                const v = new math.Vector2(0.75, 0.75);
                const vc = this.pt.sum$math_Vector2(v.product(geom.Shape2D.SNAP_DISTANCE));
                this.renderInfo(g, vc, vc);
            }
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            if (!this.__isDefined || this.pt == null)
                return false;
            return this.pt.distance$math_Vector2(pt) < geom.Shape2D.SNAP_DISTANCE;
        }
        /**
         *
         * @return {string}
         */
        toString() {
            return super.toString();
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            if (!this.isDefined() || pt == null || this.pt == null)
                return javaemul.internal.DoubleHelper.MAX_VALUE;
            return this.pt.distance$math_Vector2(pt);
        }
        /**
         *
         * @param {*} o
         * @return {boolean}
         */
        equals(o) {
            if (this === o)
                return true;
            if (!(o != null && o instanceof geom.Point2D) || !this.isDefined() || this.pt == null)
                return false;
            return this.pt.equals$math_Vector2(o.pt);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return this.name + this.getEquation();
        }
        isFreeToMove() {
            return false;
        }
    }
    geom.Point2D = Point2D;
    Point2D["__class"] = "geom.Point2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     *
     * @author mahesh
     * @class
     * @extends geom.Shape2D
     */
    class Curve2D extends geom.Shape2D {
        constructor() {
            super();
            this.__t0 = 0;
            this.__t1 = 1;
            this.beginCap = Curve2D.CAP.NONE;
            this.endCap = Curve2D.CAP.NONE;
            this.middleCap = Curve2D.CAP.NONE;
        }
        /**
         *
         * @return {string}
         */
        getExtraShapeData() {
            let s = "";
            if (this.beginCap !== Curve2D.CAP.NONE || this.middleCap !== Curve2D.CAP.NONE || this.endCap !== Curve2D.CAP.NONE) {
                s += /* Enum.ordinal */ geom.Curve2D.CAP[geom.Curve2D.CAP[this.beginCap]] + ";";
                s += /* Enum.ordinal */ geom.Curve2D.CAP[geom.Curve2D.CAP[this.middleCap]] + ";";
                s += /* Enum.ordinal */ geom.Curve2D.CAP[geom.Curve2D.CAP[this.endCap]];
            }
            else {
                return null;
            }
            return s;
        }
        /**
         *
         * @param {string} data
         */
        setExtraShapeData(data) {
            if (data == null)
                return;
            try {
                const arr = data.split(";");
                for (let i = 0; i < arr.length; i++) {
                    {
                        this.setCap(i, javaemul.internal.IntegerHelper.parseInt(arr[i]));
                    }
                    ;
                }
            }
            catch (e) {
            }
        }
        /**
         * Sets Shape of cap at specified position
         * @param {number} capLocation 0=Start,1=Middle,2=End
         * @param {number} capIndex 0=NONE,1=FOREARROW,2=BACKARROW,3=BULLET,4=DOTTED,5=TEXT}
         */
        setCap(capLocation, capIndex) {
            switch ((capLocation)) {
                case 0:
                    this.beginCap = /* Enum.values */ function () { let result = []; for (let val in geom.Curve2D.CAP) {
                        if (!isNaN(val)) {
                            result.push(parseInt(val, 10));
                        }
                    } return result; }()[capIndex];
                    break;
                case 1:
                    this.middleCap = /* Enum.values */ function () { let result = []; for (let val in geom.Curve2D.CAP) {
                        if (!isNaN(val)) {
                            result.push(parseInt(val, 10));
                        }
                    } return result; }()[capIndex];
                    break;
                case 2:
                    this.endCap = /* Enum.values */ function () { let result = []; for (let val in geom.Curve2D.CAP) {
                        if (!isNaN(val)) {
                            result.push(parseInt(val, 10));
                        }
                    } return result; }()[capIndex];
                    break;
            }
        }
        /**
         * Returns index of cap at specified location
         * @param {number} capLocation 0=Start,1=Middle,2=End
         * @param @return index 0=NONE,1=FOREARROW,2=BACKARROW,3=BULLET,4=DOTTED,5=TEXT}
         * @return {number}
         */
        getCapIndex(capLocation) {
            switch ((capLocation)) {
                case 0:
                    return /* Enum.ordinal */ geom.Curve2D.CAP[geom.Curve2D.CAP[this.beginCap]];
                case 1:
                    return /* Enum.ordinal */ geom.Curve2D.CAP[geom.Curve2D.CAP[this.middleCap]];
                case 2:
                    return /* Enum.ordinal */ geom.Curve2D.CAP[geom.Curve2D.CAP[this.endCap]];
            }
            return 0;
        }
        /**
         * Returns the parameter of the first point of the curve.
         * @return {number}
         */
        t0() {
            return this.__t0;
        }
        /**
         * Returns the parameter of the last point of the curve.
         * @return {number}
         */
        t1() {
            return this.__t1;
        }
        /**
         * Returns the starting point on the curve if defined else returns null
         * @return
         * @return {math.Vector2}
         */
        firstPoint() {
            const t0 = this.t0();
            if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(t0))
                return null;
            return this.point(t0);
        }
        /**
         * Returns the end point on the curve if defined else returns null
         * @return
         * @return {math.Vector2}
         */
        lastPoint() {
            const t1 = this.t1();
            if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(this.__t0))
                return null;
            return this.point(t1);
        }
        /**
         * Returns the projection of point on the curve (Nearest orthogonal point on curve is obtained by
         * getting point of intersection of normal from the point)
         * @param {math.Vector2} point
         * @return {math.Vector2} point nearest to curve if defined else returns null
         */
        project(point) {
            const t = this.t(point);
            if ( /* isFinite */((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(t)) {
                return this.point(t);
            }
            return null;
        }
        /**
         * Returns the unit Vector along tangent to curve
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            if (!this.__isDefined)
                return null;
            const t1 = t - geom.Shape2D.SNAP_DISTANCE / 100;
            const t2 = t + geom.Shape2D.SNAP_DISTANCE / 100;
            const v1 = this.point(t1);
            const v2 = this.point(t2);
            if (v1 == null || v2 == null)
                return null;
            return new math.Vector2(v1.to$math_Vector2(v2).getDirection());
        }
        /**
         * returns the slope of the curve
         * @param {number} t
         * @return {number} {Number}
         */
        derivative(t) {
            if (!this.isDefined())
                return javaemul.internal.DoubleHelper.NaN;
            const v = this.tangent(t);
            if (v == null)
                return javaemul.internal.DoubleHelper.NaN;
            return Math.tan(v.getDirection());
        }
        /**
         * Returns double derivative on the curve at point specified by parameter t
         * @param {number} t
         * @return {number} {Number}
         */
        doubleDerivative(t) {
            if (!this.isDefined())
                return javaemul.internal.DoubleHelper.NaN;
            let ddx = 0;
            const x = t;
            let h;
            if (x > 1 || x < -1)
                h = Math.sqrt(geom.Shape2D.ACCURACY) * x;
            else
                h = Math.sqrt(geom.Shape2D.ACCURACY);
            const answerx = this.derivative(t);
            for (let i = 1; i <= 5; i++) {
                {
                    const diff = (h * i);
                    t = x + diff;
                    let answer = this.derivative(t);
                    ddx += ((answer - answerx) / diff);
                    t = x - diff;
                    answer = this.derivative(t);
                    ddx += ((answerx - answer) / diff);
                }
                ;
            }
            ddx = ddx / 10;
            return ddx;
        }
        /**
         * Returns the curvature of the curve at the given position.
         * @param {number} t
         * @return {number}
         */
        curvature(t) {
            if (!this.isDefined())
                return javaemul.internal.DoubleHelper.NaN;
            const y1 = this.derivative(t);
            const y2 = this.doubleDerivative(t);
            if ( /* isNaN */isNaN(y1) || /* isNaN */ isNaN(y2))
                return javaemul.internal.DoubleHelper.NaN;
            if (Math.abs(y2) < geom.Shape2D.ACCURACY)
                return 0;
            return (y2 / (Math.pow(Math.sqrt(1 + y1 * y1), 3)));
        }
        /**
         * returns tangent circle on the curve
         *
         * @param point
         * @return
         * @param {number} t
         * @return {geom.Circle2D}
         */
        getOscullatingCircle(t) {
            const foot = this.point(t);
            if (foot == null)
                return null;
            let r = this.curvature(t);
            if ( /* isNaN */isNaN(r) || Math.abs(r) < geom.Shape2D.ACCURACY || Math.abs(r) > 1 / geom.Shape2D.ACCURACY)
                return null;
            r = -1 / r;
            let v = this.tangent(t);
            v.normalize();
            v = new math.Vector2(r * v.y, -r * v.x);
            const centre = foot.sum$math_Vector2(v);
            const c = new geom.Circle2D(centre.x, centre.y, Math.abs(r));
            return c;
        }
    }
    geom.Curve2D = Curve2D;
    Curve2D["__class"] = "geom.Curve2D";
    (function (Curve2D) {
        let CAP;
        (function (CAP) {
            CAP[CAP["NONE"] = 0] = "NONE";
            CAP[CAP["FOREARROW"] = 1] = "FOREARROW";
            CAP[CAP["BACKARROW"] = 2] = "BACKARROW";
            CAP[CAP["BULLET"] = 3] = "BULLET";
            CAP[CAP["DOTTED"] = 4] = "DOTTED";
            CAP[CAP["TEXT"] = 5] = "TEXT";
        })(CAP = Curve2D.CAP || (Curve2D.CAP = {}));
    })(Curve2D = geom.Curve2D || (geom.Curve2D = {}));
})(geom || (geom = {}));
(function (geom) {
    /**
     * Class to manage multiple shapes created by single construction
     * @author maheshkurmi
     * @class
     * @extends geom.Shape2D
     */
    class ParentShapeArray2D extends geom.Shape2D {
        /**
         * Returns Child at specified index, returns null if no child is found
         * @param {number} index
         * @return
         * @return {string}
         */
        getChildInfo(index) {
            return this.getShapeInfo();
        }
        /**
         * Recreate shape from its parameters, mainly intended to reparse expression and adding global vars in shapes if any
         * @param {geom.ShapesManager} manager
         */
        onAddShapeToSimulation(manager) {
            super.onAddShapeToSimulation(manager);
            let i = 0;
            const parents = [this];
            while ((true)) {
                {
                    const s = this.getChild(i);
                    if (s == null)
                        break;
                    s.id = this.id + ":" + i;
                    i++;
                    if (s != null && s instanceof geom.Point2D) {
                    }
                    s.showName = this.showName;
                    s.showEqn = this.showEqn;
                    if (s.parents == null)
                        s.parents = parents;
                    s.onAddShapeToSimulation(manager);
                    if (s != null && s instanceof geom.Line2D)
                        s.clip();
                    if (s != null && s instanceof geom.Conic2D)
                        s.clip();
                }
            }
            ;
            super.onAddShapeToSimulation(this.shapesManager);
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return null;
        }
        /**
         *
         * @param {number} strokeWidth
         */
        setLineWidth(strokeWidth) {
            if (strokeWidth > 0) {
                super.setLineWidth(strokeWidth);
                let i = 0;
                while ((true)) {
                    {
                        const shape = this.getChild(i);
                        if (shape == null)
                            break;
                        i++;
                        shape.setLineWidth(strokeWidth);
                    }
                }
                ;
            }
        }
        /**
         *
         * @param {framework.Color} fillColor
         */
        setFillColor(fillColor) {
            super.setFillColor(fillColor);
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    shape.setFillColor(fillColor);
                }
            }
            ;
        }
        /**
         *
         * @param {framework.Color} drawColor
         */
        setDrawColor(drawColor) {
            super.setDrawColor(drawColor);
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    shape.setDrawColor(drawColor);
                }
            }
            ;
        }
        /**
         *
         * @param {geom.Shape2D.DrawMode} drawPattern
         */
        setDrawPattern(drawPattern) {
            super.setDrawPattern(drawPattern);
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    shape.setDrawPattern(drawPattern);
                }
            }
            ;
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    if (shape.visible && shape.__isDefined) {
                        g.setColors(shape.fillColor, shape.drawColor);
                        shape.render(g);
                    }
                }
            }
            ;
        }
        /**
         * @return {boolean} the visible
         */
        isVisible() {
            if (this.visibilityCondition != null) {
                try {
                    this.visible = math.MathUtils.evaluateExpression(this.visibilityCondition, this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables) !== 0;
                    let i = 0;
                    while ((true)) {
                        {
                            const shape = this.getChild(i);
                            if (shape == null)
                                break;
                            i++;
                            shape.visible = this.visible;
                        }
                    }
                    ;
                }
                catch (e) {
                }
            }
            return this.visible;
        }
        /**
         * @param {boolean} visible
         * the visible to set
         */
        setVisible(visible) {
            super.setVisible(visible);
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    shape.setVisible(visible);
                }
            }
            ;
            this.visibilityCondition = null;
        }
        /**
         * Sets element selectable and draggable by mouse or touch events
         * @return
         * @param {boolean} touchable
         */
        setTouchable(touchable) {
            super.setTouchable(touchable);
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    shape.setTouchable(touchable);
                }
            }
            ;
        }
        /**
         *
         * @param {boolean} showEqn
         */
        setShowEqn(showEqn) {
            super.setShowEqn(showEqn);
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    shape.setShowEqn(showEqn);
                }
            }
            ;
        }
        /**
         *
         * @param {boolean} showName
         */
        setShowName(showName) {
            super.setShowName(showName);
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    shape.setShowName(showName);
                }
            }
            ;
        }
        /**
         *
         * @param {string} name
         */
        setName(name) {
            super.setName(name);
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    if (!shape.__isDefined || !shape.touchable || !shape.visible)
                        continue;
                    shape.setName(this.name + "[" + i + "]");
                }
            }
            ;
        }
        /**
         * Returns true if the specified point  lies close to the shape within pixels specified by {@link #ACCURACY_PIXEL}
         * @param {math.Vector2} pt {Vector2 }
         * @return {boolean} {Boolean}
         */
        isSnapped(pt) {
            if (!this.isDefined())
                return false;
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    if (!shape.__isDefined || !shape.touchable || !shape.visible)
                        continue;
                    if (shape.isSnapped(pt))
                        return true;
                }
            }
            ;
            return false;
        }
        /**
         * returns the first child close enough {@link Shape2D#ACCURACY_PIXEL} to the specified pt
         * Used in {@link ShapesManager#getSnappedShape(Vector2, Class)}
         * @param {math.Vector2} pt
         * @param {java.lang.Class} shapeClass
         * @return
         * @return {geom.Shape2D}
         */
        getSnappedShape(pt, shapeClass) {
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    if (!framework.ClassUtils.isInstanceof(shape, shapeClass) || !shape.__isDefined || !shape.visible)
                        continue;
                    if (shape.isSnapped(pt))
                        return shape;
                }
            }
            ;
            return null;
        }
        /**
         * Appends the specified list with the children that are close enough to specified point
         * used in {@link ShapesManager#getCloseShapes(Vector2, Class)}
         * @param {math.Vector2} pt
         * @param {java.util.ArrayList} listToAppend
         * @param {java.lang.Class} shapeClass
         */
        getCloseShapes(pt, shapeClass, listToAppend) {
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    if (!framework.ClassUtils.isInstanceof(shape, shapeClass) || !shape.__isDefined || !shape.visible)
                        continue;
                    if (shape != null && shape instanceof geom.ParentShapeArray2D) {
                        shape.getCloseShapes(pt, shapeClass, listToAppend);
                        continue;
                    }
                    if (shape.distance(pt) < geom.Shape2D.SNAP_DISTANCE) {
                        listToAppend.add(shape);
                    }
                }
            }
            ;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            let dist;
            let minDist = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
            let i = 0;
            while ((true)) {
                {
                    const shape = this.getChild(i);
                    if (shape == null)
                        break;
                    i++;
                    if (!shape.__isDefined || !shape.visible)
                        continue;
                    dist = shape.distance(pt);
                    if (dist < minDist)
                        minDist = dist;
                }
            }
            ;
            return minDist;
        }
    }
    geom.ParentShapeArray2D = ParentShapeArray2D;
    ParentShapeArray2D["__class"] = "geom.ParentShapeArray2D";
})(geom || (geom = {}));
(function (geom) {
    class Polygon2D extends geom.Shape2D {
        constructor(...vertices) {
            super();
            if (this.vertices === undefined) {
                this.vertices = null;
            }
            this.vertices = vertices;
            this.__isDefined = (vertices != null && vertices.length > 1);
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return "";
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Polygon with " + this.vertices.length + " Vertices";
        }
        /**
         *
         * @param {framework.Renderer} gl
         */
        render(gl) {
            if (!this.isDefined())
                return;
            if (this.vertices == null || this.vertices.length === 0)
                return;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            if (!this.isDefined())
                return false;
            let i;
            let j;
            let c = false;
            const nvert = this.vertices.length;
            for (i = 0, j = nvert - 1; i < nvert; j = i++) {
                {
                    if (((this.vertices[i].y > pt.y) !== (this.vertices[j].y > pt.y)) && (pt.x < (this.vertices[j].x - this.vertices[i].x) * (pt.y - this.vertices[i].y) / (this.vertices[j].y - this.vertices[i].y) + this.vertices[i].x))
                        c = !c;
                }
                ;
            }
            return c;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            if (!this.isDefined())
                return javaemul.internal.DoubleHelper.MAX_VALUE;
            let v0 = this.vertices[0];
            let v1;
            let dist = javaemul.internal.DoubleHelper.MAX_VALUE;
            for (let i = 1; i < this.vertices.length; i++) {
                {
                    v1 = this.vertices[i];
                    const d = geom.CurveUtils.getPointOnSegmentClosestToPoint(pt, v0, v1).distance$math_Vector2(pt);
                    if (dist > d)
                        dist = d;
                    v0 = v1;
                }
                ;
            }
            return dist;
        }
    }
    geom.Polygon2D = Polygon2D;
    Polygon2D["__class"] = "geom.Polygon2D";
})(geom || (geom = {}));
(function (geom) {
    class Text2Points2D extends geom.Shape2D {
        constructor(p1, p2, text, xalign, yalign, wrapped, font) {
            if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((typeof text === 'string') || text === null) && ((typeof xalign === 'string') || xalign === null) && ((typeof yalign === 'string') || yalign === null) && ((typeof wrapped === 'string') || wrapped === null) && ((typeof font === 'string') || font === null)) {
                let __args = arguments;
                super();
                if (this.textArray === undefined) {
                    this.textArray = null;
                }
                if (this.font === undefined) {
                    this.font = null;
                }
                this.corner = new math.Vector2();
                this.th = 0;
                this.wrapped = true;
                this.width = 0;
                this.height = 0;
                this.margin = 0.1;
                this.lineheight = 0.1;
                this.xalign = 1;
                this.yalign = 1;
                this.prevP = null;
                this.prevQ = null;
                this.revalidate = true;
                this.HAIR_LINE_CHAR = '\u200a';
                this.parents = [p1, p2];
                this.params = [text, xalign, yalign, wrapped, font];
                this.xalign = /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(xalign, "center") ? 1 : /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(xalign, "right") ? 2 : 0;
                this.yalign = /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(yalign, "center") ? 1 : /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(yalign, "bottom") ? 2 : 0;
                this.wrapped = javaemul.internal.BooleanHelper.parseBoolean(wrapped);
                this.textArray = (new java.util.ArrayList());
                this.font = font;
                this.update();
            }
            else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && text === undefined && xalign === undefined && yalign === undefined && wrapped === undefined && font === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let text = "You can add any multiline text to this element by editing \'text\' property of the element in property table. \n This element also supports automatic wrapping of text along with horizontal and vertical alignment options to create dynamic text geometry.";
                    let xalign = "center";
                    let yalign = "center";
                    let wrapped = "true";
                    let font = "default-normal";
                    super();
                    if (this.textArray === undefined) {
                        this.textArray = null;
                    }
                    if (this.font === undefined) {
                        this.font = null;
                    }
                    this.corner = new math.Vector2();
                    this.th = 0;
                    this.wrapped = true;
                    this.width = 0;
                    this.height = 0;
                    this.margin = 0.1;
                    this.lineheight = 0.1;
                    this.xalign = 1;
                    this.yalign = 1;
                    this.prevP = null;
                    this.prevQ = null;
                    this.revalidate = true;
                    this.HAIR_LINE_CHAR = '\u200a';
                    this.parents = [p1, p2];
                    this.params = [text, xalign, yalign, wrapped, font];
                    this.xalign = /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(xalign, "center") ? 1 : /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(xalign, "right") ? 2 : 0;
                    this.yalign = /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(yalign, "center") ? 1 : /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(yalign, "bottom") ? 2 : 0;
                    this.wrapped = javaemul.internal.BooleanHelper.parseBoolean(wrapped);
                    this.textArray = (new java.util.ArrayList());
                    this.font = font;
                    this.update();
                }
                if (this.textArray === undefined) {
                    this.textArray = null;
                }
                if (this.font === undefined) {
                    this.font = null;
                }
                this.corner = new math.Vector2();
                this.th = 0;
                this.wrapped = true;
                this.width = 0;
                this.height = 0;
                this.margin = 0.1;
                this.lineheight = 0.1;
                this.xalign = 1;
                this.yalign = 1;
                this.prevP = null;
                this.prevQ = null;
                this.revalidate = true;
                this.HAIR_LINE_CHAR = '\u200a';
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0) {
                geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Text", this.params[0], null);
                geom.Shape2D.editInfo_$LI$().type = framework.EditInfo.TYPE.MULTILINE_TEXT;
                return geom.Shape2D.editInfo_$LI$();
            }
            else if (index === 1) {
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$int$java_lang_String_A("X Alignment", this.xalign, ["Left", "Center", "Right", "justify"]);
            }
            else if (index === 2) {
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$int$java_lang_String_A("Y Alignment", this.yalign, ["Top", "Center", "Bottom"]);
            }
            else if (index === 3) {
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Wrapped", this.wrapped);
            }
            else if (index === 4) {
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String("Font", this.font);
            }
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            const _var = value + "";
            if (index === 0) {
                this.params[0] = _var;
            }
            else if (index === 1) {
                this.params[1] = _var;
                this.xalign = /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(_var, "center") ? 1 : /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(_var, "right") ? 2 : /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(_var, "left") ? 0 : 3;
            }
            else if (index === 2) {
                this.params[2] = _var;
                this.yalign = /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(_var, "center") ? 1 : /* equalsIgnoreCase */ ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(_var, "bottom") ? 2 : 0;
            }
            else if (index === 3) {
                this.params[3] = _var;
                this.wrapped = javaemul.internal.BooleanHelper.parseBoolean(_var);
            }
            else if (index === 4) {
                this.font = _var;
            }
            this.revalidate = true;
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].__isDefined || !this.parents[1].__isDefined)
                return;
            this.__isDefined = true;
            this.revalidate = true;
        }
        /*private*/ measureSize(g) {
            const ctx = g.context;
            const P = this.parents[0].pt;
            const Q = this.parents[1].pt;
            if ((this.prevP != null && this.prevP.approxEqual(P) && this.prevQ.approxEqual(Q)))
                return;
            if (P.equals$math_Vector2(Q))
                return;
            const scaleFactor = g.METER_TO_PIXEL;
            Text2Points2D.tmpVec = P.to$math_Vector2(Q);
            this.th = Text2Points2D.tmpVec.getDirection();
            this.width = Text2Points2D.tmpVec.normalize();
            this.margin = 10 / scaleFactor;
            this.lineheight = parseInt(ctx.font) * 1.5 / scaleFactor;
            this.height = 0;
            const justify = this.xalign === 3;
            const temptextarray = this.params[0].split("\n");
            this.textArray.clear();
            const hairLineCharWidth = justify ? ctx.measureText(this.HAIR_LINE_CHAR + "").width / scaleFactor : 0;
            const textWrapwidth = this.width - 2 * this.margin;
            if (this.wrapped === false) {
                this.width = 2 * this.margin;
            }
            else {
                if (textWrapwidth < this.lineheight * 2)
                    return;
            }
            for (let index = 0; index < temptextarray.length; index++) {
                let txtt = temptextarray[index];
                {
                    if ( /* isEmpty */(txtt.length === 0))
                        txtt = " ";
                    let textwidth = ctx.measureText(txtt).width / scaleFactor;
                    if (this.wrapped === false) {
                        this.width = Math.max(this.width, textwidth + 2 * this.margin);
                        this.textArray.add(txtt);
                        continue;
                    }
                    if (textwidth < textWrapwidth) {
                        this.textArray.add(txtt);
                    }
                    else {
                        let temptext = txtt;
                        const linelen = textWrapwidth;
                        let textlen;
                        let textpixlen;
                        let texttoprint;
                        while ((textwidth > linelen)) {
                            {
                                textlen = 0;
                                textpixlen = 0;
                                texttoprint = "";
                                while ((textpixlen < linelen)) {
                                    {
                                        if (textlen === temptext.length)
                                            break;
                                        textlen++;
                                        texttoprint = temptext.substring(0, textlen);
                                        textpixlen = ctx.measureText(temptext.substring(0, textlen)).width / scaleFactor;
                                    }
                                }
                                ;
                                textlen--;
                                if (textlen === 0)
                                    textlen = temptext.indexOf(' ');
                                if (textlen < 0)
                                    textlen = temptext.length - 1;
                                texttoprint = texttoprint.substring(0, textlen);
                                const backup = textlen;
                                if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(temptext.charAt(textlen)) != ' '.charCodeAt(0)) {
                                    while (((c => c.charCodeAt == null ? c : c.charCodeAt(0))(temptext.charAt(textlen)) != ' '.charCodeAt(0) && textlen !== 0)) {
                                        {
                                            textlen--;
                                        }
                                    }
                                    ;
                                    if (textlen === 0) {
                                        textlen = backup;
                                    }
                                    texttoprint = temptext.substring(0, textlen);
                                }
                                texttoprint = justify ? this.justifyLine(ctx, texttoprint, hairLineCharWidth, this.HAIR_LINE_CHAR, textWrapwidth) : texttoprint;
                                temptext = temptext.substring(textlen + 1);
                                textwidth = ctx.measureText(temptext).width / scaleFactor;
                                this.textArray.add(texttoprint);
                            }
                        }
                        ;
                        if (textwidth > 0) {
                            this.textArray.add(temptext);
                        }
                    }
                }
            }
            this.height = this.textArray.size() * this.lineheight + 2 * this.margin;
            switch ((this.yalign)) {
                case 0:
                    break;
                case 1:
                    break;
                case 2:
                    break;
            }
            switch ((this.xalign)) {
                case 0:
                    break;
                case 1:
                    break;
                case 2:
                    break;
            }
            this.corner.set$math_Vector2(P);
            this.revalidate = false;
        }
        /**
         * This function will insert spaces between words in a line in order
         * to raise the line width to the box width.
         * The spaces are evenly spread in the line, and extra spaces (if any) are inserted
         * between the first words.
         *
         * It returns the justified text.
         *
         * @param {string} line
         * @param {number} spaceWidth
         * @param {char} spaceChar
         * @param {number} width of bounding rectangle
         * @param {CanvasRenderingContext2D} ctx
         * @param {string} line
         * @param {number} hairLineWidth
         * @param {string} hairlineChar
         * @param {number} width
         * @return {string}
         * @private
         */
        /*private*/ justifyLine(ctx, line, hairLineWidth, hairlineChar, width) {
            const text = line.trim();
            const scaleFactor = 100.0;
            const lineWidth = ctx.measureText(text).width / scaleFactor;
            const words = text.split("\\s+");
            const nbSpaces = words.length - 1;
            const nbHairLinesToInsert = (Math.floor((width - lineWidth) / hairLineWidth) | 0);
            if (nbSpaces <= 0 || nbHairLinesToInsert <= 0)
                return text;
            const nbHairLinesMinimum = (Math.floor((nbHairLinesToInsert / nbSpaces | 0)) | 0);
            const extraSpaces = nbHairLinesToInsert - nbSpaces * nbHairLinesMinimum;
            const spaces = new java.lang.StringBuilder(nbHairLinesMinimum);
            for (let i = 0; i < nbHairLinesMinimum; i++) {
                {
                    spaces.append(hairlineChar);
                }
                ;
            }
            return text;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Text Area with corners " + (this.parents[0] == null ? "" : this.parents[0].getName()) + (this.parents[1] == null ? "" : " , " + this.parents[1].getName());
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return null;
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.__isDefined)
                return;
            if (this.revalidate)
                this.measureSize(g);
            g.setColors(this.fillColor, this.drawColor);
            const ctx = g.context;
            ctx.save();
            ctx.translate(this.corner.x, this.corner.y);
            ctx.rotate(this.th);
            let y = 0;
            let x = 0;
            switch ((this.yalign)) {
                case 0:
                    y = 0;
                    break;
                case 1:
                    y = this.height / 2;
                    break;
                case 2:
                    y = this.height;
                    break;
            }
            if (this.fillColor != null) {
                g.drawRect(0, y, this.width, this.height, true, true);
            }
            const scaleFactor = 100.0;
            if (this.drawColor != null) {
                y -= (this.lineheight + this.margin);
                ctx.textBaseline = "middle";
                for (let index = this.textArray.iterator(); index.hasNext();) {
                    let s = index.next();
                    {
                        switch ((this.xalign)) {
                            case 0:
                            case 3:
                                x = Math.fround(this.margin);
                                break;
                            case 1:
                                x = Math.fround((this.width / 2 - ctx.measureText(s).width / 2 / scaleFactor));
                                break;
                            case 2:
                                x = Math.fround((this.width - this.margin - ctx.measureText(s).width / scaleFactor));
                                break;
                        }
                        g.drawText$java_lang_String$double$double(s, x, y);
                        y -= this.lineheight;
                    }
                }
            }
            ctx.restore();
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            const p = pt.difference$math_Vector2(this.corner);
            p.rotate$double(-this.th);
            let y1 = 0;
            let y2 = -this.height;
            switch ((this.yalign)) {
                case 1:
                    y1 = this.height / 2;
                    y2 = -this.height / 2;
                    break;
                case 2:
                    y1 = this.height;
                    y2 = 0;
                    break;
            }
            return p.x > 0 && p.x < this.width && p.y < y1 && p.y > y2;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            const p = pt.difference$math_Vector2(this.corner);
            p.rotate$double(-this.th);
            let dx = Math.max(-p.x, p.x - this.width);
            if (dx < 0)
                dx = 0;
            let dy = Math.max(-p.y, p.y - this.height);
            if (dy < 0)
                dy = 0;
            return Math.sqrt(dx * dx + dy * dy);
        }
    }
    /**
     * unit vector along horizontally right direction in text area frame
     */
    Text2Points2D.tmpVec = null;
    geom.Text2Points2D = Text2Points2D;
    Text2Points2D["__class"] = "geom.Text2Points2D";
})(geom || (geom = {}));
(function (geom) {
    class Label2D extends geom.Shape2D {
        constructor(x, y, label) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof label === 'string') || label === null)) {
                let __args = arguments;
                super();
                if (this.r === undefined) {
                    this.r = 0;
                }
                if (this.th === undefined) {
                    this.th = 0;
                }
                if (this.x0 === undefined) {
                    this.x0 = 0;
                }
                if (this.y0 === undefined) {
                    this.y0 = 0;
                }
                if (this.segment === undefined) {
                    this.segment = null;
                }
                this.label = "info";
                this.x0 = x;
                this.y0 = y;
                this.label = label;
                this.r = 3 * geom.Shape2D.SNAP_DISTANCE;
                Label2D.rMax = this.r * 2.0;
                this.th = 0;
                this.__isDefined = true;
                this.showEqn = true;
                this.showName = true;
            }
            else if (((x != null && x instanceof geom.Point2D) || x === null) && ((typeof y === 'string') || y === null) && label === undefined) {
                let __args = arguments;
                let pt = __args[0];
                let label = __args[1];
                {
                    let __args = arguments;
                    let x = pt.pt.x;
                    let y = pt.pt.y;
                    super();
                    if (this.r === undefined) {
                        this.r = 0;
                    }
                    if (this.th === undefined) {
                        this.th = 0;
                    }
                    if (this.x0 === undefined) {
                        this.x0 = 0;
                    }
                    if (this.y0 === undefined) {
                        this.y0 = 0;
                    }
                    if (this.segment === undefined) {
                        this.segment = null;
                    }
                    this.label = "info";
                    this.x0 = x;
                    this.y0 = y;
                    this.label = label;
                    this.r = 3 * geom.Shape2D.SNAP_DISTANCE;
                    Label2D.rMax = this.r * 2.0;
                    this.th = 0;
                    this.__isDefined = true;
                    this.showEqn = true;
                    this.showName = true;
                }
                if (this.r === undefined) {
                    this.r = 0;
                }
                if (this.th === undefined) {
                    this.th = 0;
                }
                if (this.x0 === undefined) {
                    this.x0 = 0;
                }
                if (this.y0 === undefined) {
                    this.y0 = 0;
                }
                if (this.segment === undefined) {
                    this.segment = null;
                }
                this.label = "info";
                (() => {
                    this.parents = [pt];
                    this.update();
                })();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         */
        update() {
            if (this.parents == null)
                return;
            if (!this.parents[0].__isDefined) {
                this.__isDefined = false;
                return;
            }
            const pt = this.parents[0];
            this.x0 = pt.pt.x;
            this.y0 = pt.pt.y;
            this.__isDefined = true;
        }
        setLabel(label) {
            this.label = label;
        }
        /**
         *
         * @param {math.Vector2} delta
         * @param {math.Vector2} worldPt
         * @param {boolean} manually
         */
        mouseDragged(delta, worldPt, manually) {
            if (!this.__isDefined)
                return;
            const dir = new math.Vector2(this.th);
            this.th -= delta.cross$math_Vector2(dir) / this.r;
            this.r += delta.dot$math_Vector2(dir);
            this.r = math.MathUtils.clamp$double$double$double(this.r, Label2D.rMax / 5, Label2D.rMax);
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return this.label;
        }
        /**
         *
         * @param {framework.Renderer} gl
         */
        render(gl) {
            if (!this.__isDefined || !this.visible)
                return;
            const rect = gl.context.measureText(this.label);
            let r = this.r;
            const v = new math.Vector2(this.x0 + r * Math.cos(this.th), this.y0 + r * Math.sin(this.th));
            r += rect.width / gl.METER_TO_PIXEL;
            const v1 = new math.Vector2(this.x0 + r * Math.cos(this.th), this.y0 + r * Math.sin(this.th));
            this.segment = new geom.Segment2D(v, v1);
            if (this.showEqn)
                geom.Shape2D.renderInfo(gl, this.label, v, v1, 0, 1, this.drawColor, this.fillColor);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            if (!this.__isDefined)
                return false;
            return this.segment != null ? this.segment.contains(pt) : pt.distance$double$double(this.x0, this.y0) < geom.Shape2D.SNAP_DISTANCE;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Label:" + this.label;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            if (!this.__isDefined)
                return javaemul.internal.DoubleHelper.MAX_VALUE;
            return this.segment != null ? this.segment.distance(pt) : pt.distance$double$double(this.x0, this.y0);
        }
        /**
         *
         * @return {boolean}
         */
        isFreeToMove() {
            return this.__isDefined;
        }
    }
    Label2D.rMax = 0;
    geom.Label2D = Label2D;
    Label2D["__class"] = "geom.Label2D";
})(geom || (geom = {}));
(function (geom) {
    class ChildShapeParentIndex2D extends geom.Shape2D {
        /**
         *
         * @return {string}
         */
        getEquation() {
            return null;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return null;
        }
        /**
         *
         * @param {framework.Renderer} gl
         */
        render(gl) {
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            return false;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            return 0;
        }
    }
    geom.ChildShapeParentIndex2D = ChildShapeParentIndex2D;
    ChildShapeParentIndex2D["__class"] = "geom.ChildShapeParentIndex2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Create free Point
     * @param {number} x
     * @param {number} y
     * @class
     * @extends geom.Point2D
     * @author Mahesh
     */
    class FreePoint2D extends geom.Point2D {
        constructor(x, y) {
            if (((typeof x === 'string') || x === null) && ((typeof y === 'string') || y === null)) {
                let __args = arguments;
                super(0, 0);
                this.params = [x, y];
                try {
                    const xx = javaemul.internal.DoubleHelper.parseDouble(x);
                    const yy = javaemul.internal.DoubleHelper.parseDouble(y);
                    this.pt = new math.Vector2(xx, yy);
                    this.__isDefined = true;
                }
                catch (e) {
                    this.__isDefined = false;
                }
                this.showName = true;
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                let __args = arguments;
                super(x, y);
                this.params = [x + "", y + ""];
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                let __args = arguments;
                let v = __args[0];
                {
                    let __args = arguments;
                    let x = v.x;
                    let y = v.y;
                    super(x, y);
                    this.params = [x + "", y + ""];
                }
            }
            else if (((x != null && x instanceof geom.Point2D) || x === null) && y === undefined) {
                let __args = arguments;
                let p = __args[0];
                {
                    let __args = arguments;
                    let v = p.pt;
                    {
                        let __args = arguments;
                        let x = v.x;
                        let y = v.y;
                        super(x, y);
                        this.params = [x + "", y + ""];
                    }
                }
                (() => {
                    this.__isDefined = false;
                })();
            }
            else if (x === undefined && y === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let x = 0;
                    let y = 0;
                    super(x, y);
                    this.params = [x + "", y + ""];
                }
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$math_Vector2("Position", new math.Vector2(this.pt));
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                const v = null;
                if (v == null)
                    return;
                this.pt.set$double$double(v.x, v.y);
                this.params[0] = this.pt.x + "";
                this.params[1] = this.pt.y + "";
            }
        }
        isFreeToMove() {
            return true;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Free Point " + this.name;
        }
        /**
         *
         * @param {math.Vector2} delta
         * @param {math.Vector2} worldPt
         * @param {boolean} manually
         */
        mouseDragged(delta, worldPt, manually) {
            if (!this.isDefined() || delta.isZero())
                return;
            if (!manually)
                this.delta.set$double$double(0, 0);
            const p = this.pt.copy();
            this.delta.add$math_Vector2(delta);
            this.pt.add$math_Vector2(this.delta);
            if (manually)
                this.pt = this.shapesManager.preferences.snapToGrid(this.pt);
            if (!(Math.abs(p.x - this.pt.x) < geom.Shape2D.ACCURACY) || !(Math.abs(p.y - this.pt.y) < geom.Shape2D.ACCURACY))
                this.delta.set$double$double(0, 0);
            this.params = [this.pt.x + "", this.pt.y + ""];
        }
    }
    geom.FreePoint2D = FreePoint2D;
    FreePoint2D["__class"] = "geom.FreePoint2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Tangent to a curve at a given point.
     * @param curve
     * @param point
     * @param {geom.Conic2D} conic
     * @param {geom.Line2D} line
     * @class
     * @extends geom.Point2D
     * @author mahesh kurmi
     */
    class PoleConicLine2D extends geom.Point2D {
        constructor(conic, line) {
            super();
            this.parents = [conic, line];
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined())
                return;
            const conic = this.parents[0];
            const line = this.parents[1];
            const p = conic.getPole(line);
            if (p != null) {
                this.pt.set$double$double(p.x, p.y);
                this.__isDefined = true;
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Pole of conic  " + this.parents[0].getName() + " wrt Line " + this.parents[1].getName();
        }
    }
    geom.PoleConicLine2D = PoleConicLine2D;
    PoleConicLine2D["__class"] = "geom.PoleConicLine2D";
})(geom || (geom = {}));
(function (geom) {
    class PointRatio2D extends geom.Point2D {
        constructor(pt1, pt2, ratio) {
            super();
            this.parents = [pt1, pt2];
            this.params = [ratio];
            this.update();
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Ratio (k)", this.params[0], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                this.update();
            }
        }
        /**
         * Sets the ratio in which this point divides its parent points
         * @param {string} ratio
         */
        setRatio(ratio) {
            this.params[0] = ratio;
            this.update();
        }
        /**
         * returns the ratio in which this point divides its parent points
         * @return
         * @return {string}
         */
        getRatio() {
            return this.params[0];
        }
        /**
         *
         */
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            let ratio;
            try {
                ratio = math.MathUtils.evaluateExpression(this.params[0], this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables);
            }
            catch (e) {
                this.__isDefined = false;
                return;
            }
            if (ratio === -1) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[0].pt;
            const v2 = this.parents[1].pt;
            this.pt = new math.Vector2((v2.x * ratio + v1.x) / (ratio + 1), (v2.y * ratio + v1.y) / (ratio + 1));
            this.__isDefined = true;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Point dividing " + this.parents[0].getName() + " & " + this.parents[1].getName() + " in ratio " + this.params[0] + ":1";
        }
    }
    geom.PointRatio2D = PointRatio2D;
    PointRatio2D["__class"] = "geom.PointRatio2D";
})(geom || (geom = {}));
(function (geom) {
    class PointReflectionLine2D extends geom.Point2D {
        constructor(line, pt) {
            super();
            this.parents = [line, pt];
            this.params = null;
            this.update();
        }
        /**
         *
         */
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v = this.parents[1].pt;
            const line = this.parents[0];
            const p = line.getPoint();
            const dot = geom.Shape2D.TMP_VEC_$LI$().set$double$double(p.x - v.x, p.y - v.y).dot$double$double(line.dx, line.dy);
            geom.Shape2D.TMP_VEC_$LI$().set$double$double(geom.Shape2D.TMP_VEC_$LI$().x - dot * line.dx, geom.Shape2D.TMP_VEC_$LI$().y - dot * line.dy);
            if (this.pt == null)
                this.pt = v.copy();
            else
                this.pt.set$math_Vector2(v);
            this.pt.addScaled(2, geom.Shape2D.TMP_VEC_$LI$());
            this.__isDefined = true;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Reflection of " + this.parents[1].getName() + " on " + this.parents[0].getName();
        }
    }
    geom.PointReflectionLine2D = PointReflectionLine2D;
    PointReflectionLine2D["__class"] = "geom.PointReflectionLine2D";
})(geom || (geom = {}));
(function (geom) {
    class PointExpr2D extends geom.Point2D {
        constructor(xExpr, yExpr) {
            super();
            if (this.xExpr === undefined) {
                this.xExpr = null;
            }
            if (this.yExpr === undefined) {
                this.yExpr = null;
            }
            this.setExpressions(xExpr, yExpr);
            this.update();
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("X Coordinate", this.getExpressionX(), null);
            else if (index === 1)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Y Coordinate", this.getExpressionY(), null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                this.xExpr = this.params[0];
                this.update();
            }
            else if (index === 1) {
                this.params[1] = (value + "");
                this.yExpr = this.params[1];
                this.update();
            }
        }
        getExpressionX() {
            if (this.xExpr == null)
                return "0";
            return this.xExpr;
        }
        getExpressionY() {
            if (this.yExpr == null)
                return "0";
            return this.yExpr;
        }
        /**
         * Sets expression for the field, the expression can be a function of position <b>x</b>, <b>y</b> or polar coordinates  <b>r</b> and  <b>th</b>(theta)
         * @param {string} xExpr expression for x component of field
         * @param {string} yExpr expression for y component of field
         */
        setExpressions(xExpr, yExpr) {
            if (xExpr == null || /* isEmpty */ (xExpr.length === 0))
                xExpr = "0";
            if (yExpr == null || /* isEmpty */ (yExpr.length === 0))
                yExpr = "0";
            this.params = [xExpr, yExpr];
            this.__isDefined = false;
            this.xExpr = xExpr;
            this.yExpr = yExpr;
            this.update();
        }
        /**
         * Recreate shape from its parameters, mainly intended to reparse expression in shapes if any
         * @param {geom.ShapesManager} manager
         */
        onAddShapeToSimulation(manager) {
            super.onAddShapeToSimulation(manager);
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return "(" + this.xExpr + " , " + this.yExpr + ")";
        }
        /**
         *
         */
        update() {
            this.pt = null;
            this.__isDefined = false;
            try {
                const x = math.MathUtils.evaluateExpression(this.xExpr, this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables);
                const y = math.MathUtils.evaluateExpression(this.yExpr, this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables);
                this.pt = (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(x) || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(y)) ? null : new math.Vector2(x, y);
                this.__isDefined = (this.pt != null);
            }
            catch (e) {
                return;
            }
        }
    }
    geom.PointExpr2D = PointExpr2D;
    PointExpr2D["__class"] = "geom.PointExpr2D";
})(geom || (geom = {}));
(function (geom) {
    class ShapeArray {
        constructor() {
            if (this.shapes === undefined) {
                this.shapes = null;
            }
            this.shapes = (new java.util.ArrayList());
        }
        static clazz_$LI$() { if (ShapeArray.clazz == null) {
            ShapeArray.clazz = geom.Point2D;
        } return ShapeArray.clazz; }
        addShape(shape) {
            this.shapes.add(shape);
        }
        getShapes() {
            return this.shapes;
        }
    }
    geom.ShapeArray = ShapeArray;
    ShapeArray["__class"] = "geom.ShapeArray";
})(geom || (geom = {}));
(function (geom) {
    class PointProjection2D extends geom.Point2D {
        constructor(curve, pt) {
            super();
            this.parents = [curve, pt];
            this.params = null;
            this.update();
        }
        /**
         *
         */
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            let v = this.parents[1].pt;
            const t = this.parents[0].t(v);
            v = this.parents[0].point(t);
            if (v != null) {
                this.pt = v;
                this.__isDefined = true;
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Foot of " + this.parents[1].getName() + " on " + this.parents[0].getName();
        }
    }
    geom.PointProjection2D = PointProjection2D;
    PointProjection2D["__class"] = "geom.PointProjection2D";
})(geom || (geom = {}));
(function (geom) {
    class PointOnCurve2D extends geom.Point2D {
        constructor(curve, t) {
            if (((curve != null && curve instanceof geom.Curve2D) || curve === null) && ((typeof t === 'string') || t === null)) {
                let __args = arguments;
                super();
                this.t = 0;
                this.parserNeeded = false;
                this.parents = [curve];
                this.params = [t + ""];
                try {
                    this.t = javaemul.internal.DoubleHelper.parseDouble(t);
                    this.parserNeeded = false;
                }
                catch (e) {
                    this.parserNeeded = true;
                }
                this.update();
            }
            else if (((curve != null && curve instanceof geom.Curve2D) || curve === null) && ((typeof t === 'number') || t === null)) {
                let __args = arguments;
                super();
                this.t = 0;
                this.parserNeeded = false;
                this.parents = [curve];
                this.params = [t + ""];
                this.t = t;
                this.parserNeeded = false;
                this.update();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Parameter", this.params[0], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = value + "";
                try {
                    this.t = javaemul.internal.DoubleHelper.parseDouble(this.params[0]);
                    this.parserNeeded = false;
                }
                catch (e) {
                    this.parserNeeded = true;
                }
                this.update();
            }
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined()) {
                return;
            }
            if (this.parserNeeded) {
                try {
                    this.t = math.MathUtils.evaluateExpression(this.params[0], this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables);
                }
                catch (e) {
                    return;
                }
            }
            this.pt = this.parents[0].point(this.t);
            this.__isDefined = (this.pt != null);
        }
        /**
         *
         * @param {math.Vector2} delta
         * @param {math.Vector2} worldPt
         * @param {boolean} manually
         */
        mouseDragged(delta, worldPt, manually) {
            if (!this.isDefined())
                return;
            try {
                this.t = javaemul.internal.DoubleHelper.parseDouble(this.params[0]);
            }
            catch (e) {
                return;
            }
            let p = this.pt.copy();
            this.delta.add$math_Vector2(delta);
            p.add$math_Vector2(this.delta);
            if (manually)
                this.pt = this.shapesManager.preferences.snapToGrid(this.pt);
            const t = this.parents[0].t(p);
            p = this.parents[0].point(t);
            if (p != null && (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(p.x) || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(p.y)))
                p = null;
            if (p == null || !p.approxEqual(this.pt))
                this.delta.set$double$double(0, 0);
            if (p != null) {
                this.pt = p;
                this.t = t;
                this.params[0] = t + "";
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Point on " + this.parents[0].getName();
        }
        isFreeToMove() {
            return true;
        }
    }
    geom.PointOnCurve2D = PointOnCurve2D;
    PointOnCurve2D["__class"] = "geom.PointOnCurve2D";
})(geom || (geom = {}));
(function (geom) {
    class PointIntersection2Curves2D extends geom.Point2D {
        constructor(curve1, curve2, x, y) {
            if (((curve1 != null && curve1 instanceof geom.Curve2D) || curve1 === null) && ((curve2 != null && curve2 instanceof geom.Curve2D) || curve2 === null) && ((typeof x === 'string') || x === null) && ((typeof y === 'string') || y === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let pt = new math.Vector2(javaemul.internal.DoubleHelper.parseDouble(x), javaemul.internal.DoubleHelper.parseDouble(y));
                    super();
                    this.parents = [curve1, curve2];
                    this.pt = pt;
                    this.params = [pt.x + "", pt.y + ""];
                    this.fillColor = new framework.Color(160, 160, 160);
                    this.drawColor = new framework.Color(60, 60, 60);
                    this.update();
                }
            }
            else if (((curve1 != null && curve1 instanceof geom.Curve2D) || curve1 === null) && ((curve2 != null && curve2 instanceof geom.Curve2D) || curve2 === null) && ((x != null && x instanceof math.Vector2) || x === null) && y === undefined) {
                let __args = arguments;
                let pt = __args[2];
                super();
                this.parents = [curve1, curve2];
                this.pt = pt;
                this.params = [pt.x + "", pt.y + ""];
                this.fillColor = new framework.Color(160, 160, 160);
                this.drawColor = new framework.Color(60, 60, 60);
                this.update();
            }
            else
                throw new Error('invalid overload');
        }
        update() {
            if (!this.parents[0].isDefined() || !this.parents[0].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const curve1 = this.parents[0];
            const p = curve1.point(curve1.t(this.pt));
            const pts = geom.CurveUtils.getIntersections(this.parents[0], this.parents[1], p);
            if (pts == null || pts.length === 0) {
                this.__isDefined = false;
                return;
            }
            if (pts.length === 1 && pts[0] != null) {
                this.__isDefined = true;
                this.pt = pts[0];
            }
            else {
                let minDist = javaemul.internal.DoubleHelper.MAX_VALUE;
                let nearestPt = null;
                this.__isDefined = false;
                for (let index = 0; index < pts.length; index++) {
                    let v = pts[index];
                    {
                        if (v == null)
                            continue;
                        const d = v.distance$math_Vector2(this.pt);
                        if (d < minDist) {
                            this.__isDefined = true;
                            nearestPt = v;
                            minDist = d;
                        }
                    }
                }
                this.pt = nearestPt;
            }
            this.params[0] = this.pt.x + "";
            this.params[1] = this.pt.y + "";
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Intersection of " + this.parents[0].getName() + " & " + this.parents[1].getName();
        }
    }
    geom.PointIntersection2Curves2D = PointIntersection2Curves2D;
    PointIntersection2Curves2D["__class"] = "geom.PointIntersection2Curves2D";
})(geom || (geom = {}));
(function (geom) {
    class PointConicCenter extends geom.Point2D {
        constructor(circle) {
            super();
            this.parents = [circle];
            this.update();
        }
        /**
         *
         */
        update() {
            if (!this.parents[0].__isDefined) {
                this.__isDefined = false;
                return;
            }
            this.pt = this.parents[0].center();
            this.__isDefined = true;
        }
        /**
         *
         * @param {math.Vector2} delta
         * @param {math.Vector2} pt
         * @param {boolean} manually
         */
        mouseDragged(delta, pt, manually) {
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Center of " + this.parents[0].getName();
        }
        isFreeToMove() {
            return false;
        }
    }
    geom.PointConicCenter = PointConicCenter;
    PointConicCenter["__class"] = "geom.PointConicCenter";
})(geom || (geom = {}));
(function (geom) {
    /**
     * A set of points located at critical point on explicit curve
     * @author Mahesh
     * @param {geom.FunctionExplicit2D} func
     * @param {number} x
     * @class
     * @extends geom.Point2D
     */
    class CriticalPointFunction2D extends geom.Point2D {
        constructor(func, x) {
            if (((func != null && func instanceof geom.FunctionExplicit2D) || func === null) && ((typeof x === 'string') || x === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let x = javaemul.internal.DoubleHelper.parseDouble(__args[1]);
                    super();
                    this.x = 0;
                    this.x = x;
                    this.parents = [func];
                    this.params = [x + ""];
                    this.update();
                }
                this.x = 0;
            }
            else if (((func != null && func instanceof geom.FunctionExplicit2D) || func === null) && ((typeof x === 'number') || x === null)) {
                let __args = arguments;
                super();
                this.x = 0;
                this.x = x;
                this.parents = [func];
                this.params = [x + ""];
                this.update();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         */
        update() {
            super.update();
            this.__isDefined = false;
            if (!this.parents[0].__isDefined)
                return;
            const f = this.parents[0];
            let answer = f.getCriticalPoint(this.x);
            let tries = 0;
            while (( /* isNaN */isNaN(answer))) {
                {
                    tries++;
                    if (tries > 5)
                        return;
                    answer = f.getCriticalPoint(this.x + (Math.random() - 0.5) / 100);
                }
            }
            ;
            if ( /* isNaN */isNaN(answer))
                return;
            this.pt = new math.Vector2(answer, f.getY(answer));
            this.x = answer;
            this.params[0] = this.x + "";
            this.__isDefined = true;
        }
        isFreeToMove() {
            return false;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Critical Point on " + this.parents[0].name;
        }
    }
    geom.CriticalPointFunction2D = CriticalPointFunction2D;
    CriticalPointFunction2D["__class"] = "geom.CriticalPointFunction2D";
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalImageWrapper2D extends geom.Point2D {
            constructor(observer, index) {
                if (((observer != null && (observer.constructor != null && observer.constructor["__interfaces"] != null && observer.constructor["__interfaces"].indexOf("geom.optics.OpticalObserver") >= 0)) || observer === null) && ((typeof index === 'string') || index === null)) {
                    let __args = arguments;
                    super();
                    this.index = -1;
                    try {
                        this.index = javaemul.internal.IntegerHelper.parseInt(index);
                    }
                    catch (e) {
                    }
                    this.parents = [observer];
                    this.params = [index];
                    this.update();
                }
                else if (((observer != null && (observer.constructor != null && observer.constructor["__interfaces"] != null && observer.constructor["__interfaces"].indexOf("geom.optics.OpticalObserver") >= 0)) || observer === null) && ((typeof index === 'number') || index === null)) {
                    let __args = arguments;
                    super();
                    this.index = -1;
                    this.parents = [observer];
                    this.params = [index + ""];
                    this.index = index;
                    this.update();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             */
            update() {
                this.__isDefined = false;
                if (!this.parents[0].isDefined() || this.index < 0)
                    return;
                const observer = this.parents[0];
                const pt = observer.getOpticalImageAtIndex(this.index);
                if (pt != null) {
                    this.pt.set$math_Vector2(pt);
                    this.__isDefined = true;
                }
            }
            getShapeInfo() {
                return "Image" + this.index + " by " + this.parents[0].getName();
            }
        }
        optics.OpticalImageWrapper2D = OpticalImageWrapper2D;
        OpticalImageWrapper2D["__class"] = "geom.optics.OpticalImageWrapper2D";
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    class Path2D extends geom.Curve2D {
        constructor() {
            super();
            this.curves = (new java.util.ArrayList());
        }
        createPath(vertices, arcInfo) {
            this.__isDefined = false;
            if (vertices.length < 2)
                return;
            this.curves.clear();
            let p0 = vertices[0];
            let p;
            const n = vertices.length;
            for (let i = 1; i < n; i++) {
                {
                    p = vertices[i];
                    if (arcInfo[i] === false) {
                        if (arcInfo[i - 1] === false)
                            this.curves.add(new geom.Segment2D(p0, p));
                        if (i === n - 1 && n > 2)
                            this.curves.add(new geom.Segment2D(p, vertices[0]));
                        p0 = p;
                    }
                    else {
                        const p2 = vertices[(i + 1) % n];
                        if (math.Vector2.isCollinear(p0, p, p2)) {
                            this.curves.add(new geom.Segment2D(p0, p2));
                            p0 = p2;
                            if (i < n - 2)
                                i++;
                            continue;
                        }
                        const arc = new geom.CircleArc2D();
                        arc.set$math_Vector2$math_Vector2$math_Vector2(p0, p, p2);
                        if (arc.__isDefined === false) {
                            this.curves.add(new geom.Segment2D(p0, p2));
                            p0 = p2;
                            if (i < n - 2)
                                i++;
                            continue;
                        }
                        this.curves.add(arc);
                        p0 = p2;
                        if (i < n - 2)
                            i++;
                    }
                }
                ;
            }
            this.__t0 = 0;
            this.__t1 = this.curves.size();
            if (this.fillColor != null) {
                p0 = vertices[0];
                for (let index = this.curves.iterator(); index.hasNext();) {
                    let c = index.next();
                    {
                        if (c != null && c instanceof geom.Segment2D) {
                            const s = c;
                            p0 = s.p1;
                            p = s.p2;
                        }
                        else {
                            const arc = c;
                            p = arc.center();
                            if (!arc.__isDefined || Math.abs((arc.__t1 - arc.__t0)) < 0.01) {
                                p0 = c.lastPoint();
                            }
                            else {
                            }
                        }
                    }
                }
            }
            this.__isDefined = true;
        }
        getCurves() {
            return this.curves;
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return null;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Path2D";
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.__isDefined)
                return;
            let p0 = this.point(0);
            let p;
            g.setColors(this.fillColor, this.drawColor);
            if (this.fillColor != null) {
                g.context.beginPath();
                g.context.moveTo(Math.fround(p0.x), Math.fround(p0.y));
                for (let index = this.curves.iterator(); index.hasNext();) {
                    let c = index.next();
                    {
                        if (c != null && c instanceof geom.Segment2D) {
                            const s = c;
                            p0 = s.p1;
                            p = s.p2;
                            g.context.lineTo(Math.fround(p.x), Math.fround(p.y));
                        }
                        else {
                            const arc = c;
                            p = arc.center();
                            if (!arc.__isDefined || Math.abs((arc.__t1 - arc.__t0)) < 0.01) {
                                p0 = c.lastPoint();
                                g.context.lineTo(Math.fround(p0.x), Math.fround(p0.y));
                            }
                            else {
                                g.context.arc(Math.fround(p.x), Math.fround(p.y), Math.fround(arc.r), Math.fround(arc.startAngle), Math.fround((arc.startAngle + arc.angleExtent)), !arc.isDirect());
                            }
                        }
                    }
                }
                g.context.closePath();
                g.context.fill();
            }
            if (this.drawColor != null) {
                for (let index = this.curves.iterator(); index.hasNext();) {
                    let c = index.next();
                    {
                        c.drawColor = this.drawColor;
                        if (c.__isDefined === false && (c != null && c instanceof geom.CircleArc2D)) {
                            c.render(g);
                        }
                        else {
                            c.render(g);
                        }
                    }
                }
            }
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            for (let index = this.curves.iterator(); index.hasNext();) {
                let c = index.next();
                {
                    if (c.isSnapped(pt))
                        return true;
                }
            }
            return false;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            let d = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
            for (let index = this.curves.iterator(); index.hasNext();) {
                let c = index.next();
                {
                    d = Math.min(c.distance(pt), d);
                }
            }
            return d;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {number}
         */
        t(point) {
            let d0 = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
            let t = 0;
            let i = 0;
            for (let index = this.curves.iterator(); index.hasNext();) {
                let c = index.next();
                {
                    const d = point.distanceSquared$math_Vector2(c.project(point));
                    if (d < d0) {
                        d0 = d;
                        t = i + (c.t(point) - c.__t0) / (c.__t1 - c.__t0);
                    }
                    i++;
                }
            }
            return t;
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            const i = (Math.floor(t) | 0);
            const c = this.curves.get(i);
            return c.point(c.__t0 + (c.__t1 - c.__t0) * (t - i));
        }
        /**
         * Returns the unit Vector along tangent to curve
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            const i = (Math.floor(t) | 0);
            const c = this.curves.get(i);
            if (c != null && c instanceof geom.Line2D)
                return c.getDirection();
            return c.tangent(c.__t0 + (c.__t1 - c.__t0) * (t - i));
        }
    }
    geom.Path2D = Path2D;
    Path2D["__class"] = "geom.Path2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Creates line through point(x,y) and direction rations as dx and dy
     * @param {number} x
     * @param {number} y
     * @param {number} dx
     * @param {number} dy
     * @class
     * @extends geom.Curve2D
     */
    class Line2D extends geom.Curve2D {
        constructor(x, y, dx, dy) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && ((typeof dy === 'number') || dy === null)) {
                let __args = arguments;
                super();
                this.expr = null;
                this.x0 = 0;
                this.y0 = 0;
                this.dx = 1;
                this.dy = 0;
                this.p1 = new math.Vector2();
                this.p2 = new math.Vector2(1, 0);
                this.__t0 = javaemul.internal.DoubleHelper.NEGATIVE_INFINITY;
                this.__t1 = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                this.set$double$double$double$double(x, y, dx, dy);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && dy === undefined) {
                let __args = arguments;
                let a = __args[0];
                let b = __args[1];
                let c = __args[2];
                super();
                this.expr = null;
                this.x0 = 0;
                this.y0 = 0;
                this.dx = 1;
                this.dy = 0;
                this.p1 = new math.Vector2();
                this.p2 = new math.Vector2(1, 0);
                this.__t0 = javaemul.internal.DoubleHelper.NEGATIVE_INFINITY;
                this.__t1 = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                this.set$double$double$double(a, b, c);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && ((y != null && y instanceof math.Vector2) || y === null) && dx === undefined && dy === undefined) {
                let __args = arguments;
                let pt = __args[0];
                let dir = __args[1];
                {
                    let __args = arguments;
                    let x = pt.x;
                    let y = pt.y;
                    let dx = dir.x;
                    let dy = dir.y;
                    super();
                    this.expr = null;
                    this.x0 = 0;
                    this.y0 = 0;
                    this.dx = 1;
                    this.dy = 0;
                    this.p1 = new math.Vector2();
                    this.p2 = new math.Vector2(1, 0);
                    this.__t0 = javaemul.internal.DoubleHelper.NEGATIVE_INFINITY;
                    this.__t1 = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                    this.set$double$double$double$double(x, y, dx, dy);
                }
                this.expr = null;
                this.x0 = 0;
                this.y0 = 0;
                this.dx = 1;
                this.dy = 0;
                this.p1 = new math.Vector2();
                this.p2 = new math.Vector2(1, 0);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && y === undefined && dx === undefined && dy === undefined) {
                let __args = arguments;
                let dir = __args[0];
                {
                    let __args = arguments;
                    let pt = new math.Vector2();
                    {
                        let __args = arguments;
                        let x = pt.x;
                        let y = pt.y;
                        let dx = dir.x;
                        let dy = dir.y;
                        super();
                        this.expr = null;
                        this.x0 = 0;
                        this.y0 = 0;
                        this.dx = 1;
                        this.dy = 0;
                        this.p1 = new math.Vector2();
                        this.p2 = new math.Vector2(1, 0);
                        this.__t0 = javaemul.internal.DoubleHelper.NEGATIVE_INFINITY;
                        this.__t1 = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                        this.set$double$double$double$double(x, y, dx, dy);
                    }
                    this.expr = null;
                    this.x0 = 0;
                    this.y0 = 0;
                    this.dx = 1;
                    this.dy = 0;
                    this.p1 = new math.Vector2();
                    this.p2 = new math.Vector2(1, 0);
                }
                this.expr = null;
                this.x0 = 0;
                this.y0 = 0;
                this.dx = 1;
                this.dy = 0;
                this.p1 = new math.Vector2();
                this.p2 = new math.Vector2(1, 0);
            }
            else if (x === undefined && y === undefined && dx === undefined && dy === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let dir = new math.Vector2(1, 0);
                    {
                        let __args = arguments;
                        let pt = new math.Vector2();
                        {
                            let __args = arguments;
                            let x = pt.x;
                            let y = pt.y;
                            let dx = dir.x;
                            let dy = dir.y;
                            super();
                            this.expr = null;
                            this.x0 = 0;
                            this.y0 = 0;
                            this.dx = 1;
                            this.dy = 0;
                            this.p1 = new math.Vector2();
                            this.p2 = new math.Vector2(1, 0);
                            this.__t0 = javaemul.internal.DoubleHelper.NEGATIVE_INFINITY;
                            this.__t1 = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                            this.set$double$double$double$double(x, y, dx, dy);
                        }
                        this.expr = null;
                        this.x0 = 0;
                        this.y0 = 0;
                        this.dx = 1;
                        this.dy = 0;
                        this.p1 = new math.Vector2();
                        this.p2 = new math.Vector2(1, 0);
                    }
                    this.expr = null;
                    this.x0 = 0;
                    this.y0 = 0;
                    this.dx = 1;
                    this.dy = 0;
                    this.p1 = new math.Vector2();
                    this.p2 = new math.Vector2(1, 0);
                }
                this.expr = null;
                this.x0 = 0;
                this.y0 = 0;
                this.dx = 1;
                this.dy = 0;
                this.p1 = new math.Vector2();
                this.p2 = new math.Vector2(1, 0);
            }
            else
                throw new Error('invalid overload');
        }
        set$math_Vector2$math_Vector2(v1, v2) {
            this.set$double$double$double$double(v1.x, v1.y, v2.x - v1.x, v2.y - v1.y);
        }
        set$double$double$double$double(x, y, dx, dy) {
            this.x0 = x;
            this.y0 = y;
            if (Math.abs(dy) < framework.Preferences.EPSILON) {
                dy = 0;
            }
            else if (Math.abs(dx) < framework.Preferences.EPSILON) {
                dx = 0;
            }
            this.p1.set$double$double(this.x0, this.y0);
            this.p2.set$double$double(this.x0 + dx, this.y0 + dy);
            const r = math.MathUtils.hypot(dx, dy);
            dx /= r;
            dy /= r;
            this.dx = dx;
            this.dy = dy;
            this.__isDefined = true;
            const tab = [0, 0, 0];
            tab[0] = dy;
            tab[1] = -dx;
            tab[2] = dx * this.y0 - dy * this.x0;
            this.expr = math.MathUtils.formatEqn$double_A$java_lang_String_A(tab, ["x", "y", ""]);
            this.__isDefined = true;
            if (this.visible)
                this.clip();
        }
        /**
         * Sets line as passing through point (x,y) and direction rations as dx and dy
         * @param {number} x
         * @param {number} y
         * @param {number} dx
         * @param {number} dy
         */
        set(x, y, dx, dy) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && ((typeof dy === 'number') || dy === null)) {
                return this.set$double$double$double$double(x, y, dx, dy);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && dy === undefined) {
                return this.set$double$double$double(x, y, dx);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && ((y != null && y instanceof math.Vector2) || y === null) && dx === undefined && dy === undefined) {
                return this.set$math_Vector2$math_Vector2(x, y);
            }
            else
                throw new Error('invalid overload');
        }
        set$double$double$double(a, b, c) {
            if (a === 0 && b === 0) {
                throw new java.lang.IllegalArgumentException("Invalid cartesian coefficients of line !");
            }
            else if (a === 0) {
                this.set$double$double$double$double(0, -c / b, 1, 0);
            }
            else if (b === 0) {
                this.set$double$double$double$double(-c / a, 0, 0, 1);
            }
            else if (c === 0) {
                this.set$double$double$double$double(0, 0, b, -a);
            }
            else {
                this.set$double$double$double$double(0, -c / b, b, -a);
            }
        }
        /**
         *
         */
        update() {
        }
        /**
         * @param {boolean} visible
         * the visible to set
         */
        setVisible(visible) {
            super.setVisible(visible);
        }
        clip() {
            if (this.shapesManager == null)
                return;
            const b = this.shapesManager.getWorldBounds();
            const xmin = b[0];
            const ymin = b[1];
            const xmax = b[2];
            const ymax = b[3];
            const v1 = new math.Vector2();
            const v2 = new math.Vector2();
            if (Math.abs(this.dy) < framework.Preferences.EPSILON) {
                this.dy = 0;
                v1.set$double$double(xmin, this.y0);
                v2.set$double$double(xmax, this.y0);
            }
            else if (Math.abs(this.dx) < framework.Preferences.EPSILON) {
                this.dx = 0;
                v1.set$double$double(this.x0, ymin);
                v2.set$double$double(this.x0, ymax);
            }
            else {
                const c = [0, 0, 0];
                c[0] = this.dy;
                c[1] = -this.dx;
                c[2] = -this.dx * this.y0 + this.dy * this.x0;
                if (Math.abs(this.dy / this.dx) <= 1) {
                    const y1 = (c[2] - c[0] * xmin) / c[1];
                    const y2 = (c[2] - c[0] * xmax) / c[1];
                    v1.set$double$double(xmin, y1);
                    v2.set$double$double(xmax, y2);
                }
                else {
                    const x1 = (c[2] - c[1] * ymin) / c[0];
                    const x2 = (c[2] - c[1] * ymax) / c[0];
                    v1.set$double$double(x1, ymin);
                    v2.set$double$double(x2, ymax);
                }
            }
            if ((v2.x - v1.x) * this.dx + (v2.y - v1.y) * this.dy > 0) {
                this.p1.set$math_Vector2(v1);
                this.p2.set$math_Vector2(v2);
            }
            else {
                this.p1.set$math_Vector2(v2);
                this.p2.set$math_Vector2(v1);
            }
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return this.expr;
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.__isDefined)
                return;
            g.drawLine(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
            if (this.showEqn || this.showName) {
                this.renderInfo(g, this.p1, this.p2);
            }
        }
        /**
         * Returns the point through which line is passing
         *
         * @return {math.Vector2} {Vector2}
         */
        getPoint() {
            return new math.Vector2(this.x0, this.y0);
        }
        /**
         * returns unit vector parallel to the line
         *
         * @return {math.Vector2} {Vector2}
         */
        getDirection() {
            return new math.Vector2(this.dx, this.dy).getNormalized();
        }
        /**
         * returns the slope of the line
         *
         * @return {number} {Number}
         */
        getSlope() {
            if (this.dx === 0)
                return javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
            return this.dy / this.dx;
        }
        /**
         * Returns the visible length of the line
         *
         * @return {number} {Number}
         */
        getLength() {
            return this.p1.distance$math_Vector2(this.p2);
        }
        /**
         * Returns true if the given point lies to the left of the line when traveling along the line in the direction given
         * by its direction vector.
         *
         * @param {math.Vector2} p
         * the point to test
         * @return {boolean} true if point p lies on the 'left' of the line.
         */
        isInside(p) {
            return ((p.x - this.x0) * this.dy - (p.y - this.y0) * this.dx < 0);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            if (!this.__isDefined)
                return false;
            const p = pt.difference$double$double(this.x0, this.y0);
            return Math.abs(p.cross$double$double(this.dx, this.dy)) < geom.Shape2D.SNAP_DISTANCE;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        t(pt) {
            const denom = this.dx * this.dx + this.dy * this.dy;
            return ((pt.y - this.y0) * this.dy + (pt.x - this.x0) * this.dx) / denom;
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            if (!this.isDefined())
                return null;
            return new math.Vector2(this.x0 + t * this.dx, this.y0 + t * this.dy);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            if (!this.isDefined() || pt == null)
                return javaemul.internal.DoubleHelper.MAX_VALUE;
            const p = this.project(pt);
            return p.distance$math_Vector2(pt);
        }
        /**
         * Returns true if the specified point  lies on the boundary of shape
         * @param {math.Vector2} pt {Vector2 }
         * @return {boolean} {Boolean}
         */
        contains(pt) {
            return Math.abs(this.dy * (pt.x - this.x0) - this.dx * (pt.y - this.y0)) < geom.Shape2D.ACCURACY;
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            if (!this.__isDefined)
                return null;
            return new math.Vector2(this.dx, this.dy);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Line " + this.name;
        }
        /**
         * Returns Line after transformation (Note that returned object may be reused internally so make its clone if needed for future use)
         * @param {math.Transform} trans
         * @return
         * @return {geom.Line2D}
         */
        transform(trans) {
            if (Line2D.TMP_LINE == null)
                Line2D.TMP_LINE = new Line2D();
            Line2D.TMP_LINE.set$double$double$double$double(this.x0 * trans.m11 + this.y0 * trans.m12 + trans.m13, this.x0 * trans.m21 + this.y0 * trans.m22 + trans.m23, this.dx * trans.m11 + this.dy * trans.m12, this.dx * trans.m21 + this.dy * trans.m22);
            return Line2D.TMP_LINE;
        }
        /**
         * Returns coefficient array [a,b,c] for line in form ax+by+c=0]
         *
         * @return
         * @return {double[]}
         */
        coeff() {
            const tab = [0, 0, 0];
            tab[0] = this.dy;
            tab[1] = -this.dx;
            tab[2] = this.dx * this.y0 - this.dy * this.x0;
            return tab;
        }
        renderAsRay(g) {
            g.drawLine(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
            const l = Math.min(this.p2.distance$math_Vector2(this.p1) * 0.75, 0.75);
            const arrowhead = (this.strokeWidth + 8) / g.METER_TO_PIXEL;
            if (l > 3 * arrowhead) {
                g.context.beginPath();
                g.context.moveTo(this.x0 + this.dx * (l - arrowhead) + 0.5 * arrowhead * this.dy, this.y0 + this.dy * (l - arrowhead) - 0.5 * arrowhead * this.dx);
                g.context.lineTo(this.x0 + this.dx * l, this.y0 + this.dy * l);
                g.context.lineTo(this.x0 + this.dx * (l - arrowhead) - 0.5 * arrowhead * this.dy, this.y0 + this.dy * (l - arrowhead) + 0.5 * arrowhead * this.dx);
                g.context.stroke();
            }
        }
    }
    Line2D.TMP_LINE = null;
    geom.Line2D = Line2D;
    Line2D["__class"] = "geom.Line2D";
})(geom || (geom = {}));
(function (geom) {
    class DynamicCurve2D extends geom.Curve2D {
        constructor(p, maxPoints) {
            if (((p != null && p instanceof geom.Point2D) || p === null) && ((typeof maxPoints === 'string') || maxPoints === null)) {
                let __args = arguments;
                super();
                this.vertices = (new java.util.ArrayList());
                this.bounds = new geom.Bounds2D();
                this.maxPoints = 500;
                this.offset = -1;
                this.stopped = false;
                this.pixelLength = 0.01;
                this.parents = [p];
                this.maxPoints = javaemul.internal.IntegerHelper.parseInt(maxPoints);
                this.params = [maxPoints + ""];
                this.__isDefined = true;
            }
            else if (((p != null && p instanceof geom.Point2D) || p === null) && maxPoints === undefined) {
                let __args = arguments;
                super();
                this.vertices = (new java.util.ArrayList());
                this.bounds = new geom.Bounds2D();
                this.maxPoints = 500;
                this.offset = -1;
                this.stopped = false;
                this.pixelLength = 0.01;
                this.parents = [p];
                this.params = [this.maxPoints + ""];
                this.__isDefined = true;
            }
            else if (p === undefined && maxPoints === undefined) {
                let __args = arguments;
                super();
                this.vertices = (new java.util.ArrayList());
                this.bounds = new geom.Bounds2D();
                this.maxPoints = 500;
                this.offset = -1;
                this.stopped = false;
                this.pixelLength = 0.01;
                this.params = [this.maxPoints + ""];
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Num points", this.params[0], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                const n = javaemul.internal.IntegerHelper.parseInt(this.params[0]);
                this.maxPoints = n;
                this.reset();
            }
        }
        /**
         * removes all vertices from curve
         */
        reset() {
            this.offset = -1;
            this.bounds.reset();
            this.vertices.clear();
            this.__isDefined = true;
            this.stopped = false;
        }
        /**
         * stops curve from updating
         */
        pause() {
            this.stopped = true;
        }
        /**
         * resumes curve for updating
         */
        resume() {
            this.stopped = false;
        }
        /**
         * Sets maximum number of points in locus
         * @param {number} maxPoints must be >0
         */
        setMaxPoints(maxPoints) {
            this.maxPoints = maxPoints;
            this.params[0] = maxPoints + "";
            this.reset();
            this.update();
        }
        /**
         * Returns maximum number of points in locus
         * @return {number}
         */
        getMaxPoints() {
            return this.maxPoints;
        }
        /**
         *
         */
        update() {
            let v = null;
            if (this.parents != null && !this.stopped) {
                const p = this.parents[0];
                if (p != null && p.__isDefined) {
                    v = p.pt;
                    this.updatePoint(v);
                }
            }
        }
        /**
         * Adds points to the curve locus
         * @param {math.Vector2} v
         */
        updatePoint(v) {
            if (v != null) {
                const n = this.offset < 0 ? this.vertices.size() - 1 : this.offset;
                if (this.vertices.size() === 0 || (v.distance$math_Vector2(this.vertices.get(n)) >= this.pixelLength)) {
                    this.bounds.update$math_Vector2(v);
                    if (this.vertices.size() === this.maxPoints) {
                        this.offset++;
                        this.offset = this.offset % (this.maxPoints);
                        this.vertices.set(this.offset, v.copy());
                    }
                    else {
                        this.vertices.add(v.copy());
                    }
                }
            }
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return "Locus of ";
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.isDefined())
                return;
            this.pixelLength = 1 / g.METER_TO_PIXEL;
            g.context.beginPath();
            let v;
            let begin = false;
            if (this.offset >= 0) {
                for (let i = this.offset + 1, n = this.vertices.size(); i < n; i++) {
                    {
                        v = this.vertices.get(i);
                        if (!begin)
                            g.context.lineTo(v.x, v.y);
                        else {
                            g.context.moveTo(v.x, v.y);
                            begin = false;
                        }
                    }
                    ;
                }
                for (let i = 0, n = this.offset; i <= n; i++) {
                    {
                        v = this.vertices.get(i);
                        if (!begin)
                            g.context.lineTo(v.x, v.y);
                        else {
                            g.context.moveTo(v.x, v.y);
                            begin = false;
                        }
                    }
                    ;
                }
            }
            else {
                for (let i = 0, n = this.vertices.size(); i < n; i++) {
                    {
                        v = this.vertices.get(i);
                        if (!begin)
                            g.context.lineTo(v.x, v.y);
                        else {
                            g.context.moveTo(v.x, v.y);
                            begin = false;
                        }
                    }
                    ;
                }
            }
            g.context.stroke();
            if (this.showEqn) {
            }
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        t(pt) {
            if (this.vertices.size() <= 1)
                return 0;
            let t = 0;
            let distance = javaemul.internal.DoubleHelper.MAX_VALUE;
            let v1;
            let v2;
            let v;
            let v0;
            v0 = v = v1 = this.vertices.get(0);
            v2 = this.vertices.get(1);
            for (let i = 1; i < this.vertices.size(); i++) {
                {
                    v2 = this.vertices.get(i);
                    v = geom.CurveUtils.getPointOnSegmentClosestToPoint(pt, v1, v2);
                    const d = pt.distance$math_Vector2(v);
                    if (d < distance) {
                        distance = d;
                        t = i - 1;
                        v0 = v;
                    }
                    v1 = v2;
                }
                ;
            }
            if (t < this.vertices.size() - 1) {
                v1 = this.vertices.get(t);
                v2 = this.vertices.get(t + 1);
                return (t + (v0.distance$math_Vector2(v1)) / (v2.distance$math_Vector2(v1))) / (this.vertices.size() - 1);
            }
            return Math.fround(t / (Math.fround(this.vertices.size() - 1.0)));
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Locus of Point " + this.parents[0].name;
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            if (this.vertices.size() <= 1)
                return null;
            const i = ((Math.floor(t * (this.vertices.size() - 1))) | 0);
            if (i < this.vertices.size() - 1) {
                const v1 = this.vertices.get(i).copy();
                const v2 = this.vertices.get(i + 1);
                const dt = t - i / (this.vertices.size() - 1.0);
                v1.add$math_Vector2(v1.to$math_Vector2(v2).multiply(dt * (this.vertices.size() - 1.0)));
                return v1;
            }
            else {
                if (i >= 0 && i < this.vertices.size())
                    return this.vertices.get(i).copy();
            }
            return null;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            if (!this.bounds.contains$math_Vector2(pt))
                return false;
            if (this.vertices.size() === 0)
                return false;
            if (this.vertices.size() === 1)
                return this.vertices.get(0).equals$math_Vector2(pt);
            let v1;
            let v2;
            let v;
            v1 = this.vertices.get(0);
            v2 = this.vertices.get(1);
            for (let i = 1; i < this.vertices.size(); i++) {
                {
                    v2 = this.vertices.get(i);
                    v = geom.CurveUtils.getPointOnSegmentClosestToPoint(pt, v1, v2);
                    if (pt.distance$math_Vector2(v) < geom.Shape2D.SNAP_DISTANCE)
                        return true;
                    v1 = v2;
                }
                ;
            }
            return false;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            let distance = javaemul.internal.DoubleHelper.MAX_VALUE;
            if (this.vertices.size() === 0)
                return distance;
            if (this.vertices.size() === 1)
                return this.vertices.get(0).distance$math_Vector2(pt);
            let v1;
            let v2;
            let v;
            v1 = this.vertices.get(0);
            v2 = this.vertices.get(1);
            for (let i = 1; i < this.vertices.size(); i++) {
                {
                    v2 = this.vertices.get(i);
                    v = geom.CurveUtils.getPointOnSegmentClosestToPoint(pt, v1, v2);
                    const d = pt.distance$math_Vector2(v);
                    if (d < distance) {
                        distance = d;
                    }
                    v1 = v2;
                }
                ;
            }
            return distance;
        }
        /**
         * Returns the unit Vector along tangent to curve
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            if (!this.__isDefined || this.vertices.size() < 2)
                return null;
            const n = ((Math.round(t * (this.vertices.size() - 1))) | 0);
            if (n < 0 || n > this.vertices.size() - 1)
                return null;
            let v1;
            let v2;
            if (n === 0) {
                v1 = this.vertices.get(0);
                v2 = this.vertices.get(1);
                return new math.Vector2(v1.to$math_Vector2(v2).getDirection());
            }
            else if (n === this.vertices.size() - 1) {
                v1 = this.vertices.get(this.vertices.size() - 2);
                v2 = this.vertices.get(this.vertices.size() - 1);
                return new math.Vector2(v1.to$math_Vector2(v2).getDirection());
            }
            else {
                v1 = this.vertices.get(n - 1);
                v2 = this.vertices.get(n + 1);
                const v = this.vertices.get(n);
                const n1 = v1.to$math_Vector2(v).getNormalized();
                const n2 = v.to$math_Vector2(v2).getNormalized();
                return n1.add$math_Vector2(n2).getNormalized();
            }
        }
        /**
         * This is a brute force method of calculating derivatives, using
         * Newton's difference quotient (except without a limit)
         *
         * The derivative of a function f and point x can be approximated by
         * taking the slope of the secant from x to x+h, provided that h is sufficently
         * small. However, if h is too small, then floating point errors may result.
         *
         * This algorithm is an effective 100-point stencil in one dimension for
         * calculating the derivative of any real function y=equation.
         * @param xval
         * @return
         * @param {number} t
         * @return {number}
         */
        derivative(t) {
            if (!this.isDefined() || this.vertices.size() < 2)
                return javaemul.internal.DoubleHelper.NaN;
            const v = this.tangent(t);
            if (v == null)
                return javaemul.internal.DoubleHelper.NaN;
            return Math.tan(v.getDirection());
        }
        /**
         * returns double derivative of function for parameter t
         * @param xval
         * @return
         * @param {number} t
         * @return {number}
         */
        doubleDerivative(t) {
            if (!this.__isDefined || this.vertices.size() < 2)
                return javaemul.internal.DoubleHelper.NaN;
            let ddx = 0;
            const x = t;
            let h;
            if (x > 1 || x < -1)
                h = Math.sqrt(geom.Shape2D.ACCURACY) * x;
            else
                h = Math.sqrt(geom.Shape2D.ACCURACY);
            h = 1.0 / this.vertices.size();
            const answerx = this.derivative(t);
            for (let i = 1; i <= 5; i++) {
                {
                    const diff = (h * i);
                    t = x + diff;
                    let answer = this.derivative(t);
                    ddx += ((answer - answerx) / diff);
                    t = x - diff;
                    answer = this.derivative(t);
                    ddx += ((answerx - answer) / diff);
                }
                ;
            }
            ddx = ddx / 10;
            return ddx;
        }
    }
    geom.DynamicCurve2D = DynamicCurve2D;
    DynamicCurve2D["__class"] = "geom.DynamicCurve2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Creates a new Spline2D.
     *
     * @param {geom.Point2D[]} points
     * @class
     * @extends geom.Curve2D
     */
    class Spline2D extends geom.Curve2D {
        constructor(...points) {
            super();
            if (this.splineX === undefined) {
                this.splineX = null;
            }
            if (this.splineY === undefined) {
                this.splineY = null;
            }
            if (this.length === undefined) {
                this.length = 0;
            }
            this.parents = points;
            this.update();
        }
        update() {
            this.__isDefined = false;
            if (this.parents.length < 2)
                return;
            for (let index = 0; index < this.parents.length; index++) {
                let p = this.parents[index];
                if (!p.__isDefined)
                    return;
            }
            const x = this.splineX != null ? this.splineX.yy : (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(this.parents.length);
            const y = this.splineY != null ? this.splineY.yy : (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(this.parents.length);
            const t = this.splineX != null ? this.splineY.xx : (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(this.parents.length);
            for (let i = 0; i < this.parents.length; i++) {
                {
                    x[i] = this.parents[i].getX();
                    y[i] = this.parents[i].getY();
                }
                ;
            }
            t[0] = 0.0;
            for (let i = 1; i < t.length; i++) {
                {
                    const lx = x[i] - x[i - 1];
                    const ly = y[i] - y[i - 1];
                    if (0.0 === lx) {
                        t[i] = Math.abs(ly);
                    }
                    else if (0.0 === ly) {
                        t[i] = Math.abs(lx);
                    }
                    else {
                        t[i] = Math.sqrt(lx * lx + ly * ly);
                    }
                    this.length += t[i];
                    t[i] += t[i - 1];
                }
                ;
            }
            for (let i = 1; i < (t.length) - 1; i++) {
                {
                    t[i] = t[i] / this.length;
                }
                ;
            }
            t[(t.length) - 1] = 1.0;
            if (this.splineX == null) {
                this.splineX = new geom.Spline(t, x);
                this.splineY = new geom.Spline(t, y);
            }
            else {
                this.splineX.setValues(t, x);
                this.splineX.setValues(t, y);
            }
        }
        /**
         * @param {number} t
         * 0 <= t <= 1
         * @return {math.Vector2}
         */
        getPoint(t) {
            let x;
            let y;
            x = this.splineX.getValue(t);
            y = this.splineY.getValue(t);
            return new math.Vector2(x, y);
        }
        getDx(t) {
            return this.splineX.getDx(t);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {number}
         */
        t(point) {
            return 0;
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            let x;
            let y;
            x = this.splineX.getValue(t);
            y = this.splineY.getValue(t);
            return new math.Vector2(x, y);
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return null;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return null;
        }
        /**
         *
         * @param {framework.Renderer} gl
         */
        render(gl) {
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            return false;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            return 0;
        }
    }
    geom.Spline2D = Spline2D;
    Spline2D["__class"] = "geom.Spline2D";
    /**
     * Creates a new Spline.
     *
     * @param {double[]} xx
     * @param {double[]} yy
     * @class
     */
    class Spline {
        constructor(xx, yy) {
            if (this.xx === undefined) {
                this.xx = null;
            }
            if (this.yy === undefined) {
                this.yy = null;
            }
            if (this.a === undefined) {
                this.a = null;
            }
            if (this.b === undefined) {
                this.b = null;
            }
            if (this.c === undefined) {
                this.c = null;
            }
            if (this.d === undefined) {
                this.d = null;
            }
            this.storageIndex = 0;
            this.setValues(xx, yy);
        }
        /**
         * Set values for this Spline.
         *
         * @param {double[]} xx
         * @param {double[]} yy
         */
        setValues(xx, yy) {
            this.xx = xx;
            this.yy = yy;
            if (xx.length > 1) {
                this.calculateCoefficients();
            }
        }
        /**
         * Returns an interpolated value.
         *
         * @param {number} x
         * @return {number} the interpolated value
         */
        getValue(x) {
            if (this.xx.length === 0) {
                return javaemul.internal.DoubleHelper.NaN;
            }
            if (this.xx.length === 1) {
                if (this.xx[0] === x) {
                    return this.yy[0];
                }
                else {
                    return javaemul.internal.DoubleHelper.NaN;
                }
            }
            let index = java.util.Arrays.binarySearch(this.xx, x);
            if (index > 0) {
                return this.yy[index];
            }
            index = -(index + 1) - 1;
            if (index < 0) {
                return this.yy[0];
            }
            return this.a[index] + this.b[index] * (x - this.xx[index]) + this.c[index] * Math.pow(x - this.xx[index], 2) + this.d[index] * Math.pow(x - this.xx[index], 3);
        }
        /**
         * Returns an interpolated value. To be used when a long sequence of values are required in order, but ensure
         * checkValues() is called beforehand to ensure the boundary checks from getValue() are made
         *
         * @param {number} x
         * @return {number} the interpolated value
         */
        getFastValue(x) {
            if (this.storageIndex > -1 && this.storageIndex < this.xx.length - 1 && x > this.xx[this.storageIndex] && x < this.xx[this.storageIndex + 1]) {
            }
            else {
                let index = java.util.Arrays.binarySearch(this.xx, x);
                if (index > 0) {
                    return this.yy[index];
                }
                index = -(index + 1) - 1;
                this.storageIndex = index;
            }
            if (this.storageIndex < 0) {
                return this.yy[0];
            }
            const value = x - this.xx[this.storageIndex];
            return this.a[this.storageIndex] + this.b[this.storageIndex] * value + this.c[this.storageIndex] * (value * value) + this.d[this.storageIndex] * (value * value * value);
        }
        /**
         * Used to check the correctness of this spline
         * @return {boolean}
         */
        checkValues() {
            if (this.xx.length < 2) {
                return false;
            }
            else {
                return true;
            }
        }
        /**
         * Returns the first derivation at x.
         *
         * @param {number} x
         * @return {number} the first derivation at x
         */
        getDx(x) {
            if (this.xx.length === 0 || this.xx.length === 1) {
                return 0;
            }
            let index = java.util.Arrays.binarySearch(this.xx, x);
            if (index < 0) {
                index = -(index + 1) - 1;
            }
            return this.b[index] + 2 * this.c[index] * (x - this.xx[index]) + 3 * this.d[index] * Math.pow(x - this.xx[index], 2);
        }
        /**
         * Calculates the Spline coefficients.
         * @private
         */
        /*private*/ calculateCoefficients() {
            const N = this.yy.length;
            this.a = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(N);
            this.b = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(N);
            this.c = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(N);
            this.d = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(N);
            if (N === 2) {
                this.a[0] = this.yy[0];
                this.b[0] = this.yy[1] - this.yy[0];
                return;
            }
            const h = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(N - 1);
            for (let i = 0; i < N - 1; i++) {
                {
                    this.a[i] = this.yy[i];
                    h[i] = this.xx[i + 1] - this.xx[i];
                    if (h[i] === 0.0) {
                        h[i] = 0.01;
                    }
                }
                ;
            }
            this.a[N - 1] = this.yy[N - 1];
            const A = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                return 0;
            }
            else {
                let array = [];
                for (let i = 0; i < dims[0]; i++) {
                    array.push(allocate(dims.slice(1)));
                }
                return array;
            } }; return allocate(dims); })([N - 2, N - 2]);
            const y = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(N - 2);
            for (let i = 0; i < N - 2; i++) {
                {
                    y[i] = 3 * ((this.yy[i + 2] - this.yy[i + 1]) / h[i + 1] - (this.yy[i + 1] - this.yy[i]) / h[i]);
                    A[i][i] = 2 * (h[i] + h[i + 1]);
                    if (i > 0) {
                        A[i][i - 1] = h[i];
                    }
                    if (i < N - 3) {
                        A[i][i + 1] = h[i + 1];
                    }
                }
                ;
            }
            this.solve(A, y);
            for (let i = 0; i < N - 2; i++) {
                {
                    this.c[i + 1] = y[i];
                    this.b[i] = (this.a[i + 1] - this.a[i]) / h[i] - (2 * this.c[i] + this.c[i + 1]) / 3 * h[i];
                    this.d[i] = (this.c[i + 1] - this.c[i]) / (3 * h[i]);
                }
                ;
            }
            this.b[N - 2] = (this.a[N - 1] - this.a[N - 2]) / h[N - 2] - (2 * this.c[N - 2] + this.c[N - 1]) / 3 * h[N - 2];
            this.d[N - 2] = (this.c[N - 1] - this.c[N - 2]) / (3 * h[N - 2]);
        }
        /**
         * Solves Ax=b and stores the solution in b.
         * @param {double[][]} A
         * @param {double[]} b
         */
        solve(A, b) {
            const n = b.length;
            for (let i = 1; i < n; i++) {
                {
                    A[i][i - 1] = A[i][i - 1] / A[i - 1][i - 1];
                    A[i][i] = A[i][i] - A[i - 1][i] * A[i][i - 1];
                    b[i] = b[i] - A[i][i - 1] * b[i - 1];
                }
                ;
            }
            b[n - 1] = b[n - 1] / A[n - 1][n - 1];
            for (let i = b.length - 2; i >= 0; i--) {
                {
                    b[i] = (b[i] - A[i][i + 1] * b[i + 1]) / A[i][i];
                }
                ;
            }
        }
    }
    geom.Spline = Spline;
    Spline["__class"] = "geom.Spline";
})(geom || (geom = {}));
(function (geom) {
    class FunctionExplicit2D extends geom.Curve2D {
        constructor(expr) {
            super();
            if (this.expr === undefined) {
                this.expr = null;
            }
            this.parser = null;
            this.vertices = (new java.util.ArrayList());
            this.parseErrorMessage = null;
            this.isValidExpr = true;
            this.reCreate = false;
            this.f = null;
            this.pixLength = 0.01;
            this.setExpression(expr);
            this.__isDefined = true;
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Expression", this.expr, ["x"]);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.setExpression(value + "");
                if (this.parser != null)
                    this.createGraph();
            }
        }
        /**
         * Sets value of parameter at specified index
         *
         * @param {number} index
         * @param {string} value
         * the value to set
         */
        setParam(index, value) {
            super.setParam(index, value);
            this.setExpression(this.params[0]);
        }
        /**
         * Set expressions for each component
         *
         * @param {string} expr
         * Expression in terms of variable x ex:<code> sin(x); x*x </code>
         */
        setExpression(expr) {
            this.expr = expr;
            this.params = [expr];
            if (expr == null)
                return;
            this.parseErrorMessage = null;
            this.isValidExpr = true;
            this.parser = null;
            this.vertices.clear();
            try {
                const e = this.createParser(expr);
                if (e == null) {
                    this.isValidExpr = false;
                }
                else {
                    const res = e.validate$boolean(false);
                    if (res.isValid()) {
                        this.parser = e;
                    }
                    else {
                        this.isValidExpr = false;
                    }
                }
            }
            catch (ex) {
            }
            this.__isDefined = this.isValidExpr;
        }
        onAddShapeToSimulation(manager) {
            super.onAddShapeToSimulation(manager);
            this.setExpression(this.expr);
            this.setName(this.name);
            this.update();
        }
        /**
         * Sets the identifier name of shape
         *
         * @param {string} name
         * the name to set
         */
        setName(name) {
            if (this.shapesManager == null) {
                super.setName(name);
                return;
            }
            if (!this.shapesManager.containsShape(this)) {
                this.name = name;
                return;
            }
            if (this.shapesManager.globalFunctions.containsKey(this.name) && (this.name === name))
                return;
            this.shapesManager.globalFunctions.remove(this.name);
            if (name == null || !net.objecthunter.exp4j.__function._Function.isValidFunctionName(name))
                return;
            this.name = this.shapesManager.createNewVariableName(name);
            this.f = new FunctionExplicit2D.FunctionExplicit2D$0(this, this.name, 1);
            this.shapesManager.globalFunctions.put(this.name, this.f);
        }
        /**
         * perform some action if needed (like resource release, reset global variables etc) when the shape is removed
         */
        dispose() {
            if (this.shapesManager != null)
                this.shapesManager.globalFunctions.remove(this.name);
        }
        /**
         *
         */
        update() {
            if (this.isValidExpr) {
                this.createGraph();
            }
        }
        /*private*/ createGraph() {
            if (this.parser == null || !this.isValidExpr)
                return;
            this.__isDefined = true;
            if (this.shapesManager == null)
                return;
            let dy = this.pixLength;
            const bnds = this.shapesManager.getWorldBounds();
            const xmin = bnds[0];
            const ymin = bnds[1];
            const xmax = bnds[2];
            const ymax = bnds[3];
            for (let index = this.shapesManager.globalVariables.keySet().iterator(); index.hasNext();) {
                let key = index.next();
                {
                    this.parser.setVariable(key, this.shapesManager.globalVariables.get(key));
                }
            }
            this.shapesManager.globalVariables.put("T", this.shapesManager.getTime());
            let x = xmin;
            this.parser.setVariable("x", x);
            let y = this.parser.evaluate();
            let p = null;
            const pix = this.pixLength;
            let need_move = true;
            const max_dx = pix;
            const min_dx = pix / 10;
            let dx = max_dx;
            let count = 0;
            let xx;
            let yy;
            this.vertices.clear();
            while ((x < xmax)) {
                {
                    xx = x + dx;
                    this.parser.setVariable("x", xx);
                    yy = this.parser.evaluate();
                    if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(y) || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(yy)) {
                        need_move = true;
                    }
                    else if (yy > ymax && y > ymax) {
                        need_move = true;
                    }
                    else if (yy < ymin && y < ymin) {
                        need_move = true;
                    }
                    else {
                        dy = Math.abs(yy - y);
                        if (dy > pix) {
                            if (dx > min_dx) {
                                dx = 0.5 * dx;
                                continue;
                            }
                        }
                        else {
                            if (dx < max_dx)
                                dx = 2.0 * dx;
                        }
                        let i = 0;
                        const ITER = 10;
                        if (dy > pix) {
                            let a = x;
                            let b = xx;
                            let ya = y;
                            let yb = yy;
                            const ymid = 0.5 * (y + yy);
                            inner: for (i = 0; i < ITER; ++i) {
                                {
                                    const c = 0.5 * (a + b);
                                    this.parser.setVariable("x", c);
                                    const y1 = this.parser.evaluate();
                                    if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(y1)) {
                                        i = ITER;
                                        break inner;
                                    }
                                    if (Math.abs(y1 - ymid) < pix) {
                                        break inner;
                                    }
                                    if ((ya <= ymid && y1 >= ymid) || (ya >= ymid && y1 <= ymid)) {
                                        b = c;
                                        yb = y1;
                                    }
                                    else {
                                        a = c;
                                        ya = y1;
                                    }
                                }
                                ;
                            }
                        }
                        if (i >= ITER) {
                            need_move = true;
                        }
                        else {
                            if (need_move) {
                                let xxx = x;
                                let yyy = y;
                                if (y > ymax) {
                                    yyy = ymax;
                                    xxx = x + (yyy - y) / (yy - y) * (xx - x);
                                }
                                else if (y < ymin) {
                                    yyy = ymin;
                                    xxx = x + (yyy - y) / (yy - y) * (xx - x);
                                }
                                if (p != null)
                                    this.vertices.add(p = null);
                            }
                            if (true) {
                                let xxx = x;
                                let yyy = y;
                                if (yy > ymax) {
                                    yyy = ymax;
                                    xxx = xx + (yyy - yy) / (y - yy) * (x - xx);
                                    need_move = true;
                                }
                                else if (yy < ymin) {
                                    yyy = ymin;
                                    xxx = xx + (yyy - yy) / (y - yy) * (x - xx);
                                    need_move = true;
                                }
                                else {
                                    need_move = false;
                                }
                                this.vertices.add(p = new math.Vector2(xxx, yyy));
                                count = count + 1;
                            }
                        }
                    }
                    y = yy;
                    x = xx;
                }
            }
            ;
            this.vertices.trimToSize();
            this.__t0 = xmin;
            this.__t1 = xmax;
        }
        getExpression() {
            return this.expr;
        }
        /**
         * Creates parser for the expression
         *
         * @param {string} expr
         * @return
         * @return {net.objecthunter.exp4j.Expression}
         */
        createParser(expr) {
            if (this.shapesManager == null)
                return null;
            let exp = null;
            try {
                exp = math.MathUtils.createParser(expr, ["x"], this.shapesManager.globalVariables, this.shapesManager.globalFunctions);
                console.info("created parser successfully " + exp.toString());
            }
            catch (e) {
                this.parseErrorMessage = e.message;
                return null;
            }
            return exp;
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return this.expr;
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.isDefined())
                return;
            this.pixLength = 1 / g.METER_TO_PIXEL;
            g.context.beginPath();
            let begin = false;
            let v;
            for (let i = 0, n = this.vertices.size(); i < n; i++) {
                {
                    v = this.vertices.get(i);
                    if (v == null) {
                        g.context.stroke();
                        g.context.beginPath();
                        begin = false;
                        continue;
                    }
                    if (begin) {
                        g.context.moveTo(v.x, v.y);
                        begin = false;
                    }
                    else {
                        g.context.lineTo(v.x, v.y);
                    }
                }
                ;
            }
            g.context.stroke();
            if (this.showEqn) {
            }
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            if (!this.isDefined())
                return false;
            const y = this.getY(pt.x);
            if (y === javaemul.internal.DoubleHelper.NaN)
                return false;
            return (Math.abs(pt.y - y) < geom.Shape2D.SNAP_DISTANCE);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        t(pt) {
            return pt.x;
        }
        /**
         * Returns point of function curve for specified x coordinate, returns null if x is not in its domain
         *
         * @param {Number}
         * x
         * @return{Vector2}
         * @param {number} x
         * @return {math.Vector2}
         */
        point(x) {
            if (!this.isDefined())
                return null;
            const y = this.getY(x);
            if (y === javaemul.internal.DoubleHelper.NaN)
                return null;
            return new math.Vector2(x, y);
        }
        /**
         * Does't actually returns minimum distance rather it returns the absolute difference in y coordinate of point and
         * that of corresponding point on this graph
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            if (!this.isDefined())
                return javaemul.internal.DoubleHelper.MAX_VALUE;
            const y = this.getY(pt.x);
            if (y === javaemul.internal.DoubleHelper.NaN)
                return javaemul.internal.DoubleHelper.MAX_VALUE;
            return Math.abs(pt.y - y);
        }
        getCriticalPoint(x) {
            const dy = Math.abs(this.derivative(x)) / geom.Shape2D.ACCURACY;
            if (dy < 0.01)
                return x;
            const range = Math.min(1, dy / 100) * 2 * geom.Shape2D.SNAP_DISTANCE;
            const accuracy = geom.Shape2D.ACCURACY * 100;
            let min = geom.CurveUtils.findMinimaBrent(this, true, x - range, x + range);
            if (Math.abs(this.derivative(min.x)) < accuracy)
                return min.x;
            min = geom.CurveUtils.findMinimaBrent(this, false, x - range, x + range);
            if (Math.abs(this.derivative(min.x)) < accuracy)
                return min.x;
            return javaemul.internal.DoubleHelper.NaN;
        }
        /**
         * returns true if f(x) is continous at x
         *
         * @param {number} x
         * @return {boolean} true if f(x) is continuous at x
         */
        isContinuousAt(x) {
            const y = this.getY(x);
            if ( /* isNaN */isNaN(y))
                return false;
            const y1 = this.getY(x + geom.Shape2D.ACCURACY);
            if ( /* isNaN */isNaN(y1))
                return false;
            const y2 = this.getY(x - geom.Shape2D.ACCURACY);
            if ( /* isNaN */isNaN(y2))
                return false;
            if (Math.abs(y1 - y) < geom.Shape2D.ACCURACY * 100 && Math.abs(y2 - y) < geom.Shape2D.ACCURACY * 100)
                return true;
            return false;
        }
        /**
         * returns Y coordinate for the given x coordinate
         *
         * @param {number} x
         * @return {number} {number} returns value of function for given x if x is in its domain else returns null
         */
        getY(x) {
            if (this.parser == null)
                return javaemul.internal.DoubleHelper.NaN;
            this.parser.setVariable("x", x);
            if (this.shapesManager != null) {
                for (let index = this.shapesManager.globalVariables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    {
                        this.parser.setVariable(key, this.shapesManager.globalVariables.get(key));
                    }
                }
                this.shapesManager.globalVariables.put("T", this.shapesManager.getTime());
            }
            try {
                return this.parser.evaluate();
            }
            catch (e) {
                return javaemul.internal.DoubleHelper.NaN;
            }
        }
        /**
         * Returns the root of function in interval (guess-range , guess+range) Note: Smaller the range greater will be the
         * accuracy
         *
         * @param {number} guess
         * @param {number} range
         * @return {number} {Number} root of function if exists in given range else returns null
         */
        getRoot_Bisection(guess, range) {
            let i = 0;
            let x = guess;
            let b = guess + range;
            let a = guess - range;
            let dx = b - a;
            const maxIteration = 100;
            while ((i < maxIteration)) {
                {
                    if (Math.abs(dx) < geom.Shape2D.ACCURACY) {
                        return x;
                    }
                    x = (a + b) / 2;
                    if (this.getY(a) * this.getY(x) < 0) {
                        b = x;
                        dx = b - a;
                    }
                    else {
                        a = x;
                        dx = b - a;
                    }
                    i++;
                }
            }
            ;
            return javaemul.internal.DoubleHelper.NaN;
        }
        /**
         * returns true if f(x) is Differentiable at x
         *
         * @param {number} x
         * @return {boolean} true if f(x) is Differentiable at x
         */
        isDifferentiableAt(x) {
            const y = this.getY(x);
            if ( /* isNaN */isNaN(y))
                return false;
            const y1 = this.getY(x + geom.Shape2D.ACCURACY);
            if ( /* isNaN */isNaN(y1))
                return false;
            const y2 = this.getY(x - geom.Shape2D.ACCURACY);
            if ( /* isNaN */isNaN(y2))
                return false;
            if (Math.abs(y1 - y) > geom.Shape2D.ACCURACY * 1000 || Math.abs(y2 - y) > geom.Shape2D.ACCURACY * 1000)
                return false;
            const RHD = (y1 - y) / geom.Shape2D.ACCURACY;
            const LHD = (y - y2) / geom.Shape2D.ACCURACY;
            const dD = Math.abs(RHD - LHD);
            let maxSlope = Math.max(Math.abs(RHD), Math.abs(LHD));
            if (maxSlope < geom.Shape2D.ACCURACY * 100000)
                maxSlope = geom.Shape2D.ACCURACY * 100000;
            if (dD > maxSlope / 100.0)
                return false;
            return true;
        }
        /**
         *
         * @param {number} x
         * @return {math.Vector2}
         */
        tangent(x) {
            if (!this.isDefined())
                return null;
            const m = this.derivative(x);
            if ( /* isNaN */isNaN(m))
                return null;
            if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(m))
                return new math.Vector2(0, 1);
            return new math.Vector2(1, m).getNormalized();
        }
        /**
         *
         * @param {number} xval
         * @return {number}
         */
        derivative(xval) {
            if (!this.isDefined())
                return javaemul.internal.DoubleHelper.NaN;
            let ddx = 0;
            const x = xval;
            let h;
            if (x > 1 || x < -1)
                h = Math.sqrt(geom.Shape2D.ACCURACY) * x;
            else
                h = Math.sqrt(geom.Shape2D.ACCURACY);
            const answerx = this.getY(xval);
            for (let i = 1; i <= 5; i++) {
                {
                    const diff = (h * i);
                    xval = x + diff;
                    let answer = this.getY(xval);
                    ddx += ((answer - answerx) / diff);
                    xval = x - diff;
                    answer = this.getY(xval);
                    ddx += ((answerx - answer) / diff);
                }
                ;
            }
            ddx = ddx / 10;
            return ddx;
        }
        getOscullatingCircle(x) {
            const y = this.getY(x);
            if ( /* isNaN */isNaN(y))
                return null;
            const foot = new math.Vector2(x, y);
            let r = this.curvature(x);
            if ( /* isNaN */isNaN(r) || Math.abs(r) < geom.Shape2D.ACCURACY || Math.abs(r) > 1 / geom.Shape2D.ACCURACY)
                return null;
            r = -1 / r;
            let v = this.tangent(x);
            v.normalize();
            v = new math.Vector2(r * v.y, -r * v.x);
            const centre = foot.sum$math_Vector2(v);
            const c = new geom.Circle2D(centre.x, centre.y, Math.abs(r));
            return c;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Function of x";
        }
    }
    FunctionExplicit2D.loopcounter = 0;
    geom.FunctionExplicit2D = FunctionExplicit2D;
    FunctionExplicit2D["__class"] = "geom.FunctionExplicit2D";
    (function (FunctionExplicit2D) {
        class FunctionExplicit2D$0 extends net.objecthunter.exp4j.__function._Function {
            constructor(__parent, __arg0, __arg1) {
                super(__arg0, __arg1);
                this.__parent = __parent;
            }
            /**
             *
             * @param {double[]} args
             * @return {number}
             */
            apply(...args) {
                return this.__parent.getY(args[0]);
            }
        }
        FunctionExplicit2D.FunctionExplicit2D$0 = FunctionExplicit2D$0;
    })(FunctionExplicit2D = geom.FunctionExplicit2D || (geom.FunctionExplicit2D = {}));
})(geom || (geom = {}));
(function (geom) {
    /**
     * Intersections of two conics.
     * @param curve
     * @param point
     * @param {geom.Conic2D} conic1
     * @param {geom.Conic2D} conic2
     * @class
     * @extends geom.ParentShapeArray2D
     * @author mahesh kurmi
     */
    class Intersection2Conics2D extends geom.ParentShapeArray2D {
        constructor(conic1, conic2) {
            super();
            if (this.children === undefined) {
                this.children = null;
            }
            this.parents = [conic1, conic2];
            this.children = [null, null, null, null];
            const parents = [this];
            for (let i = 0; i < 4; i++) {
                {
                    const p = new geom.Point2D();
                    p.parents = parents;
                    p.params = [i + ""];
                    this.children[i] = p;
                }
                ;
            }
            this.update();
        }
        /**
         *
         * @return {number}
         */
        getChildrenCount() {
            return this.children.length;
        }
        /**
         *
         * @param {number} index
         * @return {geom.Shape2D}
         */
        getChild(index) {
            if (index < 0 || index >= this.children.length)
                return null;
            return this.children[index];
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            for (let i = 0; i < this.children.length; i++) {
                this.children[i].__isDefined = false;
            }
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined())
                return;
            const conic1 = this.parents[0];
            const conic2 = this.parents[1];
            const tt = conic1.getIntersections(conic2);
            for (let i = 0; i < tt.length; i++) {
                {
                    const t = tt[i];
                    const p = conic1.point(t);
                    this.children[i].set(p.x, p.y);
                    this.children[i].__isDefined = true;
                    this.__isDefined = true;
                }
                ;
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Intersection of " + this.parents[0].getName() + " & " + this.parents[1].getName();
        }
    }
    geom.Intersection2Conics2D = Intersection2Conics2D;
    Intersection2Conics2D["__class"] = "geom.Intersection2Conics2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Common Tangents to the pair of conics
     *
     * @param curve
     * @param point
     * @param {geom.Conic2D} conic1
     * @param {geom.Conic2D} conic2
     * @class
     * @extends geom.ParentShapeArray2D
     * @author mahesh kurmi
     */
    class CommonTangents2Conics2D extends geom.ParentShapeArray2D {
        constructor(conic1, conic2) {
            super();
            if (this.children === undefined) {
                this.children = null;
            }
            this.parents = [conic1, conic2];
            this.children = (s => { let a = []; while (s-- > 0)
                a.push(null); return a; })(CommonTangents2Conics2D.includeDualConic ? 5 : 4);
            const parents = [this];
            for (let i = 0; i < 4; i++) {
                {
                    const line = new geom.Line2D();
                    line.parents = parents;
                    line.params = [i + ""];
                    this.children[i] = line;
                }
                ;
            }
            if (CommonTangents2Conics2D.includeDualConic) {
                this.children[4] = new geom.ConicWrapper2D(null);
                this.children[4].setDrawPattern(geom.Shape2D.DrawMode.DASHED);
                this.children[4].parents = parents;
                this.children[4].params = [4 + ""];
                this.children[4].__isDefined = true;
            }
            this.update();
        }
        /**
         *
         * @return {number}
         */
        getChildrenCount() {
            return this.children.length;
        }
        /**
         *
         * @param {number} index
         * @return {geom.Shape2D}
         */
        getChild(index) {
            if (index < 0 || index >= this.children.length)
                return null;
            return this.children[index];
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            for (let i = 0; i < this.children.length; i++) {
                this.children[i].__isDefined = false;
            }
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined())
                return;
            const conic1 = this.parents[0];
            const conic2 = this.parents[1];
            const conic = geom.Conics2D.getDualConic(conic1, conic2);
            if (conic == null)
                return;
            const ts = conic2.getIntersections(conic);
            for (let i = 0; i < ts.length; i++) {
                {
                    const t = ts[i];
                    if ( /* isNaN */isNaN(t))
                        continue;
                    const vect = conic2.tangent(t);
                    if (vect == null) {
                        continue;
                    }
                    const point = conic2.point(t);
                    this.children[i].set$double$double$double$double(point.x, point.y, vect.x, vect.y);
                    this.__isDefined = true;
                }
                ;
            }
            if (CommonTangents2Conics2D.includeDualConic) {
                this.children[4].setConic(conic);
                this.children[4].getConic().setDrawPattern(geom.Shape2D.DrawMode.DASHED);
                this.children[4].__isDefined = true;
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Common tangent to Conics " + this.parents[0].getName() + " & " + this.parents[1].getName();
        }
    }
    CommonTangents2Conics2D.includeDualConic = false;
    geom.CommonTangents2Conics2D = CommonTangents2Conics2D;
    CommonTangents2Conics2D["__class"] = "geom.CommonTangents2Conics2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Common Tangents to the pair of conics
     *
     * @param curve
     * @param point
     * @param {number} elemIndex
     * @param {number} count
     * @param {java.lang.String[]} params
     * @class
     * @extends geom.ParentShapeArray2D
     * @author mahesh kurmi
     */
    class SequenceElementArray2D extends geom.ParentShapeArray2D {
        constructor(elemIndex, count, ...params) {
            if (((typeof elemIndex === 'number') || elemIndex === null) && ((typeof count === 'number') || count === null) && ((params != null && params instanceof Array && (params.length == 0 || params[0] == null || (typeof params[0] === 'string'))) || params === null)) {
                let __args = arguments;
                super();
                if (this.parsers === undefined) {
                    this.parsers = null;
                }
                if (this.children === undefined) {
                    this.children = null;
                }
                this.children = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(count);
                const parent = [this];
                for (let i = 0; i < count; i++) {
                    {
                        let s = null;
                        switch ((elemIndex)) {
                            case 0:
                                s = new geom.Point2D();
                                break;
                            case 1:
                                s = new geom.Circle2D();
                                break;
                            case 2:
                                s = new geom.Line2D();
                                break;
                            case 3:
                                s = new geom.Segment2D();
                                break;
                            case 4:
                                s = new geom.Vector2D();
                                break;
                        }
                        s.parents = parent;
                        s.params = [i + ""];
                        s.showEqn = false;
                        s.showName = false;
                        this.children[i] = s;
                    }
                    ;
                }
                this.params = [elemIndex + "", count + "", params[0], params[1], params[2], params[3]];
                this.parsers = (new java.util.ArrayList());
                for (let i = 0; i < params.length; i++) {
                    {
                        try {
                            if (params[i] == null || /* isEmpty */ (params[i].length === 0))
                                break;
                            const s = math.MathUtils.createParser(params[i], ["i"], this.shapesManager == null ? null : this.shapesManager.globalVariables, this.shapesManager == null ? null : this.shapesManager.globalFunctions);
                            this.parsers.add(s);
                        }
                        catch (e) {
                            console.error(e.message, e);
                        }
                    }
                    ;
                }
                this.update();
            }
            else if (((elemIndex != null && elemIndex instanceof Array && (elemIndex.length == 0 || elemIndex[0] == null || (elemIndex[0] != null && elemIndex[0] instanceof geom.Shape2D))) || elemIndex === null) && ((count != null && count instanceof Array && (count.length == 0 || count[0] == null || (typeof count[0] === 'string'))) || count === null) && params === undefined || params.length === 0) {
                let __args = arguments;
                let parents = __args[0];
                let params = __args[1];
                {
                    let __args = arguments;
                    let elemIndex = javaemul.internal.IntegerHelper.parseInt(__args[2][0]);
                    let count = javaemul.internal.IntegerHelper.parseInt(__args[2][1]);
                    let params = __args[2][2];
                    super();
                    if (this.parsers === undefined) {
                        this.parsers = null;
                    }
                    if (this.children === undefined) {
                        this.children = null;
                    }
                    this.children = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(count);
                    const parent = [this];
                    for (let i = 0; i < count; i++) {
                        {
                            let s = null;
                            switch ((elemIndex)) {
                                case 0:
                                    s = new geom.Point2D();
                                    break;
                                case 1:
                                    s = new geom.Circle2D();
                                    break;
                                case 2:
                                    s = new geom.Line2D();
                                    break;
                                case 3:
                                    s = new geom.Segment2D();
                                    break;
                                case 4:
                                    s = new geom.Vector2D();
                                    break;
                            }
                            s.parents = parent;
                            s.params = [i + ""];
                            s.showEqn = false;
                            s.showName = false;
                            this.children[i] = s;
                        }
                        ;
                    }
                    this.params = [elemIndex + "", count + "", params[0], params[1], params[2], params[3]];
                    this.parsers = (new java.util.ArrayList());
                    for (let i = 0; i < params.length; i++) {
                        {
                            try {
                                if (params[i] == null || /* isEmpty */ (params[i].length === 0))
                                    break;
                                const s = math.MathUtils.createParser(params[i], ["i"], this.shapesManager == null ? null : this.shapesManager.globalVariables, this.shapesManager == null ? null : this.shapesManager.globalFunctions);
                                this.parsers.add(s);
                            }
                            catch (e) {
                                console.error(e.message, e);
                            }
                        }
                        ;
                    }
                    this.update();
                }
                if (this.parsers === undefined) {
                    this.parsers = null;
                }
                if (this.children === undefined) {
                    this.children = null;
                }
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @return {number}
         */
        getChildrenCount() {
            return this.children.length;
        }
        /**
         *
         * @param {number} index
         * @return {geom.Shape2D}
         */
        getChild(index) {
            if (index < 0 || index >= this.children.length)
                return null;
            return this.children[index];
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            const mode = javaemul.internal.IntegerHelper.parseInt(this.params[0]);
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("x1", this.params[2], null);
            if (index === 1)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("y1", this.params[3], null);
            if (mode > 0 && index === 2)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A(mode === 1 ? "radius" : "x2", this.params[4], null);
            if (mode > 1 && index === 3)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("y2", this.params[5], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            const v = value + "";
            if (index < 4) {
                try {
                    const s = math.MathUtils.createParser(v, ["i"], this.shapesManager == null ? null : this.shapesManager.globalVariables, this.shapesManager == null ? null : this.shapesManager.globalFunctions);
                    this.params[index + 2] = v;
                    this.parsers.set(index, s);
                }
                catch (e) {
                }
                this.update();
            }
        }
        /**
         *
         * @param {number} index
         * @param {string} value
         */
        setParam(index, value) {
            if (index > 1) {
                try {
                    const s = math.MathUtils.createParser(value, ["i"], this.shapesManager == null ? null : this.shapesManager.globalVariables, this.shapesManager == null ? null : this.shapesManager.globalFunctions);
                    super.setParam(index, value);
                    this.parsers.set(index - 2, s);
                }
                catch (e) {
                    console.error(e.message, e);
                }
            }
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            for (let i = 0; i < this.children.length; i++) {
                this.children[i].__isDefined = false;
            }
            if (this.shapesManager == null)
                return;
            const mode = javaemul.internal.IntegerHelper.parseInt(this.params[0]);
            let x;
            let y;
            let z = 0;
            let w = 0;
            if (this.shapesManager != null) {
                for (let index = this.shapesManager.globalVariables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    {
                        for (let index = this.parsers.iterator(); index.hasNext();) {
                            let p = index.next();
                            p.setVariable(key, this.shapesManager.globalVariables.get(key));
                        }
                    }
                }
            }
            for (let i = 0; i < this.children.length; i++) {
                {
                    this.parsers.get(0).setVariable("i", i);
                    this.parsers.get(1).setVariable("i", i);
                    x = this.parsers.get(0).evaluate();
                    y = this.parsers.get(1).evaluate();
                    if (mode > 0) {
                        this.parsers.get(2).setVariable("i", i);
                        z = this.parsers.get(2).evaluate();
                    }
                    if (mode > 2) {
                        this.parsers.get(3).setVariable("i", i);
                        w = this.parsers.get(3).evaluate();
                    }
                    const s = this.children[i];
                    switch ((mode)) {
                        case 0:
                            s.set(x, y);
                            break;
                        case 1:
                            s.set(x, y, z);
                            break;
                        case 2:
                            s.set$double$double$double(x, y, z);
                            break;
                        case 3:
                            s.set$double$double$double$double(x, y, z - x, w - y);
                            break;
                        case 4:
                            s.set$double$double$double$double(x, y, z - x, w - y);
                            break;
                    }
                }
                ;
            }
            this.__isDefined = true;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Sequence of shapes " + this.params[0] + " count = " + this.params[1];
        }
        /**
         *
         * @param {number} index
         * @return {string}
         */
        getChildInfo(index) {
            return "Shape at index " + index;
        }
    }
    geom.SequenceElementArray2D = SequenceElementArray2D;
    SequenceElementArray2D["__class"] = "geom.SequenceElementArray2D";
})(geom || (geom = {}));
(function (geom) {
    class LineAngleBisector2D extends geom.ParentShapeArray2D {
        constructor(line1, line2, index) {
            super();
            if (this.line1 === undefined) {
                this.line1 = null;
            }
            if (this.line2 === undefined) {
                this.line2 = null;
            }
            if (this.index === undefined) {
                this.index = 0;
            }
            this.parents = [line1, line2];
            const parents = [this];
            this.line1 = new geom.Line2D();
            this.line1.parents = parents;
            this.line2 = new geom.Line2D();
            this.line2.parents = parents;
            this.update();
        }
        /**
         *
         * @return {number}
         */
        getChildrenCount() {
            return 2;
        }
        /**
         *
         * @param {number} index
         * @return {geom.Shape2D}
         */
        getChild(index) {
            return index === 0 ? this.line1 : (index === 1 ? this.line2 : null);
        }
        update() {
            this.__isDefined = false;
            if (!this.parents[0].__isDefined || !this.parents[1].__isDefined)
                return;
            const line1 = this.parents[0];
            const line2 = this.parents[1];
            const p = geom.CurveUtils.LineLineIntersection$geom_Line2D$geom_Line2D(line1, line2);
            if (p == null)
                return;
            this.__isDefined = true;
            this.line1.set$double$double$double$double(p[0].x, p[0].y, line1.dx + line2.dx, line1.dy + line2.dy);
            this.line2.set$double$double$double$double(p[0].x, p[0].y, line1.dx - line2.dx, line1.dy - line2.dy);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Angle Bisector of " + this.parents[0].getName() + " & " + this.parents[1].getName();
        }
    }
    geom.LineAngleBisector2D = LineAngleBisector2D;
    LineAngleBisector2D["__class"] = "geom.LineAngleBisector2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     *
     * @param {geom.Conic2D} conic
     * @param {geom.Point2D} pt
     * @class
     * @extends geom.ParentShapeArray2D
     * @author maheshkurmi
     */
    class TangentsConicPoint2D extends geom.ParentShapeArray2D {
        constructor(conic, pt) {
            super();
            if (this.ray1 === undefined) {
                this.ray1 = null;
            }
            if (this.ray2 === undefined) {
                this.ray2 = null;
            }
            this.parents = [conic, pt];
            const parents = [this];
            this.ray1 = new geom.Ray2D();
            this.ray1.parents = parents;
            this.ray2 = new geom.Ray2D();
            this.ray2.parents = parents;
            this.update();
        }
        /**
         *
         * @return {number}
         */
        getChildrenCount() {
            return 2;
        }
        /**
         *
         * @param {number} index
         * @return {geom.Shape2D}
         */
        getChild(index) {
            return index === 0 ? this.ray1 : (index === 1 ? this.ray2 : null);
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            this.ray1.__isDefined = false;
            this.ray2.__isDefined = false;
            if (!this.parents[0].__isDefined || !this.parents[1].__isDefined)
                return;
            const c = this.parents[0];
            const pt = this.parents[1].pt;
            if (c.contains(pt)) {
                const t = c.t(pt);
                if (!isNaN(t)) {
                    const p = c.point(t);
                    const v = c.tangent(t);
                    this.ray1.set$double$double$double$double(p.x, p.y, v.x, v.y);
                    this.ray2.set$double$double$double$double(p.x, p.y, -v.x, -v.y);
                }
                return;
            }
            const ts = c.getFeetOfTangents(pt);
            for (let i = 0; i < ts.length; i++) {
                {
                    if (!isNaN(ts[i])) {
                        let p = c.point(ts[i]);
                        if (p == null)
                            continue;
                        p = pt.to$math_Vector2(p);
                        if (i === 0)
                            this.ray1.set$double$double$double$double(pt.x, pt.y, p.x, p.y);
                        else
                            this.ray2.set$double$double$double$double(pt.x, pt.y, p.x, p.y);
                        this.__isDefined = true;
                    }
                }
                ;
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Tangent on " + this.parents[0].name + " from " + this.parents[1].name;
        }
    }
    geom.TangentsConicPoint2D = TangentsConicPoint2D;
    TangentsConicPoint2D["__class"] = "geom.TangentsConicPoint2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * @param {geom.Conic2D} conic
     * @param {geom.Point2D} pt
     * @class
     * @extends geom.ParentShapeArray2D
     * @author maheshkurmi
     */
    class NormalsConicPoint2D extends geom.ParentShapeArray2D {
        constructor(conic, pt) {
            super();
            if (this.children === undefined) {
                this.children = null;
            }
            let n = 4;
            if (conic != null && conic instanceof geom.Circle2D)
                n = 1;
            else if (conic != null && conic instanceof geom.Parabola2D)
                n = 3;
            this.parents = [conic, pt];
            const parents = [this];
            this.children = (s => { let a = []; while (s-- > 0)
                a.push(null); return a; })(n);
            for (let i = 0; i < n; i++) {
                {
                    this.children[i] = new geom.Ray2D();
                    this.children[i].parents = parents;
                    this.children[i].params = [i + ""];
                }
                ;
            }
            this.update();
        }
        /**
         *
         * @return {number}
         */
        getChildrenCount() {
            return this.children.length;
        }
        /**
         *
         * @param {number} index
         * @return {geom.Shape2D}
         */
        getChild(index) {
            if (index < 0 || index >= this.children.length)
                return null;
            return this.children[index];
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            for (let index = 0; index < this.children.length; index++) {
                let ray = this.children[index];
                ray.__isDefined = false;
            }
            if (!this.parents[0].__isDefined || !this.parents[1].__isDefined)
                return;
            const c = this.parents[0];
            const pt = this.parents[1].pt;
            if (c.contains(pt)) {
                const t = c.t(pt);
                if (!isNaN(t)) {
                    const p = c.point(t);
                    const v = c.tangent(t).right();
                    this.children[0].set$double$double$double$double(p.x, p.y, v.x, v.y);
                    this.children[0].__isDefined = true;
                }
                return;
            }
            const ts = c.getFeetOfNormals(pt);
            for (let i = 0; i < ts.length; i++) {
                {
                    if (!isNaN(ts[i])) {
                        let p = c.point(ts[i]);
                        if (p == null)
                            continue;
                        p = pt.to$math_Vector2(p);
                        if (p.isZero())
                            p = c.tangent(ts[i]).right();
                        this.children[i].set$double$double$double$double(pt.x, pt.y, p.x, p.y);
                        this.__isDefined = true;
                    }
                }
                ;
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Normal on " + this.parents[0].name + " from " + this.parents[1].name;
        }
    }
    geom.NormalsConicPoint2D = NormalsConicPoint2D;
    NormalsConicPoint2D["__class"] = "geom.NormalsConicPoint2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * @param {geom.Conic2D} conic
     * @param pt
     * @class
     * @extends geom.ParentShapeArray2D
     * @author maheshkurmi
     */
    class FociConic2D extends geom.ParentShapeArray2D {
        constructor(conic) {
            super();
            if (this.f1 === undefined) {
                this.f1 = null;
            }
            if (this.f2 === undefined) {
                this.f2 = null;
            }
            this.parents = [conic];
            this.f1 = new geom.Point2D();
            this.f1.parents = [this];
            this.f2 = new geom.Point2D();
            this.f2.parents = this.f1.parents;
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            this.f1.__isDefined = false;
            this.f2.__isDefined = false;
            if (!this.parents[0].__isDefined)
                return;
            const c = this.parents[0];
            const f = c.foci();
            if (f == null || f.length === 0)
                return;
            this.f1.set(f[0].x, f[0].y);
            if (f.length > 1)
                this.f2.set(f[1].x, f[1].y);
            this.__isDefined = f.length > 0;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Focus of Conic " + this.parents[0].name;
        }
        /**
         *
         * @return {number}
         */
        getChildrenCount() {
            return 2;
        }
        /**
         *
         * @param {number} index
         * @return {geom.Shape2D}
         */
        getChild(index) {
            return index === 0 ? this.f1 : (index === 1 ? this.f2 : null);
        }
    }
    geom.FociConic2D = FociConic2D;
    FociConic2D["__class"] = "geom.FociConic2D";
})(geom || (geom = {}));
(function (geom) {
    class Measure2D extends geom.Label2D {
        constructor(x, y, label) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof label === 'string') || label === null)) {
                let __args = arguments;
                super(x, y, label);
            }
            else if (((x != null && x instanceof geom.Point2D) || x === null) && ((typeof y === 'string') || y === null) && label === undefined) {
                let __args = arguments;
                let pt = __args[0];
                let label = __args[1];
                super(pt, label);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * perform some action if needed (like resource release, reset global variables etc) when the shape is removed
         */
        dispose() {
            if (this.shapesManager != null)
                this.shapesManager.globalVariables.remove(this.getName());
        }
        /**
         * @param {string} name
         * the name to set
         */
        setName(name) {
            if (name != null) {
                name = /* replaceAll */ name.replace(new RegExp(" ", 'g'), "");
                if (this.shapesManager.containsShape(this))
                    this.shapesManager.globalVariables.remove(this.name);
                this.name = name;
            }
            this.update();
        }
        /**
         * returns info for the shape
         *
         * @return
         * @return {string}
         */
        getInfo() {
            let s = this.showName ? this.name : "";
            if (this.showEqn)
                s += (this.showName ? "=" : "") + this.getEquation();
            return s;
        }
    }
    geom.Measure2D = Measure2D;
    Measure2D["__class"] = "geom.Measure2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * @author mahesh kurmi
     * @param {geom.Shape2D[]} shapes
     * @param {java.lang.String[]} params
     * @class
     * @extends geom.Label2D
     */
    class ShapeInfo2D extends geom.Label2D {
        constructor(shapes, params) {
            if (((shapes != null && shapes instanceof Array && (shapes.length == 0 || shapes[0] == null || (shapes[0] != null && shapes[0] instanceof geom.Shape2D))) || shapes === null) && ((params != null && params instanceof Array && (params.length == 0 || params[0] == null || (typeof params[0] === 'string'))) || params === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let p1 = shapes[1];
                    let p2 = shapes[0];
                    super(p2, "");
                    this.info = "name : expr";
                    this.updateNeeded = false;
                    this.parents = [p2, p1];
                    this.update();
                }
                this.info = "name : expr";
                this.updateNeeded = false;
            }
            else if (((shapes != null && shapes instanceof geom.Curve2D) || shapes === null) && ((params != null && params instanceof geom.Point2D) || params === null)) {
                let __args = arguments;
                let p1 = __args[0];
                let p2 = __args[1];
                super(p2, "");
                this.info = "name : expr";
                this.updateNeeded = false;
                this.parents = [p2, p1];
                this.update();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {string} label
         */
        setLabel(label) {
            this.info = label;
            this.updateNeeded = true;
        }
        update() {
            super.update();
            if (this.parents.length < 2 || !this.parents[1].__isDefined) {
                this.__isDefined = false;
                return;
            }
            this.__isDefined = true;
            let label = "";
            if (this.showName && this.showEqn)
                label = this.parents[1].getName() + " : " + this.parents[1].getEquation();
            else if (this.showName)
                label = this.parents[1].getName();
            else if (this.showEqn)
                label = this.parents[1].getEquation();
            else
                label = "";
            if (!(label === this.info))
                this.updateNeeded = true;
            this.info = label;
        }
        /**
         *
         * @param {framework.Renderer} gl
         */
        render(gl) {
            if (!this.__isDefined || !this.visible)
                return;
            super.render(gl);
        }
    }
    geom.ShapeInfo2D = ShapeInfo2D;
    ShapeInfo2D["__class"] = "geom.ShapeInfo2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * This constructor is needed to be able to construct to point when loading a file.
     *
     * @param {geom.Point2D} basePoint
     * the reference point
     * @param x
     * x-coordinate of translation vector
     * @param y
     * y-coordinate of translation vector
     * @param {string} dx
     * @param {string} dy
     * @class
     * @extends geom.FreePoint2D
     */
    class PointRelativePoint2D extends geom.FreePoint2D {
        constructor(basePoint, dx, dy) {
            if (((basePoint != null && basePoint instanceof geom.Point2D) || basePoint === null) && ((typeof dx === 'string') || dx === null) && ((typeof dy === 'string') || dy === null)) {
                let __args = arguments;
                super();
                this.parents = [basePoint];
                this.params = [dx + "", dy + ""];
                this.update();
            }
            else if (((basePoint != null && basePoint instanceof geom.Point2D) || basePoint === null) && ((dx != null && dx instanceof geom.Point2D) || dx === null) && dy === undefined) {
                let __args = arguments;
                let location = __args[1];
                super();
                this.parents = [basePoint];
                const point1 = basePoint.pt;
                const point2 = location.pt;
                const dx = point2.x - point1.x;
                const dy = point2.y - point1.y;
                this.params = [dx + "", dy + ""];
                this.update();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Point relative to Point " + this.parents[0].getName();
        }
        /**
         *
         */
        update() {
            if (!(this.parents[0].__isDefined))
                return;
            const point1 = this.parents[0].pt;
            try {
                const dx = javaemul.internal.DoubleHelper.parseDouble(this.params[0]);
                const dy = javaemul.internal.DoubleHelper.parseDouble(this.params[1]);
                this.pt = new math.Vector2(point1.x + dx, point1.y + dy);
                this.__isDefined = true;
            }
            catch (e) {
                return;
            }
        }
        /**
         *
         * @param {math.Vector2} delta
         * @param {math.Vector2} worldPt
         * @param {boolean} manually
         */
        mouseDragged(delta, worldPt, manually) {
            if (!this.isDefined())
                return;
            super.mouseDragged(delta, worldPt, manually);
            const p = this.pt.copy();
            this.delta.add$math_Vector2(delta);
            this.pt.add$math_Vector2(this.delta);
            if (manually)
                this.pt = this.shapesManager.preferences.snapToGrid(this.pt);
            if (!math.MathUtils.approxEqual(this.pt, p))
                this.delta.set$double$double(0, 0);
            const point1 = this.parents[0].pt;
            this.params = [(this.pt.x - point1.x) + "", (this.pt.y - point1.y) + ""];
        }
    }
    geom.PointRelativePoint2D = PointRelativePoint2D;
    PointRelativePoint2D["__class"] = "geom.PointRelativePoint2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Full constructor used to deserialize path
     * @param {geom.Shape2D[]} pts
     * @param pathInfo
     * @param {java.lang.String[]} params
     * @class
     * @extends geom.Path2D
     */
    class PathNpoints2D extends geom.Path2D {
        constructor(pts, params) {
            if (((pts != null && pts instanceof Array && (pts.length == 0 || pts[0] == null || (pts[0] != null && pts[0] instanceof geom.Shape2D))) || pts === null) && ((params != null && params instanceof Array && (params.length == 0 || params[0] == null || (typeof params[0] === 'string'))) || params === null)) {
                let __args = arguments;
                super();
                if (this.arcInfo === undefined) {
                    this.arcInfo = null;
                }
                if (this.vertices === undefined) {
                    this.vertices = null;
                }
                this.params = params;
                this.parents = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(pts.length);
                this.vertices = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(pts.length);
                this.arcInfo = (s => { let a = []; while (s-- > 0)
                    a.push(false); return a; })(pts.length);
                for (let i = 0; i < pts.length; i++) {
                    {
                        this.parents[i] = pts[i];
                        this.arcInfo[i] = (c => c.charCodeAt == null ? c : c.charCodeAt(0))(params[0].charAt(i)) == '0'.charCodeAt(0) ? false : true;
                    }
                    ;
                }
                this.fillColor = framework.Preferences.getRandomColor();
                this.drawColor = framework.Preferences.getRandomColor();
                this.fillColor.a = 169;
                this.createPath$();
            }
            else if (pts === undefined && params === undefined) {
                let __args = arguments;
                super();
                if (this.arcInfo === undefined) {
                    this.arcInfo = null;
                }
                if (this.vertices === undefined) {
                    this.vertices = null;
                }
            }
            else
                throw new Error('invalid overload');
        }
        createPath(vertices, arcInfo) {
            if (((vertices != null && vertices instanceof Array && (vertices.length == 0 || vertices[0] == null || (vertices[0] != null && vertices[0] instanceof math.Vector2))) || vertices === null) && ((arcInfo != null && arcInfo instanceof Array && (arcInfo.length == 0 || arcInfo[0] == null || (typeof arcInfo[0] === 'boolean'))) || arcInfo === null)) {
                super.createPath(vertices, arcInfo);
            }
            else if (vertices === undefined && arcInfo === undefined) {
                return this.createPath$();
            }
            else
                throw new Error('invalid overload');
        }
        createPath$() {
            this.curves.clear();
            let p0 = this.parents[0];
            let p;
            const n = this.parents.length;
            for (let i = 1; i < n; i++) {
                {
                    p = this.parents[i];
                    if (this.arcInfo[i] === false) {
                        this.curves.add(new geom.Segment2Points2D(p0, p));
                        if (i === n - 1 && n > 2)
                            this.curves.add(new geom.Segment2Points2D(p, this.parents[0]));
                        p0 = p;
                    }
                    else {
                        const p2 = this.parents[(i + 1) % n];
                        if (math.Vector2.isCollinear(p0.pt, p.pt, p2.pt)) {
                            this.arcInfo[i] = false;
                            i--;
                            continue;
                        }
                        const arc = new geom.CircleArc3Points2D(p0, p, p2);
                        this.curves.add(arc);
                        p0 = p2;
                        if (i < n - 2)
                            i++;
                    }
                }
                ;
            }
            this.__t0 = 0;
            this.__t1 = this.curves.size();
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (this.parents.length < 1)
                return;
            for (let index = 0; index < this.parents.length; index++) {
                let p = this.parents[index];
                {
                    if (!p.__isDefined)
                        return;
                }
            }
            for (let i = 0; i < this.vertices.length; i++) {
                {
                    this.vertices[i] = this.parents[i].pt;
                }
                ;
            }
            super.createPath(this.vertices, this.arcInfo);
        }
        getCurves() {
            return this.curves;
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return null;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Path from Pts";
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.__isDefined)
                return;
            if (this.fillColor != null) {
            }
            if (this.drawColor != null) {
                for (let index = this.curves.iterator(); index.hasNext();) {
                    let c = index.next();
                    {
                        c.drawColor = this.drawColor;
                        if (c.__isDefined === false && (c != null && c instanceof geom.CircleArc3Points2D)) {
                            const p1 = c.parents[0].pt;
                            const p2 = c.parents[2].pt;
                            g.drawLine(p1.x, p1.y, p2.x, p2.y);
                        }
                        else {
                            c.render(g);
                        }
                    }
                }
            }
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            for (let index = this.curves.iterator(); index.hasNext();) {
                let c = index.next();
                {
                    if (c.isSnapped(pt))
                        return true;
                }
            }
            return false;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            let d = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
            for (let index = this.curves.iterator(); index.hasNext();) {
                let c = index.next();
                {
                    d = Math.min(c.distance(pt), d);
                }
            }
            return d;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {number}
         */
        t(point) {
            let d0 = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
            let t = 0;
            let i = 0;
            for (let index = this.curves.iterator(); index.hasNext();) {
                let c = index.next();
                {
                    const d = point.distanceSquared$math_Vector2(c.project(point));
                    if (d < d0) {
                        d0 = d;
                        t = i + (c.t(point) - c.__t0) / (c.__t1 - c.__t0);
                    }
                    i++;
                }
            }
            return t;
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            const i = (Math.floor(t) | 0);
            const c = this.curves.get(i);
            return c.point(c.__t0 + (c.__t1 - c.__t0) * (t - i));
        }
        /**
         * Returns the unit Vector along tangent to curve
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            const i = (Math.floor(t) | 0);
            const c = this.curves.get(i);
            if (c != null && c instanceof geom.Line2D)
                return c.getDirection();
            return c.tangent(c.__t0 + (c.__t1 - c.__t0) * (t - i));
        }
    }
    geom.PathNpoints2D = PathNpoints2D;
    PathNpoints2D["__class"] = "geom.PathNpoints2D";
})(geom || (geom = {}));
(function (geom) {
    class Segment2D extends geom.Line2D {
        constructor(p1, p2) {
            if (((p1 != null && p1 instanceof math.Vector2) || p1 === null) && ((p2 != null && p2 instanceof math.Vector2) || p2 === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    super();
                    this.renderMode = 0;
                    this.__t0 = 0;
                    this.__t1 = 1;
                }
                this.renderMode = 0;
                (() => {
                    this.set$math_Vector2$math_Vector2(p1, p2);
                })();
            }
            else if (p1 === undefined && p2 === undefined) {
                let __args = arguments;
                super();
                this.renderMode = 0;
                this.__t0 = 0;
                this.__t1 = 1;
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Sets line as passing through point (x,y) and direction rations as dx and dy
         * @param {number} x
         * @param {number} y
         * @param {number} dx
         * @param {number} dy
         */
        set(x, y, dx, dy) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && ((typeof dy === 'number') || dy === null)) {
                super.set(x, y, dx, dy);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && dy === undefined) {
                return this.set$double$double$double(x, y, dx);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && ((y != null && y instanceof math.Vector2) || y === null) && dx === undefined && dy === undefined) {
                return this.set$math_Vector2$math_Vector2(x, y);
            }
            else
                throw new Error('invalid overload');
        }
        set$math_Vector2$math_Vector2(p1, p2) {
            const v = this.p2.difference$math_Vector2(p1).getNormalized();
            this.x0 = p1.x;
            this.y0 = p1.y;
            this.dx = p2.x - p1.x;
            this.dy = p2.y - p1.y;
            if (Math.abs(this.dy) < framework.Preferences.EPSILON) {
                this.dy = 0;
            }
            else if (Math.abs(this.dx) < framework.Preferences.EPSILON) {
                this.dx = 0;
            }
            this.p1.set$double$double(this.x0, this.y0);
            this.p2.set$double$double(this.x0 + this.dx, this.y0 + this.dy);
            const r = math.MathUtils.hypot(this.dx, this.dy);
            this.dx /= r;
            this.dy /= r;
            if (this != null && this instanceof geom.Vector2D) {
                this.expr = math.MathUtils.formatVector(v);
            }
            else {
                this.expr = math.MathUtils.formatValue(v.getMagnitude(), false) + " m";
            }
            this.__isDefined = true;
        }
        clip() {
        }
        update() {
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.isDefined())
                return;
            const v1 = this.p1;
            const v2 = this.p2;
            const v = v1.to$math_Vector2(v2);
            const l = v.normalize();
            switch ((this.renderMode)) {
                case 0:
                    g.drawLine(v1.x, v1.y, v2.x, v2.y);
                    break;
                case 2:
                    g.drawArrow(v1.x, v1.y, v.x, v.y, l);
                    g.drawArrow(v2.x, v2.y, -v.x, -v.y, l);
                    break;
                case 1:
                    g.drawArrow(v1.x, v1.y, v.x, v.y, l);
                    break;
                default:
                    break;
            }
            if (this.showEqn || this.showName) {
                this.renderInfo(g, v1, v2);
            }
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            return this.distance(pt) < geom.Shape2D.SNAP_DISTANCE;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        t(pt) {
            const p1ToP = pt.difference$math_Vector2(this.p1);
            const line = this.p2.difference$math_Vector2(this.p1);
            const ab2 = line.dot$math_Vector2(line);
            const ap_ab = p1ToP.dot$math_Vector2(line);
            if (ab2 <= framework.Preferences.EPSILON)
                return 0;
            let t = ap_ab / ab2;
            t = math.MathUtils.clamp$double$double$double(t, 0.0, 1.0);
            return t;
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            t = math.MathUtils.clamp$double$double$double(t, 0.0, 1.0);
            return this.p1.to$math_Vector2(this.p2).multiply(t).add$math_Vector2(this.p1);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Segment " + this.name;
        }
        /**
         * Returns true if the specified point  lies on the boundary of shape
         * @param {math.Vector2} pt {Vector2 }
         * @return {boolean} {Boolean}
         */
        contains(pt) {
            if (!this.__isDefined)
                return false;
            return this.distance(pt) < geom.Shape2D.ACCURACY;
        }
    }
    geom.Segment2D = Segment2D;
    Segment2D["__class"] = "geom.Segment2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Line from catesian eqn in form ax+by+c=0
     *
     * @param {string} a
     * @param {string} b
     * @param {string} c
     * @class
     * @extends geom.Line2D
     * @author maheshkurmi
     */
    class LineEqn2D extends geom.Line2D {
        constructor(a, b, c) {
            super();
            if (this.a === undefined) {
                this.a = null;
            }
            if (this.b === undefined) {
                this.b = null;
            }
            if (this.c === undefined) {
                this.c = null;
            }
            this.a = new geom.optics.DynamicValue(a, javaemul.internal.DoubleHelper.NEGATIVE_INFINITY, javaemul.internal.DoubleHelper.POSITIVE_INFINITY);
            this.b = new geom.optics.DynamicValue(b, javaemul.internal.DoubleHelper.NEGATIVE_INFINITY, javaemul.internal.DoubleHelper.POSITIVE_INFINITY);
            this.c = new geom.optics.DynamicValue(c, javaemul.internal.DoubleHelper.NEGATIVE_INFINITY, javaemul.internal.DoubleHelper.POSITIVE_INFINITY);
            this.set$java_lang_String$java_lang_String$java_lang_String(a, b, c);
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("a", this.params[0], null);
            if (index === 1)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("b", this.params[1], null);
            if (index === 2)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("c", this.params[2], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            const __var = value + "";
            if (index === 0) {
                this.params[0] = __var;
                this.a.set$java_lang_String(__var);
            }
            else if (index === 1) {
                this.params[1] = __var;
                this.b.set$java_lang_String(__var);
            }
            else if (index === 2) {
                this.params[2] = __var;
                this.c.set$java_lang_String(__var);
            }
            this.update();
        }
        /**
         *
         */
        update() {
            this.a.update();
            this.b.update();
            this.c.update();
            const a = this.a.getValue();
            const b = this.b.getValue();
            const c = this.c.getValue();
            if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(a) || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(b) || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(c) || (a === 0 && b === 0)) {
                this.__isDefined = false;
                return;
            }
            else if (a === 0) {
                super.set$double$double$double$double(0, -c / b, 1, 0);
            }
            else if (b === 0) {
                super.set$double$double$double$double(-c / a, 0, 0, 1);
            }
            else {
                super.set$double$double$double$double(0, -c / b, b, -a);
            }
        }
        /**
         * Sets line as passing through point (x,y) and direction rations as dx and dy
         * @param {number} x
         * @param {number} y
         * @param {number} dx
         * @param {number} dy
         */
        set(x, y, dx, dy) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && ((typeof dy === 'number') || dy === null)) {
                super.set(x, y, dx, dy);
            }
            else if (((typeof x === 'string') || x === null) && ((typeof y === 'string') || y === null) && ((typeof dx === 'string') || dx === null) && dy === undefined) {
                return this.set$java_lang_String$java_lang_String$java_lang_String(x, y, dx);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && dy === undefined) {
                return this.set$double$double$double(x, y, dx);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && ((y != null && y instanceof math.Vector2) || y === null) && dx === undefined && dy === undefined) {
                return this.set$math_Vector2$math_Vector2(x, y);
            }
            else
                throw new Error('invalid overload');
        }
        set$java_lang_String$java_lang_String$java_lang_String(expra, exprb, exprc) {
            this.params = [expra, exprb, exprc];
            this.a.set$java_lang_String(expra);
            this.b.set$java_lang_String(exprb);
            this.c.set$java_lang_String(exprc);
            this.update();
            this.expr = math.MathUtils.formatEqn$java_lang_String_A$java_lang_String_A(this.params, ["x", "y", ""]);
        }
    }
    geom.LineEqn2D = LineEqn2D;
    LineEqn2D["__class"] = "geom.LineEqn2D";
})(geom || (geom = {}));
(function (geom) {
    class LineTangent2D extends geom.Line2D {
        constructor(curve, p) {
            super();
            this.parents = [curve, p];
            this.update();
        }
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                return;
            }
            let v1 = this.parents[1].pt;
            const curve = this.parents[0];
            const t = curve.t(v1);
            if (t === javaemul.internal.DoubleHelper.NaN)
                return;
            const m = curve.tangent(t);
            v1 = curve.point(t);
            if (m == null || v1 == null)
                return;
            super.set$double$double$double$double(v1.x, v1.y, m.x, m.y);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Line tangent to " + this.parents[0].getName() + " at " + this.parents[1].getName();
        }
    }
    geom.LineTangent2D = LineTangent2D;
    LineTangent2D["__class"] = "geom.LineTangent2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     *
     * @param {geom.Conic2D} conic
     * @param pt
     * @param {geom.Line2D} line
     * @param {string} mode
     * @class
     * @extends geom.Line2D
     * @author maheshkurmi
     */
    class NormalsConicLine2D extends geom.Line2D {
        constructor(conic, line, mode) {
            if (((conic != null && conic instanceof geom.Conic2D) || conic === null) && ((line != null && line instanceof geom.Line2D) || line === null) && ((typeof mode === 'string') || mode === null)) {
                let __args = arguments;
                super();
                this.mode = 0;
                this.parents = [conic, line];
                this.params = [mode];
                this.mode = javaemul.internal.IntegerHelper.parseInt(mode);
                this.update();
            }
            else if (((conic != null && conic instanceof geom.Conic2D) || conic === null) && ((line != null && line instanceof geom.Line2D) || line === null) && mode === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let mode = "0";
                    super();
                    this.mode = 0;
                    this.parents = [conic, line];
                    this.params = [mode];
                    this.mode = javaemul.internal.IntegerHelper.parseInt(mode);
                    this.update();
                }
                this.mode = 0;
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {geom.ShapesManager} manager
         */
        onAddShapeToSimulation(manager) {
            super.onAddShapeToSimulation(manager);
            if (this.mode === 0 && this.__isDefined) {
                const curve = this.parents[0];
                const line = this.parents[1];
                const l1 = new NormalsConicLine2D(curve, line, "1");
                const l2 = new NormalsConicLine2D(curve, line, "2");
                this.shapesManager.removeShape(this);
                if (l1.__isDefined)
                    this.shapesManager.addShape(l1);
                if (l2.__isDefined)
                    this.shapesManager.addShape(l2);
            }
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].__isDefined || !this.parents[1].__isDefined)
                return;
            const c = this.parents[0];
            const line = this.parents[1];
            const ts = c.getFeetOfParallelNormals(line.getDirection());
            this.__isDefined = ts != null;
            if (this.mode === 0)
                return;
            this.__isDefined = false;
            let i = 0;
            for (let index = 0; index < ts.length; index++) {
                let t = ts[index];
                {
                    i++;
                    if ( /* isNaN */isNaN(t))
                        continue;
                    const p = c.point(t);
                    if (p != null) {
                        const dir = c.tangent(t).right();
                        if (i === this.mode) {
                            this.set$double$double$double$double(p.x, p.y, dir.x, dir.y);
                            this.__isDefined = true;
                        }
                    }
                }
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Normal on " + this.parents[0].name + " parallel to " + this.parents[1].name;
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (this.mode === 0) {
                const c = this.parents[0];
                const line = this.parents[1];
                const ts = c.getFeetOfParallelNormals(line.getDirection());
                if (ts == null)
                    return;
                for (let index = 0; index < ts.length; index++) {
                    let t = ts[index];
                    {
                        if ( /* isNaN */isNaN(t))
                            continue;
                        const p = c.point(t);
                        if (p != null) {
                            const dir = c.tangent(t).right();
                            if (NormalsConicLine2D.TMP_LINE == null)
                                NormalsConicLine2D.TMP_LINE = new geom.Line2D();
                            NormalsConicLine2D.TMP_LINE.set$double$double$double$double(p.x, p.y, dir.x, dir.y);
                            NormalsConicLine2D.TMP_LINE.clip();
                            NormalsConicLine2D.TMP_LINE.render(g);
                        }
                    }
                }
                return;
            }
            super.render(g);
        }
    }
    NormalsConicLine2D.TMP_LINE = null;
    geom.NormalsConicLine2D = NormalsConicLine2D;
    NormalsConicLine2D["__class"] = "geom.NormalsConicLine2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * By default, LineArc2Points2D with only 2 points is a line segment.
     * This is equivalent to LineArc2Points2D(point1, point2, 0, 1).
     * @param point1
     * @param point2
     * @param {geom.Point2D} point
     * @param {string} expr
     * @class
     * @extends geom.Line2D
     * @author mahesh kurmi
     */
    class LinePointAngle2D extends geom.Line2D {
        constructor(point, expr) {
            super();
            if (this.angle === undefined) {
                this.angle = 0;
            }
            this.parents = [point];
            this.params = [expr];
            this.update();
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Angle (rads)", this.params[0], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                this.update();
            }
        }
        /**
         *
         * @return {string}
         */
        getInfo() {
            return "Line at angle " + this.expr + " radians  to X axis through " + this.parents[1].getName();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined()) {
                return;
            }
            try {
                this.angle = math.MathUtils.evaluateExpression(this.params[0], this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables);
            }
            catch (e) {
                return;
            }
            const v1 = this.parents[0].pt;
            const v = new math.Vector2(this.angle);
            super.set$math_Vector2$math_Vector2(v1, v1.sum$math_Vector2(v));
            this.__isDefined = true;
        }
    }
    geom.LinePointAngle2D = LinePointAngle2D;
    LinePointAngle2D["__class"] = "geom.LinePointAngle2D";
})(geom || (geom = {}));
(function (geom) {
    class LinePointParallelLine2D extends geom.Line2D {
        constructor(line, p) {
            super();
            this.parents = [line, p];
            this.update();
        }
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[1].pt;
            const line = this.parents[0];
            super.set$double$double$double$double(v1.x, v1.y, line.dx, line.dy);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Line parallel to " + this.parents[0].getName() + " & passing through " + this.parents[1].getName();
        }
    }
    geom.LinePointParallelLine2D = LinePointParallelLine2D;
    LinePointParallelLine2D["__class"] = "geom.LinePointParallelLine2D";
})(geom || (geom = {}));
(function (geom) {
    class LinePointPerpendicularLine2D extends geom.Line2D {
        constructor(line, p) {
            super();
            this.parents = [line, p];
            this.update();
        }
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[1].pt;
            const line = this.parents[0];
            this.set$double$double$double$double(v1.x, v1.y, -line.dy, line.dx);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Line perpendicular to " + this.parents[0].getName() + " & passing through " + this.parents[1].getName();
        }
    }
    geom.LinePointPerpendicularLine2D = LinePointPerpendicularLine2D;
    LinePointPerpendicularLine2D["__class"] = "geom.LinePointPerpendicularLine2D";
})(geom || (geom = {}));
(function (geom) {
    class LineNormal2D extends geom.Line2D {
        constructor(curve, p) {
            super();
            this.parents = [curve, p];
            this.update();
        }
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                return;
            }
            let v1 = this.parents[1].pt;
            const curve = this.parents[0];
            const t = curve.t(v1);
            if (t === javaemul.internal.DoubleHelper.NaN)
                return;
            const m = curve.tangent(t);
            v1 = curve.point(t);
            if (m == null || v1 == null)
                return;
            m.right();
            super.set$double$double$double$double(v1.x, v1.y, m.x, m.y);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Line normal to " + this.parents[0].getName() + " at " + this.parents[1].getName();
        }
    }
    geom.LineNormal2D = LineNormal2D;
    LineNormal2D["__class"] = "geom.LineNormal2D";
})(geom || (geom = {}));
(function (geom) {
    class Line2Points2D extends geom.Line2D {
        constructor(p1, p2) {
            super();
            this.parents = [p1, p2];
            this.update();
        }
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[0].pt;
            const v2 = this.parents[1].pt;
            if (v1 == null || v2 == null || v1.equals$math_Vector2(v2)) {
                this.expr = null;
                this.__isDefined = false;
                return;
            }
            super.set$math_Vector2$math_Vector2(v1, v2);
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.isDefined())
                return;
            g.drawLine(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
            if (this.showEqn || this.showName) {
                this.renderInfo(g, this.parents[0].pt, this.parents[1].pt);
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Line through " + this.parents[0].getName() + " & " + this.parents[1].getName();
        }
    }
    geom.Line2Points2D = Line2Points2D;
    Line2Points2D["__class"] = "geom.Line2Points2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * @author Mahesh
     * @param {geom.Line2D} baseLine
     * @param {geom.Point2D} point
     * @param {string} angle
     * @class
     * @extends geom.Line2D
     */
    class LineLineAnglePoint2D extends geom.Line2D {
        constructor(baseLine, point, angle) {
            super();
            this.angle = javaemul.internal.DoubleHelper.NaN;
            this.parents = [baseLine, point];
            this.params = [angle];
            this.update();
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Angle (rads)", this.params[0], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                this.update();
            }
        }
        /**
         *
         * @return {string}
         */
        getInfo() {
            return "Line at angle " + this.expr + " radians  to " + this.parents[0].getName() + " through " + this.parents[1].getName();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                return;
            }
            try {
                this.angle = math.MathUtils.evaluateExpression(this.params[0], this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables);
            }
            catch (e) {
                return;
            }
            const v1 = this.parents[1].pt;
            const line = this.parents[0];
            const v = new math.Vector2(line.dx, line.dy);
            v.rotate$double(this.angle);
            super.set$math_Vector2$math_Vector2(v1, v1.sum$math_Vector2(v));
            this.__isDefined = true;
        }
    }
    geom.LineLineAnglePoint2D = LineLineAnglePoint2D;
    LineLineAnglePoint2D["__class"] = "geom.LineLineAnglePoint2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * @param {geom.Conic2D} conic
     * @param {geom.Point2D} point Midpoint of COC
     * @class
     * @extends geom.Line2D
     * @author mahesh kurmi
     */
    class MidPointChordConicPoint2D extends geom.Line2D {
        constructor(conic, point) {
            super();
            this.parents = [conic, point];
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined())
                return;
            const conic = this.parents[0];
            const point = this.parents[1].pt;
            const h = point.x;
            const k = point.y;
            let c = [0, 0, 0, 0, 0, 0];
            c = conic.conicCoefficients();
            const l = c[0] * h + c[1] * k / 2 + c[3] / 2;
            const m = c[2] * k + c[1] * h / 2 + c[4] / 2;
            let n = c[3] * h / 2 + c[4] * k / 2 + c[5];
            n = n - (c[0] * h * h + c[1] * h * k + c[2] * k * k + c[3] * h + c[4] * k + c[5]);
            if (l === 0 && m === 0)
                return;
            else if (l === 0)
                this.set$double$double$double$double(0, -n / m, 1, 0);
            else if (m === 0)
                this.set$double$double$double$double(-n / l, 0, 0, 1);
            else
                this.set$double$double$double$double(-n / l, 0, n / l, -n / m);
            this.__isDefined = true;
        }
        /**
         *
         * @return {string}
         */
        getInfo() {
            return "Chord on conic  " + this.parents[0].getName() + " with mid-point " + this.parents[1].getName();
        }
    }
    geom.MidPointChordConicPoint2D = MidPointChordConicPoint2D;
    MidPointChordConicPoint2D["__class"] = "geom.MidPointChordConicPoint2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * @param {geom.Conic2D} conic
     * @param pt
     * @param {geom.Line2D} line
     * @param {string} mode
     * @class
     * @extends geom.Line2D
     * @author maheshkurmi
     */
    class TangentsConicLine2D extends geom.Line2D {
        constructor(conic, line, mode) {
            if (((conic != null && conic instanceof geom.Conic2D) || conic === null) && ((line != null && line instanceof geom.Line2D) || line === null) && ((typeof mode === 'string') || mode === null)) {
                let __args = arguments;
                super();
                this.mode = 0;
                this.parents = [conic, line];
                this.params = [mode];
                this.mode = javaemul.internal.IntegerHelper.parseInt(mode);
                this.update();
            }
            else if (((conic != null && conic instanceof geom.Conic2D) || conic === null) && ((line != null && line instanceof geom.Line2D) || line === null) && mode === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let mode = "0";
                    super();
                    this.mode = 0;
                    this.parents = [conic, line];
                    this.params = [mode];
                    this.mode = javaemul.internal.IntegerHelper.parseInt(mode);
                    this.update();
                }
                this.mode = 0;
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {geom.ShapesManager} manager
         */
        onAddShapeToSimulation(manager) {
            super.onAddShapeToSimulation(manager);
            if (this.mode === 0 && this.__isDefined) {
                const curve = this.parents[0];
                const line = this.parents[1];
                const l1 = new TangentsConicLine2D(curve, line, "1");
                const l2 = new TangentsConicLine2D(curve, line, "2");
                this.shapesManager.removeShape(this);
                if (l1.__isDefined)
                    this.shapesManager.addShape(l1);
                if (l2.__isDefined)
                    this.shapesManager.addShape(l2);
            }
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].__isDefined || !this.parents[1].__isDefined)
                return;
            const c = this.parents[0];
            const line = this.parents[1];
            const ts = c.getFeetOfParallelTangents(line.getDirection());
            this.__isDefined = (ts != null);
            if (this.mode === 0)
                return;
            this.__isDefined = false;
            let i = 0;
            for (let index = 0; index < ts.length; index++) {
                let t = ts[index];
                {
                    i++;
                    if ( /* isNaN */isNaN(t))
                        continue;
                    const p = c.point(t);
                    if (p != null) {
                        const dir = c.tangent(t);
                        if (i === this.mode) {
                            this.set$double$double$double$double(p.x, p.y, dir.x, dir.y);
                            this.__isDefined = true;
                        }
                    }
                }
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Tangent on " + this.parents[0].name + " Parallel to " + this.parents[1].name;
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (this.mode === 0) {
                const c = this.parents[0];
                const line = this.parents[1];
                const ts = c.getFeetOfParallelTangents(line.getDirection());
                if (ts == null)
                    return;
                for (let index = 0; index < ts.length; index++) {
                    let t = ts[index];
                    {
                        if ( /* isNaN */isNaN(t))
                            continue;
                        const p = c.point(t);
                        if (p != null) {
                            const dir = c.tangent(t);
                            if (TangentsConicLine2D.TMP_LINE == null)
                                TangentsConicLine2D.TMP_LINE = new geom.Line2D();
                            TangentsConicLine2D.TMP_LINE.set$double$double$double$double(p.x, p.y, dir.x, dir.y);
                            TangentsConicLine2D.TMP_LINE.clip();
                            TangentsConicLine2D.TMP_LINE.render(g);
                        }
                    }
                }
                return;
            }
            super.render(g);
        }
    }
    TangentsConicLine2D.TMP_LINE = null;
    geom.TangentsConicLine2D = TangentsConicLine2D;
    TangentsConicLine2D["__class"] = "geom.TangentsConicLine2D";
})(geom || (geom = {}));
(function (geom) {
    class LineAngleBisectorPair2D extends geom.Line2D {
        constructor(line1, line2, mode) {
            if (((line1 != null && line1 instanceof geom.Line2D) || line1 === null) && ((line2 != null && line2 instanceof geom.Line2D) || line2 === null) && ((typeof mode === 'string') || mode === null)) {
                let __args = arguments;
                super();
                this.mode = 0;
                this.parents = [line1, line2];
                this.params = [mode];
                this.mode = javaemul.internal.IntegerHelper.parseInt(mode);
                this.update();
            }
            else if (((line1 != null && line1 instanceof geom.Line2D) || line1 === null) && ((line2 != null && line2 instanceof geom.Line2D) || line2 === null) && mode === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let mode = "0";
                    super();
                    this.mode = 0;
                    this.parents = [line1, line2];
                    this.params = [mode];
                    this.mode = javaemul.internal.IntegerHelper.parseInt(mode);
                    this.update();
                }
                this.mode = 0;
            }
            else
                throw new Error('invalid overload');
        }
        onAddShapeToSimulation(manager) {
            super.onAddShapeToSimulation(manager);
            if (this.mode === 0 && this.__isDefined) {
                const line1 = this.parents[0];
                const line2 = this.parents[1];
                const l1 = new LineAngleBisectorPair2D(line1, line2, "1");
                const l2 = new LineAngleBisectorPair2D(line1, line2, "2");
                this.shapesManager.removeShape(this);
                this.shapesManager.addShape(l1);
                this.shapesManager.addShape(l2);
            }
        }
        update() {
            this.__isDefined = false;
            if (!this.parents[0].__isDefined || !this.parents[1].__isDefined)
                return;
            const line1 = this.parents[0];
            const line2 = this.parents[1];
            const p = geom.CurveUtils.LineLineIntersection$geom_Line2D$geom_Line2D(line1, line2);
            if (p == null)
                return;
            this.__isDefined = true;
            if (this.mode === 1)
                this.set$double$double$double$double(p[0].x, p[0].y, line1.dx + line2.dx, line1.dy + line2.dy);
            else if (this.mode === 2)
                this.set$double$double$double$double(p[0].x, p[0].y, line1.dx - line2.dx, line1.dy - line2.dy);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Angle Bisector of " + this.parents[0].getName() + " & " + this.parents[1].getName();
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (this.mode === 0) {
                const line1 = this.parents[0];
                const line2 = this.parents[1];
                const p = geom.CurveUtils.LineLineIntersection$geom_Line2D$geom_Line2D(line1, line2);
                if (p == null)
                    return;
                this.__isDefined = true;
                if (LineAngleBisectorPair2D.TMP_LINE == null)
                    LineAngleBisectorPair2D.TMP_LINE = new geom.Line2D();
                LineAngleBisectorPair2D.TMP_LINE.set$double$double$double$double(p[0].x, p[0].y, line1.dx + line2.dx, line1.dy + line2.dy);
                LineAngleBisectorPair2D.TMP_LINE.clip();
                LineAngleBisectorPair2D.TMP_LINE.render(g);
                LineAngleBisectorPair2D.TMP_LINE.set$double$double$double$double(p[0].x, p[0].y, line1.dx - line2.dx, line1.dy - line2.dy);
                LineAngleBisectorPair2D.TMP_LINE.clip();
                LineAngleBisectorPair2D.TMP_LINE.render(g);
                return;
            }
            super.render(g);
        }
    }
    LineAngleBisectorPair2D.TMP_LINE = null;
    geom.LineAngleBisectorPair2D = LineAngleBisectorPair2D;
    LineAngleBisectorPair2D["__class"] = "geom.LineAngleBisectorPair2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     *
     * @param {math.Vector2} p1
     * initial point
     * @param {math.Vector2} p2
     * another point on ray
     * @class
     * @extends geom.Line2D
     */
    class Ray2D extends geom.Line2D {
        constructor(p1, p2) {
            if (((p1 != null && p1 instanceof math.Vector2) || p1 === null) && ((p2 != null && p2 instanceof math.Vector2) || p2 === null)) {
                let __args = arguments;
                super();
                this.set$math_Vector2$math_Vector2(p1, p2);
            }
            else if (p1 === undefined && p2 === undefined) {
                let __args = arguments;
                super();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Sets line as passing through point (x,y) and direction rations as dx and dy
         * @param {number} x
         * @param {number} y
         * @param {number} dx
         * @param {number} dy
         */
        set(x, y, dx, dy) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && ((typeof dy === 'number') || dy === null)) {
                super.set(x, y, dx, dy);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && dy === undefined) {
                return this.set$double$double$double(x, y, dx);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && ((y != null && y instanceof math.Vector2) || y === null) && dx === undefined && dy === undefined) {
                return this.set$math_Vector2$math_Vector2(x, y);
            }
            else if (((x != null && x instanceof geom.Line2D) || x === null) && y === undefined && dx === undefined && dy === undefined) {
                return this.set$geom_Line2D(x);
            }
            else
                throw new Error('invalid overload');
        }
        set$math_Vector2$math_Vector2(p1, p2) {
            super.set$math_Vector2$math_Vector2(p1, p2);
        }
        set$geom_Line2D(line) {
            this.set$math_Vector2$math_Vector2(line.p1, line.p2);
        }
        update() {
        }
        /**
         *
         */
        clip() {
            if (!this.__isDefined)
                return;
            if (this.shapesManager == null)
                return;
            const b = this.shapesManager.getWorldBounds();
            const xmin = b[0];
            const ymin = b[1];
            const xmax = b[2];
            const ymax = b[3];
            if (Math.abs(this.dy) < framework.Preferences.EPSILON) {
                this.dy = 0;
                this.p2.set$double$double(this.dx > 0 ? xmax : xmin, this.y0);
            }
            else if (Math.abs(this.dx) < framework.Preferences.EPSILON) {
                this.dx = 0;
                this.p2.set$double$double(this.x0, this.dy > 0 ? ymax : ymin);
            }
            else {
                const c = [0, 0, 0];
                const v1 = new math.Vector2();
                const v2 = new math.Vector2();
                c[0] = this.dy;
                c[1] = -this.dx;
                c[2] = -this.dx * this.y0 + this.dy * this.x0;
                if (Math.abs(this.dy / this.dx) <= 1) {
                    const y1 = (c[2] - c[0] * xmin) / c[1];
                    const y2 = (c[2] - c[0] * xmax) / c[1];
                    v1.set$double$double(xmin, y1);
                    v2.set$double$double(xmax, y2);
                }
                else {
                    const x1 = (c[2] - c[1] * ymin) / c[0];
                    const x2 = (c[2] - c[1] * ymax) / c[0];
                    v1.set$double$double(x1, ymin);
                    v2.set$double$double(x2, ymax);
                }
                const t1 = this.t(v1);
                const t2 = this.t(v2);
                if (t2 > t1) {
                    if (t2 > 0)
                        this.p2.set$math_Vector2(v2);
                }
                else if (t1 > 0) {
                    this.p2.set$math_Vector2(v1);
                }
            }
            this.p1.set$double$double(this.x0, this.y0);
        }
        /**
         *
         * @param {framework.Renderer} gl
         */
        render(gl) {
            if (!this.__isDefined)
                return;
            this.renderAsRay(gl);
            if (this.showEqn || this.showName) {
                this.renderInfo(gl, new math.Vector2(this.x0, this.y0), new math.Vector2(this.x0 + 2 * this.dx, this.y0 + 2 * this.dy));
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Ray " + this.name;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        t(pt) {
            const dot = (pt.x - this.x0) * this.dx + (pt.y - this.y0) * this.dy;
            return dot;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            if (!this.isDefined())
                return false;
            return this.distance(pt) < geom.Shape2D.SNAP_DISTANCE;
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            return super.point(t);
        }
        /**
         * Returns true if the specified point  lies on the boundary of shape
         * @param {math.Vector2} pt {Vector2 }
         * @return {boolean} {Boolean}
         */
        contains(pt) {
            if (!this.__isDefined)
                return false;
            return this.distance(pt) < geom.Shape2D.ACCURACY;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            if (!this.isDefined() || pt == null)
                return javaemul.internal.DoubleHelper.MAX_VALUE;
            let t = this.t(pt);
            if (t < 0)
                t = 0;
            return pt.distance$math_Vector2(this.point(t));
        }
    }
    geom.Ray2D = Ray2D;
    Ray2D["__class"] = "geom.Ray2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Tangent to a curve at a given point.
     * @param curve
     * @param {geom.Point2D} point
     * @param {geom.Conic2D} conic
     * @class
     * @extends geom.Line2D
     * @author mahesh kurmi
     */
    class PolarConicPoint2D extends geom.Line2D {
        constructor(conic, point) {
            super();
            this.parents = [conic, point];
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined())
                return;
            const conic = this.parents[0];
            const point = this.parents[1].pt;
            const h = point.x;
            const k = point.y;
            let c = [0, 0, 0, 0, 0, 0];
            c = conic.conicCoefficients();
            const l = c[0] * h + c[1] * k / 2 + c[3] / 2;
            const m = c[2] * k + c[1] * h / 2 + c[4] / 2;
            const n = c[3] * h / 2 + c[4] * k / 2 + c[5];
            if (l === 0 && m === 0)
                return;
            else if (l === 0)
                this.set$double$double$double$double(0, -n / m, 1, 0);
            else if (m === 0)
                this.set$double$double$double$double(-n / l, 0, 0, 1);
            else
                this.set$double$double$double$double(-n / l, 0, n / l, -n / m);
            this.__isDefined = true;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Polar of conic  " + this.parents[0].getName() + " wrt Point " + this.parents[1].getName();
        }
    }
    geom.PolarConicPoint2D = PolarConicPoint2D;
    PolarConicPoint2D["__class"] = "geom.PolarConicPoint2D";
})(geom || (geom = {}));
(function (geom) {
    class PolarCurve2D extends geom.DynamicCurve2D {
        constructor(maxPoints, expr, min_t, max_t) {
            if (((typeof maxPoints === 'string') || maxPoints === null) && ((typeof expr === 'string') || expr === null) && ((typeof min_t === 'string') || min_t === null) && ((typeof max_t === 'string') || max_t === null)) {
                let __args = arguments;
                super();
                this.parserX = null;
                this.isValidExpr = true;
                this.parseErrorMessage = null;
                this.min_t = new geom.optics.DynamicValue(1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                this.max_t = new geom.optics.DynamicValue(1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                this.maxPoints = javaemul.internal.IntegerHelper.parseInt(maxPoints);
                this.params = [maxPoints + "", expr, min_t, max_t];
                this.min_t.set$java_lang_String(min_t);
                this.max_t.set$java_lang_String(max_t);
                this.__t0 = this.min_t.getValue();
                this.__t1 = this.max_t.getValue();
                this.setExpression(expr);
                this.update();
            }
            else if (((typeof maxPoints === 'string') || maxPoints === null) && ((typeof expr === 'string') || expr === null) && min_t === undefined && max_t === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let min_t = "0";
                    let max_t = "2*pi";
                    super();
                    this.parserX = null;
                    this.isValidExpr = true;
                    this.parseErrorMessage = null;
                    this.min_t = new geom.optics.DynamicValue(1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.max_t = new geom.optics.DynamicValue(1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.maxPoints = javaemul.internal.IntegerHelper.parseInt(maxPoints);
                    this.params = [maxPoints + "", expr, min_t, max_t];
                    this.min_t.set$java_lang_String(min_t);
                    this.max_t.set$java_lang_String(max_t);
                    this.__t0 = this.min_t.getValue();
                    this.__t1 = this.max_t.getValue();
                    this.setExpression(expr);
                    this.update();
                }
                this.parserX = null;
                this.isValidExpr = true;
                this.parseErrorMessage = null;
                this.min_t = new geom.optics.DynamicValue(1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                this.max_t = new geom.optics.DynamicValue(1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
            }
            else if (((typeof maxPoints === 'string') || maxPoints === null) && expr === undefined && min_t === undefined && max_t === undefined) {
                let __args = arguments;
                let expr = __args[0];
                {
                    let __args = arguments;
                    let maxPoints = "200";
                    let min_t = "0";
                    let max_t = "2*pi";
                    super();
                    this.parserX = null;
                    this.isValidExpr = true;
                    this.parseErrorMessage = null;
                    this.min_t = new geom.optics.DynamicValue(1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.max_t = new geom.optics.DynamicValue(1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.maxPoints = javaemul.internal.IntegerHelper.parseInt(maxPoints);
                    this.params = [maxPoints + "", expr, min_t, max_t];
                    this.min_t.set$java_lang_String(min_t);
                    this.max_t.set$java_lang_String(max_t);
                    this.__t0 = this.min_t.getValue();
                    this.__t1 = this.max_t.getValue();
                    this.setExpression(expr);
                    this.update();
                }
                this.parserX = null;
                this.isValidExpr = true;
                this.parseErrorMessage = null;
                this.min_t = new geom.optics.DynamicValue(1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                this.max_t = new geom.optics.DynamicValue(1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Max Points", this.params[0], null);
            if (index === 1)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("r(t)", this.params[1], ["t"]);
            if (index === 2)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Minimum t", this.params[2], null);
            if (index === 3)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Maximum t", this.params[3], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                this.maxPoints = javaemul.internal.IntegerHelper.parseInt(this.params[0]);
                this.reset();
            }
            else if (index === 1) {
                this.params[1] = value + "";
                this.setExpression(this.params[1]);
            }
            else if (index === 2) {
                this.params[2] = value + "";
                this.min_t.set$java_lang_String(this.params[2]);
                this.__t0 = this.min_t.getValue();
                this.reset();
            }
            else if (index === 3) {
                this.params[3] = value + "";
                this.max_t.set$java_lang_String(this.params[3]);
                this.__t1 = this.max_t.getValue();
                this.reset();
            }
        }
        /**
         * Recreate shape from its parameters, mainly intended to reparse expression in shapes if any
         * @param {geom.ShapesManager} manager
         */
        onAddShapeToSimulation(manager) {
            super.onAddShapeToSimulation(manager);
            this.min_t.setShapesManager(manager);
            this.max_t.setShapesManager(manager);
        }
        /**
         *
         */
        update() {
            if (this.shapesManager != null && this.shapesManager.containsShape(this)) {
                this.min_t.update();
                this.max_t.update();
                this.__t0 = this.min_t.getValue();
                this.__t1 = this.max_t.getValue();
                if (this.__t1 <= this.__t0 || !this.isValidExpr) {
                    this.__isDefined = false;
                    return;
                }
                this.__isDefined = true;
                this.createGraph();
            }
        }
        /**
         * removes all vertices from curve
         */
        reset() {
            super.reset();
            this.createGraph();
        }
        /**
         * Sets expression for the field, the expression can be a function of position <b>x</b>, <b>y</b> or polar coordinates  <b>r</b> and  <b>th</b>(theta)
         * @param xExpr expression for x component of field
         * @param yExpr expression for y component of field
         * @param {string} expr
         */
        setExpression(expr) {
            if (expr == null || /* isEmpty */ (expr.length === 0)) {
                this.params[1] = expr;
                this.isValidExpr = false;
                return;
            }
            this.params[1] = expr;
            this.__isDefined = false;
            this.isValidExpr = true;
            this.parseErrorMessage = null;
            this.parserX = null;
            if (this.shapesManager == null)
                return;
            let e;
            try {
                e = math.MathUtils.createParser(expr, ["t"], this.shapesManager.globalVariables, this.shapesManager.globalFunctions);
            }
            catch (ex) {
                this.parseErrorMessage = ex.message;
                console.info("parsing error in expr: " + expr + " " + ex.message);
                e = null;
            }
            if (e == null) {
                this.isValidExpr = false;
                return;
            }
            else {
                const res = e.validate$boolean(false);
                if (res.isValid()) {
                    this.parserX = e;
                }
                else {
                    this.isValidExpr = false;
                    return;
                }
            }
            this.createGraph();
            this.__isDefined = this.isValidExpr;
        }
        /*private*/ createGraph() {
            if (this.parserX == null || !this.isValidExpr || this.__t0 >= this.__t1)
                return;
            this.vertices.clear();
            if (this.shapesManager != null) {
                for (let index = this.shapesManager.globalVariables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    {
                        this.parserX.setVariable(key, this.shapesManager.globalVariables.get(key));
                    }
                }
            }
            let t = this.__t0;
            const dt = (this.__t1 - this.__t0) / (this.maxPoints - 1);
            let r;
            for (let i = 0; i < this.maxPoints; i++) {
                {
                    this.parserX.setVariable("t", t);
                    r = this.parserX.evaluate();
                    if ( /* isFinite */((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(r))
                        this.updatePoint(math.Vector2.create(r, t));
                    t += dt;
                }
                ;
            }
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            if (this.__isDefined === false)
                return null;
            if (this.shapesManager != null) {
                for (let index = this.shapesManager.globalVariables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    {
                        this.parserX.setVariable(key, this.shapesManager.globalVariables.get(key));
                    }
                }
            }
            this.parserX.setVariable("t", t);
            const r = this.parserX.evaluate();
            if ( /* isFinite */((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(r))
                return math.Vector2.create(r, t);
            return null;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        t(pt) {
            const t = super.t(pt);
            return this.__t0 + t * (this.__t1 - this.__t0);
        }
        /*private*/ getr(t) {
            this.parserX.setVariable("t", t);
            return this.parserX.evaluate();
        }
        /**
         * Returns the unit Vector along tangent to curve
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            if (!this.__isDefined || this.vertices.size() < 2)
                return null;
            if (this.shapesManager != null) {
                for (let index = this.shapesManager.globalVariables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    {
                        this.parserX.setVariable(key, this.shapesManager.globalVariables.get(key));
                    }
                }
            }
            const r = this.getr(t);
            let ddx = 0;
            const x = t;
            let h;
            if (x > 1 || x < -1)
                h = Math.sqrt(geom.Shape2D.ACCURACY) * x;
            else
                h = Math.sqrt(geom.Shape2D.ACCURACY);
            const answerx = this.getr(t);
            for (let i = 1; i <= 5; i++) {
                {
                    const diff = (h * i);
                    t = x + diff;
                    let answer = this.getr(t);
                    ddx += ((answer - answerx) / diff);
                    t = x - diff;
                    answer = this.getr(t);
                    ddx += ((answerx - answer) / diff);
                }
                ;
            }
            ddx = ddx / 10;
            const dy = ddx * Math.sin(t) + r * Math.cos(t);
            const dx = ddx * Math.cos(t) - r * Math.sin(t);
            return geom.Shape2D.TMP_VEC_$LI$().set$double$double(dx, dy).getNormalized();
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return "r(t)=" + this.params[1];
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Polar Curve (r(t)=" + this.params[1] + ")";
        }
    }
    geom.PolarCurve2D = PolarCurve2D;
    PolarCurve2D["__class"] = "geom.PolarCurve2D";
})(geom || (geom = {}));
(function (geom) {
    class ParametricCurve2D extends geom.DynamicCurve2D {
        constructor(maxPoints, xExpr, yExpr, min_t, max_t) {
            if (((typeof maxPoints === 'string') || maxPoints === null) && ((typeof xExpr === 'string') || xExpr === null) && ((typeof yExpr === 'string') || yExpr === null) && ((typeof min_t === 'string') || min_t === null) && ((typeof max_t === 'string') || max_t === null)) {
                let __args = arguments;
                super();
                if (this.xExpr === undefined) {
                    this.xExpr = null;
                }
                if (this.yExpr === undefined) {
                    this.yExpr = null;
                }
                this.parserX = null;
                this.parserY = null;
                this.isValidExpr = true;
                this.parseErrorMessage = null;
                this.min_t = 0;
                this.max_t = 1;
                this.maxPoints = javaemul.internal.IntegerHelper.parseInt(maxPoints);
                this.params = [maxPoints + "", xExpr, yExpr, min_t, max_t];
                this.min_t = javaemul.internal.DoubleHelper.parseDouble(min_t);
                this.max_t = javaemul.internal.DoubleHelper.parseDouble(max_t);
                this.__t0 = this.min_t;
                this.__t1 = this.max_t;
                this.setExpressions(xExpr, yExpr);
                this.update();
            }
            else if (((typeof maxPoints === 'string') || maxPoints === null) && ((typeof xExpr === 'string') || xExpr === null) && ((typeof yExpr === 'string') || yExpr === null) && ((typeof min_t === 'string') || min_t === null) && max_t === undefined) {
                let __args = arguments;
                let tScale = __args[3];
                {
                    let __args = arguments;
                    let min_t = "0";
                    let max_t = tScale;
                    super();
                    if (this.xExpr === undefined) {
                        this.xExpr = null;
                    }
                    if (this.yExpr === undefined) {
                        this.yExpr = null;
                    }
                    this.parserX = null;
                    this.parserY = null;
                    this.isValidExpr = true;
                    this.parseErrorMessage = null;
                    this.min_t = 0;
                    this.max_t = 1;
                    this.maxPoints = javaemul.internal.IntegerHelper.parseInt(maxPoints);
                    this.params = [maxPoints + "", xExpr, yExpr, min_t, max_t];
                    this.min_t = javaemul.internal.DoubleHelper.parseDouble(min_t);
                    this.max_t = javaemul.internal.DoubleHelper.parseDouble(max_t);
                    this.__t0 = this.min_t;
                    this.__t1 = this.max_t;
                    this.setExpressions(xExpr, yExpr);
                    this.update();
                }
                if (this.xExpr === undefined) {
                    this.xExpr = null;
                }
                if (this.yExpr === undefined) {
                    this.yExpr = null;
                }
                this.parserX = null;
                this.parserY = null;
                this.isValidExpr = true;
                this.parseErrorMessage = null;
                this.min_t = 0;
                this.max_t = 1;
            }
            else if (((typeof maxPoints === 'string') || maxPoints === null) && ((typeof xExpr === 'string') || xExpr === null) && ((typeof yExpr === 'string') || yExpr === null) && min_t === undefined && max_t === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let min_t = "-1";
                    let max_t = "1";
                    super();
                    if (this.xExpr === undefined) {
                        this.xExpr = null;
                    }
                    if (this.yExpr === undefined) {
                        this.yExpr = null;
                    }
                    this.parserX = null;
                    this.parserY = null;
                    this.isValidExpr = true;
                    this.parseErrorMessage = null;
                    this.min_t = 0;
                    this.max_t = 1;
                    this.maxPoints = javaemul.internal.IntegerHelper.parseInt(maxPoints);
                    this.params = [maxPoints + "", xExpr, yExpr, min_t, max_t];
                    this.min_t = javaemul.internal.DoubleHelper.parseDouble(min_t);
                    this.max_t = javaemul.internal.DoubleHelper.parseDouble(max_t);
                    this.__t0 = this.min_t;
                    this.__t1 = this.max_t;
                    this.setExpressions(xExpr, yExpr);
                    this.update();
                }
                if (this.xExpr === undefined) {
                    this.xExpr = null;
                }
                if (this.yExpr === undefined) {
                    this.yExpr = null;
                }
                this.parserX = null;
                this.parserY = null;
                this.isValidExpr = true;
                this.parseErrorMessage = null;
                this.min_t = 0;
                this.max_t = 1;
            }
            else if (((typeof maxPoints === 'string') || maxPoints === null) && ((typeof xExpr === 'string') || xExpr === null) && yExpr === undefined && min_t === undefined && max_t === undefined) {
                let __args = arguments;
                let xExpr = __args[0];
                let yExpr = __args[1];
                {
                    let __args = arguments;
                    let maxPoints = "200";
                    let min_t = "-1";
                    let max_t = "1";
                    super();
                    if (this.xExpr === undefined) {
                        this.xExpr = null;
                    }
                    if (this.yExpr === undefined) {
                        this.yExpr = null;
                    }
                    this.parserX = null;
                    this.parserY = null;
                    this.isValidExpr = true;
                    this.parseErrorMessage = null;
                    this.min_t = 0;
                    this.max_t = 1;
                    this.maxPoints = javaemul.internal.IntegerHelper.parseInt(maxPoints);
                    this.params = [maxPoints + "", xExpr, yExpr, min_t, max_t];
                    this.min_t = javaemul.internal.DoubleHelper.parseDouble(min_t);
                    this.max_t = javaemul.internal.DoubleHelper.parseDouble(max_t);
                    this.__t0 = this.min_t;
                    this.__t1 = this.max_t;
                    this.setExpressions(xExpr, yExpr);
                    this.update();
                }
                if (this.xExpr === undefined) {
                    this.xExpr = null;
                }
                if (this.yExpr === undefined) {
                    this.yExpr = null;
                }
                this.parserX = null;
                this.parserY = null;
                this.isValidExpr = true;
                this.parseErrorMessage = null;
                this.min_t = 0;
                this.max_t = 1;
                (() => {
                    this.__isDefined = true;
                })();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Max Points", this.params[0], null);
            if (index === 1)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("x(t)", this.params[1], ["t"]);
            if (index === 2)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("y(t)", this.params[2], ["t"]);
            if (index === 3)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Minimum t", this.params[3], null);
            if (index === 4)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Maximum t", this.params[4], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                this.maxPoints = javaemul.internal.IntegerHelper.parseInt(this.params[0]);
                this.reset();
            }
            else if (index === 1) {
                this.params[1] = value + "";
                this.setExpressions(this.params[1], this.params[2]);
            }
            else if (index === 2) {
                this.params[2] = value + "";
                this.setExpressions(this.params[1], this.params[2]);
            }
            else if (index === 3) {
                this.params[3] = value + "";
                this.min_t = javaemul.internal.DoubleHelper.parseDouble(this.params[3]);
                this.__t0 = this.min_t;
                this.reset();
            }
            else if (index === 4) {
                this.params[4] = value + "";
                this.max_t = javaemul.internal.DoubleHelper.parseDouble(this.params[4]);
                this.__t1 = this.max_t;
                this.reset();
            }
        }
        /**
         * Recreate shape from its parameters, mainly intended to reparse expression in shapes if any
         * @param {geom.ShapesManager} manager
         */
        onAddShapeToSimulation(manager) {
            super.onAddShapeToSimulation(manager);
            this.setExpressions(this.xExpr, this.yExpr);
            this.update();
        }
        /**
         *
         */
        update() {
            if (this.shapesManager == null)
                return;
            if (this.shapesManager.containsShape(this)) {
                if (this.__t1 <= this.__t0 || !this.isValidExpr) {
                    this.__isDefined = false;
                    return;
                }
                this.__isDefined = true;
                this.createGraph();
            }
        }
        /**
         * removes all vertices from curve
         */
        reset() {
            super.reset();
            this.createGraph();
        }
        /**
         * Sets expression for the field, the expression can be a function of position <b>x</b>, <b>y</b> or polar coordinates  <b>r</b> and  <b>th</b>(theta)
         * @param {string} xExpr expression for x component of field
         * @param {string} yExpr expression for y component of field
         */
        setExpressions(xExpr, yExpr) {
            if (xExpr == null || /* isEmpty */ (xExpr.length === 0))
                xExpr = "0";
            if (yExpr == null || /* isEmpty */ (yExpr.length === 0))
                yExpr = "0";
            this.params[1] = xExpr;
            this.params[2] = yExpr;
            if (this.shapesManager == null)
                return;
            this.__isDefined = false;
            this.isValidExpr = true;
            this.parseErrorMessage = null;
            this.parserX = null;
            this.parserY = null;
            this.xExpr = xExpr;
            this.yExpr = yExpr;
            let e;
            try {
                e = math.MathUtils.createParser(xExpr, ["t"], this.shapesManager.globalVariables, this.shapesManager.globalFunctions);
            }
            catch (ex) {
                this.parseErrorMessage = ex.message;
                console.info("parsing error in expr: " + xExpr + " " + ex.message);
                e = null;
            }
            if (e == null) {
                this.isValidExpr = false;
                return;
            }
            else {
                const res = e.validate$boolean(false);
                if (res.isValid()) {
                    this.parserX = e;
                }
                else {
                    this.isValidExpr = false;
                    return;
                }
            }
            try {
                e = math.MathUtils.createParser(yExpr, ["t"], this.shapesManager == null ? null : this.shapesManager.globalVariables, this.shapesManager == null ? null : this.shapesManager.globalFunctions);
            }
            catch (ex) {
                this.parseErrorMessage = ex.message;
                console.info("parsing error in expr: " + yExpr + " " + ex.message);
                e = null;
            }
            if (e == null) {
                this.isValidExpr = false;
                return;
            }
            else {
                const res = e.validate$boolean(false);
                if (res.isValid()) {
                    this.parserY = e;
                }
                else {
                    this.isValidExpr = false;
                    return;
                }
            }
            this.createGraph();
            this.__isDefined = this.isValidExpr;
        }
        /*private*/ createGraph() {
            if (this.parserX == null || this.parserY == null || !this.isValidExpr || this.__t0 >= this.__t1)
                return;
            this.vertices.clear();
            if (this.shapesManager != null) {
                for (let index = this.shapesManager.globalVariables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    {
                        this.parserX.setVariable(key, this.shapesManager.globalVariables.get(key));
                        this.parserY.setVariable(key, this.shapesManager.globalVariables.get(key));
                    }
                }
            }
            let t = this.__t0;
            const dt = (this.__t1 - this.__t0) / (this.maxPoints - 1);
            let x;
            let y;
            for (let i = 0; i < this.maxPoints; i++) {
                {
                    this.parserX.setVariable("t", t);
                    x = this.parserX.evaluate();
                    this.parserY.setVariable("t", t);
                    y = this.parserY.evaluate();
                    if ( /* isFinite */((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(x) && /* isFinite */ ((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(y))
                        this.updatePoint(new math.Vector2(x, y));
                    t += dt;
                }
                ;
            }
        }
        /*private*/ getX(t) {
            this.parserX.setVariable("t", t);
            return this.parserX.evaluate();
        }
        /*private*/ getY(t) {
            this.parserY.setVariable("t", t);
            return this.parserY.evaluate();
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            if (this.__isDefined === false)
                return null;
            if (this.shapesManager != null) {
                for (let index = this.shapesManager.globalVariables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    {
                        this.parserX.setVariable(key, this.shapesManager.globalVariables.get(key));
                        this.parserY.setVariable(key, this.shapesManager.globalVariables.get(key));
                    }
                }
            }
            let x;
            let y;
            x = this.getX(t);
            y = this.getY(t);
            if ( /* isFinite */((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(x) && /* isFinite */ ((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(y))
                return new math.Vector2(x, y);
            return null;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        t(pt) {
            const t = super.t(pt);
            return this.__t0 + t * (this.__t1 - this.__t0);
        }
        /**
         * Returns the unit Vector along tangent to curve
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            if (!this.__isDefined || this.vertices.size() < 2)
                return null;
            if (this.shapesManager != null) {
                for (let index = this.shapesManager.globalVariables.keySet().iterator(); index.hasNext();) {
                    let key = index.next();
                    {
                        this.parserX.setVariable(key, this.shapesManager.globalVariables.get(key));
                        this.parserY.setVariable(key, this.shapesManager.globalVariables.get(key));
                    }
                }
            }
            let ddx = 0;
            let ddy = 0;
            const t0 = t;
            let h;
            if (t0 > 1 || t0 < -1)
                h = Math.sqrt(geom.Shape2D.ACCURACY) * t0;
            else
                h = Math.sqrt(geom.Shape2D.ACCURACY);
            const answerx = this.getX(t);
            const answery = this.getY(t);
            for (let i = 1; i <= 5; i++) {
                {
                    const diff = (h * i);
                    t = t0 + diff;
                    let answer = this.getX(t);
                    ddx += ((answer - answerx) / diff);
                    t = t0 - diff;
                    answer = this.getX(t);
                    ddx += ((answerx - answer) / diff);
                    t = t0 + diff;
                    answer = this.getY(t);
                    ddy += ((answer - answery) / diff);
                    t = t0 - diff;
                    answer = this.getY(t);
                    ddy += ((answery - answer) / diff);
                }
                ;
            }
            ddx = ddx / 10;
            ddy = ddy / 10;
            return geom.Shape2D.TMP_VEC_$LI$().set$double$double(ddx, ddy).getNormalized();
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return "(" + this.xExpr + " , " + this.yExpr + ")";
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Parametric Curve (" + this.xExpr + " , " + this.yExpr + ")Defined=" + this.__isDefined;
        }
    }
    geom.ParametricCurve2D = ParametricCurve2D;
    ParametricCurve2D["__class"] = "geom.ParametricCurve2D";
})(geom || (geom = {}));
(function (geom) {
    class Bezier4Points2D extends geom.DynamicCurve2D {
        constructor(p1, p2, p3, p4, maxPoints) {
            if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((p3 != null && p3 instanceof geom.Point2D) || p3 === null) && ((p4 != null && p4 instanceof geom.Point2D) || p4 === null) && ((typeof maxPoints === 'string') || maxPoints === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    super();
                    if (this.paramEqn === undefined) {
                        this.paramEqn = null;
                    }
                    this.eqn = null;
                    this.parents = [p1, p2, p3, p4];
                    this.paramEqn = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                        return 0;
                    }
                    else {
                        let array = [];
                        for (let i = 0; i < dims[0]; i++) {
                            array.push(allocate(dims.slice(1)));
                        }
                        return array;
                    } }; return allocate(dims); })([2, 4]);
                    this.update();
                }
                if (this.paramEqn === undefined) {
                    this.paramEqn = null;
                }
                this.eqn = null;
                (() => {
                    this.maxPoints = javaemul.internal.IntegerHelper.parseInt(maxPoints);
                })();
            }
            else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((p3 != null && p3 instanceof geom.Point2D) || p3 === null) && ((p4 != null && p4 instanceof geom.Point2D) || p4 === null) && maxPoints === undefined) {
                let __args = arguments;
                super();
                if (this.paramEqn === undefined) {
                    this.paramEqn = null;
                }
                this.eqn = null;
                this.parents = [p1, p2, p3, p4];
                this.paramEqn = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                    return 0;
                }
                else {
                    let array = [];
                    for (let i = 0; i < dims[0]; i++) {
                        array.push(allocate(dims.slice(1)));
                    }
                    return array;
                } }; return allocate(dims); })([2, 4]);
                this.update();
            }
            else if (p1 === undefined && p2 === undefined && p3 === undefined && p4 === undefined && maxPoints === undefined) {
                let __args = arguments;
                super();
                if (this.paramEqn === undefined) {
                    this.paramEqn = null;
                }
                this.eqn = null;
                this.paramEqn = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                    return 0;
                }
                else {
                    let array = [];
                    for (let i = 0; i < dims[0]; i++) {
                        array.push(allocate(dims.slice(1)));
                    }
                    return array;
                } }; return allocate(dims); })([2, 4]);
                this.paramEqn = this.getCoeff(0, 0, 0, 0, 0, 0, 0, 0);
            }
            else
                throw new Error('invalid overload');
        }
        static coeff_$LI$() { if (Bezier4Points2D.coeff == null) {
            Bezier4Points2D.coeff = ["", "t", "t" + math.Unicode.Superscript_2, "t" + math.Unicode.Superscript_3];
        } return Bezier4Points2D.coeff; }
        /**
         * Returns the matrix of parametric representation of the line. Result has
         * the form :
         * <p>
         * <code>[ x0  dx dx2 dx3] </code>
         * <p>
         * <code>[ y0  dy dy2 dy3] </code>
         * <p>
         * Coefficients are from the parametric equation : x(t) = x0 + dx*t +
         * dx2*t^2 + dx3*t^3 y(t) = y0 + dy*t + dy2*t^2 + dy3*t^3
         * @param {number} x1
         * @param {number} y1
         * @param {number} ctrlx1
         * @param {number} ctrly1
         * @param {number} ctrlx2
         * @param {number} ctrly2
         * @param {number} x2
         * @param {number} y2
         * @return {double[][]}
         */
        getCoeff(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
            const paramEqn = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                return 0;
            }
            else {
                let array = [];
                for (let i = 0; i < dims[0]; i++) {
                    array.push(allocate(dims.slice(1)));
                }
                return array;
            } }; return allocate(dims); })([2, 4]);
            paramEqn[0][0] = x1;
            paramEqn[0][1] = 3 * ctrlx1 - 3 * x1;
            paramEqn[0][2] = 3 * x1 - 6 * ctrlx1 + 3 * ctrlx2;
            paramEqn[0][3] = x2 - 3 * ctrlx2 + 3 * ctrlx1 - x1;
            paramEqn[1][0] = y1;
            paramEqn[1][1] = 3 * ctrly1 - 3 * y1;
            paramEqn[1][2] = 3 * y1 - 6 * ctrly1 + 3 * ctrly2;
            paramEqn[1][3] = y2 - 3 * ctrly2 + 3 * ctrly1 - y1;
            return paramEqn;
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined() || !this.parents[3].isDefined()) {
                return;
            }
            const p1 = (this.parents[0]).pt;
            const ctrl1 = (this.parents[1]).pt;
            const ctrl2 = (this.parents[2]).pt;
            const p2 = (this.parents[3]).pt;
            const c = this.getCoeff(p1.x, p1.y, ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, p2.x, p2.y);
            if (!java.util.Arrays.deepEquals(this.paramEqn, c) || this.offset === -1) {
                this.paramEqn = c;
                this.vertices.clear();
                let t = 0;
                const dt = 1.0 / (this.maxPoints - 1);
                for (let i = 0; i < this.maxPoints; i++) {
                    {
                        this.updatePoint(this.point(t));
                        t += dt;
                    }
                    ;
                }
                this.eqn = "x=" + math.MathUtils.formatEqn$double_A$java_lang_String_A(/* clone */ ((o) => { if (o.clone != undefined) {
                    return o.clone();
                }
                else {
                    let clone = Object.create(o);
                    for (let p in o) {
                        if (o.hasOwnProperty(p))
                            clone[p] = o[p];
                    }
                    return clone;
                } })(this.paramEqn[0]), Bezier4Points2D.coeff_$LI$());
                this.eqn = this.eqn.substring(0, this.eqn.length - 4);
                this.eqn += " ; y=";
                this.eqn += math.MathUtils.formatEqn$double_A$java_lang_String_A(/* clone */ ((o) => { if (o.clone != undefined) {
                    return o.clone();
                }
                else {
                    let clone = Object.create(o);
                    for (let p in o) {
                        if (o.hasOwnProperty(p))
                            clone[p] = o[p];
                    }
                    return clone;
                } })(this.paramEqn[1]), Bezier4Points2D.coeff_$LI$());
                this.eqn = this.eqn.substring(0, this.eqn.length - 4);
            }
            this.__isDefined = true;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Cubic Bezier through " + this.parents[0].getName() + " , " + this.parents[1].getName() + " , " + this.parents[2].getName() + " , " + this.parents[3].getName();
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            t = Math.min(Math.max(t, 0), 1);
            const c = this.paramEqn;
            const x = c[0][0] + (c[0][1] + (c[0][2] + c[0][3] * t) * t) * t;
            const y = c[1][0] + (c[1][1] + (c[1][2] + c[1][3] * t) * t) * t;
            return new math.Vector2(x, y);
        }
        /**
         *
         * @param {number} t
         * @return {number}
         */
        derivative(t) {
            if (!this.isDefined() || this.vertices.size() < 2)
                return javaemul.internal.DoubleHelper.NaN;
            const v = this.tangent(t);
            if (v == null)
                return javaemul.internal.DoubleHelper.NaN;
            return Math.tan(v.getDirection());
        }
        /**
         * Returns the unit Vector along tangent to curve
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            if (!this.__isDefined || this.vertices.size() < 2)
                return null;
            const c = this.paramEqn;
            const dx = c[0][1] + (2 * c[0][2] + 3 * c[0][3] * t) * t;
            const dy = c[1][1] + (2 * c[1][2] + 3 * c[1][3] * t) * t;
            return new math.Vector2(dx, dy).getNormalized();
        }
        /**
         * Returns the curvature of the curve at the given position.
         * @param {number} t
         * @return {number}
         */
        curvature(t) {
            const c = this.paramEqn;
            const xp = c[0][1] + (2 * c[0][2] + 3 * c[0][3] * t) * t;
            const yp = c[1][1] + (2 * c[1][2] + 3 * c[1][3] * t) * t;
            const xs = 2 * c[0][2] + 6 * c[0][3] * t;
            const ys = 2 * c[1][2] + 6 * c[1][3] * t;
            return (xp * ys - yp * xs) / Math.pow(math.MathUtils.hypot(xp, yp), 3);
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return this.eqn;
        }
    }
    geom.Bezier4Points2D = Bezier4Points2D;
    Bezier4Points2D["__class"] = "geom.Bezier4Points2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Creates Quadratic Bezier through points p1 and p3 with p2 as its control point
     * @param {geom.Point2D} p1
     * @param {geom.Point2D} p2
     * @param {geom.Point2D} p3
     * @param {string} maxPoints
     * @class
     * @extends geom.DynamicCurve2D
     */
    class Bezier3Points2D extends geom.DynamicCurve2D {
        constructor(p1, p2, p3, maxPoints) {
            if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((p3 != null && p3 instanceof geom.Point2D) || p3 === null) && ((typeof maxPoints === 'string') || maxPoints === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    super();
                    if (this.paramEqn === undefined) {
                        this.paramEqn = null;
                    }
                    this.eqn = null;
                    this.maxPoints = 150;
                    this.parents = [p1, p2, p3];
                    this.paramEqn = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                        return 0;
                    }
                    else {
                        let array = [];
                        for (let i = 0; i < dims[0]; i++) {
                            array.push(allocate(dims.slice(1)));
                        }
                        return array;
                    } }; return allocate(dims); })([2, 3]);
                    this.update();
                }
                if (this.paramEqn === undefined) {
                    this.paramEqn = null;
                }
                this.eqn = null;
                (() => {
                    this.maxPoints = javaemul.internal.IntegerHelper.parseInt(maxPoints);
                })();
            }
            else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((p3 != null && p3 instanceof geom.Point2D) || p3 === null) && maxPoints === undefined) {
                let __args = arguments;
                super();
                if (this.paramEqn === undefined) {
                    this.paramEqn = null;
                }
                this.eqn = null;
                this.maxPoints = 150;
                this.parents = [p1, p2, p3];
                this.paramEqn = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                    return 0;
                }
                else {
                    let array = [];
                    for (let i = 0; i < dims[0]; i++) {
                        array.push(allocate(dims.slice(1)));
                    }
                    return array;
                } }; return allocate(dims); })([2, 3]);
                this.update();
            }
            else if (p1 === undefined && p2 === undefined && p3 === undefined && maxPoints === undefined) {
                let __args = arguments;
                super();
                if (this.paramEqn === undefined) {
                    this.paramEqn = null;
                }
                this.eqn = null;
                this.paramEqn = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                    return 0;
                }
                else {
                    let array = [];
                    for (let i = 0; i < dims[0]; i++) {
                        array.push(allocate(dims.slice(1)));
                    }
                    return array;
                } }; return allocate(dims); })([2, 3]);
                this.maxPoints = 150;
            }
            else
                throw new Error('invalid overload');
        }
        static coeff_$LI$() { if (Bezier3Points2D.coeff == null) {
            Bezier3Points2D.coeff = ["", "t", "t" + math.Unicode.Superscript_2];
        } return Bezier3Points2D.coeff; }
        /**
         * returns the matrix of parametric representation of the line. Result is a 2x3 array with coefficients:
         * <p>
         * <code>[ cx0  cx1 cx2] </code>
         * <p>
         * <code>[ cy0  cy1 cy2] </code>
         * <p>
         * Coefficients are from the parametric equation : <code>
         * x(t) = cx0 + cx1*t + cx2*t^2
         * y(t) = cy0 + cy1*t + cy2*t^2
         * </code>
         * @param {number} x1
         * @param {number} y1
         * @param {number} ctrlx
         * @param {number} ctrly
         * @param {number} x2
         * @param {number} y2
         * @return {double[][]}
         */
        getCoeff(x1, y1, ctrlx, ctrly, x2, y2) {
            const paramEqn = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                return 0;
            }
            else {
                let array = [];
                for (let i = 0; i < dims[0]; i++) {
                    array.push(allocate(dims.slice(1)));
                }
                return array;
            } }; return allocate(dims); })([2, 3]);
            paramEqn[0][0] = x1;
            paramEqn[0][1] = 2 * ctrlx - 2 * x1;
            paramEqn[0][2] = x2 - 2 * ctrlx + x1;
            paramEqn[1][0] = y1;
            paramEqn[1][1] = 2 * ctrly - 2 * y1;
            paramEqn[1][2] = y2 - 2 * ctrly + y1;
            return paramEqn;
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                return;
            }
            const p1 = (this.parents[0]).pt;
            const ctrl = (this.parents[1]).pt;
            const p2 = (this.parents[2]).pt;
            const c = this.getCoeff(p1.x, p1.y, ctrl.x, ctrl.y, p2.x, p2.y);
            if (!java.util.Arrays.deepEquals(this.paramEqn, c) || this.offset === -1) {
                this.paramEqn = c;
                this.vertices.clear();
                let t = 0;
                const dt = 1.0 / (this.maxPoints - 1);
                for (let i = 0; i < this.maxPoints; i++) {
                    {
                        this.updatePoint(this.point(t));
                        t += dt;
                    }
                    ;
                }
                this.eqn = "x=" + math.MathUtils.formatEqn$double_A$java_lang_String_A(/* clone */ ((o) => { if (o.clone != undefined) {
                    return o.clone();
                }
                else {
                    let clone = Object.create(o);
                    for (let p in o) {
                        if (o.hasOwnProperty(p))
                            clone[p] = o[p];
                    }
                    return clone;
                } })(this.paramEqn[0]), Bezier3Points2D.coeff_$LI$());
                this.eqn = this.eqn.substring(0, this.eqn.length - 4);
                this.eqn += " ; y=";
                this.eqn += math.MathUtils.formatEqn$double_A$java_lang_String_A(/* clone */ ((o) => { if (o.clone != undefined) {
                    return o.clone();
                }
                else {
                    let clone = Object.create(o);
                    for (let p in o) {
                        if (o.hasOwnProperty(p))
                            clone[p] = o[p];
                    }
                    return clone;
                } })(this.paramEqn[1]), Bezier3Points2D.coeff_$LI$());
                this.eqn = this.eqn.substring(0, this.eqn.length - 4);
            }
            this.__isDefined = true;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Bezier through " + this.parents[0].getName() + " , " + this.parents[1].getName() + " , " + this.parents[2].getName();
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            t = Math.min(Math.max(t, 0), 1);
            const c = this.paramEqn;
            const x = c[0][0] + (c[0][1] + c[0][2] * t) * t;
            const y = c[1][0] + (c[1][1] + c[1][2] * t) * t;
            return new math.Vector2(x, y);
        }
        /**
         * Returns the curvature of the curve at the given position.
         * @return {string}
         */
        getEquation() {
            return this.eqn;
        }
    }
    geom.Bezier3Points2D = Bezier3Points2D;
    Bezier3Points2D["__class"] = "geom.Bezier3Points2D";
})(geom || (geom = {}));
(function (geom) {
    class LengthMeasure2D extends geom.Measure2D {
        constructor(p1, p2, offset) {
            if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((typeof offset === 'string') || offset === null)) {
                let __args = arguments;
                super(0, 0, "");
                this.offset = 0;
                this.tmp_V1 = new math.Vector2();
                this.tmp_V2 = new math.Vector2();
                this.parents = [p1, p2];
                this.params = [offset];
                try {
                    this.offset = javaemul.internal.DoubleHelper.parseDouble(offset);
                }
                catch (e) {
                }
                this.update();
            }
            else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && offset === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let offset = "0.1";
                    super(0, 0, "");
                    this.offset = 0;
                    this.tmp_V1 = new math.Vector2();
                    this.tmp_V2 = new math.Vector2();
                    this.parents = [p1, p2];
                    this.params = [offset];
                    try {
                        this.offset = javaemul.internal.DoubleHelper.parseDouble(offset);
                    }
                    catch (e) {
                    }
                    this.update();
                }
                this.offset = 0;
                this.tmp_V1 = new math.Vector2();
                this.tmp_V2 = new math.Vector2();
            }
            else
                throw new Error('invalid overload');
        }
        update() {
            if (!this.parents[0].__isDefined || !this.parents[1].__isDefined) {
                this.__isDefined = false;
                if (this.name != null && !(this.name.length === 0))
                    if (this.shapesManager != null)
                        this.shapesManager.globalVariables.put(this.name, javaemul.internal.DoubleHelper.NaN);
                return;
            }
            this.__isDefined = true;
            const v1 = this.parents[0].pt;
            const v2 = this.parents[1].pt;
            let v = new math.Vector2((v1.x + v2.x) / 2, (v1.y + v2.y) / 2);
            this.x0 = v.x;
            this.y0 = v.y;
            v = v1.to$math_Vector2(v2);
            if (v.isZero()) {
                if (this.shapesManager != null && this.name != null && !(this.name.length === 0))
                    this.shapesManager.globalVariables.put(this.name, 0.0);
                return;
            }
            const l = v.normalize();
            this.th = v.getAngleWithPositiveXAxis();
            v.right().multiply(this.offset);
            this.tmp_V1.set$math_Vector2(v1).add$math_Vector2(v);
            this.tmp_V2.set$math_Vector2(v2).add$math_Vector2(v);
            this.label = math.MathUtils.formatValue(l, false) + " m";
            this.segment = new geom.Segment2D(this.tmp_V1, this.tmp_V2);
            if (this.shapesManager != null && this.name != null && !(this.name.length === 0))
                this.shapesManager.globalVariables.put(this.name, l);
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0) {
                geom.Shape2D.editInfo_$LI$().set$java_lang_String$double$double$double("Offset", this.offset, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                return geom.Shape2D.editInfo_$LI$();
            }
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            const _var = value + "";
            if (index === 0) {
                this.params[0] = _var;
                try {
                    this.offset = javaemul.internal.DoubleHelper.parseDouble(_var);
                }
                catch (e) {
                }
                this.update();
            }
        }
        /**
         *
         * @param {string} name
         */
        setName(name) {
            if (this.shapesManager != null && name != null && !(name.length === 0))
                this.shapesManager.globalVariables.remove(this.getName());
            this.name = name;
            this.update();
        }
        /**
         *
         * @param {framework.Renderer} gl
         */
        render(gl) {
            if (!this.__isDefined)
                return;
            const v1 = this.parents[0].pt;
            const v2 = this.parents[1].pt;
            const v = this.tmp_V1.to$math_Vector2(this.tmp_V2);
            const l = v.normalize();
            if (l < 1 / gl.METER_TO_PIXEL)
                return;
            if (this.drawColor != null) {
                gl.setColors(null, this.drawColor);
                if (this.offset !== 0) {
                    gl.context.save();
                    gl.context.setLineDash([0.1, 0.2]);
                    gl.drawLine(v1.x, v1.y, this.tmp_V1.x, this.tmp_V1.y);
                    gl.drawLine(v2.x, v2.y, this.tmp_V2.x, this.tmp_V2.y);
                    gl.context.restore();
                }
                gl.drawDoubleVector(this.tmp_V1.x, this.tmp_V1.y, v.x, v.y, l, this.offset !== 0);
            }
            if (this.showEqn || this.showName)
                geom.Shape2D.renderInfo(gl, this.getInfo(), this.tmp_V1, this.tmp_V2, 1, 2, this.drawColor, this.fillColor);
        }
        /**
         *
         * @return {boolean}
         */
        isFreeToMove() {
            return false;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Length:" + this.name;
        }
    }
    geom.LengthMeasure2D = LengthMeasure2D;
    LengthMeasure2D["__class"] = "geom.LengthMeasure2D";
})(geom || (geom = {}));
(function (geom) {
    class PointMeasure2D extends geom.Measure2D {
        constructor(pt, xVarName, yVarName) {
            if (((pt != null && pt instanceof geom.Point2D) || pt === null) && ((typeof xVarName === 'string') || xVarName === null) && ((typeof yVarName === 'string') || yVarName === null)) {
                let __args = arguments;
                super(pt, "");
                this.parents = [pt];
                this.setName(pt.getName());
                this.params = [xVarName, yVarName];
                this.update();
            }
            else if (((pt != null && pt instanceof geom.Point2D) || pt === null) && xVarName === undefined && yVarName === undefined) {
                let __args = arguments;
                super(pt, "");
                this.parents = [pt];
                this.setName(pt.getName());
                this.params = [this.name + "_x", this.name + "_y"];
                this.update();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("X var name", this.params[0], null);
            if (index === 1)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Y var name", this.params[1], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (value == null || !value.toString().matches("[a-zA-Z][a-zA-Z0-9_]*")) {
                return;
            }
            const _var = value + "";
            if (index === 0) {
                if (this.shapesManager != null)
                    this.shapesManager.globalVariables.remove(this.params[0]);
                this.params[0] = _var;
                this.update();
            }
            else if (index === 1) {
                if (this.shapesManager != null)
                    this.shapesManager.globalVariables.remove(this.params[1]);
                this.params[1] = _var;
                this.update();
            }
        }
        setVariableNames(xVarName, yVarName) {
            if (xVarName != null && !(xVarName.indexOf(" ") != -1)) {
                this.params[0] = xVarName;
            }
            if (yVarName != null && !(yVarName.indexOf(" ") != -1)) {
                this.params[1] = yVarName;
            }
        }
        update() {
            if (this.parents == null || this.params == null)
                return;
            if (!this.parents[0].__isDefined) {
                this.__isDefined = false;
                return;
            }
            const pt = this.parents[0];
            this.x0 = pt.pt.x;
            this.y0 = pt.pt.y;
            this.__isDefined = true;
            if (this.shapesManager != null)
                this.shapesManager.globalVariables.put(this.params[0], this.x0);
            if (this.shapesManager != null)
                this.shapesManager.globalVariables.put(this.params[1], this.y0);
            this.label = math.MathUtils.formatPoint(pt.pt, false);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return this.params[0] + ":" + math.MathUtils.format(this.x0) + "," + this.params[1] + ":" + math.MathUtils.format(this.y0);
        }
    }
    geom.PointMeasure2D = PointMeasure2D;
    PointMeasure2D["__class"] = "geom.PointMeasure2D";
})(geom || (geom = {}));
(function (geom) {
    class ExpressionMeasure2D extends geom.Measure2D {
        constructor(pt, expression) {
            super(pt, "");
            this.parents = [pt];
            this.params = [expression];
            this.update();
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Expression", this.params[0], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                this.update();
            }
        }
        /**
         * Sets Expression to be evaluated to get the value of this measure
         * @param {string} expression
         */
        setExpression(expression) {
            this.params[0] = expression;
            this.update();
        }
        /**
         * Returns Expression to be evaluated to get the value of this measure
         *
         * @return {string}
         */
        getExpression() {
            return this.params[0];
        }
        update() {
            if (!this.parents[0].__isDefined) {
                this.__isDefined = false;
                return;
            }
            const pt = this.parents[0];
            this.x0 = pt.pt.x;
            this.y0 = pt.pt.y;
            this.__isDefined = true;
            let value = javaemul.internal.DoubleHelper.NaN;
            try {
                value = math.MathUtils.evaluateExpression(this.params[0], this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables);
            }
            catch (e) {
            }
            if (this.shapesManager != null)
                this.shapesManager.globalVariables.put(this.getName(), value);
            this.label = this.getName() + "=" + math.MathUtils.formatValue(value, true);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return this.params[0];
        }
    }
    geom.ExpressionMeasure2D = ExpressionMeasure2D;
    ExpressionMeasure2D["__class"] = "geom.ExpressionMeasure2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * @param {geom.Line2D} p1
     * @param {geom.Line2D} p2
     * @param {string} forceAcute "true"|"false"
     * @param {string} offset
     * @class
     * @extends geom.Measure2D
     * @author mahesh kurmi
     */
    class AngleMeasure2D extends geom.Measure2D {
        constructor(p1, p2, forceAcute, offset) {
            if (((p1 != null && p1 instanceof geom.Line2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Line2D) || p2 === null) && ((typeof forceAcute === 'string') || forceAcute === null) && ((typeof offset === 'string') || offset === null)) {
                let __args = arguments;
                super(0, 0, "");
                this.angle1 = 0;
                this.angle2 = 0;
                this.forceAcute = false;
                this.offset = 0;
                this.parents = [p1, p2];
                this.params = [forceAcute];
                try {
                    this.offset = javaemul.internal.DoubleHelper.parseDouble(offset);
                }
                catch (e) {
                }
                this.update();
            }
            else if (((p1 != null && p1 instanceof geom.Line2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Line2D) || p2 === null) && ((typeof forceAcute === 'string') || forceAcute === null) && offset === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let offset = 3 * geom.Shape2D.SNAP_DISTANCE + "";
                    super(0, 0, "");
                    this.angle1 = 0;
                    this.angle2 = 0;
                    this.forceAcute = false;
                    this.offset = 0;
                    this.parents = [p1, p2];
                    this.params = [forceAcute];
                    try {
                        this.offset = javaemul.internal.DoubleHelper.parseDouble(offset);
                    }
                    catch (e) {
                    }
                    this.update();
                }
                this.angle1 = 0;
                this.angle2 = 0;
                this.forceAcute = false;
                this.offset = 0;
            }
            else if (((p1 != null && p1 instanceof geom.Line2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Line2D) || p2 === null) && forceAcute === undefined && offset === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let forceAcute = "false";
                    {
                        let __args = arguments;
                        let offset = 3 * geom.Shape2D.SNAP_DISTANCE + "";
                        super(0, 0, "");
                        this.angle1 = 0;
                        this.angle2 = 0;
                        this.forceAcute = false;
                        this.offset = 0;
                        this.parents = [p1, p2];
                        this.params = [forceAcute];
                        try {
                            this.offset = javaemul.internal.DoubleHelper.parseDouble(offset);
                        }
                        catch (e) {
                        }
                        this.update();
                    }
                    this.angle1 = 0;
                    this.angle2 = 0;
                    this.forceAcute = false;
                    this.offset = 0;
                }
                this.angle1 = 0;
                this.angle2 = 0;
                this.forceAcute = false;
                this.offset = 0;
            }
            else
                throw new Error('invalid overload');
        }
        static M_PI_$LI$() { if (AngleMeasure2D.M_PI == null) {
            AngleMeasure2D.M_PI = Math.PI;
        } return AngleMeasure2D.M_PI; }
        static M_2PI_$LI$() { if (AngleMeasure2D.M_2PI == null) {
            AngleMeasure2D.M_2PI = Math.PI * 2;
        } return AngleMeasure2D.M_2PI; }
        static M_PI_2_$LI$() { if (AngleMeasure2D.M_PI_2 == null) {
            AngleMeasure2D.M_PI_2 = Math.PI / 2;
        } return AngleMeasure2D.M_PI_2; }
        static M_3PI_2_$LI$() { if (AngleMeasure2D.M_3PI_2 == null) {
            AngleMeasure2D.M_3PI_2 = 3 * Math.PI / 2;
        } return AngleMeasure2D.M_3PI_2; }
        static M_PI_4_$LI$() { if (AngleMeasure2D.M_PI_4 == null) {
            AngleMeasure2D.M_PI_4 = Math.PI / 4;
        } return AngleMeasure2D.M_PI_4; }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Allow -ve angle", this.forceAcute);
            if (index === 1) {
                geom.Shape2D.editInfo_$LI$().set$java_lang_String$double$double$double("Offset", this.offset, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                return geom.Shape2D.editInfo_$LI$();
            }
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = value + "";
                this.update();
            }
            else if (index === 1) {
                this.params[0] = value + "";
                try {
                    this.offset = javaemul.internal.DoubleHelper.parseDouble(this.params[0]);
                }
                catch (e) {
                }
                this.update();
            }
        }
        update() {
            this.__isDefined = false;
            if ((!this.parents[0].__isDefined || !this.parents[1].__isDefined) && (this.name != null && !(this.name.length === 0))) {
                if (this.shapesManager != null)
                    this.shapesManager.globalVariables.put(this.name, javaemul.internal.DoubleHelper.NaN);
                return;
            }
            this.forceAcute = javaemul.internal.BooleanHelper.parseBoolean(this.params[0]);
            const line1 = this.parents[0];
            const line2 = this.parents[1];
            const denom = line1.dx * line2.dy - line1.dy * line2.dx;
            if (Math.abs(denom) < 1.0E-9)
                return;
            const t = ((line1.y0 - line2.y0) * line2.dx - (line1.x0 - line2.x0) * line2.dy) / denom;
            const pt = new math.Vector2(line1.x0 + t * line1.dx, line1.y0 + t * line1.dy);
            this.x0 = pt.x;
            this.y0 = pt.y;
            const v1 = new math.Vector2(line1.dx, line1.dy);
            const v2 = new math.Vector2(line2.dx, line2.dy);
            if ((line1 != null && line1 instanceof geom.Segment2D) && (line2 != null && line2 instanceof geom.Segment2D)) {
                const t1 = line1.t(pt);
                const t2 = line2.t(pt);
                if (t1 > 0.9)
                    v1.negate();
                else if (t2 > 0.9)
                    v2.negate();
            }
            if ((line1 != null && line1 instanceof geom.Segment2D) && (line2 != null && line2 instanceof geom.Segment2D) && !(Math.abs(line1.x0 - line2.x0) < framework.Preferences.getEpsilon() && Math.abs(line1.y0 - line2.y0) < framework.Preferences.getEpsilon())) {
            }
            let angle = geom.AngleUtils.angle$math_Vector2$math_Vector2(v1, v2);
            this.angle1 = geom.AngleUtils.horizontalAngle$math_Vector2(v1);
            angle = Math.acos(v1.dot$math_Vector2(v2));
            if (this.forceAcute) {
                if (v1.cross$math_Vector2(v2) < 0) {
                    this.angle2 = geom.AngleUtils.horizontalAngle$math_Vector2(v2);
                    angle = -angle;
                }
            }
            else {
                if (v1.cross$math_Vector2(v2) < 0)
                    angle = Math.PI * 2 - angle;
            }
            this.angle2 = this.angle1 + angle;
            if (this.forceAcute) {
            }
            else {
            }
            this.th = (this.angle1 + this.angle2) / 2;
            this.th = this.angle1 + angle / 2;
            this.segment = new geom.Segment2D(new math.Vector2(this.x0, this.y0), new math.Vector2(this.x0 + this.offset * Math.cos(this.th), this.y0 + this.offset * Math.sin(this.th)));
            this.label = math.MathUtils.formatAngle(/* toDegrees */ (x => x * 180 / Math.PI)(angle));
            this.__isDefined = true;
            if (this.shapesManager != null && this.name != null && !(this.name.length === 0))
                this.shapesManager.globalVariables.put(this.name, angle);
        }
        /**
         *
         * @param {string} name
         */
        setName(name) {
            if (name != null && !(name.length === 0) && this.shapesManager != null && this.shapesManager.containsShape(this))
                this.shapesManager.globalVariables.remove(this.getName());
            this.name = name;
            this.update();
        }
        static horizontalAngle$double$double(x, y) {
            return (Math.atan2(y, x) + AngleMeasure2D.M_2PI_$LI$()) % (AngleMeasure2D.M_2PI_$LI$());
        }
        static horizontalAngle$math_Vector2$math_Vector2(p1, p2) {
            return (Math.atan2(p2.y - p1.y, p2.x - p1.x) + AngleMeasure2D.M_2PI_$LI$()) % (AngleMeasure2D.M_2PI_$LI$());
        }
        /**
         * Returns the horizontal angle formed by the line joining the two given points.
         * @param {math.Vector2} p1
         * @param {math.Vector2} p2
         * @return {number}
         */
        static horizontalAngle(p1, p2) {
            if (((p1 != null && p1 instanceof math.Vector2) || p1 === null) && ((p2 != null && p2 instanceof math.Vector2) || p2 === null)) {
                return geom.AngleMeasure2D.horizontalAngle$math_Vector2$math_Vector2(p1, p2);
            }
            else if (((typeof p1 === 'number') || p1 === null) && ((typeof p2 === 'number') || p2 === null)) {
                return geom.AngleMeasure2D.horizontalAngle$double$double(p1, p2);
            }
            else
                throw new Error('invalid overload');
        }
        static angle$geom_Line2D$geom_Line2D(obj1, obj2) {
            const angle1 = AngleMeasure2D.horizontalAngle$double$double(obj1.dx, obj1.dy);
            const angle2 = AngleMeasure2D.horizontalAngle$double$double(obj2.dx, obj2.dy);
            return (angle2 - angle1 + AngleMeasure2D.M_2PI_$LI$()) % (AngleMeasure2D.M_2PI_$LI$());
        }
        /**
         * Returns the oriented angle between two (directed) straight objects. Result is
         * given in radians, between 0 and 2*PI.
         * @param {geom.Line2D} obj1
         * @param {geom.Line2D} obj2
         * @return {number}
         */
        static angle(obj1, obj2) {
            if (((obj1 != null && obj1 instanceof geom.Line2D) || obj1 === null) && ((obj2 != null && obj2 instanceof geom.Line2D) || obj2 === null)) {
                return geom.AngleMeasure2D.angle$geom_Line2D$geom_Line2D(obj1, obj2);
            }
            else if (((obj1 != null && obj1 instanceof math.Vector2) || obj1 === null) && ((obj2 != null && obj2 instanceof math.Vector2) || obj2 === null)) {
                return geom.AngleMeasure2D.angle$math_Vector2$math_Vector2(obj1, obj2);
            }
            else
                throw new Error('invalid overload');
        }
        static angle$math_Vector2$math_Vector2(vect1, vect2) {
            const angle1 = AngleMeasure2D.horizontalAngle$double$double(vect1.x, vect1.y);
            const angle2 = AngleMeasure2D.horizontalAngle$double$double(vect2.x, vect2.y);
            return (angle2 - angle1 + AngleMeasure2D.M_2PI_$LI$()) % (AngleMeasure2D.M_2PI_$LI$());
        }
        /**
         * Checks whether two angles are equal, with respect to the given error bound.
         *
         * @param {number} angle1 first angle to compare
         * @param {number} angle2 second angle to compare
         * @param {number} eps    the threshold value for comparison
         * @return {boolean} true if the two angle are equal modulo 2*PI
         */
        static almostEquals(angle1, angle2, eps) {
            const diff = Math.abs(angle1 - angle2);
            if (diff < eps)
                return true;
            if (Math.abs(diff - AngleMeasure2D.M_PI_$LI$() * 2) < eps)
                return true;
            return false;
        }
        /**
         *
         * @param {number} angle in radians
         * @return {string} String representing
         */
        static angleDegrees(angle) {
            return math.MathUtils.roundOffToPreferredSigFigures(/* toDegrees */ (x => x * 180 / Math.PI)(angle)) + "\u00b0";
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.__isDefined)
                return;
            const ctx = g.context;
            let info = this.getInfo();
            let r = this.offset;
            const is90 = Math.abs(2 * Math.abs(this.angle2 - this.angle1) - AngleMeasure2D.M_PI_$LI$()) < framework.Preferences.getEpsilon();
            if (is90) {
                r *= 0.75;
                const dx1 = r * Math.cos(this.angle1);
                const dy1 = r * Math.sin(this.angle1);
                const dx2 = r * Math.cos(this.angle2);
                const dy2 = r * Math.sin(this.angle2);
                if (this.drawColor != null) {
                    this.drawColor.a = 80;
                    g.setColors(this.drawColor, null);
                }
                ctx.beginPath();
                ctx.moveTo(this.x0, this.y0);
                ctx.lineTo(this.x0 + dx1, this.y0 + dy1);
                ctx.lineTo(this.x0 + dx1 + dx2, this.y0 + dy1 + dy2);
                ctx.lineTo(this.x0 + dx2, this.y0 + dy2);
                ctx.closePath();
                ctx.fill();
                if (this.drawColor != null) {
                    this.drawColor.a = 160;
                    g.setColors(this.drawColor, null);
                }
                ctx.moveTo(this.x0, this.y0);
                ctx.lineTo(this.x0 + dx1, this.y0 + dy1);
                ctx.lineTo(this.x0 + dx1 + dx2, this.y0 + dy1 + dy2);
                ctx.lineTo(this.x0 + dx2, this.y0 + dy2);
                ctx.stroke();
                info = this.name;
            }
            else {
                if (this.drawColor != null) {
                    this.drawColor.a = 80;
                    g.setColors(this.drawColor, null);
                }
                g.drawSlice(this.x0, this.y0, r, this.angle2 - this.angle1, -(this.angle2 + this.angle1) / 2, true, this.drawColor != null);
            }
            const rect = ctx.measureText(info);
            r += 10 / g.METER_TO_PIXEL;
            const v = new math.Vector2(this.x0 + r * Math.cos(this.th), this.y0 + r * Math.sin(this.th));
            r += rect.width / g.METER_TO_PIXEL;
            const v1 = new math.Vector2(this.x0 + r * Math.cos(this.th), this.y0 + r * Math.sin(this.th));
            if (this.showEqn || this.showName)
                this.renderInfo(g, v, v1);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Angle:" + this.name;
        }
        /**
         *
         * @return {boolean}
         */
        isFreeToMove() {
            return false;
        }
    }
    geom.AngleMeasure2D = AngleMeasure2D;
    AngleMeasure2D["__class"] = "geom.AngleMeasure2D";
})(geom || (geom = {}));
(function (geom) {
    class Segment2Points2D extends geom.Segment2D {
        constructor(p1, p2, renderMode) {
            if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((typeof renderMode === 'number') || renderMode === null)) {
                let __args = arguments;
                super();
                this.renderMode = renderMode;
                this.parents = [p1, p2];
                this.update();
            }
            else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && renderMode === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let renderMode = 0;
                    super();
                    this.renderMode = renderMode;
                    this.parents = [p1, p2];
                    this.update();
                }
            }
            else
                throw new Error('invalid overload');
        }
        update() {
            if (this.parents == null || this.parents[0] == null || this.parents[1] == null)
                return;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[0].pt;
            const v2 = this.parents[1].pt;
            if (v1 == null || v2 == null || v1.equals$math_Vector2(v2)) {
                this.expr = null;
                this.__isDefined = false;
                return;
            }
            super.set$math_Vector2$math_Vector2(v1, v2);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Segment joining " + this.parents[0].getName() + " & " + this.parents[1].getName();
        }
    }
    geom.Segment2Points2D = Segment2Points2D;
    Segment2Points2D["__class"] = "geom.Segment2Points2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Interface for all conic curves: parametric conics, or ellipses, parabolas,
     * and hyperbolas. Degenerate conics are also encompassed by this interface.
     * @class
     * @extends geom.Curve2D
     */
    class Conic2D extends geom.Curve2D {
        static TMP_SEGMENT_$LI$() { if (Conic2D.TMP_SEGMENT == null) {
            Conic2D.TMP_SEGMENT = new geom.Segment2D();
        } return Conic2D.TMP_SEGMENT; }
        /**
         * Returns pole of the polar Line wrt this conic
         * @param {geom.Line2D} polar
         * @return
         * @return {math.Vector2}
         */
        getPole(polar) {
            const c = this.conicCoefficients();
            const L = polar.coeff();
            const matrixA = [[c[0] * L[1] - c[1] * L[0] / 2, c[1] * L[1] / 2 - c[2] * L[0]], [c[1] * L[2] / 2 - c[3] * L[1] / 2, c[2] * L[2] - c[4] * L[1] / 2]];
            const matrixB = [-c[3] * L[1] / 2 + c[4] * L[0] / 2, -c[4] * L[2] / 2 + c[5] * L[1]];
            const res = math.EquationUtils.solveLinear(matrixA, matrixB);
            return res == null ? null : new math.Vector2(res[0], res[1]);
        }
        /**
         * Returns the polar line of the point (pole) wrt this conic
         * @param {math.Vector2} pole
         * @return
         * @return {geom.Line2D}
         */
        getPolar(pole) {
            const c = this.conicCoefficients();
            const h = pole.x;
            const k = pole.y;
            const l = c[0] * h + c[1] * k / 2 + c[3] / 2;
            const m = c[2] * k + c[1] * h / 2 + c[4] / 2;
            const n = c[3] * h / 2 + c[4] * k / 2 + c[5];
            return new geom.Line2D(l, m, n);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Conic " + this.name;
        }
    }
    geom.Conic2D = Conic2D;
    Conic2D["__class"] = "geom.Conic2D";
    (function (Conic2D) {
        /**
         * The different types of conic.
         * @enum
         * @property {geom.Conic2D.Type} NOT_A_CONIC
         * Degenerate conic, for example a conic given by the equation
         * <code>x^2+1=0</code>)
         * @property {geom.Conic2D.Type} ELLIPSE
         * Ellipse
         * @property {geom.Conic2D.Type} HYPERBOLA
         * Hyperbola
         * @property {geom.Conic2D.Type} PARABOLA
         * Parabola
         * @property {geom.Conic2D.Type} CIRCLE
         * Circle
         * @property {geom.Conic2D.Type} STRAIGHT_LINE
         * Straight Line
         * @property {geom.Conic2D.Type} TWO_LINES
         * Union of two lines
         * @property {geom.Conic2D.Type} POINT
         * Single point
         * @class
         */
        let Type;
        (function (Type) {
            /**
             * Degenerate conic, for example a conic given by the equation
             * <code>x^2+1=0</code>)
             */
            Type[Type["NOT_A_CONIC"] = 0] = "NOT_A_CONIC";
            /**
             * Ellipse
             */
            Type[Type["ELLIPSE"] = 1] = "ELLIPSE";
            /**
             * Hyperbola
             */
            Type[Type["HYPERBOLA"] = 2] = "HYPERBOLA";
            /**
             * Parabola
             */
            Type[Type["PARABOLA"] = 3] = "PARABOLA";
            /**
             * Circle
             */
            Type[Type["CIRCLE"] = 4] = "CIRCLE";
            /**
             * Straight Line
             */
            Type[Type["STRAIGHT_LINE"] = 5] = "STRAIGHT_LINE";
            /**
             * Union of two lines
             */
            Type[Type["TWO_LINES"] = 6] = "TWO_LINES";
            /**
             * Single point
             */
            Type[Type["POINT"] = 7] = "POINT";
        })(Type = Conic2D.Type || (Conic2D.Type = {}));
    })(Conic2D = geom.Conic2D || (geom.Conic2D = {}));
})(geom || (geom = {}));
(function (geom) {
    class Vector2D extends geom.Segment2D {
        constructor(p1, p2) {
            if (((p1 != null && p1 instanceof math.Vector2) || p1 === null) && ((p2 != null && p2 instanceof math.Vector2) || p2 === null)) {
                let __args = arguments;
                super(p1, p2);
            }
            else if (p1 === undefined && p2 === undefined) {
                let __args = arguments;
                super();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.isDefined())
                return;
            const dir = this.p1.to$math_Vector2(this.p2);
            const l = dir.normalize();
            const dx = dir.x;
            const dy = dir.y;
            const arrowlength = (15 + 2 * this.strokeWidth) / g.METER_TO_PIXEL;
            const sx = this.p2.x - dx * arrowlength;
            const sy = this.p2.y - dy * arrowlength;
            g.drawLine(this.p1.x, this.p1.y, sx, sy);
            g.drawArrow(sx, sy, dx, dy, arrowlength);
            if (this.showEqn || this.showName) {
                this.renderInfo(g, this.p1, this.p2);
            }
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Vector " + this.name;
        }
    }
    geom.Vector2D = Vector2D;
    Vector2D["__class"] = "geom.Vector2D";
})(geom || (geom = {}));
(function (geom) {
    class Slider2D extends geom.Segment2D {
        constructor(pt1, pt2) {
            super(pt1.pt, pt2.pt);
            this.length = 1;
            this.min = 0;
            this.max = 5;
            this.value = 1;
            this.pt = new math.Vector2();
            this.knobDrag = false;
            this.setRange(this.min, this.max);
            this.showEqn = true;
            this.showName = true;
        }
        setRange(min, max) {
            this.min = min;
            this.max = max;
            this.update();
        }
        setValue(value) {
            this.value = math.MathUtils.clamp$double$double$double(value, this.min, this.max);
            this.pt = math.Vector2.interpolate(this.p1, this.p2, (value - this.min) / (this.max - value));
            if (this.shapesManager != null && this.name != null && !(this.name.length === 0))
                this.shapesManager.globalVariables.put(this.name, this.value);
        }
        /**
         * @param {string} name
         * the name to set
         */
        setName(name) {
            if (name != null) {
                name = /* replaceAll */ name.replace(new RegExp(" ", 'g'), "");
                if (this.shapesManager.containsShape(this))
                    this.shapesManager.globalVariables.remove(this.name);
                this.name = name;
            }
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = true;
            this.setValue(this.value);
            this.expr = math.MathUtils.format(this.value);
        }
        mousePressed(pt) {
            if (pt.distance$math_Vector2(this.pt) < geom.Shape2D.SNAP_DISTANCE) {
                this.knobDrag = true;
            }
            else {
                this.knobDrag = false;
            }
        }
        mouseReleased(pt) {
            this.knobDrag = false;
        }
        /**
         *
         * @param {math.Vector2} delta
         * @param {math.Vector2} pt
         * @param {boolean} manually
         */
        mouseDragged(delta, pt, manually) {
            if (!this.__isDefined)
                return;
            if (this.knobDrag) {
                this.pt.add$math_Vector2(delta);
                const t = this.t(pt);
                this.setValue(this.min + t * (this.max - this.min));
            }
            else {
                this.set$math_Vector2$math_Vector2(this.p1.add$math_Vector2(delta), this.p2.add$math_Vector2(delta));
            }
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.isDefined())
                return;
            super.render(g);
            g.drawCircle(this.pt.x, this.pt.y, 0.07, true, true);
        }
        /**
         * returns true if shape can be moved freely by mouse drag or arrow keys
         * @return
         * @return {boolean}
         */
        isFreeToMove() {
            return true;
        }
    }
    geom.Slider2D = Slider2D;
    Slider2D["__class"] = "geom.Slider2D";
})(geom || (geom = {}));
(function (geom) {
    class RayRefract2PointsCurveMu2D extends geom.Ray2D {
        constructor(p1, p2, curve, mu) {
            super();
            if (this.incidentRay === undefined) {
                this.incidentRay = null;
            }
            this.parents = [p1, p2, curve];
            this.params = [mu];
            this.update();
        }
        update() {
            if (this.parents == null)
                return;
            this.expr = null;
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                return;
            }
            let mu = 1;
            try {
                mu = Math.fround(math.MathUtils.evaluateExpression(this.params[0], null, null));
            }
            catch (e) {
                return;
            }
            const v1 = this.parents[0].pt;
            const v2 = this.parents[1].pt;
            if (v1 == null || v2 == null || v1.equals$math_Vector2(v2))
                return;
            this.incidentRay = new geom.Line2D(v1, v2.difference$math_Vector2(v1));
            const curve = this.parents[2];
            const pts = geom.CurveUtils.getIntersections(this.incidentRay, curve, v2);
            if (pts == null)
                return;
            const p = pts[0];
            const n = curve.tangent(curve.t(p)).right();
            const iDir = this.incidentRay.getDirection();
            const sini = n.cross$math_Vector2(iDir);
            const i = Math.asin(sini);
            let r;
            if (sini / mu > 1) {
                r = Math.PI - i;
            }
            else {
                r = Math.asin(sini / mu);
            }
            if ( /* isNaN */isNaN(r))
                return;
            iDir.rotate$double(i - r);
            this.x0 = p.x;
            this.y0 = p.y;
            this.dx = iDir.x;
            this.dy = iDir.y;
            this.__isDefined = true;
            this.clip();
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return this.parents == null ? "Refracted Ray " + this.name : ("from " + this.parents[2].getName() + " to " + this.parents[1].getName());
        }
    }
    geom.RayRefract2PointsCurveMu2D = RayRefract2PointsCurveMu2D;
    RayRefract2PointsCurveMu2D["__class"] = "geom.RayRefract2PointsCurveMu2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     *
     * @param {geom.Point2D} p1 initial point
     * @param {geom.Point2D} p2 another point on ray
     * @class
     * @extends geom.Ray2D
     */
    class Ray2Points2D extends geom.Ray2D {
        constructor(p1, p2) {
            super();
            this.parents = [p1, p2];
            this.update();
        }
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[0].pt;
            const v2 = this.parents[1].pt;
            if (v1 == null || v2 == null || v1.equals$math_Vector2(v2)) {
                this.expr = null;
                this.__isDefined = false;
                return;
            }
            this.__isDefined = true;
            this.x0 = v1.x;
            this.y0 = v1.y;
            const v = v1.to$math_Vector2(v2);
            v.normalize();
            this.dx = v.x;
            this.dy = v.y;
            if (this.visible)
                this.clip();
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return this.parents == null ? "Ray " + this.name : ("from " + this.parents[0].getName() + " to " + this.parents[1].getName());
        }
    }
    geom.Ray2Points2D = Ray2Points2D;
    Ray2Points2D["__class"] = "geom.Ray2Points2D";
})(geom || (geom = {}));
(function (geom) {
    class RayReflect2PointsCurve2D extends geom.ParentShapeArray2D {
        constructor(p1, p2, curve, reflectivity, refractiveIndex) {
            if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((curve != null && curve instanceof geom.Curve2D) || curve === null) && ((typeof reflectivity === 'string') || reflectivity === null) && ((typeof refractiveIndex === 'string') || refractiveIndex === null)) {
                let __args = arguments;
                super();
                if (this.incidentRay === undefined) {
                    this.incidentRay = null;
                }
                if (this.reflectedRay === undefined) {
                    this.reflectedRay = null;
                }
                if (this.refractedRay === undefined) {
                    this.refractedRay = null;
                }
                this.reflectivity = 0.5;
                this.parents = [p1, p2, curve];
                this.incidentRay = new geom.Segment2D();
                this.reflectedRay = new geom.Ray2D();
                this.refractedRay = new geom.Ray2D();
                this.params = [reflectivity, refractiveIndex];
                this.update();
            }
            else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((curve != null && curve instanceof geom.Curve2D) || curve === null) && reflectivity === undefined && refractiveIndex === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let reflectivity = "1";
                    let refractiveIndex = "1.5";
                    super();
                    if (this.incidentRay === undefined) {
                        this.incidentRay = null;
                    }
                    if (this.reflectedRay === undefined) {
                        this.reflectedRay = null;
                    }
                    if (this.refractedRay === undefined) {
                        this.refractedRay = null;
                    }
                    this.reflectivity = 0.5;
                    this.parents = [p1, p2, curve];
                    this.incidentRay = new geom.Segment2D();
                    this.reflectedRay = new geom.Ray2D();
                    this.refractedRay = new geom.Ray2D();
                    this.params = [reflectivity, refractiveIndex];
                    this.update();
                }
                if (this.incidentRay === undefined) {
                    this.incidentRay = null;
                }
                if (this.reflectedRay === undefined) {
                    this.reflectedRay = null;
                }
                if (this.refractedRay === undefined) {
                    this.refractedRay = null;
                }
                this.reflectivity = 0.5;
            }
            else
                throw new Error('invalid overload');
        }
        static TMP_RAY_$LI$() { if (RayReflect2PointsCurve2D.TMP_RAY == null) {
            RayReflect2PointsCurve2D.TMP_RAY = new geom.Ray2D();
        } return RayReflect2PointsCurve2D.TMP_RAY; }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Reflective Coefficient", this.params[0], null);
            else if (index === 1) {
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("RefractiveIndex", this.params[1], null);
            }
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
            }
            else if (index === 1) {
                this.params[1] = (value + "");
            }
        }
        update() {
            this.__isDefined = false;
            this.incidentRay.__isDefined = false;
            this.reflectedRay.__isDefined = false;
            this.refractedRay.__isDefined = false;
            if (this.parents[0] != null && !this.parents[0].isDefined() || this.parents[1] != null && !this.parents[1].isDefined()) {
                return;
            }
            const v1 = this.parents[0].pt;
            const v2 = this.parents[1].pt;
            const curve = this.parents[2];
            if (v1 == null || v2 == null || v1.equals$math_Vector2(v2))
                return;
            RayReflect2PointsCurve2D.TMP_RAY_$LI$().set$math_Vector2$math_Vector2(v1, v2);
            let p = null;
            const pts = geom.CurveUtils.getIntersections(curve, RayReflect2PointsCurve2D.TMP_RAY_$LI$(), v2);
            if (pts != null) {
                for (let index = 0; index < pts.length; index++) {
                    let v = pts[index];
                    {
                        if (RayReflect2PointsCurve2D.TMP_RAY_$LI$().contains(v) && !math.MathUtils.approxEqual(v, v1)) {
                            p = v;
                            break;
                        }
                    }
                }
            }
            if (p == null)
                return;
            this.incidentRay.set$math_Vector2$math_Vector2(v1, p);
            const t = curve.t(p);
            let refCoeff = 0.5;
            let mu = 1.5;
            try {
                refCoeff = math.MathUtils.evaluateExpression(this.params[0], null, null);
                mu = math.MathUtils.evaluateExpression(this.params[1], null, null);
            }
            catch (e) {
                return;
            }
            const iDir = this.incidentRay.getDirection();
            const n = curve.tangent(t).right();
            if (n.dot$math_Vector2(iDir) > 0)
                n.negate();
            mu = 1 / mu;
            const cos1 = -n.x * iDir.x - n.y * iDir.y;
            const sq1 = 1 - mu * mu * (1 - cos1 * cos1);
            if (sq1 < 0 || refCoeff === 1) {
                this.reflectedRay.set$double$double$double$double(p.x, p.y, iDir.x + 2 * cos1 * n.x, iDir.y + 2 * cos1 * n.y);
            }
            else {
                const cos2 = Math.sqrt(sq1);
                const R_s = Math.pow((mu * cos1 - cos2) / (mu * cos1 + cos2), 2);
                const R_p = Math.pow((mu * cos2 - cos1) / (mu * cos2 + cos1), 2);
                const brightness = refCoeff;
                this.refractedRay.set$double$double$double$double(p.x, p.y, mu * iDir.x + (mu * cos1 - cos2) * n.x, mu * iDir.y + (mu * cos1 - cos2) * n.y);
                if (brightness > 0) {
                    this.reflectedRay.set$double$double$double$double(p.x, p.y, iDir.x + 2 * cos1 * n.x, iDir.y + 2 * cos1 * n.y);
                    this.reflectivity = Math.fround(brightness);
                }
                else {
                    this.reflectivity = 0;
                }
            }
            this.__isDefined = true;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Ray " + this.name + ("from " + this.parents[0].getName() + " to " + this.parents[1].getName());
        }
        /**
         *
         * @return {number}
         */
        getChildrenCount() {
            return 3;
        }
        /**
         *
         * @param {number} index
         * @return {geom.Shape2D}
         */
        getChild(index) {
            if (index === 0) {
                return this.incidentRay;
            }
            else if (index === 1) {
                return this.reflectedRay;
            }
            else if (index === 2) {
                return this.refractedRay;
            }
            return null;
        }
        /**
         *
         * @param {framework.Renderer} gl
         */
        render(gl) {
            if (this.drawColor != null) {
                gl.setColors(null, this.drawColor);
            }
            if (this.reflectedRay.__isDefined && this.refractedRay.__isDefined) {
                this.incidentRay.renderAsRay(gl);
                const color = this.incidentRay.drawColor;
                color.a = ((Math.fround(this.reflectivity * 255)) | 0);
                gl.setColors(null, color);
                this.reflectedRay.render(gl);
                color.a = ((Math.fround(255 - Math.fround(this.reflectivity * 255))) | 0);
                gl.setColors(null, color);
                this.refractedRay.render(gl);
            }
            else {
                this.incidentRay.renderAsRay(gl);
                if (this.reflectedRay.__isDefined)
                    this.reflectedRay.render(gl);
                if (this.refractedRay.__isDefined)
                    this.refractedRay.render(gl);
            }
        }
    }
    geom.RayReflect2PointsCurve2D = RayReflect2PointsCurve2D;
    RayReflect2PointsCurve2D["__class"] = "geom.RayReflect2PointsCurve2D";
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalRay2D extends geom.Ray2D {
            constructor(parent, pt1, pt2, brightness) {
                if (((parent != null && parent instanceof geom.optics.OpticalRay2D) || parent === null) && ((pt1 != null && pt1 instanceof math.Vector2) || pt1 === null) && ((pt2 != null && pt2 instanceof math.Vector2) || pt2 === null) && ((typeof brightness === 'number') || brightness === null)) {
                    let __args = arguments;
                    super();
                    if (this.refractedRay === undefined) {
                        this.refractedRay = null;
                    }
                    if (this.reflectedRay === undefined) {
                        this.reflectedRay = null;
                    }
                    if (this.source === undefined) {
                        this.source = null;
                    }
                    if (this.device === undefined) {
                        this.device = null;
                    }
                    this.index = 0;
                    this.brightness = 1;
                    this.isTerminated = false;
                    this.waveLength = 500;
                    this.extentionPoint = null;
                    if (parent != null) {
                        this.parents = parent.parents == null ? [parent] : parent.parents;
                        this.source = parent.source;
                        this.drawColor = parent.drawColor;
                        this.index = parent.index + 1;
                        this.waveLength = parent.waveLength;
                        this.shapesManager = parent.shapesManager;
                    }
                    this.set$math_Vector2$math_Vector2(pt1, pt2);
                    this.brightness = math.MathUtils.clamp$double$double$double(brightness, 0, 1);
                    this.__isDefined = true;
                }
                else if (((parent != null && (parent.constructor != null && parent.constructor["__interfaces"] != null && parent.constructor["__interfaces"].indexOf("geom.optics.OpticalSource") >= 0)) || parent === null) && pt1 === undefined && pt2 === undefined && brightness === undefined) {
                    let __args = arguments;
                    let source = __args[0];
                    {
                        let __args = arguments;
                        let parent = null;
                        let pt1 = new math.Vector2();
                        let pt2 = new math.Vector2(1, 0);
                        let brightness = 1;
                        super();
                        if (this.refractedRay === undefined) {
                            this.refractedRay = null;
                        }
                        if (this.reflectedRay === undefined) {
                            this.reflectedRay = null;
                        }
                        if (this.source === undefined) {
                            this.source = null;
                        }
                        if (this.device === undefined) {
                            this.device = null;
                        }
                        this.index = 0;
                        this.brightness = 1;
                        this.isTerminated = false;
                        this.waveLength = 500;
                        this.extentionPoint = null;
                        if (parent != null) {
                            this.parents = parent.parents == null ? [parent] : parent.parents;
                            this.source = parent.source;
                            this.drawColor = parent.drawColor;
                            this.index = parent.index + 1;
                            this.waveLength = parent.waveLength;
                            this.shapesManager = parent.shapesManager;
                        }
                        this.set$math_Vector2$math_Vector2(pt1, pt2);
                        this.brightness = math.MathUtils.clamp$double$double$double(brightness, 0, 1);
                        this.__isDefined = true;
                    }
                    if (this.refractedRay === undefined) {
                        this.refractedRay = null;
                    }
                    if (this.reflectedRay === undefined) {
                        this.reflectedRay = null;
                    }
                    if (this.source === undefined) {
                        this.source = null;
                    }
                    if (this.device === undefined) {
                        this.device = null;
                    }
                    this.index = 0;
                    this.brightness = 1;
                    this.isTerminated = false;
                    this.waveLength = 500;
                    this.extentionPoint = null;
                    (() => {
                        this.source = source;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            set$double$double$double$double(x, y, dx, dy) {
                this.x0 = x;
                this.y0 = y;
                this.p1.set$double$double(this.x0, this.y0);
                this.p2.set$double$double(this.x0 + dx, this.y0 + dy);
                const r = math.MathUtils.hypot(dx, dy);
                dx /= r;
                dy /= r;
                this.dx = dx;
                this.dy = dy;
                this.isTerminated = false;
                this.__isDefined = true;
            }
            /**
             * Sets line as passing through point (x,y) and direction rations as dx and dy
             * @param {number} x
             * @param {number} y
             * @param {number} dx
             * @param {number} dy
             */
            set(x, y, dx, dy) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && ((typeof dy === 'number') || dy === null)) {
                    return this.set$double$double$double$double(x, y, dx, dy);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && dy === undefined) {
                    return this.set$double$double$double(x, y, dx);
                }
                else if (((x != null && x instanceof math.Vector2) || x === null) && ((y != null && y instanceof math.Vector2) || y === null) && dx === undefined && dy === undefined) {
                    return this.set$math_Vector2$math_Vector2(x, y);
                }
                else if (((x != null && x instanceof geom.Line2D) || x === null) && y === undefined && dx === undefined && dy === undefined) {
                    return this.set$geom_Line2D(x);
                }
                else
                    throw new Error('invalid overload');
            }
            set$math_Vector2$math_Vector2(p1, p2) {
                this.set$double$double$double$double(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
            }
            /**
             * terminates ray at this point (starting point remains same)
             * @param {math.Vector2} p
             */
            terminate(p) {
                this.p2.set$math_Vector2(p);
                this.isTerminated = true;
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} ray
             * @return {number} number of subrays (0,1,2)
             * @param {geom.ShapesManager} shapesManager
             */
            static processRay(ray, shapesManager) {
                if (ray == null)
                    return 0;
                if (ray.index > shapesManager.preferences.MAX_RAY_INTERACTIONS) {
                    ray.refractedRay = null;
                    ray.reflectedRay = null;
                    return 0;
                }
                if (ray.brightness < 0.01) {
                    ray.reflectedRay = null;
                    ray.refractedRay = null;
                    ray.isTerminated = false;
                    return 0;
                }
                if (shapesManager.surfaceMergingObjects.size() > 0)
                    shapesManager.surfaceMergingObjects.clear();
                ray.extentionPoint = null;
                let t0 = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                let device = null;
                for (let index = shapesManager.getAllShapes().iterator(); index.hasNext();) {
                    let s = index.next();
                    {
                        if (!s.isDefined() || !s.isVisible() || !(s != null && s instanceof geom.optics.OpticalDevice2D))
                            continue;
                        const od = s;
                        const t = od.intersection(ray);
                        if (t > 0 && device != null && Math.abs(t - t0) < geom.Shape2D.ACCURACY) {
                            if (device != null && (device.constructor != null && device.constructor["__interfaces"] != null && device.constructor["__interfaces"].indexOf("geom.optics.OpticalRefractor") >= 0)) {
                                if (od != null && (od.constructor != null && od.constructor["__interfaces"] != null && od.constructor["__interfaces"].indexOf("geom.optics.OpticalRefractor") >= 0)) {
                                    shapesManager.surfaceMergingObjects.add(od);
                                }
                                else {
                                    device = od;
                                    t0 = t;
                                }
                            }
                        }
                        else if (t > geom.Shape2D.ACCURACY && t < t0) {
                            device = od;
                            t0 = t;
                            if (shapesManager.surfaceMergingObjects.size() > 0)
                                shapesManager.surfaceMergingObjects.clear();
                        }
                    }
                }
                if (device == null) {
                    ray.reflectedRay = null;
                    ray.refractedRay = null;
                    ray.isTerminated = false;
                    return 0;
                }
                const n = device.shot(ray);
                if (n !== -1) {
                    ray.terminate(ray.point(t0));
                }
                switch ((n)) {
                    case -1:
                    case 0:
                        ray.reflectedRay = null;
                        ray.refractedRay = null;
                        return 0;
                    case 1:
                        ray.refractedRay = null;
                        device.addRayToObserve(ray.reflectedRay, true);
                        OpticalRay2D.processRay(ray.reflectedRay, shapesManager);
                        return 1;
                    case 2:
                        ray.reflectedRay = null;
                        device.addRayToObserve(ray.refractedRay, false);
                        OpticalRay2D.processRay(ray.refractedRay, shapesManager);
                        return 1;
                    case 3:
                        device.addRayToObserve(ray.reflectedRay, true);
                        device.addRayToObserve(ray.refractedRay, false);
                        OpticalRay2D.processRay(ray.reflectedRay, shapesManager);
                        OpticalRay2D.processRay(ray.refractedRay, shapesManager);
                        return 2;
                }
                return 0;
            }
            /**
             *
             * @param {framework.Renderer} gl
             */
            render(gl) {
                const ctx = gl.context;
                if (this.extentionPoint != null) {
                    ctx.save();
                    ctx.setLineDash([0.1, 0.1]);
                    this.shapesManager.preferences.virtualRaysColor.a = ((255 * this.brightness) | 0);
                    gl.setColors(null, this.shapesManager.preferences.virtualRaysColor);
                    let v;
                    if (this.t(this.extentionPoint) < 0) {
                        v = this.p1;
                    }
                    else {
                        v = this.p2;
                    }
                    gl.drawLine(v.x, v.y, this.extentionPoint.x, this.extentionPoint.y);
                    ctx.restore();
                }
                if (!this.isTerminated) {
                    this.clip();
                }
                if (this.drawColor != null) {
                    this.drawColor.a = ((255 * this.brightness) | 0);
                }
                gl.setColors(null, this.drawColor);
                super.renderAsRay(gl);
                if (this.reflectedRay != null)
                    this.reflectedRay.render(gl);
                if (this.refractedRay != null)
                    this.refractedRay.render(gl);
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Ray from " + this.source;
            }
        }
        optics.OpticalRay2D = OpticalRay2D;
        OpticalRay2D["__class"] = "geom.optics.OpticalRay2D";
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticsUtils {
            static TMP_RAY_$LI$() { if (OpticsUtils.TMP_RAY == null) {
                OpticsUtils.TMP_RAY = new geom.Ray2D();
            } return OpticsUtils.TMP_RAY; }
            static TMP_SEGMENT_$LI$() { if (OpticsUtils.TMP_SEGMENT == null) {
                OpticsUtils.TMP_SEGMENT = new geom.Segment2D();
            } return OpticsUtils.TMP_SEGMENT; }
            static TMP_VEC_$LI$() { if (OpticsUtils.TMP_VEC == null) {
                OpticsUtils.TMP_VEC = new math.Vector2();
            } return OpticsUtils.TMP_VEC; }
            static TMP_VEC2_$LI$() { if (OpticsUtils.TMP_VEC2 == null) {
                OpticsUtils.TMP_VEC2 = new math.Vector2();
            } return OpticsUtils.TMP_VEC2; }
            /**
             *
             * @param {geom.optics.OpticalRay2D} opticalray
             * @param {geom.Ray2D} ray incident ray
             * @param {math.Vector2} s_point point where ray meets surface
             * @param {math.Vector2} normal normal at the surface at s_point
             * @param {number} n1 refractive index
             * @param {number} reflectivity (0 to 1)
             * @return {number} -1 ray does't hit, 0 = ray is blocked, 1=if reflects only, 2 =refracts only, 3=both reflection and refraction
             */
            static refract(opticalray, ray, s_point, normal, n1, reflectivity) {
                if (ray.getDirection().dot$math_Vector2(normal) > 0)
                    normal.negate();
                if (normal.isZero())
                    return -1;
                const normal_len = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                const normal_x = normal.x / normal_len;
                const normal_y = normal.y / normal_len;
                const ray_len = Math.sqrt((ray.p2.x - ray.p1.x) * (ray.p2.x - ray.p1.x) + (ray.p2.y - ray.p1.y) * (ray.p2.y - ray.p1.y));
                const ray_x = (ray.p2.x - ray.p1.x) / ray_len;
                const ray_y = (ray.p2.y - ray.p1.y) / ray_len;
                const cos1 = -normal_x * ray_x - normal_y * ray_y;
                const sq1 = 1 - n1 * n1 * (1 - cos1 * cos1);
                if (sq1 < 0) {
                    OpticsUtils.TMP_VEC_$LI$().set$double$double(s_point.x + ray_x + 2 * cos1 * normal_x, s_point.y + ray_y + 2 * cos1 * normal_y);
                    OpticsUtils.addReflectedRay(opticalray, s_point, OpticsUtils.TMP_VEC_$LI$(), opticalray.brightness);
                    return 1;
                }
                else {
                    const cos2 = Math.sqrt(sq1);
                    const R_s = Math.pow((n1 * cos1 - cos2) / (n1 * cos1 + cos2), 2);
                    const R_p = Math.pow((n1 * cos2 - cos1) / (n1 * cos2 + cos1), 2);
                    const R = math.MathUtils.clamp$double$double$double(reflectivity * (R_s + R_p), 0, 1);
                    const brightness = opticalray.brightness * R;
                    OpticsUtils.TMP_VEC_$LI$().set$double$double(s_point.x + n1 * ray_x + (n1 * cos1 - cos2) * normal_x, s_point.y + n1 * ray_y + (n1 * cos1 - cos2) * normal_y);
                    OpticsUtils.addRefractedRay(opticalray, s_point, OpticsUtils.TMP_VEC_$LI$(), opticalray.brightness * (1 - R));
                    OpticsUtils.TMP_VEC_$LI$().set$double$double(s_point.x + ray_x + 2 * cos1 * normal_x, s_point.y + ray_y + 2 * cos1 * normal_y);
                    if (brightness > 0.05) {
                        OpticsUtils.addReflectedRay(opticalray, s_point, OpticsUtils.TMP_VEC_$LI$(), brightness);
                        return 3;
                    }
                    else {
                        return 2;
                    }
                }
            }
            /**
             * Append reflected light to the optical ray
             * @param {geom.optics.OpticalRay2D} opticalray
             * @param {math.Vector2} p1
             * @param {math.Vector2} p2
             * @param {number} brightness
             */
            static addReflectedRay(opticalray, p1, p2, brightness) {
                if (opticalray.reflectedRay == null)
                    opticalray.reflectedRay = new geom.optics.OpticalRay2D(opticalray, p1, p2, brightness);
                else
                    opticalray.reflectedRay.set$math_Vector2$math_Vector2(p1, p2);
                opticalray.reflectedRay.brightness = brightness;
            }
            /**
             * Append refracted light to the optical ray
             * @param {geom.optics.OpticalRay2D} opticalray
             * @param {math.Vector2} p1
             * @param {math.Vector2} p2
             * @param {number} brightness
             */
            static addRefractedRay(opticalray, p1, p2, brightness) {
                brightness = Math.abs(brightness);
                if (opticalray.refractedRay == null)
                    opticalray.refractedRay = new geom.optics.OpticalRay2D(opticalray, p1, p2, brightness);
                else
                    opticalray.refractedRay.set$math_Vector2$math_Vector2(p1, p2);
                opticalray.refractedRay.brightness = brightness;
            }
            static intersection$geom_Circle2D$geom_Ray2D(circle, ray) {
                if (circle.isDefined() === false && (circle != null && circle instanceof geom.CircleArc3Points2D)) {
                    const p1 = circle.getParents()[0];
                    const p2 = circle.getParents()[2];
                    if (p1.isDefined() && p2.isDefined()) {
                        OpticsUtils.TMP_SEGMENT_$LI$().set$math_Vector2$math_Vector2(p1.pt, p2.pt);
                        return [OpticsUtils.intersection$geom_Line2D$geom_Ray2D(OpticsUtils.TMP_SEGMENT_$LI$(), ray)];
                    }
                    return null;
                }
                const cx = circle.cx;
                const cy = circle.cy;
                const l = math.MathUtils.hypot(ray.dx, ray.dy);
                const ux = ray.dx / l;
                const uy = ray.dy / l;
                const cu = ((cx - ray.p1.x) * ux + (cy - ray.p1.y) * uy);
                const px = ray.p1.x + cu * ux;
                const py = ray.p1.y + cu * uy;
                const d = Math.sqrt(circle.r * circle.r - (px - cx) * (px - cx) - (py - cy) * (py - cy));
                if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(d))
                    return null;
                OpticsUtils.TMP_VEC_$LI$().set$double$double(px + ux * d, py + uy * d);
                OpticsUtils.TMP_VEC2_$LI$().set$double$double(px - ux * d, py - uy * d);
                let t1 = ray.t(OpticsUtils.TMP_VEC_$LI$());
                let t2 = ray.t(OpticsUtils.TMP_VEC2_$LI$());
                if (t1 < geom.Shape2D.ACCURACY || !circle.contains(OpticsUtils.TMP_VEC_$LI$()))
                    t1 = -1;
                if (t2 < geom.Shape2D.ACCURACY || !circle.contains(OpticsUtils.TMP_VEC2_$LI$()))
                    t2 = -1;
                if (t1 > 0) {
                    if (t2 > 0) {
                        return [Math.min(t1, t2), Math.max(t1, t2)];
                    }
                    else {
                        return [t1];
                    }
                }
                else if (t2 > 0) {
                    return [t2];
                }
                return null;
            }
            /**
             * Returns array of parameteric point on ray (t) in ascending order if it intersects else returns null
             * @param {geom.Circle2D} circle A circle or an arc
             * @param {geom.Ray2D} ray
             * @return
             * @return {double[]}
             */
            static intersection(circle, ray) {
                if (((circle != null && circle instanceof geom.Circle2D) || circle === null) && ((ray != null && ray instanceof geom.Ray2D) || ray === null)) {
                    return geom.optics.OpticsUtils.intersection$geom_Circle2D$geom_Ray2D(circle, ray);
                }
                else if (((circle != null && circle instanceof geom.Conic2D) || circle === null) && ((ray != null && ray instanceof geom.Ray2D) || ray === null)) {
                    return geom.optics.OpticsUtils.intersection$geom_Conic2D$geom_Ray2D(circle, ray);
                }
                else if (((circle != null && circle instanceof geom.Line2D) || circle === null) && ((ray != null && ray instanceof geom.Ray2D) || ray === null)) {
                    return geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(circle, ray);
                }
                else
                    throw new Error('invalid overload');
            }
            static intersection$geom_Conic2D$geom_Ray2D(conic, ray) {
                const t = conic.intersections(ray);
                if (t.length === 0)
                    return null;
                if (t.length === 1) {
                    OpticsUtils.TMP_VEC_$LI$().set$math_Vector2(conic.point(t[0]));
                    return [ray.t(OpticsUtils.TMP_VEC_$LI$())];
                }
                else if (t.length === 2) {
                    OpticsUtils.TMP_VEC_$LI$().set$math_Vector2(conic.point(t[0]));
                    OpticsUtils.TMP_VEC2_$LI$().set$math_Vector2(conic.point(t[1]));
                    let t1 = ray.t(OpticsUtils.TMP_VEC_$LI$());
                    let t2 = ray.t(OpticsUtils.TMP_VEC2_$LI$());
                    if (t1 < geom.Shape2D.ACCURACY || !conic.contains(OpticsUtils.TMP_VEC_$LI$()))
                        t1 = -1;
                    if (t2 < geom.Shape2D.ACCURACY || !conic.contains(OpticsUtils.TMP_VEC2_$LI$()))
                        t2 = -1;
                    if (t1 > 0) {
                        if (t2 > 0) {
                            return [Math.min(t1, t2), Math.max(t1, t2)];
                        }
                        else {
                            return [t1];
                        }
                    }
                    else if (t2 > 0) {
                        return [t2];
                    }
                    return null;
                }
                return null;
            }
            static intersection$geom_Line2D$geom_Ray2D(line, ray) {
                const denom = ray.dx * line.dy - ray.dy * line.dx;
                if (Math.abs(denom) < 1.0E-9)
                    return -1;
                const t = ((ray.y0 - line.y0) * line.dx - (ray.x0 - line.x0) * line.dy) / denom;
                if (t > geom.Shape2D.ACCURACY && line.contains(ray.point(t)))
                    return t;
                return -1;
            }
            /**
             * Returns true if the specified point  lies on the line
             * @param {math.Vector2} pt {Vector2 }
             * @return {boolean} {Boolean}
             * @param {geom.Line2D} line
             */
            static contains(line, pt) {
                return Math.abs(line.dy * (pt.x - line.x0) - line.dx * (pt.y - line.y0)) < framework.Preferences.EPSILON;
            }
            /**
             * Returns true if the specified point  lies on the line
             * @param {geom.optics.OpticalImage} pt {Vector2 }
             * @return {boolean} {Boolean}
             * @param {geom.optics.OpticalRay2D} ray
             */
            static isExtendedRay(ray, pt) {
                if (!OpticsUtils.contains(ray, pt))
                    return false;
                const t = (pt.x - ray.p1.x) / (ray.p2.x - ray.p1.x);
                if (ray.isTerminated) {
                    return t > 1 || t < 0;
                }
                else {
                    return t < 0;
                }
            }
            /**
             * Creates images from collection of rays and updated list of images
             * @param {java.util.ArrayList} rays
             * @param {java.util.ArrayList} images
             * @param {boolean} extendedRays
             * @param {*} observer
             * @param {number} minIntersectionCount
             */
            static findImages(observer, rays, images, extendedRays, minIntersectionCount) {
                const n = rays.size();
                const prevImagesCount = images.size();
                if (n < 2)
                    return;
                for (let i = 0; i < n; i++) {
                    {
                        const last_ray = rays.get(i);
                        inner: for (let j = i + 1; j < n; j++) {
                            {
                                const ray = rays.get(j);
                                if (last_ray === ray || ray.source !== last_ray.source || ray.device !== last_ray.device || ray.index !== last_ray.index || ray.waveLength !== last_ray.waveLength)
                                    continue;
                                const pt = geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(ray.p1, ray.p2, last_ray.p1, last_ray.p2);
                                if (pt != null) {
                                    if (pt.equals$math_Vector2(ray.p1) || pt.equals$math_Vector2(last_ray.p1))
                                        continue;
                                    const brightness = (ray.brightness + last_ray.brightness) / 2;
                                    const real = ray.isSnapped(pt) && last_ray.isSnapped(pt);
                                    for (let index = images.iterator(); index.hasNext();) {
                                        let img = index.next();
                                        {
                                            if (math.MathUtils.approxEqual(img, pt) && img.source === ray.source && img.device === ray.device) {
                                                img.updatePoint(brightness);
                                                continue inner;
                                            }
                                        }
                                    }
                                    const image = new geom.optics.OpticalImage(ray.device, ray.source, pt, brightness, real);
                                    images.add(image);
                                }
                            }
                            ;
                        }
                    }
                    ;
                }
                if (images.size() === 1 && (observer != null && observer instanceof geom.optics.OpticalObserver2D)) {
                    const img = images.get(0);
                    if (img.rayCount < minIntersectionCount) {
                        images.remove(0);
                    }
                }
                else if (images.size() > 1) {
                    for (let i = images.size() - 1; i >= prevImagesCount; i--) {
                        {
                            const img = images.get(i);
                            if (img.rayCount < minIntersectionCount) {
                                images.remove(i);
                            }
                        }
                        ;
                    }
                }
                images.trimToSize();
                if (extendedRays) {
                    for (let index = rays.iterator(); index.hasNext();) {
                        let ray = index.next();
                        {
                            ray.extentionPoint = null;
                            inner: for (let i = images.size() - 1; i >= prevImagesCount; i--) {
                                {
                                    const img = images.get(i);
                                    if (OpticsUtils.isExtendedRay(ray, img)) {
                                        ray.extentionPoint = img;
                                        break inner;
                                    }
                                }
                                ;
                            }
                        }
                    }
                }
            }
            /**
             * Converts wavelength to color
             * @param {number} Wavelength
             * @return
             * @return {framework.Color}
             */
            static waveLengthToColor(Wavelength) {
                let factor;
                const Gamma = 1;
                let r;
                let g;
                let b;
                if ((Wavelength >= 380) && (Wavelength < 440)) {
                    r = Math.fround(-(Math.fround(Wavelength - 440)) / (440 - 380));
                    g = 0.0;
                    b = 1.0;
                }
                else if ((Wavelength >= 440) && (Wavelength < 490)) {
                    r = 0.0;
                    g = Math.fround((Math.fround(Wavelength - 440)) / (490 - 440));
                    b = 1.0;
                }
                else if ((Wavelength >= 490) && (Wavelength < 510)) {
                    r = 0.0;
                    g = 1.0;
                    b = Math.fround(-(Math.fround(Wavelength - 510)) / (510 - 490));
                }
                else if ((Wavelength >= 510) && (Wavelength < 580)) {
                    r = Math.fround((Math.fround(Wavelength - 510)) / (580 - 510));
                    g = 1.0;
                    b = 0.0;
                }
                else if ((Wavelength >= 580) && (Wavelength < 645)) {
                    r = 1.0;
                    g = Math.fround(-(Math.fround(Wavelength - 645)) / (645 - 580));
                    b = 0.0;
                }
                else if ((Wavelength >= 645) && (Wavelength < 800)) {
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                }
                else {
                    r = 0.0;
                    g = 0.0;
                    b = 0.0;
                }
                if ((Wavelength >= 380) && (Wavelength < 420)) {
                    factor = 0.3 + 0.7 * (Math.fround(Wavelength - 380)) / (420 - 380);
                }
                else if ((Wavelength >= 420) && (Wavelength < 701)) {
                    factor = 1.0;
                }
                else if ((Wavelength >= 701) && (Wavelength < 781)) {
                    factor = 0.4 + 0.6 * (Math.fround(900 - Wavelength)) / (900 - 700);
                }
                else {
                    factor = 0.0;
                }
                r = Math.fround((r === 0.0 ? 0 : Math.pow(r * factor, Gamma)));
                g = Math.fround((g === 0.0 ? 0 : Math.pow(g * factor, Gamma)));
                b = Math.fround((b === 0.0 ? 0 : Math.pow(b * factor, Gamma)));
                const color = new framework.Color(((Math.fround(r * 255)) | 0), ((Math.fround(g * 255)) | 0), ((Math.fround(b * 255)) | 0));
                return color;
            }
        }
        optics.OpticsUtils = OpticsUtils;
        OpticsUtils["__class"] = "geom.optics.OpticsUtils";
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalDevice2D extends geom.ParentShapeArray2D {
            constructor() {
                super();
                this.rays = (new java.util.ArrayList());
                this.images = (new java.util.ArrayList());
                this.showImages = true;
                this.showImagesExpr = null;
                this.minIntersectionsNeeded = 1;
            }
            static TMP_RAY_$LI$() { if (OpticalDevice2D.TMP_RAY == null) {
                OpticalDevice2D.TMP_RAY = new geom.Ray2D();
            } return OpticalDevice2D.TMP_RAY; }
            static TMP_LINE_$LI$() { if (OpticalDevice2D.TMP_LINE == null) {
                OpticalDevice2D.TMP_LINE = new geom.Line2D();
            } return OpticalDevice2D.TMP_LINE; }
            /**
             *
             * @param {framework.Color} fillColor
             */
            setFillColor(fillColor) {
                super.setFillColor(fillColor);
            }
            /**
             *
             */
            beginObserve() {
                this.rays.clear();
                if (this.showImagesExpr != null)
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
            }
            /**
             * Find all images for the rays received by this observer
             */
            endObserve() {
                this.images.clear();
                if (this.showImages)
                    geom.optics.OpticsUtils.findImages(this, this.rays, this.images, true, this.minIntersectionsNeeded);
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} ray
             * @param {boolean} reflected
             */
            addRayToObserve(ray, reflected) {
                if (this.showImages && ray != null) {
                    ray.device = this;
                    this.rays.add(ray);
                }
            }
            /**
             *
             * @param {number} index
             * @return {geom.optics.OpticalImage}
             */
            getOpticalImageAtIndex(index) {
                if (index < 0 || index >= this.images.size())
                    return null;
                return this.images.get(index);
            }
            /**
             *
             * @param {framework.Renderer} gl
             */
            render(gl) {
                super.render(gl);
                if (!this.showImages)
                    return;
                const r = 2 * Math.sqrt(this.strokeWidth) * geom.Shape2D.SNAP_DISTANCE / 2.5;
                for (let index = this.images.iterator(); index.hasNext();) {
                    let img = index.next();
                    {
                        this.shapesManager.preferences.ImageColor.a = ((Math.fround(img.brightness * 255)) | 0);
                        gl.setColors(this.shapesManager.preferences.ImageColor, null);
                        gl.drawRect(img.x - r / 2, img.y - r / 2, r, r, true, false);
                        if (this.showEqn || this.showName) {
                            geom.Shape2D.TMP_VEC_$LI$().set$double$double(0.7 * geom.Shape2D.SNAP_DISTANCE, 0.7 * geom.Shape2D.SNAP_DISTANCE);
                            geom.Shape2D.renderInfo(gl, math.MathUtils.formatPoint(img, false), geom.Shape2D.TMP_VEC_$LI$(), geom.Shape2D.TMP_VEC_$LI$(), 1, 2, this.drawColor, null);
                        }
                    }
                }
            }
            /**
             *
             * @param {math.Vector2} pt
             * @param {java.lang.Class} shapeClass
             * @param {java.util.ArrayList} listToAppend
             */
            getCloseShapes(pt, shapeClass, listToAppend) {
                if (framework.ClassUtils.isAssignableFrom(shapeClass, geom.Point2D)) {
                    let i = 0;
                    for (let index = this.images.iterator(); index.hasNext();) {
                        let img = index.next();
                        {
                            if (img.distance$math_Vector2(pt) < geom.Shape2D.SNAP_DISTANCE) {
                                listToAppend.add(new geom.optics.OpticalImageWrapper2D(this, i));
                            }
                            i++;
                        }
                    }
                }
            }
        }
        optics.OpticalDevice2D = OpticalDevice2D;
        OpticalDevice2D["__class"] = "geom.optics.OpticalDevice2D";
        OpticalDevice2D["__interfaces"] = ["geom.optics.OpticalDevice", "geom.optics.OpticalObserver"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    class Ruler2Points2D extends geom.Segment2Points2D {
        constructor(p1, p2, alignment, divSize, numSubDivisions) {
            if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((typeof alignment === 'string') || alignment === null) && ((typeof divSize === 'string') || divSize === null) && ((typeof numSubDivisions === 'string') || numSubDivisions === null)) {
                let __args = arguments;
                super(p1, p2);
                this.bottomAlign = false;
                this.divSize = 0.5;
                this.numSubDivision = 5;
                this.params = [alignment, divSize, numSubDivisions];
                this.bottomAlign = javaemul.internal.BooleanHelper.parseBoolean(alignment);
                this.divSize = javaemul.internal.DoubleHelper.parseDouble(divSize);
                this.numSubDivision = javaemul.internal.IntegerHelper.parseInt(numSubDivisions);
                this.showEqn = true;
            }
            else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && alignment === undefined && divSize === undefined && numSubDivisions === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let alignment = "false";
                    let divSize = 0.1 + "";
                    let numSubDivisions = "5";
                    super(p1, p2);
                    this.bottomAlign = false;
                    this.divSize = 0.5;
                    this.numSubDivision = 5;
                    this.params = [alignment, divSize, numSubDivisions];
                    this.bottomAlign = javaemul.internal.BooleanHelper.parseBoolean(alignment);
                    this.divSize = javaemul.internal.DoubleHelper.parseDouble(divSize);
                    this.numSubDivision = javaemul.internal.IntegerHelper.parseInt(numSubDivisions);
                    this.showEqn = true;
                }
                this.bottomAlign = false;
                this.divSize = 0.5;
                this.numSubDivision = 5;
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0) {
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Alignment", this.bottomAlign);
            }
            else if (index === 1) {
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$double$double$double("Division Size", this.divSize, javaemul.internal.DoubleHelper.MIN_NORMAL, javaemul.internal.DoubleHelper.MAX_VALUE);
            }
            else if (index === 2) {
                geom.Shape2D.editInfo_$LI$().set$java_lang_String$int$double$double("Division Size", this.numSubDivision, 1, 100);
                geom.Shape2D.editInfo_$LI$().type = framework.EditInfo.TYPE.INTEGER;
                return geom.Shape2D.editInfo_$LI$();
            }
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            const _var = value + "";
            if (index === 0) {
                this.params[0] = _var;
                this.bottomAlign = javaemul.internal.BooleanHelper.parseBoolean(_var);
            }
            else if (index === 1) {
                this.params[1] = _var;
                this.divSize = javaemul.internal.DoubleHelper.parseDouble(this.params[1]);
            }
            else if (index === 2) {
                this.params[2] = _var;
                this.numSubDivision = javaemul.internal.IntegerHelper.parseInt(this.params[2]);
            }
            this.update();
        }
        /**
         *
         * @param {geom.ShapesManager} shapesManager
         */
        onAddShapeToSimulation(shapesManager) {
            this.divSize = 5 * shapesManager.preferences.gridSize;
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (this.__isDefined === false)
                return;
            const P = this.parents[0].pt;
            const Q = this.parents[1].pt;
            const th = geom.Shape2D.TMP_VEC_$LI$().set$math_Vector2(P).to$math_Vector2(Q).getDirection();
            const divSize = this.numSubDivision > 0 ? this.divSize / this.numSubDivision : this.divSize;
            let majorTicklength = 16 / g.METER_TO_PIXEL;
            const l = P.distance$math_Vector2(Q);
            const textHeight = 16 / g.METER_TO_PIXEL;
            g.context.save();
            g.context.translate(P.x, P.y);
            g.context.rotate(th);
            const tickCount = ((l / divSize) | 0);
            if (tickCount < 2) {
                g.context.restore();
                return;
            }
            if (this.bottomAlign)
                majorTicklength = -majorTicklength;
            const minorTickLength = majorTicklength * 0.6;
            if (this.fillColor != null || this.drawColor != null) {
                g.drawLine(0, 0, l, 0);
                g.context.beginPath();
                for (let i = 0; i <= tickCount; i++) {
                    {
                        const pos = i * divSize;
                        if (i % this.numSubDivision === 0) {
                            g.context.moveTo(pos, 0);
                            g.context.lineTo(pos, -majorTicklength);
                        }
                        else {
                            g.context.moveTo(pos, 0);
                            g.context.lineTo(pos, -minorTickLength);
                        }
                    }
                    ;
                }
                g.context.stroke();
            }
            if (this.showEqn === false) {
                g.context.restore();
                return;
            }
            const scale = ((1 / 100 | 0));
            let x = 0;
            let y;
            y = Math.fround((this.bottomAlign ? textHeight - majorTicklength : -1.5 * textHeight - majorTicklength));
            let gap = 0;
            for (let i = 0; i <= tickCount; i += this.numSubDivision) {
                {
                    const str = math.MathUtils.format(i * divSize);
                    const w = 0.12;
                    x = Math.fround((i * divSize));
                    if (gap > 2 * w) {
                        g.drawLine(x, 0, x, -majorTicklength);
                        x -= w / 2;
                        g.drawText$java_lang_String$double$double(str, x, y);
                        gap = 0;
                    }
                    gap += this.numSubDivision * divSize;
                }
                ;
            }
            g.context.restore();
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Ruler";
        }
    }
    geom.Ruler2Points2D = Ruler2Points2D;
    Ruler2Points2D["__class"] = "geom.Ruler2Points2D";
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalSource2D extends geom.Segment2Points2D {
            constructor(p1, p2, p3, numRays, waveLength, drawRays) {
                if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((p3 != null && p3 instanceof geom.Point2D) || p3 === null) && ((typeof numRays === 'string') || numRays === null) && ((typeof waveLength === 'string') || waveLength === null) && ((typeof drawRays === 'string') || drawRays === null)) {
                    let __args = arguments;
                    super(p1, p2);
                    this.rays = (new java.util.ArrayList());
                    this.drawRays = true;
                    this.parents = [p1, p2, p3];
                    this.params = [numRays, waveLength, drawRays];
                    this.setEditValue(0, numRays);
                    this.setEditValue(1, waveLength);
                    this.setEditValue(2, drawRays);
                    this.update();
                }
                else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((p3 != null && p3 instanceof geom.Point2D) || p3 === null) && numRays === undefined && waveLength === undefined && drawRays === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let numRays = "5";
                        let waveLength = "500";
                        let drawRays = "true";
                        super(p1, p2);
                        this.rays = (new java.util.ArrayList());
                        this.drawRays = true;
                        this.parents = [p1, p2, p3];
                        this.params = [numRays, waveLength, drawRays];
                        this.setEditValue(0, numRays);
                        this.setEditValue(1, waveLength);
                        this.setEditValue(2, drawRays);
                        this.update();
                    }
                    this.rays = (new java.util.ArrayList());
                    this.drawRays = true;
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0) {
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Number of Rays", this.params[0], null);
                }
                else if (index === 1) {
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$double$double$double("WaveLength (nm)", javaemul.internal.DoubleHelper.parseDouble(this.params[1]), 380, 780);
                }
                else if (index === 2) {
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Draw Rays (nm)", this.params[2], null);
                }
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                }
                else if (index === 1) {
                    this.params[2] = (value + "");
                    const l = javaemul.internal.DoubleHelper.parseDouble(this.params[2]);
                    for (let index1 = this.rays.iterator(); index1.hasNext();) {
                        let ray = index1.next();
                        {
                            ray.waveLength = l;
                        }
                    }
                }
                else if (index === 2) {
                    this.params[2] = value + "";
                    this.drawRays = math.MathUtils.evaluateBoolean(this.params[2]);
                }
            }
            /**
             * Recreate shape from its parameters, mainly intended to reparse expression and adding global vars in shapes if any
             * @param {geom.ShapesManager} manager
             */
            onAddShapeToSimulation(manager) {
                for (let index = this.rays.iterator(); index.hasNext();) {
                    let ray = index.next();
                    {
                        ray.onAddShapeToSimulation(manager);
                    }
                }
                super.onAddShapeToSimulation(manager);
            }
            update() {
                super.update();
                if (this.rays == null || !this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                    this.__isDefined = false;
                    return;
                }
                let n = this.rays.size();
                try {
                    n = (math.MathUtils.evaluateExpression(this.params[0], null, null) | 0);
                    n = math.MathUtils.clamp$int$int$int(n, 2, 100);
                    if (n !== this.rays.size()) {
                        this.rays = (new java.util.ArrayList(n));
                        for (let i = 0; i < n; i++) {
                            {
                                const ray = new geom.optics.OpticalRay2D(this);
                                ray.onAddShapeToSimulation(this.shapesManager);
                                this.rays.add(ray);
                            }
                            ;
                        }
                    }
                }
                catch (e) {
                    this.__isDefined = false;
                    return;
                }
                const p1 = this.parents[0].pt;
                const p2 = this.parents[1].pt;
                const p3 = this.parents[2].pt;
                this.set$math_Vector2$math_Vector2(p1, p2);
                const th1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const v1 = p1.to$math_Vector2(p3);
                const v2 = p1.to$math_Vector2(p2);
                let th = v2.getAngleBetween$math_Vector2(v1);
                const dTh = th / (n - 1);
                let ray;
                th = th1;
                for (let i = 0; i < n; i++) {
                    {
                        ray = this.rays.get(i);
                        ray.set$math_Vector2$math_Vector2(p1, p1.sum$math_Vector2(new math.Vector2(th)));
                        th += dTh;
                    }
                    ;
                }
                this.__isDefined = true;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Beam " + this.parents[0].getName() + " & " + this.parents[1].getName();
            }
            /**
             *
             * @param {math.Vector2} pt
             * @return {boolean}
             */
            isSnapped(pt) {
                const p = geom.CurveUtils.getPointOnSegmentClosestToPoint(pt, this.parents[0].pt, this.parents[1].pt);
                return p.distance$math_Vector2(pt) < geom.Shape2D.SNAP_DISTANCE;
            }
            /**
             *
             * @param {framework.Renderer} gl
             */
            render(gl) {
                if (this.drawRays) {
                    if (this.drawColor != null)
                        gl.setColors(this.fillColor, this.drawColor);
                    for (let index = this.rays.iterator(); index.hasNext();) {
                        let ray = index.next();
                        {
                            ray.render(gl);
                        }
                    }
                }
                const p = this.parents[0].pt;
                const r = Math.sqrt(this.strokeWidth) * geom.Shape2D.SNAP_DISTANCE / 2.5;
                gl.drawRect(p.x - r / 2, p.y - r / 2, r, r, true, true);
                if (this.showEqn || this.showName) {
                    geom.Shape2D.TMP_VEC_$LI$().set$double$double(0.7 * geom.Shape2D.SNAP_DISTANCE, 0.7 * geom.Shape2D.SNAP_DISTANCE);
                    geom.Shape2D.renderInfo(gl, this.getInfo(), geom.Shape2D.TMP_VEC_$LI$(), geom.Shape2D.TMP_VEC_$LI$(), 1, 2, this.drawColor, null);
                }
            }
            /**
             *
             */
            shootRays() {
                if (!this.visible || !this.__isDefined)
                    return;
                for (let index = this.rays.iterator(); index.hasNext();) {
                    let ray = index.next();
                    {
                        geom.optics.OpticalRay2D.processRay(ray, this.shapesManager);
                    }
                }
                this.drawRays = math.MathUtils.evaluateBoolean(this.params[2]);
            }
        }
        optics.OpticalSource2D = OpticalSource2D;
        OpticalSource2D["__class"] = "geom.optics.OpticalSource2D";
        OpticalSource2D["__interfaces"] = ["geom.optics.OpticalSource"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalBeam2D extends geom.Segment2Points2D {
            constructor(p1, p2, numRays, waveLength, drawRays) {
                if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((typeof numRays === 'string') || numRays === null) && ((typeof waveLength === 'string') || waveLength === null) && ((typeof drawRays === 'string') || drawRays === null)) {
                    let __args = arguments;
                    super(p1, p2);
                    this.rays = (new java.util.ArrayList());
                    this.drawRays = true;
                    this.params = [numRays, waveLength, drawRays];
                    this.setEditValue(0, numRays);
                    this.setEditValue(1, waveLength);
                    this.setEditValue(2, drawRays);
                }
                else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && numRays === undefined && waveLength === undefined && drawRays === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let numRays = "5";
                        let waveLength = "500";
                        let drawRays = "true";
                        super(p1, p2);
                        this.rays = (new java.util.ArrayList());
                        this.drawRays = true;
                        this.params = [numRays, waveLength, drawRays];
                        this.setEditValue(0, numRays);
                        this.setEditValue(1, waveLength);
                        this.setEditValue(2, drawRays);
                    }
                    this.rays = (new java.util.ArrayList());
                    this.drawRays = true;
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0) {
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Number of Rays", this.params[0], null);
                }
                else if (index === 1) {
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$double$double$double("WaveLength (nm)", javaemul.internal.DoubleHelper.parseDouble(this.params[1]), 380, 780);
                }
                else if (index === 2) {
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Draw Rays (nm)", this.params[2], null);
                }
                return null;
            }
            /**
             * Recreate shape from its parameters, mainly intended to reparse expression and adding global vars in shapes if any
             * @param {geom.ShapesManager} manager
             */
            onAddShapeToSimulation(manager) {
                for (let index = this.rays.iterator(); index.hasNext();) {
                    let ray = index.next();
                    {
                        ray.onAddShapeToSimulation(manager);
                    }
                }
                super.onAddShapeToSimulation(manager);
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                    this.update();
                }
                else if (index === 1) {
                    this.params[1] = (value + "");
                    const l = javaemul.internal.DoubleHelper.parseDouble(this.params[1]);
                    for (let index1 = this.rays.iterator(); index1.hasNext();) {
                        let ray = index1.next();
                        {
                            ray.waveLength = l;
                        }
                    }
                }
                else if (index === 2) {
                    this.params[2] = value + "";
                    this.drawRays = math.MathUtils.evaluateBoolean(this.params[2]);
                }
            }
            update() {
                super.update();
                if (this.rays == null || !this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                    this.__isDefined = false;
                    return;
                }
                let n = this.rays.size();
                try {
                    n = (math.MathUtils.evaluateExpression(this.params[0], null, null) | 0);
                    n = math.MathUtils.clamp$int$int$int(n, 2, 100);
                    if (n !== this.rays.size()) {
                        this.rays = (new java.util.ArrayList(n));
                        for (let i = 0; i < n; i++) {
                            {
                                const ray = new geom.optics.OpticalRay2D(this);
                                ray.onAddShapeToSimulation(this.shapesManager);
                                this.rays.add(ray);
                            }
                            ;
                        }
                    }
                }
                catch (e) {
                    this.__isDefined = false;
                    return;
                }
                const v1 = this.parents[0].pt;
                const v2 = this.parents[1].pt;
                const dir = v1.to$math_Vector2(v2).right().getNormalized();
                n = this.rays.size();
                const del = 1.0 / (n - 1);
                let ray;
                for (let i = 0; i < n; i++) {
                    {
                        ray = this.rays.get(i);
                        geom.Shape2D.TMP_VEC_$LI$().set$double$double(v1.x + i * del * (v2.x - v1.x), v1.y + i * del * (v2.y - v1.y));
                        ray.set$math_Vector2$math_Vector2(geom.Shape2D.TMP_VEC_$LI$(), geom.Shape2D.TMP_VEC_$LI$().sum$math_Vector2(dir));
                    }
                    ;
                }
                this.__isDefined = true;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Beam " + this.parents[0].getName() + " & " + this.parents[1].getName();
            }
            /**
             *
             * @param {math.Vector2} pt
             * @return {boolean}
             */
            isSnapped(pt) {
                const p = geom.CurveUtils.getPointOnSegmentClosestToPoint(pt, this.parents[0].pt, this.parents[1].pt);
                return p.distance$math_Vector2(pt) < geom.Shape2D.SNAP_DISTANCE;
            }
            /**
             *
             * @param {framework.Renderer} gl
             */
            render(gl) {
                if (this.drawRays) {
                    if (this.drawColor != null)
                        gl.setColors(null, this.drawColor);
                    for (let index = this.rays.iterator(); index.hasNext();) {
                        let ray = index.next();
                        {
                            ray.render(gl);
                        }
                    }
                }
                super.render(gl);
            }
            /**
             *
             */
            shootRays() {
                if (!this.visible || !this.__isDefined)
                    return;
                for (let index = this.rays.iterator(); index.hasNext();) {
                    let ray = index.next();
                    {
                        geom.optics.OpticalRay2D.processRay(ray, this.shapesManager);
                    }
                }
                this.drawRays = math.MathUtils.evaluateBoolean(this.params[2]);
            }
        }
        optics.OpticalBeam2D = OpticalBeam2D;
        OpticalBeam2D["__class"] = "geom.optics.OpticalBeam2D";
        OpticalBeam2D["__interfaces"] = ["geom.optics.OpticalSource"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalWhiteLight2D extends geom.Segment2Points2D {
            constructor(p1, p2, subRaysCount) {
                if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((typeof subRaysCount === 'string') || subRaysCount === null)) {
                    let __args = arguments;
                    super(p1, p2);
                    if (this.rays === undefined) {
                        this.rays = null;
                    }
                    this.raysCount = 7;
                    this.rays = (new java.util.ArrayList());
                    this.params = [subRaysCount];
                    this.raysCount = javaemul.internal.IntegerHelper.parseInt(subRaysCount);
                    this.setEditValue(0, subRaysCount);
                    this.drawColor = new framework.Color(255, 255, 255);
                    this.update();
                }
                else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && subRaysCount === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let subRaysCount = "7";
                        super(p1, p2);
                        if (this.rays === undefined) {
                            this.rays = null;
                        }
                        this.raysCount = 7;
                        this.rays = (new java.util.ArrayList());
                        this.params = [subRaysCount];
                        this.raysCount = javaemul.internal.IntegerHelper.parseInt(subRaysCount);
                        this.setEditValue(0, subRaysCount);
                        this.drawColor = new framework.Color(255, 255, 255);
                        this.update();
                    }
                    if (this.rays === undefined) {
                        this.rays = null;
                    }
                    this.raysCount = 7;
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$int$double$double("Ray Count", this.raysCount, 1, 25);
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                    this.raysCount = javaemul.internal.IntegerHelper.parseInt(this.params[0]);
                    this.rays = (new java.util.ArrayList(this.raysCount));
                    let waveLength = 500;
                    if (this.raysCount === 1) {
                        const ray = new geom.optics.OpticalRay2D(this);
                        waveLength = 500;
                        ray.waveLength = waveLength;
                        ray.setDrawColor(this.drawColor);
                        ray.source = this;
                        this.rays.add(ray);
                    }
                    else {
                        for (let i = 0; i < this.raysCount; i++) {
                            {
                                const ray = new geom.optics.OpticalRay2D(this);
                                waveLength = 380 + (400 * i / (this.raysCount - 1) | 0);
                                ray.waveLength = waveLength;
                                ray.setDrawColor(geom.optics.OpticsUtils.waveLengthToColor(Math.fround(waveLength)));
                                ray.source = this;
                                this.rays.add(ray);
                            }
                            ;
                        }
                    }
                    this.rays.trimToSize();
                    this.update();
                }
            }
            /**
             * Recreate shape from its parameters, mainly intended to reparse expression and adding global vars in shapes if any
             * @param {geom.ShapesManager} manager
             */
            onAddShapeToSimulation(manager) {
                for (let index = this.rays.iterator(); index.hasNext();) {
                    let ray = index.next();
                    {
                        ray.onAddShapeToSimulation(manager);
                    }
                }
                super.onAddShapeToSimulation(manager);
            }
            update() {
                super.update();
                if (this.__isDefined = false) {
                    return;
                }
                let ray;
                for (let i = 0; i < this.raysCount; i++) {
                    {
                        ray = this.rays.get(i);
                        ray.set$math_Vector2$math_Vector2(this.p1, this.p2);
                    }
                    ;
                }
                this.__isDefined = true;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "WhiteLight from " + this.parents[0].getName() + " to " + this.parents[1].getName();
            }
            /**
             *
             * @param {framework.Renderer} gl
             */
            render(gl) {
                if (this.raysCount === 1) {
                    if (this.drawColor != null)
                        gl.setColors(this.fillColor, this.drawColor);
                    this.rays.get(0).render(gl);
                }
                else {
                    for (let index = this.rays.iterator(); index.hasNext();) {
                        let ray = index.next();
                        {
                            gl.setColors(ray.getFillColor(), ray.getDrawColor());
                            ray.render(gl);
                        }
                    }
                }
            }
            /**
             *
             */
            shootRays() {
                if (!this.visible || !this.__isDefined)
                    return;
                for (let index = this.rays.iterator(); index.hasNext();) {
                    let ray = index.next();
                    {
                        geom.optics.OpticalRay2D.processRay(ray, this.shapesManager);
                    }
                }
            }
        }
        optics.OpticalWhiteLight2D = OpticalWhiteLight2D;
        OpticalWhiteLight2D["__class"] = "geom.optics.OpticalWhiteLight2D";
        OpticalWhiteLight2D["__interfaces"] = ["geom.optics.OpticalSource"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalRay2Points2D extends geom.Segment2Points2D {
            constructor(p1, p2, waveLength) {
                if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((typeof waveLength === 'string') || waveLength === null)) {
                    let __args = arguments;
                    super(p1, p2);
                    if (this.ray === undefined) {
                        this.ray = null;
                    }
                    this.ray = new geom.optics.OpticalRay2D(this);
                    this.ray.source = p1;
                    this.params = [waveLength];
                    this.setEditValue(0, waveLength);
                    this.update();
                }
                else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && waveLength === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let waveLength = "500";
                        super(p1, p2);
                        if (this.ray === undefined) {
                            this.ray = null;
                        }
                        this.ray = new geom.optics.OpticalRay2D(this);
                        this.ray.source = p1;
                        this.params = [waveLength];
                        this.setEditValue(0, waveLength);
                        this.update();
                    }
                    if (this.ray === undefined) {
                        this.ray = null;
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 1) {
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$double$double$double("WaveLength (nm)", javaemul.internal.DoubleHelper.parseDouble(this.params[0]), 380, 780);
                }
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                    this.ray.waveLength = javaemul.internal.DoubleHelper.parseDouble(this.params[0]);
                }
            }
            /**
             * Recreate shape from its parameters, mainly intended to reparse expression and adding global vars in shapes if any
             * @param {geom.ShapesManager} manager
             */
            onAddShapeToSimulation(manager) {
                this.ray.onAddShapeToSimulation(this.shapesManager);
                super.onAddShapeToSimulation(manager);
            }
            /**
             *
             */
            update() {
                super.update();
                if (this.__isDefined && this.ray != null) {
                    this.ray.set$math_Vector2$math_Vector2(this.p1, this.p2);
                    this.ray.clip();
                }
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Ray through " + this.parents[0].getName() + " & " + this.parents[1].getName();
            }
            /**
             *
             * @param {framework.Renderer} gl
             */
            render(gl) {
                gl.setColors(this.fillColor, this.drawColor);
                this.ray.render(gl);
            }
            /**
             *
             */
            shootRays() {
                if (!this.visible || !this.__isDefined)
                    return;
                geom.optics.OpticalRay2D.processRay(this.ray, this.shapesManager);
            }
        }
        optics.OpticalRay2Points2D = OpticalRay2Points2D;
        OpticalRay2Points2D["__class"] = "geom.optics.OpticalRay2Points2D";
        OpticalRay2Points2D["__interfaces"] = ["geom.optics.OpticalSource"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    /**
     * Create new parabola
     *
     * @param {number} xv
     * x coordinate of vertex
     * @param {number} yv
     * y coordinate of vertex
     * @param {number} a
     * focal distance (must be positive, use theta =pi to create parabola in opposite direction
     * @param {number} theta
     * angle axis makes with positive x axis
     * @class
     * @extends geom.Conic2D
     * @author mahesh kurmi
     */
    class Parabola2D extends geom.Conic2D {
        constructor(xv, yv, a, theta) {
            if (((typeof xv === 'number') || xv === null) && ((typeof yv === 'number') || yv === null) && ((typeof a === 'number') || a === null) && ((typeof theta === 'number') || theta === null)) {
                let __args = arguments;
                super();
                this.clipt0 = -10;
                this.clipt1 = 10;
                this.expr = null;
                this.tmpTransform = new math.Transform();
                this.tmpInverseTransform = new math.Transform();
                this.tmpVector = new math.Vector2();
                this.xv = 0;
                this.yv = 0;
                this.theta = 0;
                this.a = 1;
                this.debug = false;
                this.set(xv, yv, a, theta);
            }
            else if (((xv != null && xv instanceof math.Vector2) || xv === null) && ((typeof yv === 'number') || yv === null) && ((typeof a === 'number') || a === null) && theta === undefined) {
                let __args = arguments;
                let vertex = __args[0];
                let a = __args[1];
                let theta = __args[2];
                {
                    let __args = arguments;
                    let xv = vertex.x;
                    let yv = vertex.y;
                    super();
                    this.clipt0 = -10;
                    this.clipt1 = 10;
                    this.expr = null;
                    this.tmpTransform = new math.Transform();
                    this.tmpInverseTransform = new math.Transform();
                    this.tmpVector = new math.Vector2();
                    this.xv = 0;
                    this.yv = 0;
                    this.theta = 0;
                    this.a = 1;
                    this.debug = false;
                    this.set(xv, yv, a, theta);
                }
                this.clipt0 = -10;
                this.clipt1 = 10;
                this.expr = null;
                this.tmpTransform = new math.Transform();
                this.tmpInverseTransform = new math.Transform();
                this.tmpVector = new math.Vector2();
                this.xv = 0;
                this.yv = 0;
                this.theta = 0;
                this.a = 1;
                this.debug = false;
            }
            else if (xv === undefined && yv === undefined && a === undefined && theta === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let xv = 0;
                    let yv = 0;
                    let a = 1;
                    let theta = 0;
                    super();
                    this.clipt0 = -10;
                    this.clipt1 = 10;
                    this.expr = null;
                    this.tmpTransform = new math.Transform();
                    this.tmpInverseTransform = new math.Transform();
                    this.tmpVector = new math.Vector2();
                    this.xv = 0;
                    this.yv = 0;
                    this.theta = 0;
                    this.a = 1;
                    this.debug = false;
                    this.set(xv, yv, a, theta);
                }
                this.clipt0 = -10;
                this.clipt1 = 10;
                this.expr = null;
                this.tmpTransform = new math.Transform();
                this.tmpInverseTransform = new math.Transform();
                this.tmpVector = new math.Vector2();
                this.xv = 0;
                this.yv = 0;
                this.theta = 0;
                this.a = 1;
                this.debug = false;
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Sets parabola
         *
         * @param {number} xv
         * x coordinate of vertex
         * @param {number} yv
         * y coordinate of vertex
         * @param {number} a
         * focal distance (must be positive, use theta =pi to create parabola in opposite direction
         * @param {number} theta
         * angle axis makes with positive x axis
         */
        set(xv, yv, a, theta) {
            this.xv = xv;
            this.yv = yv;
            this.a = a;
            this.theta = theta;
            this.__isDefined = /* isFinite */ ((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(a) && a > 0;
            if (!this.__isDefined)
                return;
            this.tmpTransform.setToTrnRotScl$double$double$double$double$double(Math.fround(xv), Math.fround(yv), Math.fround(theta), 1, 1);
            this.tmpInverseTransform = this.tmpTransform.getInverse().copy(this.tmpInverseTransform);
            const c = this.conicCoefficients();
            this.expr = math.MathUtils.formatEqn$double_A$java_lang_String_A(c, geom.CurveUtils.conicTerms_$LI$());
            this.clip();
        }
        /**
         *
         */
        update() {
        }
        /**
         *
         * @return {geom.Conic2D.Type}
         */
        conicType() {
            return geom.Conic2D.Type.PARABOLA;
        }
        /**
         *
         * @return {double[]}
         */
        conicCoefficients() {
            const m11 = this.tmpInverseTransform.m11;
            const m12 = this.tmpInverseTransform.m12;
            const m13 = this.tmpInverseTransform.m13;
            const m21 = this.tmpInverseTransform.m21;
            const m22 = this.tmpInverseTransform.m22;
            const m23 = this.tmpInverseTransform.m23;
            const A = m21 * m21;
            const B = 2 * m21 * m22;
            const C = m22 * m22;
            const D = 2 * m21 * m23 - 4 * this.a * m11;
            const E = 2 * m22 * m23 - 4 * this.a * m12;
            const F = m23 * m23 - 4 * this.a * m13;
            return [A, B, C, D, E, F];
        }
        /**
         * Return 1, by definition for a parabola.
         * @return {number}
         */
        eccentricity() {
            return 1.0;
        }
        /**
         * center does't exist for Parabola so null is returned
         * @return {math.Vector2}
         */
        center() {
            return null;
        }
        /**
         * returns axis of the Parabola
         * @return {math.Vector2}
         */
        axis() {
            return new math.Vector2(this.theta);
        }
        /**
         * returns axis of the Parabola
         * @return {math.Vector2[]}
         */
        foci() {
            const f = new math.Vector2();
            this.tmpVector.set$double$double(Math.fround(this.a), 0);
            this.tmpTransform.transform$math_Vector2(this.tmpVector);
            return [f.set$double$double(this.tmpVector.x, this.tmpVector.y)];
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {boolean}
         */
        isInside(point) {
            const p2 = this.transformPoint(point);
            const x = p2.x;
            const y = p2.y;
            return y * y < 4 * this.a * x;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {math.Vector2}
         */
        transformPoint(point) {
            const v = this.tmpInverseTransform.transform$double$double(Math.fround(point.x), Math.fround(point.y));
            return new math.Vector2(v.x, v.y);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {math.Vector2}
         */
        inverseTransformPoint(point) {
            const v = this.tmpTransform.transform$double$double(Math.fround(point.x), Math.fround(point.y));
            return new math.Vector2(v.x, v.y);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfNormals(point) {
            let x;
            let y;
            const pt = this.transformPoint(point);
            x = pt.x;
            y = pt.y;
            const T = [0, 0, 0];
            const n = math.EquationUtils.SolveCubic$double$double$double$double$double_A(this.a, 0, 2 * this.a - x, -y, T);
            const pts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(n);
            if (n >= 1) {
                for (let i = 0; i < n; i++) {
                    {
                        pts[i] = T[i];
                    }
                    ;
                }
            }
            return pts;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfTangents(point) {
            if (this.isInside(point))
                return [];
            if (this.isSnapped(point))
                return [this.t(point)];
            let h;
            let k;
            const pt = this.transformPoint(point);
            h = pt.x;
            k = pt.y;
            const T = [0, 0];
            const n = math.EquationUtils.SolveQuadratic(this.a, -k, h, T);
            const pts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(n);
            for (let i = 0; i < n; i++) {
                {
                    pts[i] = T[i];
                }
                ;
            }
            return pts;
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelTangents(dir) {
            const v = dir.copy();
            this.tmpVector = this.tmpInverseTransform.transformDir$double$double(Math.fround(v.x), Math.fround(v.y));
            v.set$double$double(this.tmpVector.x, this.tmpVector.y);
            const theta = v.getAngleWithPositiveXAxis();
            let m = Math.tan(theta);
            let t;
            if (Math.abs(m) < geom.Shape2D.ACCURACY) {
                m = 0;
                t = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
            }
            else if (Math.abs(m) > 1 / geom.Shape2D.ACCURACY) {
                m = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                t = 0;
            }
            else {
                t = 1 / m;
            }
            return [t];
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelNormals(dir) {
            return this.getFeetOfParallelTangents(dir.right());
        }
        /**
         *
         * @param {geom.Conic2D} conic
         * @return {double[]}
         */
        getIntersections(conic) {
            const d = geom.Conics2D.transform(conic.conicCoefficients(), this.tmpTransform);
            let c4;
            let c3;
            let c2;
            let c1;
            let c0;
            c4 = d[0] * this.a * this.a;
            c3 = 2 * d[1] * this.a * this.a;
            c2 = 4 * d[2] * this.a * this.a + d[3] * this.a;
            c1 = 2 * d[4] * this.a;
            c0 = d[5];
            const T = [0, 0, 0, 0];
            const result = math.EquationUtils.SolveBiQuartic$double$double$double$double$double$double_A(c4, c3, c2, c1, c0, T);
            const pts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(result);
            if (result >= 1) {
                for (let i = 0; i < result; i++) {
                    {
                        pts[i] = T[i];
                    }
                    ;
                }
            }
            return pts;
        }
        /**
         * Returns distance of focus from vertex
         *
         * @return
         * @return {number}
         */
        focusDistance() {
            return this.a;
        }
        /**
         * Returns vertex of the parabola
         *
         * @return
         * @return {math.Vector2}
         */
        vertex() {
            return new math.Vector2(this.xv, this.yv);
        }
        /**
         * Returns the parameter of the first point of the line, which is always Double.NEGATIVE_INFINITY.
         * @return {number}
         */
        t0() {
            return javaemul.internal.DoubleHelper.NEGATIVE_INFINITY;
        }
        /**
         * Returns the parameter of the last point of the line, which is always Double.POSITIVE_INFINITY.
         * @return {number}
         */
        t1() {
            return javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
        }
        /**
         * Returns point on parabola for parametric point t
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            this.tmpVector = this.tmpTransform.transform$double$double(Math.fround((this.a * t * t)), Math.fround((2 * this.a * t)));
            return new math.Vector2(this.tmpVector.x, this.tmpVector.y);
        }
        /**
         * Returns position of point on the parabola. If point is not on the parabola returns the positions on its
         * "vertical" projection (i.e. its projection parallel to the symetry axis of the parabola).
         * @param {math.Vector2} point
         * @return {number}
         */
        t(point) {
            let x;
            let y;
            const pt = this.transformPoint(point);
            x = pt.x;
            y = pt.y;
            const T = [0, 0, 0];
            const n = math.EquationUtils.SolveCubic$double$double$double$double$double_A(this.a, 0, 2 * this.a - x, -y, T);
            if (n > 0) {
                let closest_t;
                let t = T[0];
                let dist = (x - this.a * t * t) * (x - this.a * t * t) + (y - 2 * this.a * t) * (y - 2 * this.a * t);
                closest_t = t;
                for (let i = 1; i < n; i++) {
                    {
                        t = T[i];
                        const newDist = (x - this.a * t * t) * (x - this.a * t * t) + (y - 2 * this.a * t) * (y - 2 * this.a * t);
                        if (dist > newDist) {
                            dist = newDist;
                            closest_t = t;
                        }
                    }
                    ;
                }
                return closest_t;
            }
            else
                return javaemul.internal.DoubleHelper.NaN;
        }
        /**
         * Returns the unit Vector along tangent to curve
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            return new math.Vector2(t, 1).rotate$double(this.theta).getNormalized();
        }
        /**
         * returns the slope of the curve
         *
         * @param {number} t
         * @return {number} {Number}
         */
        derivative(t) {
            return Math.tan(new math.Vector2(t, 1).rotate$double(this.theta).getAngleWithPositiveXAxis());
        }
        /**
         * Returns double derivative on the curve at point specified by parameter t
         *
         * @param {number} t
         * @return {number} {Number}
         */
        doubleDerivative(t) {
            return -1 / (2 * this.a * t * t * t);
        }
        /**
         * Returns the curvature of the parabola at the given position.
         * @param {number} t
         * @return {number}
         */
        curvature(t) {
            return -1 / (2 * this.a * Math.pow(math.MathUtils.hypot(1, t), 3));
        }
        intersections(line) {
            const line2 = line.transform(this.tmpInverseTransform);
            const dx = line2.dx;
            const dy = line2.dy;
            const points = (new java.util.ArrayList(2));
            if (Math.abs(dy) < geom.Shape2D.ACCURACY) {
                if (this.debug)
                    console.info("intersect parabola with horizontal line ");
                const t = line2.y0 / (2 * this.a);
                const point = this.point(t);
                if (line.isSnapped(point))
                    points.add(t);
            }
            else if (Math.abs(dx) < geom.Shape2D.ACCURACY) {
                if (this.debug)
                    console.info("intersect parabola with vertical line ");
                const t2 = line2.x0 / (this.a);
                if (t2 > 0) {
                    let t = Math.sqrt(t2);
                    let point = this.point(t);
                    if (line.isSnapped(point))
                        points.add(t);
                    t = -Math.sqrt(t2);
                    point = this.point(t);
                    if (line.isSnapped(point))
                        points.add(t);
                }
            }
            else {
                const m = dy / dx;
                const c = line2.y0 - m * line2.x0;
                const delta = (4 * this.a / m) * (4 * this.a / m) - 4 * ((4 * this.a * c / m));
                if (delta > 0) {
                    let y = 2 * this.a / m + Math.sqrt(delta) * 0.5;
                    let t = y / (2 * this.a);
                    let point = this.point(t);
                    if (line.isSnapped(point)) {
                        points.add(t);
                    }
                    y = 2 * this.a / m - Math.sqrt(delta) * 0.5;
                    t = y / (2 * this.a);
                    point = this.point(t);
                    if (line.isSnapped(point)) {
                        points.add(t);
                    }
                }
            }
            const ts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(points.size());
            let i = 0;
            for (let index = points.iterator(); index.hasNext();) {
                let t = index.next();
                ts[i++] = t;
            }
            return ts;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {number}
         */
        distance(point) {
            const p = this.project(point);
            return point.distance$math_Vector2(p);
        }
        /**
         * Clip the parabola by a box. The result is an instance of CurveSet2D<ParabolaArc2D>, which contains only instances
         * of ParabolaArc2D. If the parabola is not clipped, the result is an instance of CurveSet2D<ParabolaArc2D> which
         * contains 0 curves.
         */
        clip() {
            if (!this.visible)
                return;
            if (this.shapesManager == null)
                return;
            const A = new math.Vector2();
            const C = new math.Vector2();
            const b = this.shapesManager.getWorldBounds();
            const xmin = b[0];
            const ymin = b[1];
            const xmax = b[2];
            const ymax = b[3];
            const pts = (new java.util.ArrayList());
            const line = geom.Conic2D.TMP_SEGMENT_$LI$();
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmin, ymin), C.set$double$double(xmin, ymax));
            let intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmin, ymax), C.set$double$double(xmax, ymax));
            intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmax, ymax), C.set$double$double(xmax, ymin));
            intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmax, ymin), C.set$double$double(xmin, ymin));
            intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            if (pts.size() > 1) {
                java.util.Collections.sort(pts);
                this.clipt0 = pts.get(0);
                this.clipt1 = pts.get(pts.size() - 1);
            }
        }
        isSnapped(point) {
            const p2 = this.transformPoint(point);
            const xp = p2.x;
            const yp = p2.y;
            if (Math.abs(yp * yp - 4 * this.a * xp) < 2 * geom.Shape2D.SNAP_DISTANCE) {
                return true;
            }
            return false;
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return this.expr;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Parabola [ a = " + math.MathUtils.formatValue(this.a, false) + ", " + math.Unicode.Theta + " = " + math.MathUtils.formatValue(this.theta, true) + "]";
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.isDefined())
                return;
            let v;
            g.context.beginPath();
            let t = this.clipt0;
            v = this.point(t);
            g.context.moveTo(v.x, v.y);
            const dt = (this.clipt1 - this.clipt0) / 200;
            while ((t < this.clipt1)) {
                {
                    t += dt;
                    v = this.point(t);
                    if (v == null)
                        break;
                    g.context.lineTo(v.x, v.y);
                }
            }
            ;
            g.context.stroke();
            if (this.showEqn) {
                this.renderInfo(g, this.vertex(), this.foci()[0]);
            }
        }
    }
    geom.Parabola2D = Parabola2D;
    Parabola2D["__class"] = "geom.Parabola2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Define center by coordinate, major and minor semi axis lengths, and orientation angle.
     * @param {number} xc
     * @param {number} yc
     * @param {number} r1
     * @param {number} r2
     * @param {number} theta
     * @class
     * @extends geom.Conic2D
     */
    class Hyperbola2D extends geom.Conic2D {
        constructor(xc, yc, r1, r2, theta) {
            if (((typeof xc === 'number') || xc === null) && ((typeof yc === 'number') || yc === null) && ((typeof r1 === 'number') || r1 === null) && ((typeof r2 === 'number') || r2 === null) && ((typeof theta === 'number') || theta === null)) {
                let __args = arguments;
                super();
                if (this.xc === undefined) {
                    this.xc = 0;
                }
                if (this.yc === undefined) {
                    this.yc = 0;
                }
                if (this.r1 === undefined) {
                    this.r1 = 0;
                }
                if (this.r2 === undefined) {
                    this.r2 = 0;
                }
                this.tmpTransform = new math.Transform();
                this.tmpInverseTransform = new math.Transform();
                this.tmpVector = new math.Vector2();
                this.expr = null;
                this.theta = 0;
                this.clipt0 = -0.5;
                this.clipt1 = 0.5;
                this.clipt2 = -2;
                this.clipt3 = 2;
                this.set$double$double$double$double$double(xc, yc, r1, r2, theta);
            }
            else if (((typeof xc === 'number') || xc === null) && ((typeof yc === 'number') || yc === null) && ((typeof r1 === 'number') || r1 === null) && ((typeof r2 === 'number') || r2 === null) && theta === undefined) {
                let __args = arguments;
                let l1 = __args[2];
                let l2 = __args[3];
                {
                    let __args = arguments;
                    let r1 = l1;
                    let r2 = l2;
                    let theta = 0;
                    super();
                    if (this.xc === undefined) {
                        this.xc = 0;
                    }
                    if (this.yc === undefined) {
                        this.yc = 0;
                    }
                    if (this.r1 === undefined) {
                        this.r1 = 0;
                    }
                    if (this.r2 === undefined) {
                        this.r2 = 0;
                    }
                    this.tmpTransform = new math.Transform();
                    this.tmpInverseTransform = new math.Transform();
                    this.tmpVector = new math.Vector2();
                    this.expr = null;
                    this.theta = 0;
                    this.clipt0 = -0.5;
                    this.clipt1 = 0.5;
                    this.clipt2 = -2;
                    this.clipt3 = 2;
                    this.set$double$double$double$double$double(xc, yc, r1, r2, theta);
                }
                if (this.xc === undefined) {
                    this.xc = 0;
                }
                if (this.yc === undefined) {
                    this.yc = 0;
                }
                if (this.r1 === undefined) {
                    this.r1 = 0;
                }
                if (this.r2 === undefined) {
                    this.r2 = 0;
                }
                this.tmpTransform = new math.Transform();
                this.tmpInverseTransform = new math.Transform();
                this.tmpVector = new math.Vector2();
                this.expr = null;
                this.theta = 0;
                this.clipt0 = -0.5;
                this.clipt1 = 0.5;
                this.clipt2 = -2;
                this.clipt3 = 2;
            }
            else if (xc === undefined && yc === undefined && r1 === undefined && r2 === undefined && theta === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let xc = 0;
                    let yc = 0;
                    let r1 = 1;
                    let r2 = 1;
                    let theta = 0;
                    super();
                    if (this.xc === undefined) {
                        this.xc = 0;
                    }
                    if (this.yc === undefined) {
                        this.yc = 0;
                    }
                    if (this.r1 === undefined) {
                        this.r1 = 0;
                    }
                    if (this.r2 === undefined) {
                        this.r2 = 0;
                    }
                    this.tmpTransform = new math.Transform();
                    this.tmpInverseTransform = new math.Transform();
                    this.tmpVector = new math.Vector2();
                    this.expr = null;
                    this.theta = 0;
                    this.clipt0 = -0.5;
                    this.clipt1 = 0.5;
                    this.clipt2 = -2;
                    this.clipt3 = 2;
                    this.set$double$double$double$double$double(xc, yc, r1, r2, theta);
                }
                if (this.xc === undefined) {
                    this.xc = 0;
                }
                if (this.yc === undefined) {
                    this.yc = 0;
                }
                if (this.r1 === undefined) {
                    this.r1 = 0;
                }
                if (this.r2 === undefined) {
                    this.r2 = 0;
                }
                this.tmpTransform = new math.Transform();
                this.tmpInverseTransform = new math.Transform();
                this.tmpVector = new math.Vector2();
                this.expr = null;
                this.theta = 0;
                this.clipt0 = -0.5;
                this.clipt1 = 0.5;
                this.clipt2 = -2;
                this.clipt3 = 2;
            }
            else
                throw new Error('invalid overload');
        }
        set$math_Vector2$math_Vector2$double(focus1, focus2, chord) {
            const x1 = focus1.x;
            const y1 = focus1.y;
            const x2 = focus2.x;
            const y2 = focus2.y;
            const dist = focus1.distance$math_Vector2(focus2);
            this.set$double$double$double$double$double((x1 + x2) / 2, (y1 + y2) / 2, chord / 2, Math.sqrt(chord * chord - dist * dist) / 2, geom.AngleUtils.horizontalAngle$double$double$double$double(x1, y1, x2, y2));
        }
        set$double$double$double$double$double(xc, yc, l1, l2, theta) {
            this.xc = xc;
            this.yc = yc;
            this.r1 = l1;
            this.r2 = l2;
            this.theta = theta;
            this.__isDefined = /* isFinite */ ((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(l1) && l1 >= 0 && /* isFinite */ ((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(l2) && l2 >= 0;
            if (!this.__isDefined)
                return;
            this.tmpTransform.setToTrnRotScl$double$double$double$double$double(Math.fround(xc), Math.fround(yc), Math.fround(theta), 1, 1);
            this.tmpInverseTransform = this.tmpTransform.getInverse().copy(this.tmpInverseTransform);
            const c = this.conicCoefficients();
            this.expr = math.MathUtils.formatEqn$double_A$java_lang_String_A(c, geom.CurveUtils.conicTerms_$LI$());
            this.clip();
        }
        set(xc, yc, l1, l2, theta) {
            if (((typeof xc === 'number') || xc === null) && ((typeof yc === 'number') || yc === null) && ((typeof l1 === 'number') || l1 === null) && ((typeof l2 === 'number') || l2 === null) && ((typeof theta === 'number') || theta === null)) {
                return this.set$double$double$double$double$double(xc, yc, l1, l2, theta);
            }
            else if (((xc != null && xc instanceof math.Vector2) || xc === null) && ((yc != null && yc instanceof math.Vector2) || yc === null) && ((typeof l1 === 'number') || l1 === null) && l2 === undefined && theta === undefined) {
                return this.set$math_Vector2$math_Vector2$double(xc, yc, l1);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         */
        update() {
        }
        /**
         * Clip the parabola by a box. The result is an instance of CurveSet2D<ParabolaArc2D>,
         * which contains only instances of ParabolaArc2D. If the parabola is not
         * clipped, the result is an instance of CurveSet2D<ParabolaArc2D> which
         * contains 0 curves.
         */
        clip() {
            if (!this.visible)
                return;
            if (this.shapesManager == null)
                return;
            const A = new math.Vector2();
            const C = new math.Vector2();
            const b = this.shapesManager.getWorldBounds();
            const xmin = b[0];
            const ymin = b[1];
            const xmax = b[2];
            const ymax = b[3];
            const pts = (new java.util.ArrayList());
            const line = geom.Conic2D.TMP_SEGMENT_$LI$();
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmin, ymin), C.set$double$double(xmin, ymax));
            let intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmin, ymax), C.set$double$double(xmax, ymax));
            intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmax, ymax), C.set$double$double(xmax, ymin));
            intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmax, ymin), C.set$double$double(xmin, ymin));
            intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            const posBranch = (new java.util.ArrayList());
            const negBranch = (new java.util.ArrayList());
            for (let index = pts.iterator(); index.hasNext();) {
                let t = index.next();
                {
                    if (Math.abs(t) < 1)
                        posBranch.add(t);
                    else
                        negBranch.add(1 / t);
                }
            }
            java.util.Collections.sort(posBranch);
            java.util.Collections.sort(negBranch);
            if (posBranch.size() > 1) {
                this.clipt0 = posBranch.get(0);
                this.clipt1 = posBranch.get(posBranch.size() - 1);
            }
            else {
                this.clipt0 = 0;
                this.clipt1 = 0;
            }
            if (negBranch.size() > 1) {
                this.clipt2 = negBranch.get(0);
                this.clipt3 = negBranch.get(negBranch.size() - 1);
            }
            else {
                this.clipt2 = 1;
                this.clipt3 = 1;
            }
        }
        conicType() {
            return geom.Conic2D.Type.HYPERBOLA;
        }
        /**
         * Returns the conic coefficients of the ellipse. Algorithm taken from
         * http://tog.acm.org/GraphicsGems/gemsv/ch2-6/conmat.c
         * @return {double[]}
         */
        conicCoefficients() {
            const aSq = this.r1 * this.r1;
            const bSq = this.r2 * this.r2;
            const aSqInv = 1.0 / aSq;
            const bSqInv = 1.0 / bSq;
            const sint = Math.sin(this.theta);
            const cost = Math.cos(this.theta);
            const sin2t = 2.0 * sint * cost;
            const sintSq = sint * sint;
            const costSq = cost * cost;
            const xcSq = this.xc * this.xc;
            const ycSq = this.yc * this.yc;
            const a = costSq / aSq - sintSq / bSq;
            const b = (bSq + aSq) * sin2t / (aSq * bSq);
            const c = sintSq / aSq - costSq / bSq;
            const d = -this.yc * b - 2 * this.xc * a;
            const e = -this.xc * b - 2 * this.yc * c;
            const f = -1.0 + (xcSq + ycSq) * (aSqInv - bSqInv) / 2.0 + (costSq - sintSq) * (xcSq - ycSq) * (aSqInv + bSqInv) / 2.0 + this.xc * this.yc * (aSqInv + bSqInv) * sin2t;
            return [-a, -b, -c, -d, -e, -f];
        }
        /**
         * Computes eccentricity of ellipse, depending on the lengths of the semi-axes. Eccentricity is 0 for a circle
         * (r1==r2), and tends to 1 when ellipse elongates.
         * @return {number}
         */
        eccentricity() {
            return math.MathUtils.hypot(1, this.r2 * this.r2 / this.r1 / this.r1);
        }
        /**
         * Returns center of the ellipse.
         * @return {math.Vector2}
         */
        center() {
            return new math.Vector2(this.xc, this.yc);
        }
        /**
         * Return the first focus. It is defined as the first focus on the Major axis, in the direction given by angle
         * theta.
         * @return {math.Vector2[]}
         */
        foci() {
            const c = math.MathUtils.hypot(this.r1, this.r2);
            return [new math.Vector2(this.xc + c * Math.cos(this.theta), this.yc + c * Math.sin(this.theta)), new math.Vector2(this.xc - c * Math.cos(this.theta), this.yc - c * Math.sin(this.theta))];
        }
        /**
         * Returns the first direction vector of the ellipse, in the direction of the major axis.
         * @return {math.Vector2}
         */
        axis() {
            return new math.Vector2(this.theta);
        }
        /**
         * Test whether the point is inside the ellipse. The test is performed by rotating the ellipse and the point to
         * align with axis, rescaling in each direction, then computing distance to origin.
         * @param {math.Vector2} point
         * @return {boolean}
         */
        isInside(point) {
            const pt = this.transformPoint(point);
            const xp = pt.x / this.r1;
            const yp = pt.y / this.r2;
            return (xp * xp - yp * yp > 1);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfNormals(point) {
            const p = this.transformPoint(point);
            const a = this.r1;
            const b = this.r2;
            const x = p.x;
            const y = p.y;
            const c4 = -b * y;
            const c3 = -2 * a * (x + a) - 2 * b * b;
            const c2 = 0;
            const c1 = -2 * b * b + 2 * a * (x - a);
            const c0 = b * y;
            const T = [0, 0, 0, 0];
            math.EquationUtils.allowInfinityAsRoot = true;
            const result = math.EquationUtils.SolveBiQuartic$double$double$double$double$double$double_A(c4, c3, c2, c1, c0, T);
            math.EquationUtils.allowInfinityAsRoot = false;
            const pts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(result);
            if (result >= 1) {
                for (let i = 0; i < result; i++) {
                    {
                        pts[i] = this.getTheta_from_t(T[i]);
                    }
                    ;
                }
            }
            return pts;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfTangents(point) {
            if (this.isInside(point))
                return [];
            if (this.isSnapped(point))
                return [this.t(point)];
            const p = this.transformPoint(point);
            const a = this.r1;
            const b = this.r2;
            const x = p.x;
            const y = p.y;
            const c2 = a * b + b * x;
            const c1 = -2 * a * y;
            const c0 = b * x - a * b;
            if (c2 === 0) {
                return [Math.PI, this.getTheta_from_t(-c0 / c1)];
            }
            else {
                const T = [0, 0];
                math.EquationUtils.allowInfinityAsRoot = true;
                const n = math.EquationUtils.SolveQuadratic(c2, c1, c0, T);
                math.EquationUtils.allowInfinityAsRoot = false;
                const pts = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(n);
                for (let i = 0; i < n; i++) {
                    {
                        pts[i] = this.getTheta_from_t(T[i]);
                    }
                    ;
                }
                return pts;
            }
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelTangents(dir) {
            const v = dir.rotate$double(-this.theta);
            const theta = v.getDirection();
            let m = Math.tan(theta);
            let th;
            if (Math.abs(m) < this.r2 / this.r1) {
                return [];
            }
            else if (Math.abs(m) > 1 / geom.Shape2D.ACCURACY) {
                m = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                th = 0;
            }
            else {
                th = Math.asin(this.r2 / (this.r1 * m));
            }
            return [th, Math.PI - th];
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelNormals(dir) {
            return this.getFeetOfParallelTangents(dir.right());
        }
        /**
         *
         * @param {geom.Conic2D} conic
         * @return {double[]}
         */
        getIntersections(conic) {
            const coeff = geom.Conics2D.transform(conic.conicCoefficients(), this.tmpTransform);
            let a;
            let b;
            let c;
            let d;
            let e;
            let f;
            a = coeff[0];
            b = coeff[1];
            c = coeff[2];
            d = coeff[3];
            e = coeff[4];
            f = coeff[5];
            let c4;
            let c3;
            let c2;
            let c1;
            let c0;
            c4 = a * this.r1 * this.r1 - d * this.r1 + f;
            c3 = 2 * b * this.r1 * this.r2 - 2 * e * this.r2;
            c2 = 2 * a * this.r1 * this.r1 + 4 * c * this.r2 * this.r2 - 2 * f;
            c1 = 2 * b * this.r1 * this.r2 + 2 * e * this.r2;
            c0 = a * this.r1 * this.r1 + d * this.r1 + f;
            const T = [0, 0, 0, 0];
            const result = math.EquationUtils.SolveBiQuartic$double$double$double$double$double$double_A(c4, c3, c2, c1, c0, T);
            const pts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(result);
            if (result >= 1) {
                for (let i = 0; i < result; i++) {
                    {
                        pts[i] = this.getTheta_from_t(T[i]);
                    }
                    ;
                }
            }
            return pts;
        }
        /**
         * Compute intersections of the ellipse with a straight object (line, line segment, ray...).
         * <p>
         * Principle of the algorithm is to transform line and ellipse such that ellipse becomes a circle, then using the
         * intersections computation from circle.
         * @param {geom.Line2D} line
         * @return {double[]}
         */
        intersections(line) {
            const line2 = line.transform(this.tmpInverseTransform);
            const coeff = line2.coeff();
            const c = [0, 0, 0];
            c[0] = coeff[0] * this.r1 + coeff[2];
            c[1] = 2 * this.r2 * coeff[1];
            c[2] = coeff[0] * this.r1 - coeff[2];
            const result = [0, 0];
            math.EquationUtils.allowInfinityAsRoot = true;
            const n = math.EquationUtils.SolveQuadric$double_A$double_A(c, result);
            const points = (new java.util.ArrayList(2));
            let th = 0;
            for (let i = 0; i < n; i++) {
                {
                    th = this.getTheta_from_t(result[i]);
                    const point = this.point(th);
                    if (line.isSnapped(point))
                        points.add(result[i]);
                }
                ;
            }
            const ts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(points.size());
            let i = 0;
            for (let index = points.iterator(); index.hasNext();) {
                let t = index.next();
                ts[i++] = t;
            }
            return ts;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {math.Vector2}
         */
        transformPoint(point) {
            const v = this.tmpInverseTransform.transform$double$double(Math.fround(point.x), Math.fround(point.y));
            return new math.Vector2(v.x, v.y);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {math.Vector2}
         */
        inverseTransformPoint(point) {
            const v = this.tmpTransform.transform$double$double(Math.fround(point.x), Math.fround(point.y));
            return new math.Vector2(v.x, v.y);
        }
        /**
         * Returns the length of the major semi-axis of the ellipse.
         * @return {number}
         */
        semiTransverseAxisLength() {
            return this.r1;
        }
        /**
         * Returns the length of the minor semi-axis of the ellipse.
         * @return {number}
         */
        semiConjugateAxisLength() {
            return this.r2;
        }
        /**
         * returns algebric parameter t for the point represented by eccentric angle
         *
         * @param {number} theta
         * parameter theta as eccentric angle of ellipse
         * @return {number} t algebric parametric point on hyperbola ( a(1+t*t)/(1-t*t), b(2*t)/(1-t*t) )
         * @private
         */
        /*private*/ gett_from_Theta(theta) {
            return Math.tan(theta / 2);
        }
        /**
         * returns  eccentric angle parameter coorresponding to t on hyperbola
         * @param {number} t algebric parametric point on hyperbola ( a(1+t*t)/(1-t*t), b(2*t)/(1-t*t) )
         * @return {number} theta in [0 to 2*PI]
         */
        getTheta_from_t(t) {
            if ( /* isInfinite */((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(t))
                return Math.PI;
            t = 2 * Math.atan(t);
            return geom.AngleUtils.formatAngle(t);
        }
        /**
         * Returns the parameter of the first point of the ellipse, set to 0.
         * @return {number}
         */
        t0() {
            return 0;
        }
        /**
         * Returns the parameter of the last point of the ellipse, set to 2*PI.
         * @return {number}
         */
        t1() {
            return 2 * Math.PI;
        }
        /**
         * Returns the first point of the ellipse, which is the same as the last point.
         *
         * @return {math.Vector2} the first point of the ellipse
         */
        firstPoint() {
            return new math.Vector2(this.xc + this.r1 * Math.cos(this.theta), this.yc + this.r1 * Math.sin(this.theta));
        }
        /**
         * Returns the last point of the ellipse, which is the same as the first point.
         *
         * @return {math.Vector2} the last point of the ellipse.
         */
        lastPoint() {
            return new math.Vector2(this.xc + this.r1 * Math.cos(this.theta), this.yc + this.r1 * Math.sin(this.theta));
        }
        /**
         * get the position of the curve from internal parametric representation, depending on the parameter t. This
         * parameter is between the two limits 0 and 2*PI.
         * @param {number} theta
         * @return {math.Vector2}
         */
        point(theta) {
            return this.inverseTransformPoint(geom.Shape2D.TMP_VEC_$LI$().set$double$double(this.r1 / Math.cos(theta), this.r2 * Math.tan(theta)));
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {number}
         */
        t(point) {
            const p = this.transformPoint(point);
            const a = this.r1;
            const b = this.r2;
            const x = p.x;
            const y = p.y;
            const c4 = -b * y;
            const c3 = -2 * a * (x + a) - 2 * b * b;
            const c2 = 0;
            const c1 = -2 * b * b + 2 * a * (x - a);
            const c0 = b * y;
            const T = [0, 0, 0, 0];
            math.EquationUtils.allowInfinityAsRoot = true;
            const result = math.EquationUtils.SolveBiQuartic$double$double$double$double$double$double_A(c4, c3, c2, c1, c0, T);
            math.EquationUtils.allowInfinityAsRoot = false;
            if (result >= 1) {
                let t = this.getTheta_from_t(T[0]);
                let closest_t = t;
                let dist = point.distanceSquared$math_Vector2(this.point(t));
                for (let i = 1; i < result; i++) {
                    {
                        t = this.getTheta_from_t(T[i]);
                        const newDist = point.distanceSquared$math_Vector2(this.point(t));
                        if (dist > newDist) {
                            dist = newDist;
                            closest_t = t;
                        }
                    }
                    ;
                }
                return closest_t;
            }
            else
                return javaemul.internal.DoubleHelper.NaN;
        }
        /**
         *
         * @param {number} theta
         * @return {math.Vector2}
         */
        tangent(theta) {
            const m = Math.tan(theta);
            let v;
            if (m === 0)
                v = new math.Vector2(0, 1);
            else if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(m))
                v = new math.Vector2(1, /* signum */ (f => { if (f > 0) {
                    return 1;
                }
                else if (f < 0) {
                    return -1;
                }
                else {
                    return 0;
                } })(m) * Math.atan(this.r2 / this.r1));
            else
                v = math.Vector2.create(1, Math.atan(this.r2 / Math.sin(theta) / this.r1));
            return v.rotate$double(this.theta);
        }
        /**
         * Returns the curvature of the ellipse.
         * @param {number} theta
         * @return {number}
         */
        curvature(theta) {
            let cot;
            let sit;
            const t = this.gett_from_Theta(theta);
            if ( /* isInfinite */((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(t)) {
                cot = -1;
                sit = 0;
            }
            else {
                cot = (1 + t * t) / (1 - t * t);
                sit = 2 * t / (1 - t * t);
            }
            const k = -(f => { if (f > 0) {
                return 1;
            }
            else if (f < 0) {
                return -1;
            }
            else {
                return 0;
            } })(sit) * this.r1 * this.r2 / Math.pow(math.MathUtils.hypot(this.r2 * cot, this.r1 * sit), 3);
            return k;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            return this.project(pt).distance$math_Vector2(pt);
        }
        /**
         *
         * @return {string}
         */
        toString() {
            return javaemul.internal.StringHelper.format("Hyperbola2D(%f,%f,%f,%f,%f)", this.xc, this.yc, this.r1, this.r2, this.theta);
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return this.expr;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Hyperbola [ a = " + math.MathUtils.formatValue(this.r1, false) + ",  b = " + math.MathUtils.formatValue(this.r2, false) + ", " + math.Unicode.Theta + " = " + math.MathUtils.formatValue(this.theta, true) + "]";
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            const p = this.project(pt);
            if (p == null)
                return false;
            return (p.distance$math_Vector2(pt)) < geom.Shape2D.SNAP_DISTANCE;
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.__isDefined)
                return;
            let v;
            if (this.drawColor != null) {
                if (this.clipt0 < this.clipt1) {
                    g.context.beginPath();
                    const dt = (this.clipt1 - this.clipt0) / 200;
                    let t = this.clipt0;
                    v = this.point(this.getTheta_from_t(t));
                    g.context.moveTo(v.x, v.y);
                    while ((t < this.clipt1)) {
                        {
                            t += dt;
                            v = this.point(this.getTheta_from_t(t));
                            g.context.lineTo(v.x, v.y);
                        }
                    }
                    ;
                    g.context.stroke();
                }
                if (this.clipt2 < this.clipt3) {
                    g.context.beginPath();
                    const dt = (this.clipt3 - this.clipt2) / 200;
                    let t = this.clipt2;
                    v = this.point(this.getTheta_from_t(1 / t));
                    g.context.moveTo(v.x, v.y);
                    while ((t < this.clipt3)) {
                        {
                            t += dt;
                            v = this.point(this.getTheta_from_t(1 / t));
                            g.context.lineTo(v.x, v.y);
                        }
                    }
                    ;
                    g.context.stroke();
                }
            }
            if (this.showEqn || this.showName) {
                geom.Shape2D.renderInfo(g, this.getInfo(), this.point(0), this.point(Math.PI), 1, 0, this.drawColor, null);
            }
        }
    }
    geom.Hyperbola2D = Hyperbola2D;
    Hyperbola2D["__class"] = "geom.Hyperbola2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Define center by coordinate, major and minor semi axis lengths, and orientation angle.
     * @param {number} xc
     * @param {number} yc
     * @param {number} r1
     * @param {number} r2
     * @param {number} theta
     * @class
     * @extends geom.Conic2D
     */
    class Ellipse2D extends geom.Conic2D {
        constructor(xc, yc, r1, r2, theta) {
            if (((typeof xc === 'number') || xc === null) && ((typeof yc === 'number') || yc === null) && ((typeof r1 === 'number') || r1 === null) && ((typeof r2 === 'number') || r2 === null) && ((typeof theta === 'number') || theta === null)) {
                let __args = arguments;
                super();
                if (this.xc === undefined) {
                    this.xc = 0;
                }
                if (this.yc === undefined) {
                    this.yc = 0;
                }
                if (this.r1 === undefined) {
                    this.r1 = 0;
                }
                if (this.r2 === undefined) {
                    this.r2 = 0;
                }
                this.clipt0 = 0;
                this.clipt1 = 2 * Math.PI;
                this.tmpTransform = new math.Transform();
                this.tmpInverseTransform = new math.Transform();
                this.tmpVector = new math.Vector2();
                this.expr = null;
                this.theta = 0;
                this.set$double$double$double$double$double(xc, yc, r1, r2, theta);
            }
            else if (((typeof xc === 'number') || xc === null) && ((typeof yc === 'number') || yc === null) && ((typeof r1 === 'number') || r1 === null) && ((typeof r2 === 'number') || r2 === null) && theta === undefined) {
                let __args = arguments;
                let l1 = __args[2];
                let l2 = __args[3];
                {
                    let __args = arguments;
                    let r1 = l1;
                    let r2 = l2;
                    let theta = 0;
                    super();
                    if (this.xc === undefined) {
                        this.xc = 0;
                    }
                    if (this.yc === undefined) {
                        this.yc = 0;
                    }
                    if (this.r1 === undefined) {
                        this.r1 = 0;
                    }
                    if (this.r2 === undefined) {
                        this.r2 = 0;
                    }
                    this.clipt0 = 0;
                    this.clipt1 = 2 * Math.PI;
                    this.tmpTransform = new math.Transform();
                    this.tmpInverseTransform = new math.Transform();
                    this.tmpVector = new math.Vector2();
                    this.expr = null;
                    this.theta = 0;
                    this.set$double$double$double$double$double(xc, yc, r1, r2, theta);
                }
                if (this.xc === undefined) {
                    this.xc = 0;
                }
                if (this.yc === undefined) {
                    this.yc = 0;
                }
                if (this.r1 === undefined) {
                    this.r1 = 0;
                }
                if (this.r2 === undefined) {
                    this.r2 = 0;
                }
                this.clipt0 = 0;
                this.clipt1 = 2 * Math.PI;
                this.tmpTransform = new math.Transform();
                this.tmpInverseTransform = new math.Transform();
                this.tmpVector = new math.Vector2();
                this.expr = null;
                this.theta = 0;
            }
            else if (xc === undefined && yc === undefined && r1 === undefined && r2 === undefined && theta === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let xc = 0;
                    let yc = 0;
                    let r1 = 1;
                    let r2 = 1;
                    let theta = 0;
                    super();
                    if (this.xc === undefined) {
                        this.xc = 0;
                    }
                    if (this.yc === undefined) {
                        this.yc = 0;
                    }
                    if (this.r1 === undefined) {
                        this.r1 = 0;
                    }
                    if (this.r2 === undefined) {
                        this.r2 = 0;
                    }
                    this.clipt0 = 0;
                    this.clipt1 = 2 * Math.PI;
                    this.tmpTransform = new math.Transform();
                    this.tmpInverseTransform = new math.Transform();
                    this.tmpVector = new math.Vector2();
                    this.expr = null;
                    this.theta = 0;
                    this.set$double$double$double$double$double(xc, yc, r1, r2, theta);
                }
                if (this.xc === undefined) {
                    this.xc = 0;
                }
                if (this.yc === undefined) {
                    this.yc = 0;
                }
                if (this.r1 === undefined) {
                    this.r1 = 0;
                }
                if (this.r2 === undefined) {
                    this.r2 = 0;
                }
                this.clipt0 = 0;
                this.clipt1 = 2 * Math.PI;
                this.tmpTransform = new math.Transform();
                this.tmpInverseTransform = new math.Transform();
                this.tmpVector = new math.Vector2();
                this.expr = null;
                this.theta = 0;
            }
            else
                throw new Error('invalid overload');
        }
        set$math_Vector2$math_Vector2$double(focus1, focus2, chord) {
            const x1 = focus1.x;
            const y1 = focus1.y;
            const x2 = focus2.x;
            const y2 = focus2.y;
            const dist = focus1.distance$math_Vector2(focus2);
            this.set$double$double$double$double$double((x1 + x2) / 2, (y1 + y2) / 2, chord / 2, Math.sqrt(chord * chord - dist * dist) / 2, geom.AngleUtils.horizontalAngle$double$double$double$double(x1, y1, x2, y2));
        }
        set$double$double$double$double$double(xc, yc, l1, l2, theta) {
            this.xc = xc;
            this.yc = yc;
            this.r1 = l1;
            this.r2 = l2;
            this.theta = theta;
            this.__isDefined = /* isFinite */ ((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(l1) && l1 >= 0 && /* isFinite */ ((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(l2) && l2 >= 0;
            if (!this.__isDefined)
                return;
            this.tmpTransform.setToTrnRotScl$double$double$double$double$double(Math.fround(xc), Math.fround(yc), Math.fround(theta), 1, 1);
            this.tmpInverseTransform = this.tmpTransform.getInverse().copy(this.tmpInverseTransform);
            const c = this.conicCoefficients();
            this.expr = math.MathUtils.formatEqn$double_A$java_lang_String_A(c, geom.CurveUtils.conicTerms_$LI$());
            this.clip();
        }
        set(xc, yc, l1, l2, theta) {
            if (((typeof xc === 'number') || xc === null) && ((typeof yc === 'number') || yc === null) && ((typeof l1 === 'number') || l1 === null) && ((typeof l2 === 'number') || l2 === null) && ((typeof theta === 'number') || theta === null)) {
                return this.set$double$double$double$double$double(xc, yc, l1, l2, theta);
            }
            else if (((xc != null && xc instanceof math.Vector2) || xc === null) && ((yc != null && yc instanceof math.Vector2) || yc === null) && ((typeof l1 === 'number') || l1 === null) && l2 === undefined && theta === undefined) {
                return this.set$math_Vector2$math_Vector2$double(xc, yc, l1);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         */
        update() {
        }
        /**
         * Clip the parabola by a box. The result is an instance of CurveSet2D<ParabolaArc2D>, which contains only instances
         * of ParabolaArc2D. If the parabola is not clipped, the result is an instance of CurveSet2D<ParabolaArc2D> which
         * contains 0 curves.
         */
        clip() {
            if (!this.visible)
                return;
            this.clipt0 = 0;
            this.clipt1 = 2 * Math.PI;
            if (this.shapesManager == null)
                return;
            let A = new math.Vector2();
            const C = new math.Vector2();
            const b = this.shapesManager.getWorldBounds();
            const xmin = b[0];
            const ymin = b[1];
            const xmax = b[2];
            const ymax = b[3];
            const pts = (new java.util.ArrayList());
            const line = geom.Conic2D.TMP_SEGMENT_$LI$();
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmin, ymin), C.set$double$double(xmin, ymax));
            let intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmin, ymax), C.set$double$double(xmax, ymax));
            intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmax, ymax), C.set$double$double(xmax, ymin));
            intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            line.set$math_Vector2$math_Vector2(A.set$double$double(xmax, ymin), C.set$double$double(xmin, ymin));
            intersections = this.intersections(line);
            for (let index = 0; index < intersections.length; index++) {
                let d = intersections[index];
                pts.add(d);
            }
            if (pts.size() === 2) {
                java.util.Collections.sort(pts);
                this.clipt0 = pts.get(0);
                this.clipt1 = pts.get(pts.size() - 1);
                let t = (this.clipt0 + this.clipt1) / 2;
                A = this.point(t);
                if (xmin >= A.x || xmax <= A.x || ymin >= A.y || ymax <= A.y) {
                    t = this.clipt0;
                    this.clipt0 = this.clipt1;
                    this.clipt1 = t + 2 * Math.PI - this.clipt1 + this.clipt0;
                }
            }
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.__isDefined)
                return;
            if (this.clipt1 - this.clipt0 > 6) {
                g.drawOval(this.xc, this.yc, this.r1, this.r2, this.theta, this.fillColor != null, true);
            }
            else {
                let v;
                g.context.beginPath();
                let t = this.clipt0;
                v = this.point(t);
                g.context.moveTo(v.x, v.y);
                const dt = (this.clipt1 - this.clipt0) / 200;
                while ((t < this.clipt1)) {
                    {
                        t += dt;
                        v = this.point(t);
                        g.context.lineTo(v.x, v.y);
                    }
                }
                ;
                g.context.stroke();
            }
            if (this.showEqn || this.showName) {
                geom.Shape2D.renderInfo(g, this.getInfo(), this.point(0), this.point(Math.PI), 1, 0, this.drawColor, null);
            }
        }
        conicType() {
            if (Math.abs(this.r1 - this.r2) < geom.Shape2D.ACCURACY)
                return geom.Conic2D.Type.CIRCLE;
            return geom.Conic2D.Type.ELLIPSE;
        }
        /**
         * Returns the conic coefficients of the ellipse. Algorithm taken from
         * http://tog.acm.org/GraphicsGems/gemsv/ch2-6/conmat.c
         * @return {double[]}
         */
        conicCoefficients() {
            const r1Sq = this.r1 * this.r1;
            const r2Sq = this.r2 * this.r2;
            const sint = Math.sin(this.theta);
            const cost = Math.cos(this.theta);
            const sin2t = 2.0 * sint * cost;
            const sintSq = sint * sint;
            const costSq = cost * cost;
            const xcSq = this.xc * this.xc;
            const ycSq = this.yc * this.yc;
            const r1SqInv = 1.0 / r1Sq;
            const r2SqInv = 1.0 / r2Sq;
            const a = costSq / r1Sq + sintSq / r2Sq;
            const b = (r2Sq - r1Sq) * sin2t / (r1Sq * r2Sq);
            const c = costSq / r2Sq + sintSq / r1Sq;
            const d = -this.yc * b - 2 * this.xc * a;
            const e = -this.xc * b - 2 * this.yc * c;
            const f = -1.0 + (xcSq + ycSq) * (r1SqInv + r2SqInv) / 2.0 + (costSq - sintSq) * (xcSq - ycSq) * (r1SqInv - r2SqInv) / 2.0 + this.xc * this.yc * (r1SqInv - r2SqInv) * sin2t;
            return [a, b, c, d, e, f];
        }
        /**
         * Computes eccentricity of ellipse, depending on the lengths of the semi-axes. Eccentricity is 0 for a circle
         * (r1==r2), and tends to 1 when ellipse elongates.
         * @return {number}
         */
        eccentricity() {
            const a = Math.max(this.r1, this.r2);
            const b = Math.min(this.r1, this.r2);
            const r = b / a;
            return Math.sqrt(1 - r * r);
        }
        /**
         * Returns center of the ellipse.
         * @return {math.Vector2}
         */
        center() {
            return new math.Vector2(this.xc, this.yc);
        }
        /**
         * Return the first focus. It is defined as the first focus on the Major axis, in the direction given by angle
         * theta.
         * @return {math.Vector2[]}
         */
        foci() {
            let a;
            let b;
            let theta;
            if (this.r1 > this.r2) {
                a = this.r1;
                b = this.r2;
                theta = this.theta;
            }
            else {
                a = this.r2;
                b = this.r1;
                theta = this.theta + Math.PI / 2;
            }
            const r = Math.sqrt(a * a - b * b);
            const f1 = math.Vector2.create(r, theta);
            f1.add$double$double(this.xc, this.yc);
            const f2 = math.Vector2.create(r, theta + Math.PI);
            f2.add$double$double(this.xc, this.yc);
            return [f1, f2];
        }
        /**
         * Returns the first direction vector of the ellipse, in the direction of the major axis.
         * @return {math.Vector2}
         */
        axis() {
            return new math.Vector2(this.theta);
        }
        /**
         * Test whether the point is inside the ellipse. The test is performed by rotating the ellipse and the point to
         * align with axis, rescaling in each direction, then computing distance to origin.
         * @param {math.Vector2} point
         * @return {boolean}
         */
        isInside(point) {
            const pt = this.transformPoint(point);
            const xp = pt.x / this.r1;
            const yp = pt.y / this.r2;
            return (xp * xp + yp * yp < 1);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfNormals(point) {
            const p = this.transformPoint(point);
            const x = p.x;
            const y = p.y;
            const a = this.r1;
            const b = this.r2;
            const c4 = -b * y;
            const c3 = (2 * b * b - 2 * a * (x + a));
            const c2 = 0;
            const c1 = -2 * b * b - 2 * a * (x - a);
            const c0 = b * y;
            const T = [0, 0, 0, 0];
            math.EquationUtils.allowInfinityAsRoot = true;
            const result = math.EquationUtils.SolveBiQuartic$double$double$double$double$double$double_A(c4, c3, c2, c1, c0, T);
            math.EquationUtils.allowInfinityAsRoot = false;
            const pts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(result);
            if (result >= 1) {
                for (let i = 0; i < result; i++) {
                    {
                        pts[i] = this.getTheta_from_t(T[i]);
                    }
                    ;
                }
            }
            return pts;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfTangents(point) {
            if (this.isInside(point))
                return [];
            if (this.isSnapped(point))
                return [this.t(point)];
            const p = this.transformPoint(point);
            const h = p.x;
            const k = p.y;
            const a = this.r1 * this.r2 + h * this.r2;
            const b = -2 * k * this.r1;
            const c = this.r1 * this.r2 - h * this.r2;
            if (a === 0) {
                return [Math.PI, this.getTheta_from_t(-c / b)];
            }
            else {
                const T = [0, 0];
                math.EquationUtils.allowInfinityAsRoot = true;
                const n = math.EquationUtils.SolveQuadratic(a, b, c, T);
                math.EquationUtils.allowInfinityAsRoot = false;
                const pts = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(n);
                for (let i = 0; i < n; i++) {
                    {
                        pts[i] = this.getTheta_from_t(T[i]);
                    }
                    ;
                }
                return pts;
            }
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelTangents(dir) {
            const v = dir.rotate$double(-this.theta);
            const theta = v.getDirection();
            let m = Math.tan(theta);
            let th;
            if (Math.abs(m) < geom.Shape2D.ACCURACY) {
                m = 0;
                th = Math.PI / 2;
            }
            else if (Math.abs(m) > 1 / geom.Shape2D.ACCURACY) {
                m = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                th = 0;
            }
            else {
                th = Math.atan(-this.r2 / (this.r1 * m));
            }
            return [th, th + Math.PI];
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelNormals(dir) {
            return this.getFeetOfParallelTangents(dir.right());
        }
        /**
         *
         * @param {geom.Conic2D} conic
         * @return {double[]}
         */
        getIntersections(conic) {
            const coeff = geom.Conics2D.transform(conic.conicCoefficients(), this.tmpTransform);
            let a;
            let b;
            let c;
            let d;
            let e;
            let f;
            a = coeff[0];
            b = coeff[1];
            c = coeff[2];
            d = coeff[3];
            e = coeff[4];
            f = coeff[5];
            let c4;
            let c3;
            let c2;
            let c1;
            let c0;
            c4 = a * this.r1 * this.r1 - d * this.r1 + f;
            c3 = -2 * b * this.r1 * this.r2 + 2 * e * this.r2;
            c2 = -2 * a * this.r1 * this.r1 + 4 * c * this.r2 * this.r2 + 2 * f;
            c1 = 2 * b * this.r1 * this.r2 + 2 * e * this.r2;
            c0 = a * this.r1 * this.r1 + d * this.r1 + f;
            const T = [0, 0, 0, 0];
            math.EquationUtils.allowInfinityAsRoot = true;
            const result = math.EquationUtils.SolveBiQuartic$double$double$double$double$double$double_A(c4, c3, c2, c1, c0, T);
            math.EquationUtils.allowInfinityAsRoot = false;
            const pts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(result);
            if (result >= 1) {
                for (let i = 0; i < result; i++) {
                    {
                        pts[i] = this.getTheta_from_t(T[i]);
                    }
                    ;
                }
            }
            return pts;
        }
        /**
         * Compute intersections of the ellipse with a straight object (line, line segment, ray...).
         * <p>
         * Principle of the algorithm is to transform line and ellipse such that ellipse becomes a circle, then using the
         * intersections computation from circle.
         * @param {geom.Line2D} line
         * @return {double[]}
         */
        intersections(line) {
            const line2 = line.transform(this.tmpInverseTransform);
            const coeff = line2.coeff();
            const c = [0, 0, 0];
            c[0] = coeff[2] + coeff[0] * this.r1;
            c[1] = 2 * this.r2 * coeff[1];
            c[2] = coeff[2] - coeff[0] * this.r1;
            const result = [0, 0];
            math.EquationUtils.allowInfinityAsRoot = true;
            const n = math.EquationUtils.SolveQuadric$double_A$double_A(c, result);
            const points = (new java.util.ArrayList(2));
            let th = 0;
            for (let i = 0; i < n; i++) {
                {
                    th = this.getTheta_from_t(result[i]);
                    const point = this.point(th);
                    if (line.isSnapped(point))
                        points.add(th);
                }
                ;
            }
            const ts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(points.size());
            let i = 0;
            for (let index = points.iterator(); index.hasNext();) {
                let t = index.next();
                ts[i++] = t;
            }
            return ts;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {math.Vector2}
         */
        transformPoint(point) {
            const v = this.tmpInverseTransform.transform$double$double(Math.fround(point.x), Math.fround(point.y));
            return new math.Vector2(v.x, v.y);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {math.Vector2}
         */
        inverseTransformPoint(point) {
            const v = this.tmpTransform.transform$double$double(Math.fround(point.x), Math.fround(point.y));
            return new math.Vector2(v.x, v.y);
        }
        /**
         * Returns the length of the major semi-axis of the ellipse.
         * @return {number}
         */
        semiMajorAxisLength() {
            return this.r1;
        }
        /**
         * Returns the length of the minor semi-axis of the ellipse.
         * @return {number}
         */
        semiMinorAxisLength() {
            return this.r2;
        }
        /**
         * returns algebric parameter of ellipse (a.(1-t^2)/(1+t^2), b.2t/(1+t^2)
         *
         * @param {number} theta
         * parametric angle of ellipse in [0,2*PI)
         * @return
         * @return {number}
         * @private
         */
        /*private*/ gett_from_Theta(theta) {
            return Math.tan(theta / 2);
        }
        /**
         * returns parametric angle of ellipse
         *
         * @param {number} t
         * algebric parameter of ellipse (a.(1-t^2)/(1+t^2), b.2t/(1+t^2)
         * @return {number} theta in [0,2*PI)
         */
        getTheta_from_t(t) {
            t = 2 * Math.atan(t);
            return geom.AngleUtils.formatAngle(t);
        }
        /**
         * Returns the parameter of the first point of the ellipse, set to 0.
         * @return {number}
         */
        t0() {
            return 0;
        }
        /**
         * Returns the parameter of the last point of the ellipse, set to 2*PI.
         * @return {number}
         */
        t1() {
            return 2 * Math.PI;
        }
        /**
         * Returns the first point of the ellipse, which is the same as the last point.
         *
         * @return {math.Vector2} the first point of the ellipse
         */
        firstPoint() {
            return new math.Vector2(this.xc + this.r1 * Math.cos(this.theta), this.yc + this.r1 * Math.sin(this.theta));
        }
        /**
         * Returns the last point of the ellipse, which is the same as the first point.
         *
         * @return {math.Vector2} the last point of the ellipse.
         */
        lastPoint() {
            return new math.Vector2(this.xc + this.r1 * Math.cos(this.theta), this.yc + this.r1 * Math.sin(this.theta));
        }
        /**
         * get the position of the curve from internal parametric representation, depending on the parameter t. This
         * parameter is between the two limits 0 and 2*PI.
         *
         * @parma theta in [0,2*PI)
         * @return {math.Vector2} point on ellipse
         * @param {number} theta
         */
        point(theta) {
            return this.inverseTransformPoint(geom.Shape2D.TMP_VEC_$LI$().set$double$double(this.r1 * Math.cos(theta), this.r2 * Math.sin(theta)));
        }
        /**
         * Returns eccentric angle of the projected point on ellipse
         *
         * @param {math.Vector2} point
         * The point to be projected
         * @return {number} theta in [0,2*PI)
         */
        t(point) {
            const p = this.transformPoint(point);
            const x = p.x;
            const y = p.y;
            const a = this.r1;
            const b = this.r2;
            const c4 = -b * y;
            const c3 = (2 * b * b - 2 * a * (x + a));
            const c2 = 0;
            const c1 = -2 * b * b - 2 * a * (x - a);
            const c0 = b * y;
            const T = [0, 0, 0, 0];
            math.EquationUtils.allowInfinityAsRoot = true;
            const result = math.EquationUtils.SolveBiQuartic$double$double$double$double$double$double_A(c4, c3, c2, c1, c0, T);
            math.EquationUtils.allowInfinityAsRoot = false;
            if (result >= 1) {
                let t = this.getTheta_from_t(T[0]);
                let closest_t = t;
                let dist = point.distanceSquared$math_Vector2(this.point(t));
                for (let i = 1; i < result; i++) {
                    {
                        t = this.getTheta_from_t(T[i]);
                        const newDist = point.distanceSquared$math_Vector2(this.point(t));
                        if (dist > newDist) {
                            dist = newDist;
                            closest_t = t;
                        }
                    }
                    ;
                }
                return closest_t;
            }
            else
                return javaemul.internal.DoubleHelper.NaN;
        }
        /**
         *
         * @param {number} theta
         * @return {math.Vector2}
         */
        tangent(theta) {
            const m = Math.tan(theta);
            let v;
            if (m === 0)
                v = new math.Vector2(0, 1);
            else if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(m))
                v = new math.Vector2(1, 0);
            else
                v = math.Vector2.create(1, Math.atan(-this.r2 / m / this.r1));
            return v.rotate$double(this.theta);
        }
        /**
         * Returns the curvature of the ellipse.
         * @param {number} theta
         * @return {number}
         */
        curvature(theta) {
            const cot = Math.cos(theta);
            const sit = Math.sin(theta);
            const k = -(f => { if (f > 0) {
                return 1;
            }
            else if (f < 0) {
                return -1;
            }
            else {
                return 0;
            } })(sit) * this.r1 * this.r2 / Math.pow(math.MathUtils.hypot(this.r2 * cot, this.r1 * sit), 3);
            return k;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            return this.project(pt).distance$math_Vector2(pt);
        }
        /**
         *
         * @return {string}
         */
        toString() {
            return javaemul.internal.StringHelper.format("Ellipse2D(%f,%f,%f,%f,%f)", this.xc, this.yc, this.r1, this.r2, this.theta);
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return this.expr;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Ellipse [ a = " + math.MathUtils.formatValue(this.r1, false) + ",  b = " + math.MathUtils.formatValue(this.r2, false) + ", " + math.Unicode.Theta + " = " + math.MathUtils.formatValue(this.theta, true) + "]";
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            pt = this.transformPoint(pt);
            const xp = pt.x / this.r1;
            const yp = pt.y / this.r2;
            return (Math.abs(xp * xp + yp * yp - 1)) < geom.Shape2D.SNAP_DISTANCE;
        }
    }
    geom.Ellipse2D = Ellipse2D;
    Ellipse2D["__class"] = "geom.Ellipse2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Pair of non parallel lines
     * @param {number} l1
     * @param {number} m1
     * @param {number} n1
     * @param {number} l2
     * @param {number} m2
     * @param {number} n2
     * @class
     * @extends geom.Conic2D
     */
    class ConicTwoLines2D extends geom.Conic2D {
        constructor(l1, m1, n1, l2, m2, n2) {
            if (((typeof l1 === 'number') || l1 === null) && ((typeof m1 === 'number') || m1 === null) && ((typeof n1 === 'number') || n1 === null) && ((typeof l2 === 'number') || l2 === null) && ((typeof m2 === 'number') || m2 === null) && ((typeof n2 === 'number') || n2 === null)) {
                let __args = arguments;
                super();
                if (this.line1 === undefined) {
                    this.line1 = null;
                }
                if (this.line2 === undefined) {
                    this.line2 = null;
                }
                if (this.expr === undefined) {
                    this.expr = null;
                }
                this.line1 = new geom.Line2D(l1, m1, n1);
                this.line2 = new geom.Line2D(l2, m2, n2);
                const c = this.conicCoefficients();
                this.expr = math.MathUtils.formatEqn$double_A$java_lang_String_A(c, geom.CurveUtils.conicTerms_$LI$());
            }
            else if (((typeof l1 === 'number') || l1 === null) && ((typeof m1 === 'number') || m1 === null) && ((typeof n1 === 'number') || n1 === null) && ((typeof l2 === 'number') || l2 === null) && m2 === undefined && n2 === undefined) {
                let __args = arguments;
                let xc = __args[0];
                let yc = __args[1];
                let d = __args[2];
                let theta = __args[3];
                super();
                if (this.line1 === undefined) {
                    this.line1 = null;
                }
                if (this.line2 === undefined) {
                    this.line2 = null;
                }
                if (this.expr === undefined) {
                    this.expr = null;
                }
                const dir = new math.Vector2(theta);
                const c = new math.Vector2(xc, yc);
                let p = c.sum$math_Vector2(dir.getRightHandOrthogonalVector().multiply(d));
                this.line1 = new geom.Line2D(p, dir);
                p = c.sum$math_Vector2(dir.getNegative().product(d));
                this.line2 = new geom.Line2D(p, dir);
                const coeff = this.conicCoefficients();
                this.expr = math.MathUtils.formatEqn$double_A$java_lang_String_A(coeff, geom.CurveUtils.conicTerms_$LI$());
            }
            else if (((typeof l1 === 'number') || l1 === null) && ((typeof m1 === 'number') || m1 === null) && ((typeof n1 === 'number') || n1 === null) && l2 === undefined && m2 === undefined && n2 === undefined) {
                let __args = arguments;
                let l = __args[0];
                let m = __args[1];
                let n = __args[2];
                {
                    let __args = arguments;
                    let l1 = l;
                    let m1 = m;
                    let n1 = n;
                    let l2 = l;
                    let m2 = m;
                    let n2 = n;
                    super();
                    if (this.line1 === undefined) {
                        this.line1 = null;
                    }
                    if (this.line2 === undefined) {
                        this.line2 = null;
                    }
                    if (this.expr === undefined) {
                        this.expr = null;
                    }
                    this.line1 = new geom.Line2D(l1, m1, n1);
                    this.line2 = new geom.Line2D(l2, m2, n2);
                    const c = this.conicCoefficients();
                    this.expr = math.MathUtils.formatEqn$double_A$java_lang_String_A(c, geom.CurveUtils.conicTerms_$LI$());
                }
                if (this.line1 === undefined) {
                    this.line1 = null;
                }
                if (this.line2 === undefined) {
                    this.line2 = null;
                }
                if (this.expr === undefined) {
                    this.expr = null;
                }
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {geom.ShapesManager} shapesManager
         */
        onAddShapeToSimulation(shapesManager) {
            super.onAddShapeToSimulation(shapesManager);
            this.line1.shapesManager = shapesManager;
            this.line2.shapesManager = shapesManager;
            this.line1.clip();
            this.line2.clip();
        }
        clip() {
            this.line1.clip();
            this.line2.clip();
        }
        /**
         *
         * @return {double[]}
         */
        conicCoefficients() {
            const coefs = [0, 0, 1, 0, 0, -1];
            const d1 = this.line1.coeff();
            const d2 = this.line2.coeff();
            coefs[0] = d1[0] * d2[0];
            coefs[1] = d1[0] * d2[1] + d1[1] * d2[0];
            coefs[2] = d1[1] * d2[1];
            coefs[3] = d1[0] * d2[2] + d1[2] * d2[0];
            coefs[4] = d1[1] * d2[2] + d1[2] * d2[1];
            coefs[5] = d1[2] * d2[2];
            return coefs;
        }
        /**
         *
         * @return {geom.Conic2D.Type}
         */
        conicType() {
            return geom.Conic2D.Type.TWO_LINES;
        }
        /**
         *
         * @return {number}
         */
        eccentricity() {
            return javaemul.internal.DoubleHelper.NaN;
        }
        /**
         *
         * @return {math.Vector2[]}
         */
        foci() {
            return null;
        }
        /**
         * returns point of intesection of constituent lines
         * @see math.geom2d.conic.Conic2D#center()
         * @return {math.Vector2}
         */
        center() {
            if (this.line1 === this.line2 || geom.AngleUtils.angle$geom_Line2D$geom_Line2D(this.line1, this.line2) === 0)
                return null;
            const centre = geom.CurveUtils.LineLineIntersection$geom_Line2D$geom_Line2D(this.line1, this.line2);
            return centre[0];
        }
        /**
         * If abs(t)<1 point is on line1 else on line 2
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            if (Math.abs(t) < 1) {
                return this.line1.point(Math.tan(t));
            }
            else {
                if ( /* isFinite */((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(t))
                    t = 0;
                else
                    t = 1 / t;
                return this.line2.point(Math.tan(t));
            }
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {number}
         */
        t(point) {
            let p1;
            let p2;
            p1 = this.line1.project(point);
            p2 = this.line2.project(point);
            if (point.distance$math_Vector2(p1) < point.distance$math_Vector2(p2))
                return 2 * Math.atan(this.line1.t(point)) / Math.PI;
            else
                return Math.PI / 2 / Math.atan(this.line1.t(point));
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {boolean}
         */
        isSnapped(point) {
            return this.line1.isSnapped(point) || this.line2.isSnapped(point);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {number}
         */
        distance(point) {
            return Math.min(this.line1.distance(point), this.line2.distance(point));
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfNormals(point) {
            let t1;
            let t2;
            t1 = 2 * Math.atan(this.line1.t(point)) / Math.PI;
            t2 = Math.PI / Math.atan(this.line1.t(point)) / 2;
            return [t1, t2];
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfTangents(point) {
            return null;
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelTangents(dir) {
            return [];
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelNormals(dir) {
            return [];
        }
        /**
         *
         * @param {geom.Conic2D} conic
         * @return {double[]}
         */
        getIntersections(conic) {
            const pts1 = conic.intersections(this.line1);
            const pts2 = conic.intersections(this.line2);
            const pts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(pts1.length + pts2.length);
            for (let i = 0; i < pts1.length; i++) {
                {
                    pts[i] = pts1[i];
                }
                ;
            }
            for (let i = pts1.length; i < pts.length; i++) {
                {
                    pts[i] = pts2[i - pts1.length];
                }
                ;
            }
            return pts;
        }
        /**
         *
         * @return {math.Vector2}
         */
        axis() {
            return new math.Vector2((this.line1.getDirection().getAngleWithPositiveXAxis() + this.line2.getDirection().getAngleWithPositiveXAxis()) / 2);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {math.Vector2}
         */
        transformPoint(pt) {
            return null;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {math.Vector2}
         */
        inverseTransformPoint(pt) {
            return null;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {boolean}
         */
        isInside(point) {
            return false;
        }
        /**
         *
         * @param {geom.Line2D} line
         * @return {double[]}
         */
        intersections(line) {
            return null;
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return this.expr;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Pair of Lines";
        }
        /**
         *
         * @param {geom.Line2D} line
         * @return {math.Vector2}
         */
        getPole(line) {
            return null;
        }
        /**
         *
         * @param {math.Vector2} p
         * @return {geom.Line2D}
         */
        getPolar(p) {
            return null;
        }
        /**
         *
         * @param {framework.Renderer} gl
         */
        render(gl) {
            this.line1.render(gl);
            this.line2.render(gl);
        }
    }
    geom.ConicTwoLines2D = ConicTwoLines2D;
    ConicTwoLines2D["__class"] = "geom.ConicTwoLines2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Creates the circle with center at (x,y) and specified radius
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @class
     * @extends geom.Conic2D
     */
    class Circle2D extends geom.Conic2D {
        constructor(x, y, radius) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof radius === 'number') || radius === null)) {
                let __args = arguments;
                super();
                if (this.expr === undefined) {
                    this.expr = null;
                }
                if (this.cx === undefined) {
                    this.cx = 0;
                }
                if (this.cy === undefined) {
                    this.cy = 0;
                }
                if (this.r === undefined) {
                    this.r = 0;
                }
                this.clipt0 = 0;
                this.clipt1 = 2 * Math.PI;
                this.ACW = true;
                this.set(x, y, radius);
            }
            else if (x === undefined && y === undefined && radius === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let x = 0;
                    let y = 0;
                    let radius = 1;
                    super();
                    if (this.expr === undefined) {
                        this.expr = null;
                    }
                    if (this.cx === undefined) {
                        this.cx = 0;
                    }
                    if (this.cy === undefined) {
                        this.cy = 0;
                    }
                    if (this.r === undefined) {
                        this.r = 0;
                    }
                    this.clipt0 = 0;
                    this.clipt1 = 2 * Math.PI;
                    this.ACW = true;
                    this.set(x, y, radius);
                }
                if (this.expr === undefined) {
                    this.expr = null;
                }
                if (this.cx === undefined) {
                    this.cx = 0;
                }
                if (this.cy === undefined) {
                    this.cy = 0;
                }
                if (this.r === undefined) {
                    this.r = 0;
                }
                this.clipt0 = 0;
                this.clipt1 = 2 * Math.PI;
                this.ACW = true;
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Sets this circle with center at (x,y) and specified radius
         * @param {number} x
         * @param {number} y
         * @param {number} radius
         */
        set(x, y, radius) {
            this.__t0 = 0;
            this.__t1 = 2 * Math.PI;
            this.cx = x;
            this.cy = y;
            this.__isDefined = /* isFinite */ ((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(radius) && radius > 0;
            if (!this.__isDefined)
                return;
            this.r = radius;
            this.expr = math.MathUtils.formatEqn$double_A$java_lang_String_A([1, 0, 1, -2 * this.cx, -2 * this.cy, this.cx * this.cx + this.cy * this.cy - this.r * this.r], geom.CurveUtils.circleTerms_$LI$());
            if (this.visible)
                this.clip();
        }
        /**
         *
         */
        update() {
        }
        /**
         * Clip the parabola by a box. The result is an instance of CurveSet2D<ParabolaArc2D>, which contains only instances
         * of ParabolaArc2D. If the parabola is not clipped, the result is an instance of CurveSet2D<ParabolaArc2D> which
         * contains 0 curves.
         */
        clip() {
            this.clipt0 = 0;
            this.clipt1 = 2 * Math.PI;
            if (this.shapesManager == null)
                return;
            let A = new math.Vector2();
            const C = new math.Vector2();
            const b = this.shapesManager.getWorldBounds();
            const xmin = b[0];
            const ymin = b[1];
            const xmax = b[2];
            const ymax = b[3];
            const pts = (new java.util.ArrayList());
            const line = geom.Conic2D.TMP_SEGMENT_$LI$();
            let intersections;
            if (Math.abs(this.cx - xmin) < this.r) {
                line.set$math_Vector2$math_Vector2(A.set$double$double(xmin, ymin), C.set$double$double(xmin, ymax));
                intersections = this.intersections(line);
                for (let index = 0; index < intersections.length; index++) {
                    let d = intersections[index];
                    pts.add(d);
                }
            }
            if (Math.abs(ymax - this.cy) < this.r) {
                line.set$math_Vector2$math_Vector2(A.set$double$double(xmin, ymax), C.set$double$double(xmax, ymax));
                intersections = this.intersections(line);
                for (let index = 0; index < intersections.length; index++) {
                    let d = intersections[index];
                    pts.add(d);
                }
            }
            if (Math.abs(xmax - this.cx) < this.r) {
                line.set$math_Vector2$math_Vector2(A.set$double$double(xmax, ymax), C.set$double$double(xmax, ymin));
                intersections = this.intersections(line);
                for (let index = 0; index < intersections.length; index++) {
                    let d = intersections[index];
                    pts.add(d);
                }
            }
            if (Math.abs(this.cy - ymin) < this.r) {
                line.set$math_Vector2$math_Vector2(A.set$double$double(xmax, ymin), C.set$double$double(xmin, ymin));
                intersections = this.intersections(line);
                for (let index = 0; index < intersections.length; index++) {
                    let d = intersections[index];
                    pts.add(d);
                }
            }
            if (pts.size() === 2) {
                java.util.Collections.sort(pts);
                this.clipt0 = pts.get(0);
                this.clipt1 = pts.get(pts.size() - 1);
                const t = (this.clipt0 + this.clipt1) / 2;
                A = this.point(t);
                this.ACW = true;
                if (A != null && (xmin >= A.x || xmax <= A.x || ymin >= A.y || ymax <= A.y)) {
                    this.ACW = false;
                }
            }
        }
        /**
         * returns algebric parameter of ellipse (a.(1-t^2)/(1+t^2), b.2t/(1+t^2)
         *
         * @param {number} theta
         * parametric angle of ellipse  in [0,2*PI)
         * @return
         * @return {number}
         * @private
         */
        /*private*/ gett_from_Theta(theta) {
            return Math.tan(theta / 2);
        }
        /**
         * returns parametric angle of ellipse
         *
         * @param {number} t
         * algebric parameter of ellipse (a.(1-t^2)/(1+t^2), b.2t/(1+t^2)
         * @return {number} theta in [0,2*PI)
         */
        getTheta_from_t(t) {
            t = 2 * Math.atan(t);
            return geom.AngleUtils.formatAngle(t);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        t(pt) {
            let t = new math.Vector2(this.cx, this.cy).to$math_Vector2(pt).getDirection();
            t = geom.AngleUtils.formatAngle(t);
            return t;
        }
        /**
         * Returns point on circle based on specified parametric angle in radians (3:00 AM as 0 and ACW as positive)
         * @param {Number} t parametric angle
         * @param {Vector2} the point on curve if valid else null
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            return math.Vector2.create(this.r, t).add$double$double(this.cx, this.cy);
        }
        /**
         * Returns the radius of this circle
         * @return {number} {Number} the radius of circle
         */
        radius() {
            return this.r;
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            if (!this.isDefined())
                return null;
            return this.expr;
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.__isDefined)
                return;
            g.setColors(this.fillColor, this.drawColor);
            if (this.clipt1 - this.clipt0 > 6) {
                g.drawCircle(this.cx, this.cy, this.r, this.fillColor != null, true);
            }
            else {
                let v;
                g.context.beginPath();
                if (this.ACW) {
                    let t = this.clipt0;
                    v = this.point(t);
                    g.context.moveTo(v.x, v.y);
                    const dt = (this.clipt1 - this.clipt0) / 200;
                    while ((t < this.clipt1)) {
                        {
                            t += dt;
                            v = this.point(t);
                            g.context.lineTo(v.x, v.y);
                        }
                    }
                    ;
                }
                else {
                    let t = this.clipt1;
                    const t2 = this.clipt0 + Math.PI * 2;
                    v = this.point(t);
                    g.context.moveTo(v.x, v.y);
                    const dt = (t2 - this.clipt1) / 200;
                    while ((t < t2)) {
                        {
                            t += dt;
                            v = this.point(t);
                            g.context.lineTo(v.x, v.y);
                        }
                    }
                    ;
                }
                g.context.stroke();
            }
            if (this.showEqn || this.showName) {
                geom.Shape2D.renderInfo(g, this.getInfo(), new math.Vector2(this.cx - this.r, this.cy), new math.Vector2(this.cx + this.r, this.cy), 1, 0, this.drawColor, null);
            }
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        contains(pt) {
            if (!this.isDefined())
                return false;
            return Math.abs(pt.distance$double$double(this.cx, this.cy) - this.r) < geom.Shape2D.ACCURACY;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            if (!this.isDefined())
                return false;
            return Math.abs(pt.distance$double$double(this.cx, this.cy) - this.r) < geom.Shape2D.SNAP_DISTANCE;
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            if (!this.isDefined())
                return javaemul.internal.DoubleHelper.MAX_VALUE;
            return Math.abs(pt.distance$double$double(this.cx, this.cy) - this.r);
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            if (!this.__isDefined)
                return null;
            return new math.Vector2(t).right();
        }
        /**
         *
         * @param {number} t
         * @return {number}
         */
        derivative(t) {
            if (!this.__isDefined)
                return javaemul.internal.DoubleHelper.NaN;
            return -Math.tan(Math.PI / 2 + t);
        }
        /**
         *
         * @param {number} t
         * @return {number}
         */
        doubleDerivative(t) {
            const p = this.point(t);
            if (p.y === 0)
                return javaemul.internal.DoubleHelper.NEGATIVE_INFINITY;
            return -this.r * this.r / Math.pow(p.y, 3);
        }
        /**
         *
         * @param {number} t
         * @return {number}
         */
        curvature(t) {
            return 1 / this.r;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "Circle with center (" + this.cx + "," + this.cy + ") & Radius " + this.r;
        }
        /**
         *
         * @return {geom.Conic2D.Type}
         */
        conicType() {
            return geom.Conic2D.Type.CIRCLE;
        }
        /**
         *
         * @return {double[]}
         */
        conicCoefficients() {
            return [1, 0, 1, -2 * this.cx, -2 * this.cy, this.cx * this.cx + this.cy * this.cy - this.r * this.r];
        }
        /**
         *
         * @return {number}
         */
        eccentricity() {
            return 0;
        }
        /**
         *
         * @return {math.Vector2}
         */
        center() {
            return new math.Vector2(this.cx, this.cy);
        }
        /**
         *
         * @return {math.Vector2}
         */
        axis() {
            return new math.Vector2(1, 0);
        }
        /**
         *
         * @return {math.Vector2[]}
         */
        foci() {
            return [new math.Vector2(this.cx, this.cy)];
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {boolean}
         */
        isInside(point) {
            return point.distanceSquared$double$double(this.cx, this.cy) < this.r * this.r;
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfNormals(point) {
            const c = new math.Vector2(this.cx, this.cy);
            let th = c.to$math_Vector2(point).getAngleWithPositiveXAxis();
            if ( /* isNaN */isNaN(th))
                th = 0;
            return [th];
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfTangents(point) {
            const c = new math.Vector2(this.cx, this.cy);
            const v = c.to$math_Vector2(point);
            const d = v.normalize();
            if (d < this.r)
                return [];
            let t = new math.Vector2(this.cx, this.cy).to$math_Vector2(point).getDirection();
            t = geom.AngleUtils.formatAngle(t);
            if (d === this.r)
                return [t];
            const th = Math.acos(this.r / d);
            return [geom.AngleUtils.formatAngle(t + th), geom.AngleUtils.formatAngle(t - th)];
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelTangents(dir) {
            const th = dir.getAngleWithPositiveXAxis() + Math.PI / 2;
            return [th, th + Math.PI];
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelNormals(dir) {
            const th = dir.getAngleWithPositiveXAxis();
            return [th, th + Math.PI];
        }
        /**
         *
         * @param {geom.Conic2D} conic
         * @return {double[]}
         */
        getIntersections(conic) {
            const coeff = geom.Conics2D.transform(conic.conicCoefficients(), geom.Shape2D.TMP_TRANSFORM_$LI$().setToTranslate(Math.fround(this.cx), Math.fround(this.cy)));
            let a;
            let b;
            let c;
            let d;
            let e;
            let f;
            a = coeff[0];
            b = coeff[1];
            c = coeff[2];
            d = coeff[3];
            e = coeff[4];
            f = coeff[5];
            let c4;
            let c3;
            let c2;
            let c1;
            let c0;
            c4 = a * this.r * this.r - d * this.r + f;
            c3 = -2 * b * this.r * this.r + 2 * e * this.r;
            c2 = -2 * a * this.r * this.r + 4 * c * this.r * this.r + 2 * f;
            c1 = 2 * b * this.r * this.r + 2 * e * this.r;
            c0 = a * this.r * this.r + d * this.r + f;
            const T = [0, 0, 0, 0];
            math.EquationUtils.allowInfinityAsRoot = true;
            const result = math.EquationUtils.SolveBiQuartic$double$double$double$double$double$double_A(c4, c3, c2, c1, c0, T);
            math.EquationUtils.allowInfinityAsRoot = false;
            const pts = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(result);
            if (result >= 1) {
                for (let i = 0; i < result; i++) {
                    {
                        pts[i] = this.getTheta_from_t(T[i]);
                    }
                    ;
                }
            }
            return pts;
        }
        /**
         *
         * @param {geom.Line2D} line
         * @return {double[]}
         */
        intersections(line) {
            let th = geom.AngleUtils.horizontalAngle$geom_Line2D(line);
            const p = line.project(geom.Shape2D.TMP_VEC_$LI$().set$double$double(this.cx, this.cy));
            const d = p.distance$math_Vector2(this.center());
            if (d > this.r)
                return [];
            th = geom.Shape2D.TMP_VEC_$LI$().set$double$double(this.cx, this.cy).to$math_Vector2(p).getAngleWithPositiveXAxis();
            if (d === this.r)
                return [th];
            const dTh = Math.acos(d / this.r);
            return [geom.AngleUtils.formatAngle(th - dTh), geom.AngleUtils.formatAngle(th + dTh)];
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {math.Vector2}
         */
        transformPoint(pt) {
            return pt.subtract$double$double(this.cx, this.cy);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {math.Vector2}
         */
        inverseTransformPoint(pt) {
            return pt.add$double$double(this.cx, this.cy);
        }
        /**
         * Returns pole of the polar Line wrt this conic
         * @param {geom.Line2D} polar
         * @return
         * @return {math.Vector2}
         */
        getPole(polar) {
            geom.Shape2D.TMP_VEC = polar.project(geom.Shape2D.TMP_VEC.set$double$double(this.cx, this.cy));
            const p = this.center().to$math_Vector2(geom.Shape2D.TMP_VEC_$LI$());
            const d = p.getMagnitude();
            if (d === 0)
                return null;
            p.setMagnitude(this.r * this.r / d);
            return p.add$double$double(this.cx, this.cy);
        }
        /**
         * Returns the polar line of the point (pole) wrt this conic
         * @param {math.Vector2} pole
         * @return
         * @return {geom.Line2D}
         */
        getPolar(pole) {
            if (pole.equals$double$double(this.cx, this.cy))
                return null;
            const p = this.center().to$math_Vector2(pole);
            const d = p.getMagnitude();
            if (d === 0)
                return null;
            p.setMagnitude(this.r * this.r / d);
            return new geom.Line2D(p.sum$double$double(this.cx, this.cy), p.right());
        }
    }
    geom.Circle2D = Circle2D;
    Circle2D["__class"] = "geom.Circle2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Class to wrap genral dynamic conic, used when conic type is not fixed
     * @author maheshkurmi
     * @param {geom.Conic2D} conic
     * @class
     * @extends geom.Conic2D
     */
    class ConicWrapper2D extends geom.Conic2D {
        constructor(conic) {
            if (((conic != null && conic instanceof geom.Conic2D) || conic === null)) {
                let __args = arguments;
                super();
                this.conic = null;
                this.conic = conic;
            }
            else if (conic === undefined) {
                let __args = arguments;
                super();
                this.conic = null;
            }
            else
                throw new Error('invalid overload');
        }
        getConic() {
            return this.conic;
        }
        setConic(conic) {
            this.conic = conic;
            if (conic != null) {
                this.conic.shapesManager = this.shapesManager;
                this.conic.clip();
            }
        }
        /**
         *
         * @param {geom.ShapesManager} shapesManager
         */
        onAddShapeToSimulation(shapesManager) {
            super.onAddShapeToSimulation(shapesManager);
            if (this.conic != null) {
                this.conic.shapesManager = shapesManager;
                this.conic.clip();
            }
        }
        getShapeInfo() {
            if (this.conic == null)
                return "undefined conic";
            const s = geom.ShapesManager.getShapeName(this.conic.constructor);
            return s;
        }
        /**
         *
         */
        clip() {
            if (this.conic != null)
                this.conic.clip();
        }
        /**
         *
         * @return {geom.Conic2D.Type}
         */
        conicType() {
            if (this.conic == null)
                return geom.Conic2D.Type.NOT_A_CONIC;
            return this.conic.conicType();
        }
        /**
         *
         * @return {double[]}
         */
        conicCoefficients() {
            if (this.conic == null)
                return null;
            return this.conic.conicCoefficients();
        }
        /**
         *
         * @return {number}
         */
        eccentricity() {
            if (this.conic == null)
                return javaemul.internal.DoubleHelper.NaN;
            return this.conic.eccentricity();
        }
        /**
         *
         * @return {math.Vector2}
         */
        center() {
            if (this.conic == null)
                return null;
            return this.conic.center();
        }
        /**
         *
         * @return {math.Vector2}
         */
        axis() {
            if (this.conic == null)
                return null;
            return this.conic.axis();
        }
        /**
         *
         * @return {math.Vector2[]}
         */
        foci() {
            if (this.conic == null)
                return null;
            return this.conic.foci();
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {math.Vector2}
         */
        transformPoint(pt) {
            if (this.conic == null)
                return null;
            return this.conic.transformPoint(pt);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {math.Vector2}
         */
        inverseTransformPoint(pt) {
            if (this.conic == null)
                return null;
            return this.conic.inverseTransformPoint(pt);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {boolean}
         */
        isInside(point) {
            if (this.conic == null)
                return false;
            return this.conic.isInside(point);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfNormals(point) {
            if (this.conic == null)
                return null;
            return this.conic.getFeetOfNormals(point);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfTangents(point) {
            if (this.conic == null)
                return null;
            return this.conic.getFeetOfTangents(point);
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelTangents(dir) {
            if (this.conic == null)
                return null;
            return this.conic.getFeetOfParallelTangents(dir);
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelNormals(dir) {
            if (this.conic == null)
                return null;
            return this.conic.getFeetOfParallelNormals(dir);
        }
        /**
         *
         * @param {geom.Conic2D} conic
         * @return {double[]}
         */
        getIntersections(conic) {
            if (this.conic == null)
                return null;
            return this.conic.getIntersections(conic);
        }
        /**
         *
         * @param {geom.Line2D} line
         * @return {double[]}
         */
        intersections(line) {
            if (this.conic == null)
                return null;
            return this.conic.intersections(line);
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {number}
         */
        t(point) {
            if (this.conic == null)
                return javaemul.internal.DoubleHelper.NaN;
            return this.conic.t(point);
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            if (this.conic == null)
                return null;
            return this.conic.point(t);
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            if (this.conic == null)
                return null;
            return this.conic.getEquation();
        }
        /**
         *
         * @param {framework.Renderer} gl
         */
        render(gl) {
            if (this.conic == null)
                return;
            this.conic.drawColor = this.drawColor;
            this.conic.fillColor = this.fillColor;
            this.conic.showEqn = this.showEqn;
            this.conic.name = this.name;
            this.conic.showName = this.showName;
            this.conic.render(gl);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            if (this.conic == null)
                return false;
            return this.conic.isSnapped(pt);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            if (this.conic == null)
                return javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
            return this.conic.distance(pt);
        }
        /**
         *
         * @param {number} strokeWidth
         */
        setLineWidth(strokeWidth) {
            if (strokeWidth > 0) {
                super.setLineWidth(strokeWidth);
                if (this.conic != null)
                    this.conic.setLineWidth(strokeWidth);
            }
        }
        /**
         *
         * @param {framework.Color} fillColor
         */
        setFillColor(fillColor) {
            super.setFillColor(fillColor);
            if (this.conic != null)
                this.conic.setFillColor(fillColor);
        }
        /**
         *
         * @param {framework.Color} drawColor
         */
        setDrawColor(drawColor) {
            super.setDrawColor(drawColor);
            if (this.conic != null)
                this.conic.setDrawColor(drawColor);
        }
        /**
         *
         * @param {geom.Shape2D.DrawMode} drawPattern
         */
        setDrawPattern(drawPattern) {
            super.setDrawPattern(drawPattern);
            if (this.conic != null)
                this.conic.setDrawPattern(drawPattern);
        }
        /**
         * @param {boolean} visible
         * the visible to set
         */
        setVisible(visible) {
            super.setVisible(visible);
            if (this.conic != null)
                this.conic.setVisible(visible);
        }
        /**
         * @return {boolean} the visible
         */
        isVisible() {
            if (this.visibilityCondition != null) {
                try {
                    this.visible = math.MathUtils.evaluateExpression(this.visibilityCondition, this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables) !== 0;
                    if (this.conic != null)
                        this.conic.visible = this.visible;
                }
                catch (e) {
                }
            }
            return this.visible;
        }
        /**
         * Sets element selectable and draggable by mouse or touch events
         * @return
         * @param {boolean} touchable
         */
        setTouchable(touchable) {
            super.setTouchable(touchable);
            if (this.conic != null)
                this.conic.setTouchable(touchable);
        }
        /**
         * Sets the identifier name of shape
         * @param {string} name
         * the name to set
         */
        setName(name) {
            this.name = name;
        }
        /**
         *
         * @param {boolean} showEqn
         */
        setShowEqn(showEqn) {
            this.showEqn = showEqn;
            if (this.conic != null)
                this.conic.showEqn = showEqn;
        }
    }
    geom.ConicWrapper2D = ConicWrapper2D;
    ConicWrapper2D["__class"] = "geom.ConicWrapper2D";
})(geom || (geom = {}));
(function (geom) {
    class VectorSum2D extends geom.Vector2D {
        constructor(p1, p2, p) {
            super();
            this.parents = [p1, p2, p];
            this.update();
        }
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[0];
            const v2 = this.parents[1];
            const p = this.parents[2].pt;
            const vec1 = v1.p1.to$math_Vector2(v1.p2);
            const vec2 = v2.p1.to$math_Vector2(v2.p2);
            const p2 = p.sum$math_Vector2(vec2.sum$math_Vector2(vec1));
            if (p.equals$math_Vector2(p2)) {
                this.expr = null;
                this.__isDefined = false;
                return;
            }
            super.set$math_Vector2$math_Vector2(p, p2);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Resultant of Vectors " + this.parents[0].getName() + " & " + this.parents[1].getName();
        }
    }
    geom.VectorSum2D = VectorSum2D;
    VectorSum2D["__class"] = "geom.VectorSum2D";
})(geom || (geom = {}));
(function (geom) {
    class VectorPointPerpendicularLine2D extends geom.Vector2D {
        constructor(line, p) {
            super();
            this.parents = [line, p];
            this.update();
        }
        /**
         *
         */
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const p = this.parents[1].pt;
            const line = this.parents[0];
            const p0 = line.project(p);
            if (p0 == null)
                return;
            super.set$math_Vector2$math_Vector2(p0, p);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Vector Normal to " + this.parents[0].getName() + " from " + this.parents[1].getName();
        }
    }
    geom.VectorPointPerpendicularLine2D = VectorPointPerpendicularLine2D;
    VectorPointPerpendicularLine2D["__class"] = "geom.VectorPointPerpendicularLine2D";
})(geom || (geom = {}));
(function (geom) {
    class VectorDifference2D extends geom.Vector2D {
        constructor(v1, v2, p) {
            super();
            this.parents = [v1, v2, p];
            this.update();
        }
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[0];
            const v2 = this.parents[1];
            const p = this.parents[2].pt;
            const vec1 = v1.p1.to$math_Vector2(v1.p2);
            const vec2 = v2.p1.to$math_Vector2(v2.p2);
            const p2 = p.sum$math_Vector2(vec1.subtract$math_Vector2(vec2));
            if (p.equals$math_Vector2(p2)) {
                this.expr = null;
                this.__isDefined = false;
                return;
            }
            super.set$math_Vector2$math_Vector2(p, p2);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Difference of Vectors " + this.parents[0].getName() + " & " + this.parents[1].getName();
        }
    }
    geom.VectorDifference2D = VectorDifference2D;
    VectorDifference2D["__class"] = "geom.VectorDifference2D";
})(geom || (geom = {}));
(function (geom) {
    class Vector2Points2D extends geom.Vector2D {
        constructor(p1, p2) {
            super();
            this.parents = [p1, p2];
            this.update();
        }
        update() {
            if (this.parents == null)
                return;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[0].pt;
            const v2 = this.parents[1].pt;
            super.set$math_Vector2$math_Vector2(v1, v2);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return this.parents == null ? "Vector " + this.name : ("Vector through " + this.parents[0].getName() + " & " + this.parents[1].getName());
        }
    }
    geom.Vector2Points2D = Vector2Points2D;
    Vector2Points2D["__class"] = "geom.Vector2Points2D";
})(geom || (geom = {}));
(function (geom) {
    class VectorPointParallelLine2D extends geom.Vector2D {
        constructor(line, p1, p2) {
            super();
            this.parents = [line, p1, p2];
            this.update();
        }
        /**
         *
         */
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[1].pt;
            let v2 = this.parents[2].pt;
            const line = this.parents[0];
            this.x0 = v1.x;
            this.y0 = v1.y;
            this.dx = line.dx;
            this.dy = line.dy;
            const v = v1.to$math_Vector2(v2);
            const dir = new math.Vector2(this.dx, this.dy);
            v2 = v1.sum$math_Vector2(dir.product(v.dot$math_Vector2(dir)));
            if (v1.to$math_Vector2(v2).isZero())
                return;
            dir.set$math_Vector2(v1.to$math_Vector2(v2)).normalize();
            this.dx = dir.x;
            this.dy = dir.y;
            super.set$math_Vector2$math_Vector2(v1, v2);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Vector parallel to " + this.parents[0].getName() + " & passing through " + this.parents[1].getName() + " and " + this.parents[2].getName();
        }
    }
    geom.VectorPointParallelLine2D = VectorPointParallelLine2D;
    VectorPointParallelLine2D["__class"] = "geom.VectorPointParallelLine2D";
})(geom || (geom = {}));
(function (geom) {
    class VectorUnit2D extends geom.Vector2D {
        constructor(line, p) {
            super();
            this.parents = [line, p];
            this.update();
        }
        /**
         *
         */
        update() {
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const v1 = this.parents[1].pt;
            const line = this.parents[0];
            if (v1 == null || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(v1.x) || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(v1.y))
                return;
            const v2 = v1.sum$double$double(line.dx, line.dy);
            super.set$math_Vector2$math_Vector2(v1, v2);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Unit Vector parallel to " + this.parents[0].getName() + " & passing through " + this.parents[1].getName();
        }
    }
    geom.VectorUnit2D = VectorUnit2D;
    VectorUnit2D["__class"] = "geom.VectorUnit2D";
})(geom || (geom = {}));
(function (geom) {
    class VectorEqn2D extends geom.Vector2D {
        constructor(p1, a, b) {
            super();
            if (this.a === undefined) {
                this.a = null;
            }
            if (this.b === undefined) {
                this.b = null;
            }
            this.parents = [p1];
            this.a = new geom.optics.DynamicValue(a, javaemul.internal.DoubleHelper.NEGATIVE_INFINITY, javaemul.internal.DoubleHelper.POSITIVE_INFINITY);
            this.b = new geom.optics.DynamicValue(a, javaemul.internal.DoubleHelper.NEGATIVE_INFINITY, javaemul.internal.DoubleHelper.POSITIVE_INFINITY);
            this.set$java_lang_String$java_lang_String(a, b);
        }
        /**
         * Sets line as passing through point (x,y) and direction rations as dx and dy
         * @param {number} x
         * @param {number} y
         * @param {number} dx
         * @param {number} dy
         */
        set(x, y, dx, dy) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && ((typeof dy === 'number') || dy === null)) {
                super.set(x, y, dx, dy);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof dx === 'number') || dx === null) && dy === undefined) {
                return this.set$double$double$double(x, y, dx);
            }
            else if (((typeof x === 'string') || x === null) && ((typeof y === 'string') || y === null) && dx === undefined && dy === undefined) {
                return this.set$java_lang_String$java_lang_String(x, y);
            }
            else if (((x != null && x instanceof math.Vector2) || x === null) && ((y != null && y instanceof math.Vector2) || y === null) && dx === undefined && dy === undefined) {
                return this.set$math_Vector2$math_Vector2(x, y);
            }
            else
                throw new Error('invalid overload');
        }
        set$java_lang_String$java_lang_String(expra, exprb) {
            this.params = [expra, exprb];
            this.a.set$java_lang_String(expra);
            this.b.set$java_lang_String(exprb);
            this.expr = math.MathUtils.formatEqn$java_lang_String_A$java_lang_String_A(this.params, [math.Unicode.hat + "i", math.Unicode.hat + "j"]);
            this.update();
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("a", this.params[0], null);
            if (index === 1)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("b", this.params[1], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            const __var = value + "";
            if (index === 0) {
                this.params[0] = __var;
                this.a.set$java_lang_String(__var);
            }
            else if (index === 1) {
                this.params[1] = __var;
                this.b.set$java_lang_String(__var);
            }
            this.update();
        }
        update() {
            this.a.update();
            this.b.update();
            const a = this.a.getValue();
            const b = this.b.getValue();
            if (!this.parents[0].isDefined() || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(a) || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(b) || (a === 0 && b === 0)) {
                this.__isDefined = false;
                return;
            }
            const p = this.parents[0].pt;
            this.__isDefined = true;
            this.x0 = p.x;
            this.y0 = p.y;
            const v = new math.Vector2(a, b);
            this.dx = v.x;
            this.dy = v.y;
            super.set$math_Vector2$math_Vector2(p, v.add$math_Vector2(p));
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Vectors " + this.expr + " from " + this.parents[0].getName();
        }
    }
    geom.VectorEqn2D = VectorEqn2D;
    VectorEqn2D["__class"] = "geom.VectorEqn2D";
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalIdealLens2D extends geom.optics.OpticalDevice2D {
            constructor(pole, point, f, showFoci, showAxis, showImages) {
                if (((pole != null && pole instanceof geom.Point2D) || pole === null) && ((point != null && point instanceof geom.Point2D) || point === null) && ((typeof f === 'string') || f === null) && ((typeof showFoci === 'string') || showFoci === null) && ((typeof showAxis === 'string') || showAxis === null) && ((typeof showImages === 'string') || showImages === null)) {
                    let __args = arguments;
                    super();
                    if (this.focalLength === undefined) {
                        this.focalLength = null;
                    }
                    this.center = new math.Vector2();
                    this.lens = new geom.Segment2D();
                    this.focus1 = new geom.Point2D();
                    this.focus2 = new geom.Point2D();
                    this.axis = new geom.Line2D();
                    this.parents = [pole, point];
                    this.params = [f, showFoci, showAxis, showImages];
                    this.minIntersectionsNeeded = 1;
                    this.showImages = javaemul.internal.BooleanHelper.parseBoolean(showImages);
                    this.axis.setDrawPattern(geom.Shape2D.DrawMode.DASHED);
                    this.fillColor = framework.Preferences.getRandomColor();
                    this.drawColor = this.fillColor.darker();
                    this.fillColor.a = 127;
                    this.focalLength = new geom.optics.DynamicValue(f, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    let b = javaemul.internal.BooleanHelper.parseBoolean(showFoci);
                    this.focus1.setVisible(b);
                    this.focus2.setVisible(b);
                    b = javaemul.internal.BooleanHelper.parseBoolean(showAxis);
                    this.axis.setVisible(b);
                    this.showImagesExpr = showImages;
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                    this.showName = false;
                    this.showEqn = false;
                    if (OpticalIdealLens2D.tmpVertexBufConvex == null) {
                        const h = 1;
                        const w = 0.1;
                        const R = 0.5 * (w * w + h * h) / w;
                        const th0 = Math.asin(h / R);
                        let dth = th0 / 10;
                        let th = -th0;
                        let x = 0;
                        let y = h;
                        let cx = -R + w;
                        OpticalIdealLens2D.tmpVertexBufConvex = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(21);
                        for (let i = 0; i <= 20; i++) {
                            {
                                x = cx + R * Math.cos(th);
                                y = R * Math.sin(th);
                                OpticalIdealLens2D.tmpVertexBufConvex[i] = new math.Vector2(x, y);
                                th += dth;
                            }
                            ;
                        }
                        th = th0;
                        dth = th0 / 10;
                        cx = -R - w / 2;
                        th = th0;
                        dth = th0 / 10;
                        cx = -R - w / 2;
                        OpticalIdealLens2D.tmpVertexBufConcave = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(12);
                        OpticalIdealLens2D.tmpVertexBufConcave[0] = new math.Vector2(0, h);
                        for (let i = 0; i <= 10; i++) {
                            {
                                x = cx + R * Math.cos(th);
                                y = R * Math.sin(th);
                                OpticalIdealLens2D.tmpVertexBufConcave[i + 1] = new math.Vector2(x, y);
                                th -= dth;
                            }
                            ;
                        }
                    }
                    this.update();
                }
                else if (((pole != null && pole instanceof geom.Point2D) || pole === null) && ((point != null && point instanceof geom.Point2D) || point === null) && f === undefined && showFoci === undefined && showAxis === undefined && showImages === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let f = "2";
                        let showFoci = "false";
                        let showAxis = "false";
                        let showImages = "true";
                        super();
                        if (this.focalLength === undefined) {
                            this.focalLength = null;
                        }
                        this.center = new math.Vector2();
                        this.lens = new geom.Segment2D();
                        this.focus1 = new geom.Point2D();
                        this.focus2 = new geom.Point2D();
                        this.axis = new geom.Line2D();
                        this.parents = [pole, point];
                        this.params = [f, showFoci, showAxis, showImages];
                        this.minIntersectionsNeeded = 1;
                        this.showImages = javaemul.internal.BooleanHelper.parseBoolean(showImages);
                        this.axis.setDrawPattern(geom.Shape2D.DrawMode.DASHED);
                        this.fillColor = framework.Preferences.getRandomColor();
                        this.drawColor = this.fillColor.darker();
                        this.fillColor.a = 127;
                        this.focalLength = new geom.optics.DynamicValue(f, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                        let b = javaemul.internal.BooleanHelper.parseBoolean(showFoci);
                        this.focus1.setVisible(b);
                        this.focus2.setVisible(b);
                        b = javaemul.internal.BooleanHelper.parseBoolean(showAxis);
                        this.axis.setVisible(b);
                        this.showImagesExpr = showImages;
                        this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                        this.showName = false;
                        this.showEqn = false;
                        if (OpticalIdealLens2D.tmpVertexBufConvex == null) {
                            const h = 1;
                            const w = 0.1;
                            const R = 0.5 * (w * w + h * h) / w;
                            const th0 = Math.asin(h / R);
                            let dth = th0 / 10;
                            let th = -th0;
                            let x = 0;
                            let y = h;
                            let cx = -R + w;
                            OpticalIdealLens2D.tmpVertexBufConvex = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(21);
                            for (let i = 0; i <= 20; i++) {
                                {
                                    x = cx + R * Math.cos(th);
                                    y = R * Math.sin(th);
                                    OpticalIdealLens2D.tmpVertexBufConvex[i] = new math.Vector2(x, y);
                                    th += dth;
                                }
                                ;
                            }
                            th = th0;
                            dth = th0 / 10;
                            cx = -R - w / 2;
                            th = th0;
                            dth = th0 / 10;
                            cx = -R - w / 2;
                            OpticalIdealLens2D.tmpVertexBufConcave = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(12);
                            OpticalIdealLens2D.tmpVertexBufConcave[0] = new math.Vector2(0, h);
                            for (let i = 0; i <= 10; i++) {
                                {
                                    x = cx + R * Math.cos(th);
                                    y = R * Math.sin(th);
                                    OpticalIdealLens2D.tmpVertexBufConcave[i + 1] = new math.Vector2(x, y);
                                    th -= dth;
                                }
                                ;
                            }
                        }
                        this.update();
                    }
                    if (this.focalLength === undefined) {
                        this.focalLength = null;
                    }
                    this.center = new math.Vector2();
                    this.lens = new geom.Segment2D();
                    this.focus1 = new geom.Point2D();
                    this.focus2 = new geom.Point2D();
                    this.axis = new geom.Line2D();
                }
                else
                    throw new Error('invalid overload');
            }
            static TMP_LINE2_$LI$() { if (OpticalIdealLens2D.TMP_LINE2 == null) {
                OpticalIdealLens2D.TMP_LINE2 = new geom.Line2D();
            } return OpticalIdealLens2D.TMP_LINE2; }
            /**
             *
             * @param {geom.ShapesManager} manager
             */
            onAddShapeToSimulation(manager) {
                super.onAddShapeToSimulation(manager);
                this.focalLength.setShapesManager(manager);
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Focal Length", this.params[0], null);
                if (index === 1)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Show Foci", this.focus1.isVisible());
                if (index === 2)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Show Axis", this.axis.isVisible());
                if (index === 3)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Show Images", this.showImagesExpr, null);
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                    this.focalLength.set$java_lang_String(this.params[0]);
                    this.update();
                }
                else if (index === 1) {
                    this.params[1] = (value + "");
                    const b = javaemul.internal.BooleanHelper.parseBoolean(this.params[1]);
                    this.focus1.setVisible(b);
                    this.focus2.setVisible(b);
                }
                else if (index === 2) {
                    this.params[2] = (value + "");
                    const b = javaemul.internal.BooleanHelper.parseBoolean(this.params[2]);
                    this.axis.setVisible(b);
                }
                else if (index === 3) {
                    this.params[3] = (value + "");
                    this.showImagesExpr = this.params[3];
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                }
                this.update();
            }
            update() {
                if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                    this.__isDefined = false;
                    return;
                }
                this.focalLength.update();
                const v1 = this.parents[0].pt;
                const v2 = this.parents[1].pt;
                const f = this.focalLength.getValue();
                if (v1 == null || v2 == null || v1.equals$math_Vector2(v2) || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(f)) {
                    this.__isDefined = false;
                    return;
                }
                this.center.set$math_Vector2(v1);
                this.lens.set$double$double$double$double(2 * v1.x - v2.x, 2 * v1.y - v2.y, 2 * (v2.x - v1.x), 2 * (v2.y - v1.y));
                this.axis.set$double$double$double$double(this.center.x, this.center.y, this.lens.dy, -this.lens.dx);
                this.focus1.set(this.center.x + -this.lens.dy * f, this.center.y + this.lens.dx * f);
                this.focus2.set(this.center.x + this.lens.dy * f, this.center.y - this.lens.dx * f);
                this.__isDefined = true;
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            intersection(ray) {
                return geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(this.lens, ray);
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            getShotType(ray) {
                const rcrosss = (ray.p2.x - ray.p1.x) * (this.lens.p2.y - this.lens.p1.y) - (ray.p2.y - ray.p1.y) * (this.lens.p2.x - this.lens.p1.x);
                if (rcrosss > 0) {
                    return 1;
                }
                if (rcrosss < 0) {
                    return -1;
                }
                return 2;
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} opticalray
             * @return {number}
             */
            shot(opticalray) {
                geom.optics.OpticalDevice2D.TMP_RAY_$LI$().set$geom_Line2D(opticalray);
                const t = this.intersection(geom.optics.OpticalDevice2D.TMP_RAY_$LI$());
                if (t > geom.Shape2D.ACCURACY) {
                    const f = this.focalLength.getValue();
                    geom.optics.OpticalDevice2D.TMP_LINE_$LI$().set$double$double$double$double(this.center.x + -this.lens.dy * 2 * f, this.center.y + this.lens.dx * 2 * f, this.lens.dx, this.lens.dy);
                    OpticalIdealLens2D.TMP_LINE2_$LI$().set$double$double$double$double(this.center.x + this.lens.dy * 2 * f, this.center.y - this.lens.dx * 2 * f, this.lens.dx, this.lens.dy);
                    let twoF_line_near = geom.optics.OpticalDevice2D.TMP_LINE_$LI$();
                    let twoF_line_far = OpticalIdealLens2D.TMP_LINE2_$LI$();
                    if (geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.distanceSquared$double$double(geom.optics.OpticalDevice2D.TMP_LINE_$LI$().x0, geom.optics.OpticalDevice2D.TMP_LINE_$LI$().y0) > geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.distanceSquared$double$double(OpticalIdealLens2D.TMP_LINE2_$LI$().x0, OpticalIdealLens2D.TMP_LINE2_$LI$().y0)) {
                        twoF_line_near = OpticalIdealLens2D.TMP_LINE2_$LI$();
                        twoF_line_far = geom.optics.OpticalDevice2D.TMP_LINE_$LI$();
                    }
                    if (f > 0) {
                        geom.Shape2D.TMP_VEC_$LI$().set$math_Vector2(geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(twoF_line_near.p1, twoF_line_near.p2, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p2));
                        geom.optics.OpticsUtils.addRefractedRay(opticalray, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t), geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(twoF_line_far.p1, twoF_line_far.p2, this.center, geom.Shape2D.TMP_VEC_$LI$()), opticalray.brightness);
                    }
                    else if (f < 0) {
                        geom.Shape2D.TMP_VEC_$LI$().set$math_Vector2(geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(twoF_line_far.p1, twoF_line_far.p2, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p2));
                        geom.Shape2D.TMP_VEC_$LI$().set$math_Vector2(geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(twoF_line_near.p1, twoF_line_near.p2, this.center, geom.Shape2D.TMP_VEC_$LI$()));
                        geom.optics.OpticsUtils.addRefractedRay(opticalray, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t), geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(twoF_line_far.p1, twoF_line_far.p2, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t), geom.Shape2D.TMP_VEC_$LI$()), opticalray.brightness);
                    }
                    else {
                        return 1;
                    }
                    return 2;
                }
                return -1;
            }
            /**
             *
             * @return {number}
             */
            getChildrenCount() {
                return 4;
            }
            /**
             *
             * @param {number} index
             * @return {geom.Shape2D}
             */
            getChild(index) {
                if (index === 0)
                    return this.lens;
                else if (index === 1)
                    return this.focus1;
                else if (index === 2)
                    return this.focus2;
                else if (index === 3)
                    return this.axis;
                return null;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Ideal Lens (f=" + this.params[0] + "m)";
            }
            /**
             *
             * @param {number} index
             * @return {string}
             */
            getChildInfo(index) {
                if (index === 0)
                    return this.getShapeInfo();
                else if (index === 1)
                    return "First Focus of " + this.name;
                else if (index === 2)
                    return "Second Focus of " + this.name;
                else if (index === 3)
                    return "Axis of " + this.name;
                return null;
            }
            /**
             *
             * @param {string} name
             */
            setName(name) {
                super.setName(name);
                this.lens.setName(name);
                this.axis.setName("Axis of " + name);
                this.focus1.setName("Focus1 of " + name);
                this.focus2.setName("Focus2 of " + name);
            }
            /**
             *
             * @param {framework.Renderer} gl
             */
            render(gl) {
                let i = 0;
                const ctx = gl.context;
                ctx.save();
                ctx.translate(this.center.x, this.center.y);
                const th = this.axis.getDirection().getAngleWithPositiveXAxis();
                ctx.rotate(th);
                const f = this.focalLength.getValue();
                if (f === 0) {
                    i = 0;
                }
                else {
                    i = 1;
                    const l = this.lens.getLength();
                    ctx.scale(l * (0.6 - 0.3 * Math.exp(-Math.abs(2 / f))), l / 2);
                    gl.setLineWidth(1);
                    gl.setColors(this.fillColor, this.drawColor);
                    if (f > 0) {
                        ctx.beginPath();
                        ctx.moveTo(OpticalIdealLens2D.tmpVertexBufConvex[0].x, OpticalIdealLens2D.tmpVertexBufConvex[0].y);
                        for (let index = 0; index < OpticalIdealLens2D.tmpVertexBufConvex.length; index++) {
                            let v = OpticalIdealLens2D.tmpVertexBufConvex[index];
                            {
                                ctx.lineTo(v.x, v.y);
                            }
                        }
                        for (let index = 0; index < OpticalIdealLens2D.tmpVertexBufConvex.length; index++) {
                            let v = OpticalIdealLens2D.tmpVertexBufConvex[index];
                            {
                                ctx.lineTo(-v.x, -v.y);
                            }
                        }
                        if (this.drawColor != null)
                            ctx.stroke();
                        if (this.fillColor != null) {
                            ctx.fill();
                        }
                        if (this.drawColor != null) {
                            ctx.stroke();
                        }
                    }
                    else {
                        ctx.beginPath();
                        ctx.moveTo(OpticalIdealLens2D.tmpVertexBufConcave[0].x, OpticalIdealLens2D.tmpVertexBufConcave[0].y);
                        for (let index = 0; index < OpticalIdealLens2D.tmpVertexBufConcave.length; index++) {
                            let v = OpticalIdealLens2D.tmpVertexBufConcave[index];
                            {
                                ctx.lineTo(v.x, v.y);
                            }
                        }
                        for (let index = OpticalIdealLens2D.tmpVertexBufConcave.length - 1; index > 0; index--) {
                            {
                                const v = OpticalIdealLens2D.tmpVertexBufConcave[index];
                                ctx.lineTo(v.x, -v.y);
                            }
                            ;
                        }
                        for (let index = 0; index < OpticalIdealLens2D.tmpVertexBufConcave.length; index++) {
                            let v = OpticalIdealLens2D.tmpVertexBufConcave[index];
                            {
                                ctx.lineTo(-v.x, -v.y);
                            }
                        }
                        for (let index = OpticalIdealLens2D.tmpVertexBufConcave.length - 1; index > 0; index--) {
                            {
                                const v = OpticalIdealLens2D.tmpVertexBufConcave[index];
                                ctx.lineTo(-v.x, v.y);
                            }
                            ;
                        }
                        ctx.closePath();
                        if (this.fillColor != null) {
                            ctx.fill();
                        }
                        if (this.drawColor != null) {
                            ctx.stroke();
                        }
                    }
                }
                ctx.restore();
                gl.drawCircle(this.center.x, this.center.y, 0.1, true, true);
                this.lens.setVisible(false);
                super.render(gl);
                this.lens.setVisible(true);
            }
            /**
             *
             * @param {math.Vector2} pt
             * @return {boolean}
             */
            isSnapped(pt) {
                let b = this.lens.isSnapped(pt);
                if (!b)
                    b = super.isSnapped(pt);
                return b;
            }
            /**
             *
             * @param {math.Vector2} pt
             * @return {number}
             */
            distance(pt) {
                return this.lens.distance(pt);
            }
        }
        OpticalIdealLens2D.tmpVertexBufConvex = null;
        OpticalIdealLens2D.tmpVertexBufConcave = null;
        optics.OpticalIdealLens2D = OpticalIdealLens2D;
        OpticalIdealLens2D["__class"] = "geom.optics.OpticalIdealLens2D";
        OpticalIdealLens2D["__interfaces"] = ["geom.optics.OpticalDevice", "geom.optics.OpticalObserver"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        /**
         * Full constructor used to deserialize path
         *
         * @param {geom.Shape2D[]} pts
         * @param pathInfo
         * @param {java.lang.String[]} params
         * @class
         * @extends geom.optics.OpticalDevice2D
         */
        class OpticalPathShape2D extends geom.optics.OpticalDevice2D {
            constructor(pts, params) {
                if (((pts != null && pts instanceof Array && (pts.length == 0 || pts[0] == null || (pts[0] != null && pts[0] instanceof geom.Shape2D))) || pts === null) && ((params != null && params instanceof Array && (params.length == 0 || params[0] == null || (typeof params[0] === 'string'))) || params === null)) {
                    let __args = arguments;
                    super();
                    this.arcInfo = null;
                    this.vertices = null;
                    this.path = new geom.Path2D();
                    this.mu = new geom.optics.DynamicValue(1.5, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.w = new geom.optics.DynamicValue(0.1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.r = new geom.optics.DynamicValue(0, 0, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.rays2 = (new java.util.ArrayList());
                    if (params.length === 1)
                        params = [params[0], "1.5", "0", "0.1", "false"];
                    this.params = params;
                    this.parents = pts;
                    this.vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(pts.length);
                    this.arcInfo = (s => { let a = []; while (s-- > 0)
                        a.push(false); return a; })(pts.length);
                    for (let i = 0; i < pts.length; i++) {
                        {
                            this.arcInfo[i] = (c => c.charCodeAt == null ? c : c.charCodeAt(0))(params[0].charAt(i)) == '0'.charCodeAt(0) ? false : true;
                        }
                        ;
                    }
                    this.minIntersectionsNeeded = 1;
                    this.mu.set$java_lang_String(params[1]);
                    this.r.set$java_lang_String(params[2]);
                    this.w.set$java_lang_String(params[3]);
                    this.showImagesExpr = params[4];
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                    this.fillColor = framework.Preferences.getRandomColor();
                    this.drawColor = this.fillColor.brighter();
                    this.fillColor.a = 127;
                    this.path.setDrawColor(this.drawColor);
                    this.path.setFillColor(this.fillColor);
                    this.update();
                }
                else if (pts === undefined && params === undefined) {
                    let __args = arguments;
                    super();
                    this.arcInfo = null;
                    this.vertices = null;
                    this.path = new geom.Path2D();
                    this.mu = new geom.optics.DynamicValue(1.5, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.w = new geom.optics.DynamicValue(0.1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.r = new geom.optics.DynamicValue(0, 0, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.rays2 = (new java.util.ArrayList());
                    this.path = new geom.Path2D();
                }
                else
                    throw new Error('invalid overload');
            }
            static TMP_SEGMENT_$LI$() { if (OpticalPathShape2D.TMP_SEGMENT == null) {
                OpticalPathShape2D.TMP_SEGMENT = new geom.Segment2D();
            } return OpticalPathShape2D.TMP_SEGMENT; }
            static TMP_SHOT_DATA_$LI$() { if (OpticalPathShape2D.TMP_SHOT_DATA == null) {
                OpticalPathShape2D.TMP_SHOT_DATA = new geom.optics.ShotData();
            } return OpticalPathShape2D.TMP_SHOT_DATA; }
            static TMP_RAY2_$LI$() { if (OpticalPathShape2D.TMP_RAY2 == null) {
                OpticalPathShape2D.TMP_RAY2 = new geom.Ray2D();
            } return OpticalPathShape2D.TMP_RAY2; }
            /**
             *
             * @param {geom.ShapesManager} manager
             */
            onAddShapeToSimulation(manager) {
                super.onAddShapeToSimulation(manager);
                this.mu.setShapesManager(manager);
                this.r.setShapesManager(manager);
                this.w.setShapesManager(manager);
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Refractive Index", this.params[1], null);
                if (index === 1)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Reflectivity", this.params[2], null);
                if (index === 2)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Dispersive power", this.params[3], null);
                if (index === 3)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Show Images", this.showImagesExpr, null);
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[1] = (value + "");
                    this.mu.set$java_lang_String(this.params[1]);
                }
                else if (index === 1) {
                    this.params[2] = (value + "");
                    this.r.set$java_lang_String(this.params[2]);
                }
                else if (index === 2) {
                    this.params[3] = (value + "");
                    this.w.set$java_lang_String(this.params[3]);
                }
                else if (index === 3) {
                    this.params[4] = (value + "");
                    this.showImagesExpr = this.params[4];
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                }
            }
            /**
             *
             */
            update() {
                this.path.update();
                if (this.parents.length < 2)
                    return;
                for (let index = 0; index < this.parents.length; index++) {
                    let p = this.parents[index];
                    {
                        if (!p.isDefined())
                            return;
                    }
                }
                for (let i = 0; i < this.vertices.length; i++) {
                    {
                        this.vertices[i] = this.parents[i].pt;
                    }
                    ;
                }
                this.path.createPath(this.vertices, this.arcInfo);
                if (!this.path.isDefined() || this.mu == null)
                    return;
                this.__isDefined = true;
                this.mu.update();
                if (this.fillColor != null)
                    this.fillColor.a = ((Math.log(this.mu.getValue()) / Math.log(1.5) * 0.2 * 255) | 0);
                this.w.update();
                this.r.update();
            }
            /**
             *
             */
            beginObserve() {
                this.rays.clear();
                this.rays2.clear();
                if (this.showImagesExpr != null)
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
            }
            /**
             * Find all images for the rays received by this observer
             */
            endObserve() {
                this.images.clear();
                if (this.showImages) {
                    geom.optics.OpticsUtils.findImages(this, this.rays, this.images, true, this.minIntersectionsNeeded);
                    geom.optics.OpticsUtils.findImages(this, this.rays2, this.images, true, this.minIntersectionsNeeded);
                }
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} ray
             * @param {boolean} reflected
             */
            addRayToObserve(ray, reflected) {
                if (this.showImages) {
                    ray.device = OpticalPathShape2D.tmp_refractor;
                    if (reflected)
                        this.rays2.add(ray);
                    else
                        this.rays.add(ray);
                }
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            intersection(ray) {
                let t0 = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                let t = 0;
                for (let index = this.path.getCurves().iterator(); index.hasNext();) {
                    let c = index.next();
                    {
                        if (c != null && c instanceof geom.Line2D) {
                            t = geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(c, ray);
                        }
                        else {
                            const ts = geom.optics.OpticsUtils.intersection$geom_Circle2D$geom_Ray2D(c, ray);
                            t = (ts == null ? -1 : ts[0]);
                        }
                        if (t > geom.Shape2D.ACCURACY && t < t0) {
                            t0 = t;
                            OpticalPathShape2D.tmp_refractor = c;
                        }
                    }
                }
                return t0 === javaemul.internal.DoubleHelper.POSITIVE_INFINITY ? -1 : t0;
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            getShotType(ray) {
                return OpticalPathShape2D.TMP_SHOT_DATA_$LI$().shotType;
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} opticalray
             * @return {number}
             */
            shot(opticalray) {
                if (this.mu.getValue() === 0)
                    return 0;
                geom.optics.OpticalDevice2D.TMP_RAY_$LI$().set$geom_Line2D(opticalray);
                const t = this.intersection(geom.optics.OpticalDevice2D.TMP_RAY_$LI$());
                if (t > geom.Shape2D.ACCURACY) {
                    this.getShotData(geom.optics.OpticalDevice2D.TMP_RAY_$LI$());
                    const rp = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t);
                    const normal = OpticalPathShape2D.TMP_SHOT_DATA_$LI$().normal;
                    let shotType = OpticalPathShape2D.TMP_SHOT_DATA_$LI$().shotType;
                    let n1 = 1;
                    let mu = this.mu.getValue();
                    const w = this.w.getValue();
                    if (w !== 0) {
                        mu = mu - w * (mu - 1) * (opticalray.waveLength - 500) / 400;
                    }
                    if (shotType === 1) {
                        n1 = mu;
                    }
                    else if (shotType === -1) {
                        n1 = 1 / mu;
                    }
                    else {
                        return 0;
                    }
                    if (this.shapesManager.surfaceMergingObjects.size() > 0) {
                        for (let index = this.shapesManager.surfaceMergingObjects.iterator(); index.hasNext();) {
                            let refractor = index.next();
                            {
                                shotType = refractor.getShotType(opticalray);
                                if (shotType === 1) {
                                    n1 /= refractor.getRefractiveIndex();
                                }
                                else if (shotType === -1) {
                                    n1 *= refractor.getRefractiveIndex();
                                }
                                else if (shotType === 0) {
                                }
                                else {
                                    return 0;
                                }
                            }
                        }
                    }
                    return geom.optics.OpticsUtils.refract(opticalray, geom.optics.OpticalDevice2D.TMP_RAY_$LI$(), rp, normal, n1, this.r.getValue());
                }
                return -1;
            }
            /*private*/ getShotData(ray) {
                let s_lensq = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                let s_lensq_temp = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                let s_point = null;
                let s_point_temp = new math.Vector2();
                let surfaceMultiplicity = 1;
                let rp_temp = null;
                let rp2_temp = null;
                let normal_x = 0;
                let normal_x_temp = 0;
                let normal_y = 0;
                let normal_y_temp = 0;
                let rdots;
                let ssq;
                let nearEdge = false;
                let nearEdge_temp = false;
                let p1 = null;
                let p3 = null;
                let center = null;
                OpticalPathShape2D.TMP_RAY2_$LI$().set$math_Vector2$math_Vector2(ray.p1, geom.Shape2D.TMP_VEC_$LI$().set$double$double(ray.p2.x + Math.random() * 1.0E-5, ray.p2.y + Math.random() * 1.0E-5));
                const ray2 = OpticalPathShape2D.TMP_RAY2_$LI$();
                let ray_intersect_count = 0;
                for (let index = this.path.getCurves().iterator(); index.hasNext();) {
                    let c = index.next();
                    {
                        s_point_temp = null;
                        nearEdge_temp = false;
                        if (c != null && c instanceof geom.CircleArc2D) {
                            const arc = c;
                            p1 = c.firstPoint();
                            p3 = c.lastPoint();
                            if (c.isDefined()) {
                                center = arc.center();
                                const ts = geom.optics.OpticsUtils.intersection$geom_Circle2D$geom_Ray2D(arc, ray);
                                if (ts != null) {
                                    s_point_temp = ray.point(ts[0]);
                                    s_lensq_temp = s_point_temp.distanceSquared$math_Vector2(ray.p1);
                                    let inToOut;
                                    const PR = ray.p1.distance$double$double(arc.cx, arc.cy);
                                    if (PR < arc.radius()) {
                                        inToOut = true;
                                        ray_intersect_count++;
                                    }
                                    else {
                                        inToOut = PR > ray.p1.distance$math_Vector2(s_point_temp);
                                        ray_intersect_count += ts.length;
                                    }
                                    if (inToOut) {
                                        normal_x_temp = s_point_temp.x - center.x;
                                        normal_y_temp = s_point_temp.y - center.y;
                                    }
                                    else {
                                        normal_x_temp = center.x - s_point_temp.x;
                                        normal_y_temp = center.y - s_point_temp.y;
                                    }
                                    if (s_point_temp.distance$math_Vector2(p1) < geom.Shape2D.ACCURACY || s_point_temp.distance$math_Vector2(p3) < geom.Shape2D.ACCURACY) {
                                        nearEdge_temp = true;
                                    }
                                }
                            }
                            else {
                                OpticalPathShape2D.TMP_SEGMENT_$LI$().set$math_Vector2$math_Vector2(p1, p3);
                                c = OpticalPathShape2D.TMP_SEGMENT_$LI$();
                            }
                        }
                        if (c != null && c instanceof geom.Line2D) {
                            const line = c;
                            const t = geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(line, ray);
                            const t2 = geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(line, ray2);
                            rp_temp = null;
                            rp2_temp = null;
                            if (t > geom.Shape2D.ACCURACY)
                                rp_temp = ray.point(t);
                            if (t2 > geom.Shape2D.ACCURACY)
                                rp2_temp = ray2.point(t2);
                            if (rp_temp != null) {
                                s_lensq_temp = rp_temp.distanceSquared$math_Vector2(ray.p1);
                                s_point_temp = rp_temp;
                                rdots = (ray.p2.x - ray.p1.x) * line.dx + (ray.p2.y - ray.p1.y) * line.dy;
                                ssq = math.MathUtils.hypot(line.dx, line.dy);
                                normal_x_temp = rdots * (line.dx) - ssq * (ray.p2.x - ray.p1.x);
                                normal_y_temp = rdots * (line.dy) - ssq * (ray.p2.y - ray.p1.y);
                            }
                            if (rp2_temp != null) {
                                ray_intersect_count++;
                            }
                            if (s_point_temp != null && (line.p1.distance$math_Vector2(s_point_temp) < geom.Shape2D.ACCURACY || line.p2.distance$math_Vector2(s_point_temp) < geom.Shape2D.ACCURACY)) {
                                nearEdge_temp = true;
                            }
                        }
                        else {
                        }
                        if (s_point_temp != null) {
                            if (s_point != null && s_point_temp.distance$math_Vector2(s_point) < geom.Shape2D.ACCURACY) {
                                surfaceMultiplicity++;
                            }
                            else if (s_lensq_temp < s_lensq) {
                                s_lensq = s_lensq_temp;
                                s_point = s_point_temp;
                                normal_x = normal_x_temp;
                                normal_y = normal_y_temp;
                                nearEdge = nearEdge_temp;
                                surfaceMultiplicity = 1;
                            }
                        }
                    }
                }
                let shotType;
                if (nearEdge) {
                    shotType = 2;
                }
                else if (surfaceMultiplicity % 2 === 0) {
                    shotType = 0;
                }
                else if (ray_intersect_count % 2 === 1) {
                    shotType = 1;
                }
                else {
                    shotType = -1;
                }
                return OpticalPathShape2D.TMP_SHOT_DATA_$LI$().set(s_point, geom.Shape2D.TMP_VEC_$LI$().set$double$double(normal_x, normal_y).getNormalized(), shotType);
            }
            /**
             *
             * @return {number}
             */
            getChildrenCount() {
                return 1;
            }
            /**
             *
             * @param {number} index
             * @return {geom.Shape2D}
             */
            getChild(index) {
                if (index === 0)
                    return this.path;
                return null;
            }
            /**
             *
             * @param {number} index
             * @return {string}
             */
            getChildInfo(index) {
                if (index === 0)
                    return this.getShapeInfo();
                return null;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Surface";
            }
            /**
             *
             * @return {number}
             */
            getRefractiveIndex() {
                return this.mu.getValue();
            }
            /**
             *
             * @return {number}
             */
            getDispersivePower() {
                return this.w.getValue();
            }
            /**
             *
             * @return {number}
             */
            getReflectiveIndex() {
                return this.r.getValue();
            }
        }
        OpticalPathShape2D.tmp_refractor = null;
        optics.OpticalPathShape2D = OpticalPathShape2D;
        OpticalPathShape2D["__class"] = "geom.optics.OpticalPathShape2D";
        OpticalPathShape2D["__interfaces"] = ["geom.optics.OpticalDevice", "geom.optics.OpticalObserver", "geom.optics.OpticalRefractor"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalIdealMirror2D extends geom.optics.OpticalDevice2D {
            constructor(pole, endPoint, f, showFoci, showAxis, showImages) {
                if (((pole != null && pole instanceof geom.Point2D) || pole === null) && ((endPoint != null && endPoint instanceof geom.Point2D) || endPoint === null) && ((typeof f === 'string') || f === null) && ((typeof showFoci === 'string') || showFoci === null) && ((typeof showAxis === 'string') || showAxis === null) && ((typeof showImages === 'string') || showImages === null)) {
                    let __args = arguments;
                    super();
                    if (this.focalLength === undefined) {
                        this.focalLength = null;
                    }
                    this.center = new math.Vector2();
                    this.mirror = new geom.Segment2D();
                    this.arc = new geom.CircleArc2D();
                    this.focus = new geom.Point2D();
                    this.axis = new geom.Line2D();
                    this.parents = [pole, endPoint];
                    this.params = [f, showFoci, showAxis, showImages];
                    this.minIntersectionsNeeded = 1;
                    OpticalIdealMirror2D.TMP_LINE2_$LI$().setVisible(false);
                    this.axis.setDrawPattern(geom.Shape2D.DrawMode.DASHED);
                    this.fillColor = framework.Preferences.getRandomColor();
                    this.drawColor = this.fillColor.darker();
                    this.fillColor.a = 127;
                    this.focalLength = new geom.optics.DynamicValue(f, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    let b = javaemul.internal.BooleanHelper.parseBoolean(showFoci);
                    this.focus.setVisible(b);
                    b = javaemul.internal.BooleanHelper.parseBoolean(showAxis);
                    this.axis.setVisible(b);
                    this.showImagesExpr = showImages;
                    this.showImages = math.MathUtils.evaluateBoolean(showImages);
                    this.showName = false;
                    this.showEqn = false;
                    if (OpticalIdealMirror2D.tmpVertexBufConvex == null || true) {
                        const h = 1;
                        const w = 0.1;
                        const R = 0.5 * (w * w + h * h) / w;
                        const th0 = Math.asin(h / R);
                        const dth = th0 / 10;
                        let th = -th0;
                        let x = 0;
                        let y = h;
                        const cx = -R;
                        OpticalIdealMirror2D.tmpVertexBufConvex = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(21);
                        for (let i = 0; i <= 20; i++) {
                            {
                                x = cx + R * Math.cos(th);
                                y = R * Math.sin(th);
                                OpticalIdealMirror2D.tmpVertexBufConvex[i] = new math.Vector2(x, y);
                                th += dth;
                            }
                            ;
                        }
                    }
                    this.update();
                }
                else if (((pole != null && pole instanceof geom.Point2D) || pole === null) && ((endPoint != null && endPoint instanceof geom.Point2D) || endPoint === null) && f === undefined && showFoci === undefined && showAxis === undefined && showImages === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let f = "3";
                        let showFoci = "true";
                        let showAxis = "true";
                        let showImages = "true";
                        super();
                        if (this.focalLength === undefined) {
                            this.focalLength = null;
                        }
                        this.center = new math.Vector2();
                        this.mirror = new geom.Segment2D();
                        this.arc = new geom.CircleArc2D();
                        this.focus = new geom.Point2D();
                        this.axis = new geom.Line2D();
                        this.parents = [pole, endPoint];
                        this.params = [f, showFoci, showAxis, showImages];
                        this.minIntersectionsNeeded = 1;
                        OpticalIdealMirror2D.TMP_LINE2_$LI$().setVisible(false);
                        this.axis.setDrawPattern(geom.Shape2D.DrawMode.DASHED);
                        this.fillColor = framework.Preferences.getRandomColor();
                        this.drawColor = this.fillColor.darker();
                        this.fillColor.a = 127;
                        this.focalLength = new geom.optics.DynamicValue(f, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                        let b = javaemul.internal.BooleanHelper.parseBoolean(showFoci);
                        this.focus.setVisible(b);
                        b = javaemul.internal.BooleanHelper.parseBoolean(showAxis);
                        this.axis.setVisible(b);
                        this.showImagesExpr = showImages;
                        this.showImages = math.MathUtils.evaluateBoolean(showImages);
                        this.showName = false;
                        this.showEqn = false;
                        if (OpticalIdealMirror2D.tmpVertexBufConvex == null || true) {
                            const h = 1;
                            const w = 0.1;
                            const R = 0.5 * (w * w + h * h) / w;
                            const th0 = Math.asin(h / R);
                            const dth = th0 / 10;
                            let th = -th0;
                            let x = 0;
                            let y = h;
                            const cx = -R;
                            OpticalIdealMirror2D.tmpVertexBufConvex = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(21);
                            for (let i = 0; i <= 20; i++) {
                                {
                                    x = cx + R * Math.cos(th);
                                    y = R * Math.sin(th);
                                    OpticalIdealMirror2D.tmpVertexBufConvex[i] = new math.Vector2(x, y);
                                    th += dth;
                                }
                                ;
                            }
                        }
                        this.update();
                    }
                    if (this.focalLength === undefined) {
                        this.focalLength = null;
                    }
                    this.center = new math.Vector2();
                    this.mirror = new geom.Segment2D();
                    this.arc = new geom.CircleArc2D();
                    this.focus = new geom.Point2D();
                    this.axis = new geom.Line2D();
                }
                else
                    throw new Error('invalid overload');
            }
            static TMP_LINE2_$LI$() { if (OpticalIdealMirror2D.TMP_LINE2 == null) {
                OpticalIdealMirror2D.TMP_LINE2 = new geom.Line2D();
            } return OpticalIdealMirror2D.TMP_LINE2; }
            /**
             *
             * @param {geom.ShapesManager} manager
             */
            onAddShapeToSimulation(manager) {
                super.onAddShapeToSimulation(manager);
                this.focalLength.setShapesManager(manager);
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Focal Length", this.params[0], null);
                if (index === 1)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Show Foci", this.focus.isVisible());
                if (index === 2)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Show Axis", this.axis.isVisible());
                else if (index === 3)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Show Images", this.showImagesExpr, null);
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                    this.focalLength.set$java_lang_String(this.params[0]);
                    this.update();
                }
                else if (index === 1) {
                    this.params[1] = (value + "");
                    const b = javaemul.internal.BooleanHelper.parseBoolean(this.params[1]);
                    this.focus.setVisible(b);
                }
                else if (index === 2) {
                    this.params[2] = (value + "");
                    const b = javaemul.internal.BooleanHelper.parseBoolean(this.params[2]);
                    this.axis.setVisible(b);
                    this.update();
                }
                else if (index === 3) {
                    this.params[3] = (value + "");
                    this.showImagesExpr = this.params[3];
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                }
            }
            update() {
                if (!this.mirror.isDefined()) {
                    this.__isDefined = false;
                    return;
                }
                this.focalLength.update();
                const v1 = this.parents[0].pt;
                const v2 = this.parents[1].pt;
                if (v1 == null || v2 == null || v1.equals$math_Vector2(v2) || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(this.focalLength.getValue())) {
                    this.__isDefined = false;
                    return;
                }
                this.center.set$math_Vector2(v1);
                this.mirror.set$double$double$double$double(2 * v1.x - v2.x, 2 * v1.y - v2.y, 2 * (v2.x - v1.x), 2 * (v2.y - v1.y));
                this.axis.set$double$double$double$double(this.center.x, this.center.y, this.mirror.dy, -this.mirror.dx);
                const f = this.focalLength.getValue();
                const sx = -(f => { if (f > 0) {
                    return 1;
                }
                else if (f < 0) {
                    return -1;
                }
                else {
                    return 0;
                } })(f) * 0.1 * this.mirror.getLength() * (0.6 - 0.3 * Math.exp(-Math.abs(2 / f)));
                this.createArc(this.mirror.p1.sum$double$double(this.axis.dx * sx, this.axis.dy * sx), v1, this.mirror.p2.sum$double$double(this.axis.dx * sx, this.axis.dy * sx));
                this.focus.set(this.center.x + -this.mirror.dy * this.focalLength.getValue(), this.center.y + this.mirror.dx * this.focalLength.getValue());
                this.__isDefined = true;
            }
            /*private*/ createArc(p1, p2, p3) {
                const l1 = new geom.Line2D(new math.Vector2((p1.x + p2.x) / 2, (p1.y + p2.y) / 2), p1.to$math_Vector2(p2).right());
                const l2 = new geom.Line2D(new math.Vector2((p2.x + p3.x) / 2, (p2.y + p3.y) / 2), p2.to$math_Vector2(p3).right());
                const inter = geom.CurveUtils.LineLineIntersection$geom_Line2D$geom_Line2D(l1, l2);
                if (inter == null) {
                    this.arc.set(this.arc.cx, this.arc.cy, javaemul.internal.DoubleHelper.POSITIVE_INFINITY);
                    return;
                }
                const c = inter[0];
                const r = c.distance$math_Vector2(p1);
                const a1 = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(c, p1);
                const a2 = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(c, p2);
                const a3 = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(c, p3);
                this.arc.set$double$double$double$double$double$boolean(c.x, c.y, r, a1, a3, geom.AngleUtils.containsAngle$double$double$double(a1, a3, a2));
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} opticalray
             * @return {number}
             */
            shot(opticalray) {
                geom.optics.OpticalDevice2D.TMP_RAY_$LI$().set$geom_Line2D(opticalray);
                if (this.getShotType(geom.optics.OpticalDevice2D.TMP_RAY_$LI$()) !== 1)
                    return 0;
                const t = geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(this.mirror, geom.optics.OpticalDevice2D.TMP_RAY_$LI$());
                const f = this.focalLength.getValue();
                if (t > geom.Shape2D.ACCURACY) {
                    const rp = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t);
                    geom.optics.OpticalDevice2D.TMP_LINE_$LI$().set$double$double$double$double(this.center.x + -this.mirror.dy * 2 * f, this.center.y + this.mirror.dx * 2 * f, this.mirror.dx, this.mirror.dy);
                    OpticalIdealMirror2D.TMP_LINE2_$LI$().set$double$double$double$double(this.center.x + this.mirror.dy * 2 * f, this.center.y - this.mirror.dx * 2 * f, this.mirror.dx, this.mirror.dy);
                    let twoF_line_near = geom.optics.OpticalDevice2D.TMP_LINE_$LI$();
                    let twoF_line_far = OpticalIdealMirror2D.TMP_LINE2_$LI$();
                    if (geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.distanceSquared$double$double(geom.optics.OpticalDevice2D.TMP_LINE_$LI$().x0, geom.optics.OpticalDevice2D.TMP_LINE_$LI$().y0) > geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.distanceSquared$double$double(OpticalIdealMirror2D.TMP_LINE2_$LI$().x0, OpticalIdealMirror2D.TMP_LINE2_$LI$().y0)) {
                        twoF_line_near = OpticalIdealMirror2D.TMP_LINE2_$LI$();
                        twoF_line_far = geom.optics.OpticalDevice2D.TMP_LINE_$LI$();
                    }
                    if (f < 0) {
                        geom.Shape2D.TMP_VEC_$LI$().set$math_Vector2(geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(twoF_line_near.p1, twoF_line_near.p2, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p2));
                        geom.optics.OpticalDevice2D.TMP_RAY_$LI$().set$math_Vector2$math_Vector2(rp, geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(twoF_line_far.p1, twoF_line_far.p2, this.center, geom.Shape2D.TMP_VEC_$LI$()));
                    }
                    else if (f > 0) {
                        geom.Shape2D.TMP_VEC_$LI$().set$math_Vector2(geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(twoF_line_far.p1, twoF_line_far.p2, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p2));
                        geom.Shape2D.TMP_VEC_$LI$().set$math_Vector2(geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(twoF_line_near.p1, twoF_line_near.p2, this.center, geom.Shape2D.TMP_VEC_$LI$()));
                        geom.optics.OpticalDevice2D.TMP_RAY_$LI$().set$math_Vector2$math_Vector2(rp, geom.CurveUtils.LineLineIntersection$math_Vector2$math_Vector2$math_Vector2$math_Vector2(twoF_line_far.p1, twoF_line_far.p2, geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t), geom.Shape2D.TMP_VEC_$LI$()));
                    }
                    geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.x = 2 * geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.x - geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p2.x;
                    geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.y = 2 * geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.y - geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p2.y;
                    const rx = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.x - rp.x;
                    const ry = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.y - rp.y;
                    const mx = this.mirror.p2.x - this.mirror.p1.x;
                    const my = this.mirror.p2.y - this.mirror.p1.y;
                    geom.Shape2D.TMP_VEC_$LI$().set$double$double(rp.x + rx * (my * my - mx * mx) - 2 * ry * mx * my, rp.y + ry * (mx * mx - my * my) - 2 * rx * mx * my);
                    geom.optics.OpticsUtils.addReflectedRay(opticalray, rp, geom.Shape2D.TMP_VEC_$LI$(), opticalray.brightness);
                    return 1;
                }
                return -1;
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            intersection(ray) {
                if (!this.arc.isDefined() || true)
                    return geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(this.mirror, ray);
                const ts = geom.optics.OpticsUtils.intersection$geom_Circle2D$geom_Ray2D(this.arc, ray);
                return ts == null ? -1 : ts[0];
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            getShotType(ray) {
                const rcrosss = (ray.p2.x - ray.p1.x) * (this.mirror.p2.y - this.mirror.p1.y) - (ray.p2.y - ray.p1.y) * (this.mirror.p2.x - this.mirror.p1.x);
                if (rcrosss > 0) {
                    return 2;
                }
                if (rcrosss < 0) {
                    return 1;
                }
                return 2;
            }
            /**
             *
             * @return {number}
             */
            getChildrenCount() {
                return 3;
            }
            /**
             *
             * @param {number} index
             * @return {geom.Shape2D}
             */
            getChild(index) {
                if (index === 0)
                    return this.arc.isDefined() ? this.arc : this.mirror;
                else if (index === 1)
                    return this.focus;
                else if (index === 2)
                    return this.axis;
                return null;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Mirror " + this.name + "(f=" + this.params[0] + "m)";
            }
            /**
             *
             * @param {number} index
             * @return {string}
             */
            getChildInfo(index) {
                if (index === 0)
                    return this.getShapeInfo();
                else if (index === 1)
                    return "Focus of " + this.name;
                if (index === 2)
                    return "Axis of " + this.name;
                return null;
            }
            /**
             *
             * @param {framework.Renderer} gl
             */
            render(gl) {
                let i = 0;
                const ctx = gl.context;
                ctx.save();
                ctx.translate(this.center.x, this.center.y);
                const th = this.axis.getDirection().getAngleWithPositiveXAxis();
                ctx.rotate(th);
                const f = this.focalLength.getValue();
                const l = this.mirror.getLength();
                if (f === 0) {
                    i = 0;
                    ctx.scale(1, l / 2);
                    if (this.fillColor != null) {
                        const dx = 5 / gl.METER_TO_PIXEL / l;
                        ctx.translate(-dx, 0);
                        gl.setColors(this.fillColor, this.fillColor);
                        gl.setLineWidth(7);
                        gl.drawLine(0, -1, 0, 1);
                        gl.setLineWidth(1);
                        ctx.translate(dx, 0);
                    }
                    if (this.drawColor != null) {
                        gl.setColors(this.fillColor, this.drawColor);
                        gl.drawLine(0, -1, 0, 1);
                    }
                }
                else {
                    this.arc.setFillColor(null);
                    i = 1;
                    ctx.scale(l * (0.6 - 0.3 * Math.exp(-Math.abs(2 / f))), l / 2);
                    if (f > 0) {
                        if (this.fillColor != null) {
                            const dx = 3.5 / gl.scaleFactor;
                            ctx.translate(-dx, 0);
                            gl.setColors(this.fillColor, this.fillColor);
                            gl.setLineWidth(7);
                            ctx.beginPath();
                            ctx.moveTo(OpticalIdealMirror2D.tmpVertexBufConvex[0].x, OpticalIdealMirror2D.tmpVertexBufConvex[0].y);
                            for (let index = 0; index < OpticalIdealMirror2D.tmpVertexBufConvex.length; index++) {
                                let v = OpticalIdealMirror2D.tmpVertexBufConvex[index];
                                {
                                    ctx.lineTo(v.x, v.y);
                                }
                            }
                            ctx.stroke();
                            ctx.translate(dx, 0);
                        }
                        if (this.drawColor != null) {
                            gl.setLineWidth(1.5);
                            gl.setColors(null, this.drawColor);
                            ctx.beginPath();
                            ctx.moveTo(OpticalIdealMirror2D.tmpVertexBufConvex[0].x, OpticalIdealMirror2D.tmpVertexBufConvex[0].y);
                            for (let index = 0; index < OpticalIdealMirror2D.tmpVertexBufConvex.length; index++) {
                                let v = OpticalIdealMirror2D.tmpVertexBufConvex[index];
                                {
                                    ctx.lineTo(v.x, v.y);
                                }
                            }
                            ctx.stroke();
                        }
                    }
                    else {
                        ctx.scale(-1, 1);
                        if (this.fillColor != null) {
                            const dx = 5 / gl.scaleFactor;
                            ctx.translate(dx, 0);
                            gl.setColors(this.fillColor, this.fillColor);
                            gl.setLineWidth(7);
                            ctx.beginPath();
                            ctx.moveTo(OpticalIdealMirror2D.tmpVertexBufConvex[0].x, OpticalIdealMirror2D.tmpVertexBufConvex[0].y);
                            for (let index = 0; index < OpticalIdealMirror2D.tmpVertexBufConvex.length; index++) {
                                let v = OpticalIdealMirror2D.tmpVertexBufConvex[index];
                                {
                                    ctx.lineTo(v.x, v.y);
                                }
                            }
                            ctx.stroke();
                            ctx.translate(-dx, 0);
                        }
                        if (this.drawColor != null) {
                            gl.setLineWidth(1.5);
                            gl.setColors(null, this.drawColor);
                            ctx.beginPath();
                            ctx.moveTo(OpticalIdealMirror2D.tmpVertexBufConvex[0].x, OpticalIdealMirror2D.tmpVertexBufConvex[0].y);
                            for (let index = 0; index < OpticalIdealMirror2D.tmpVertexBufConvex.length; index++) {
                                let v = OpticalIdealMirror2D.tmpVertexBufConvex[index];
                                {
                                    ctx.lineTo(v.x, v.y);
                                }
                            }
                            ctx.stroke();
                        }
                        ctx.scale(-1, 1);
                    }
                }
                ctx.restore();
                super.render(gl);
            }
            /**
             *
             * @param {math.Vector2} pt
             * @return {boolean}
             */
            isSnapped(pt) {
                return super.isSnapped(pt);
            }
            /**
             *
             * @param {math.Vector2} pt
             * @return {number}
             */
            distance(pt) {
                return this.mirror.distance(pt);
            }
        }
        OpticalIdealMirror2D.tmpVertexBufConvex = null;
        optics.OpticalIdealMirror2D = OpticalIdealMirror2D;
        OpticalIdealMirror2D["__class"] = "geom.optics.OpticalIdealMirror2D";
        OpticalIdealMirror2D["__interfaces"] = ["geom.optics.OpticalDevice", "geom.optics.OpticalObserver"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        /**
         * Ideal Plane Mirror
         * @author maheshkurmi
         * @param {geom.Point2D} p1
         * @param {geom.Point2D} p2
         * @param {string} showImages
         * @class
         * @extends geom.optics.OpticalDevice2D
         */
        class OpticalPlaneMirror2D extends geom.optics.OpticalDevice2D {
            constructor(p1, p2, showImages) {
                if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((typeof showImages === 'string') || showImages === null)) {
                    let __args = arguments;
                    super();
                    if (this.mirror === undefined) {
                        this.mirror = null;
                    }
                    this.mirror = new geom.Segment2Points2D(p1, p2);
                    this.parents = this.mirror.getParents();
                    this.params = [showImages];
                    this.minIntersectionsNeeded = 1;
                    this.fillColor = framework.Preferences.getRandomColor();
                    this.drawColor = this.fillColor.darker();
                    this.fillColor.a = 128;
                    this.showImagesExpr = showImages;
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                    this.update();
                }
                else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && showImages === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let showImages = "true";
                        super();
                        if (this.mirror === undefined) {
                            this.mirror = null;
                        }
                        this.mirror = new geom.Segment2Points2D(p1, p2);
                        this.parents = this.mirror.getParents();
                        this.params = [showImages];
                        this.minIntersectionsNeeded = 1;
                        this.fillColor = framework.Preferences.getRandomColor();
                        this.drawColor = this.fillColor.darker();
                        this.fillColor.a = 128;
                        this.showImagesExpr = showImages;
                        this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                        this.update();
                    }
                    if (this.mirror === undefined) {
                        this.mirror = null;
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Show Images", this.showImagesExpr, null);
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                    this.showImagesExpr = this.params[0];
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                }
            }
            /**
             *
             */
            update() {
                this.mirror.update();
                this.__isDefined = this.mirror.isDefined();
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} opticalray
             * @return {number}
             */
            shot(opticalray) {
                geom.optics.OpticalDevice2D.TMP_RAY_$LI$().set$geom_Line2D(opticalray);
                const t = geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(this.mirror, geom.optics.OpticalDevice2D.TMP_RAY_$LI$());
                if (t > geom.Shape2D.ACCURACY) {
                    const shotType = this.getShotType(geom.optics.OpticalDevice2D.TMP_RAY_$LI$());
                    if (shotType === 1) {
                        return 0;
                    }
                    else if (shotType === -1) {
                        const rp = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t);
                        const rx = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.x - rp.x;
                        const ry = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.y - rp.y;
                        const mx = this.mirror.p2.x - this.mirror.p1.x;
                        const my = this.mirror.p2.y - this.mirror.p1.y;
                        geom.Shape2D.TMP_VEC_$LI$().set$double$double(rp.x + rx * (my * my - mx * mx) - 2 * ry * mx * my, rp.y + ry * (mx * mx - my * my) - 2 * rx * mx * my);
                        geom.optics.OpticsUtils.addReflectedRay(opticalray, rp, geom.Shape2D.TMP_VEC_$LI$(), opticalray.brightness);
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
                return -1;
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            intersection(ray) {
                return geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(this.mirror, ray);
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            getShotType(ray) {
                const rcrosss = (ray.p2.x - ray.p1.x) * (this.mirror.p2.y - this.mirror.p1.y) - (ray.p2.y - ray.p1.y) * (this.mirror.p2.x - this.mirror.p1.x);
                if (rcrosss > 0) {
                    return -1;
                }
                if (rcrosss < 0) {
                    return 1;
                }
                return 0;
            }
            /**
             *
             * @param {framework.Renderer} gl
             */
            render(gl) {
                if (this.fillColor != null) {
                    const dt = 4 / gl.METER_TO_PIXEL;
                    const dx = dt * this.mirror.dy;
                    const dy = -dt * this.mirror.dx;
                    const ctx = gl.context;
                    ctx.save();
                    ctx.translate(dx, dy);
                    gl.setColors(this.fillColor, this.fillColor);
                    gl.setLineWidth(7);
                    gl.drawLine(this.mirror.p1.x, this.mirror.p1.y, this.mirror.p2.x, this.mirror.p2.y);
                    ctx.restore();
                }
                super.render(gl);
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Plane Mirror " + this.name;
            }
            /**
             *
             * @return {number}
             */
            getChildrenCount() {
                return 1;
            }
            /**
             *
             * @param {number} index
             * @return {geom.Shape2D}
             */
            getChild(index) {
                if (index === 0)
                    return this.mirror;
                return null;
            }
        }
        optics.OpticalPlaneMirror2D = OpticalPlaneMirror2D;
        OpticalPlaneMirror2D["__class"] = "geom.optics.OpticalPlaneMirror2D";
        OpticalPlaneMirror2D["__interfaces"] = ["geom.optics.OpticalDevice", "geom.optics.OpticalObserver"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalBlocker2D extends geom.optics.OpticalDevice2D {
            constructor(p1, p2) {
                super();
                if (this.segment === undefined) {
                    this.segment = null;
                }
                this.segment = new geom.Segment2Points2D(p1, p2);
                this.parents = this.segment.getParents();
                this.showImages = false;
                this.update();
            }
            /**
             *
             */
            update() {
                this.segment.update();
                this.__isDefined = this.segment.isDefined();
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            intersection(ray) {
                return geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(this.segment, ray);
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            getShotType(ray) {
                const rcrosss = (ray.p2.x - ray.p1.x) * (this.segment.p2.y - this.segment.p1.y) - (ray.p2.y - ray.p1.y) * (this.segment.p2.x - this.segment.p1.x);
                if (rcrosss > 0) {
                    return 1;
                }
                if (rcrosss < 0) {
                    return -1;
                }
                return 2;
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} ray
             * @return {number}
             */
            shot(ray) {
                return 0;
            }
            /**
             *
             * @return {number}
             */
            getChildrenCount() {
                return 1;
            }
            /**
             *
             * @param {number} index
             * @return {geom.Shape2D}
             */
            getChild(index) {
                if (index === 0)
                    return this.segment;
                return null;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Blocker";
            }
            /**
             *
             * @param {number} index
             * @return {string}
             */
            getChildInfo(index) {
                if (index === 0)
                    return this.getShapeInfo();
                return null;
            }
        }
        optics.OpticalBlocker2D = OpticalBlocker2D;
        OpticalBlocker2D["__class"] = "geom.optics.OpticalBlocker2D";
        OpticalBlocker2D["__interfaces"] = ["geom.optics.OpticalDevice", "geom.optics.OpticalObserver"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalArc2D extends geom.optics.OpticalDevice2D {
            constructor(point1, point2, point3, showCenter, showAxis, showImages) {
                if (((point1 != null && point1 instanceof geom.Point2D) || point1 === null) && ((point2 != null && point2 instanceof geom.Point2D) || point2 === null) && ((point3 != null && point3 instanceof geom.Point2D) || point3 === null) && ((typeof showCenter === 'string') || showCenter === null) && ((typeof showAxis === 'string') || showAxis === null) && ((typeof showImages === 'string') || showImages === null)) {
                    let __args = arguments;
                    super();
                    if (this.arc === undefined) {
                        this.arc = null;
                    }
                    this.center = new geom.Point2D();
                    this.axis = new geom.Line2D();
                    this.arc = new geom.CircleArc3Points2D(point1, point2, point3);
                    this.parents = this.arc.getParents();
                    this.params = [showCenter, showAxis, showImages];
                    let b = javaemul.internal.BooleanHelper.parseBoolean(showCenter);
                    this.center.setVisible(b);
                    b = javaemul.internal.BooleanHelper.parseBoolean(showAxis);
                    this.axis.setVisible(b);
                    this.axis.setDrawPattern(geom.Shape2D.DrawMode.DASHED);
                    this.showImagesExpr = showImages;
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                    this.minIntersectionsNeeded = 1;
                    this.update();
                }
                else if (((point1 != null && point1 instanceof geom.Point2D) || point1 === null) && ((point2 != null && point2 instanceof geom.Point2D) || point2 === null) && ((point3 != null && point3 instanceof geom.Point2D) || point3 === null) && showCenter === undefined && showAxis === undefined && showImages === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let showCenter = "true";
                        let showAxis = "true";
                        let showImages = "true";
                        super();
                        if (this.arc === undefined) {
                            this.arc = null;
                        }
                        this.center = new geom.Point2D();
                        this.axis = new geom.Line2D();
                        this.arc = new geom.CircleArc3Points2D(point1, point2, point3);
                        this.parents = this.arc.getParents();
                        this.params = [showCenter, showAxis, showImages];
                        let b = javaemul.internal.BooleanHelper.parseBoolean(showCenter);
                        this.center.setVisible(b);
                        b = javaemul.internal.BooleanHelper.parseBoolean(showAxis);
                        this.axis.setVisible(b);
                        this.axis.setDrawPattern(geom.Shape2D.DrawMode.DASHED);
                        this.showImagesExpr = showImages;
                        this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                        this.minIntersectionsNeeded = 1;
                        this.update();
                    }
                    if (this.arc === undefined) {
                        this.arc = null;
                    }
                    this.center = new geom.Point2D();
                    this.axis = new geom.Line2D();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Show Center", this.center.isVisible());
                if (index === 1)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Show Axis", this.axis.isVisible());
                if (index === 2)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Show Images", this.showImagesExpr, null);
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                    const b = javaemul.internal.BooleanHelper.parseBoolean(this.params[0]);
                    this.center.setVisible(b);
                }
                else if (index === 1) {
                    this.params[1] = (value + "");
                    const b = javaemul.internal.BooleanHelper.parseBoolean(this.params[1]);
                    this.axis.setVisible(b);
                }
                else if (index === 2) {
                    this.params[2] = (value + "");
                    this.showImagesExpr = this.params[2];
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                }
                this.update();
            }
            /**
             *
             */
            update() {
                this.__isDefined = false;
                if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[1].isDefined()) {
                    return;
                }
                this.arc.update();
                const p1 = (this.parents[0]).pt;
                const p2 = (this.parents[1]).pt;
                const p3 = (this.parents[2]).pt;
                if (!this.arc.isDefined()) {
                    this.axis.set$double$double$double$double(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                    this.center.setVisible(false);
                }
                else {
                    this.center.set(this.arc.cx, this.arc.cy);
                    this.axis.set$double$double$double$double(this.arc.cx, this.arc.cy, p1.y - p3.y, p3.x - p1.x);
                    if (!this.center.isVisible())
                        this.center.setVisible(javaemul.internal.BooleanHelper.parseBoolean(this.params[0]));
                }
                this.__isDefined = true;
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            intersection(ray) {
                if (this.arc.isDefined()) {
                    const t = geom.optics.OpticsUtils.intersection$geom_Circle2D$geom_Ray2D(this.arc, ray);
                    return t == null ? -1 : t[0];
                }
                else {
                    return geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(this.axis, ray);
                }
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            getShotType(ray) {
                return 0;
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} ray
             * @return {number}
             */
            shot(ray) {
                geom.optics.OpticalDevice2D.TMP_RAY_$LI$().set$geom_Line2D(ray);
                const t = this.intersection(geom.optics.OpticalDevice2D.TMP_RAY_$LI$());
                if (t < geom.Shape2D.ACCURACY)
                    return 0;
                if (this.arc.isDefined() === false) {
                    const p1 = (this.parents[0]).pt;
                    const p2 = (this.parents[1]).pt;
                    const rp = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t);
                    const rx = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.x - rp.x;
                    const ry = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.y - rp.y;
                    const mx = p2.x - p1.x;
                    const my = p2.y - p1.y;
                    geom.Shape2D.TMP_VEC_$LI$().set$double$double(rp.x + rx * (my * my - mx * mx) - 2 * ry * mx * my, rp.y + ry * (mx * mx - my * my) - 2 * rx * mx * my);
                    geom.optics.OpticsUtils.addReflectedRay(ray, rp, geom.Shape2D.TMP_VEC_$LI$(), ray.brightness);
                    return 1;
                }
                else {
                    const rp = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t);
                    const rx = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.x - rp.x;
                    const ry = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.y - rp.y;
                    const cx = this.arc.cx - rp.x;
                    const cy = this.arc.cy - rp.y;
                    const c_sq = cx * cx + cy * cy;
                    const r_dot_c = rx * cx + ry * cy;
                    geom.optics.OpticsUtils.addReflectedRay(ray, rp, geom.Shape2D.TMP_VEC_$LI$().set$double$double(rp.x - c_sq * rx + 2 * r_dot_c * cx, rp.y - c_sq * ry + 2 * r_dot_c * cy), ray.brightness);
                }
                return 1;
            }
            /**
             *
             * @return {number}
             */
            getChildrenCount() {
                return 3;
            }
            /**
             *
             * @param {number} index
             * @return {geom.Shape2D}
             */
            getChild(index) {
                if (index === 0)
                    return this.arc;
                else if (index === 1)
                    return this.center;
                else if (index === 2)
                    return this.axis;
                return null;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Mirror Arc " + this.name;
            }
            /**
             *
             * @param {number} index
             * @return {string}
             */
            getChildInfo(index) {
                if (index === 0)
                    return this.getShapeInfo();
                else if (index === 1)
                    return "Center of " + this.name;
                else if (index === 2)
                    return "Axis of " + this.name;
                return null;
            }
        }
        optics.OpticalArc2D = OpticalArc2D;
        OpticalArc2D["__class"] = "geom.optics.OpticalArc2D";
        OpticalArc2D["__interfaces"] = ["geom.optics.OpticalDevice", "geom.optics.OpticalObserver"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        /**
         * Full Constructor
         *
         * @param {geom.Point2D} p1
         * @param {geom.Point2D} p2
         * @param {string} minIntersections
         * Minimum number of intersections needed to assume the
         * intersection point as an image
         * @param extendedRays
         * if true intersecting rays are extended to their point of
         * intersection
         * @param {string} circular
         * @class
         * @extends geom.optics.OpticalDevice2D
         * @author maheshkurmi
         */
        class OpticalObserver2D extends geom.optics.OpticalDevice2D {
            constructor(p1, p2, minIntersections, circular) {
                if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((typeof minIntersections === 'string') || minIntersections === null) && ((typeof circular === 'string') || circular === null)) {
                    let __args = arguments;
                    super();
                    if (this.segment === undefined) {
                        this.segment = null;
                    }
                    this.parents = [p1, p2];
                    this.segment = new geom.Segment2Points2D(p1, p2);
                    this.segment.setVisible(false);
                    this.params = [minIntersections, circular];
                    this.update();
                }
                else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && minIntersections === undefined && circular === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let minIntersections = "2";
                        let circular = "false";
                        super();
                        if (this.segment === undefined) {
                            this.segment = null;
                        }
                        this.parents = [p1, p2];
                        this.segment = new geom.Segment2Points2D(p1, p2);
                        this.segment.setVisible(false);
                        this.params = [minIntersections, circular];
                        this.update();
                    }
                    if (this.segment === undefined) {
                        this.segment = null;
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$int$double$double("Min Intersections", this.minIntersectionsNeeded, 1, 50);
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                    this.minIntersectionsNeeded = javaemul.internal.IntegerHelper.parseInt(this.params[0]);
                    this.update();
                }
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            intersection(ray) {
                if (this.getShotType(ray) === 1)
                    return -1;
                return geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(this.segment, ray);
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            getShotType(ray) {
                const rcrosss = (ray.p2.x - ray.p1.x) * (this.segment.p2.y - this.segment.p1.y) - (ray.p2.y - ray.p1.y) * (this.segment.p2.x - this.segment.p1.x);
                if (rcrosss > 0) {
                    return 1;
                }
                if (rcrosss < 0) {
                    return -1;
                }
                return 2;
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} ray
             * @return {number}
             */
            shot(ray) {
                if (this.getShotType(ray) === 1)
                    return 0;
                ray.extentionPoint = null;
                this.rays.add(ray);
                return 0;
            }
            /**
             *
             * @param {framework.Renderer} gl
             */
            render(gl) {
                if (!this.visible)
                    return;
                if (!this.showImages)
                    return;
                const r = 2 * Math.sqrt(this.strokeWidth) * geom.Shape2D.SNAP_DISTANCE / 2.5;
                const color = this.shapesManager.preferences.ImageColor;
                for (let index = this.images.iterator(); index.hasNext();) {
                    let img = index.next();
                    {
                        color.a = ((Math.fround(img.brightness * 255)) | 0);
                        gl.drawRect(img.x - r / 2, img.y - r / 2, r, r, true, false);
                        if (this.showEqn || this.showName) {
                            geom.Shape2D.TMP_VEC_$LI$().set$double$double(0.7 * geom.Shape2D.SNAP_DISTANCE, 0.7 * geom.Shape2D.SNAP_DISTANCE);
                            geom.Shape2D.renderInfo(gl, math.MathUtils.formatPoint(img, false), geom.Shape2D.TMP_VEC_$LI$(), geom.Shape2D.TMP_VEC_$LI$(), 1, 2, this.drawColor, null);
                        }
                    }
                }
                const p1 = this.segment.p1;
                const p2 = this.segment.p2;
                const l = p1.distance$math_Vector2(p2) / 2;
                if (this.drawColor != null)
                    gl.setColors(null, this.drawColor);
                const p = math.Vector2.interpolate(p1, p2, 1).add$double$double(-this.segment.dy * l, this.segment.dx * l);
                const ctx = gl.context;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p.x, p.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                gl.drawSlice(p.x, p.y, l * 0.6, Math.PI / 2, Math.atan2(this.segment.dx, this.segment.dy), true, false);
                gl.drawSlice(p.x, p.y, l * 0.7, Math.PI / 2, Math.atan2(this.segment.dx, this.segment.dy), false, true);
            }
            /**
             *
             * @return {number}
             */
            getChildrenCount() {
                return 1;
            }
            /**
             *
             * @param {number} index
             * @return {geom.Shape2D}
             */
            getChild(index) {
                if (index === 0)
                    return this.segment;
                return null;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Observer " + this.name;
            }
            /**
             *
             * @param {string} name
             */
            setName(name) {
                super.setName(name);
                this.segment.setName(name);
            }
            /**
             *
             * @param {math.Vector2} pt
             * @return {boolean}
             */
            isSnapped(pt) {
                return this.segment.isSnapped(pt);
            }
            /**
             *
             * @param {math.Vector2} pt
             * @return {number}
             */
            distance(pt) {
                return this.segment.distance(pt);
            }
        }
        optics.OpticalObserver2D = OpticalObserver2D;
        OpticalObserver2D["__class"] = "geom.optics.OpticalObserver2D";
        OpticalObserver2D["__interfaces"] = ["geom.optics.OpticalDevice", "geom.optics.OpticalObserver"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalPlane2D extends geom.optics.OpticalDevice2D {
            constructor(p1, p2, mu, reflectivity, dispPower, showImages) {
                if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((typeof mu === 'string') || mu === null) && ((typeof reflectivity === 'string') || reflectivity === null) && ((typeof dispPower === 'string') || dispPower === null) && ((typeof showImages === 'string') || showImages === null)) {
                    let __args = arguments;
                    super();
                    if (this.line === undefined) {
                        this.line = null;
                    }
                    this.mu = new geom.optics.DynamicValue(1.5, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.w = new geom.optics.DynamicValue(0.1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.r = new geom.optics.DynamicValue(0, 0, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.rays2 = (new java.util.ArrayList());
                    this.line = new geom.Line2Points2D(p1, p2);
                    this.parents = this.line.getParents();
                    this.params = [mu, reflectivity, dispPower, showImages];
                    this.showImages = javaemul.internal.BooleanHelper.parseBoolean(showImages);
                    this.minIntersectionsNeeded = 1;
                    this.mu.set$java_lang_String(mu);
                    this.r.set$java_lang_String(reflectivity);
                    this.w.set$java_lang_String(dispPower);
                    this.showImagesExpr = showImages;
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                    this.fillColor = framework.Preferences.getRandomColor();
                    this.drawColor = this.fillColor.brighter();
                    this.fillColor.a = 127;
                    this.update();
                }
                else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && mu === undefined && reflectivity === undefined && dispPower === undefined && showImages === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let mu = "1.5";
                        let reflectivity = "0";
                        let dispPower = "0.1";
                        let showImages = "false";
                        super();
                        if (this.line === undefined) {
                            this.line = null;
                        }
                        this.mu = new geom.optics.DynamicValue(1.5, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                        this.w = new geom.optics.DynamicValue(0.1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                        this.r = new geom.optics.DynamicValue(0, 0, javaemul.internal.DoubleHelper.MAX_VALUE);
                        this.rays2 = (new java.util.ArrayList());
                        this.line = new geom.Line2Points2D(p1, p2);
                        this.parents = this.line.getParents();
                        this.params = [mu, reflectivity, dispPower, showImages];
                        this.showImages = javaemul.internal.BooleanHelper.parseBoolean(showImages);
                        this.minIntersectionsNeeded = 1;
                        this.mu.set$java_lang_String(mu);
                        this.r.set$java_lang_String(reflectivity);
                        this.w.set$java_lang_String(dispPower);
                        this.showImagesExpr = showImages;
                        this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                        this.fillColor = framework.Preferences.getRandomColor();
                        this.drawColor = this.fillColor.brighter();
                        this.fillColor.a = 127;
                        this.update();
                    }
                    if (this.line === undefined) {
                        this.line = null;
                    }
                    this.mu = new geom.optics.DynamicValue(1.5, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.w = new geom.optics.DynamicValue(0.1, -javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.r = new geom.optics.DynamicValue(0, 0, javaemul.internal.DoubleHelper.MAX_VALUE);
                    this.rays2 = (new java.util.ArrayList());
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {geom.ShapesManager} manager
             */
            onAddShapeToSimulation(manager) {
                super.onAddShapeToSimulation(manager);
                this.mu.setShapesManager(manager);
                this.r.setShapesManager(manager);
                this.w.setShapesManager(manager);
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Refractive Index", this.params[0], null);
                if (index === 1)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Reflectivity", this.params[1], null);
                if (index === 2)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Dispersive power", this.params[2], null);
                if (index === 3)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Show Images", this.showImagesExpr, null);
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                    this.mu.set$java_lang_String(this.params[0]);
                }
                else if (index === 1) {
                    this.params[1] = (value + "");
                    this.r.set$java_lang_String(this.params[1]);
                }
                else if (index === 2) {
                    this.params[2] = (value + "");
                    this.w.set$java_lang_String(this.params[2]);
                }
                else if (index === 3) {
                    this.params[3] = (value + "");
                    this.showImagesExpr = this.params[3];
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                }
            }
            update() {
                this.__isDefined = false;
                this.line.update();
                if (!this.line.isDefined() || this.mu == null) {
                    return;
                }
                this.mu.update();
                if (this.fillColor != null)
                    this.fillColor.a = ((Math.log(this.mu.getValue()) / Math.log(1.5) * 0.2 * 255) | 0);
                this.w.update();
                this.r.update();
                this.__isDefined = true;
            }
            render(gl) {
                if (this.fillColor != null && this.__isDefined) {
                    if (this.shapesManager == null)
                        return;
                    const b = this.shapesManager.getWorldBounds();
                    const w = b[2] - b[0];
                    const h = b[3] - b[1];
                    const par_x = -this.line.dx;
                    const par_y = -this.line.dy;
                    const per_x = -this.line.dy;
                    const per_y = this.line.dx;
                    const sufficientlyLargeDistance = w + h;
                    gl.setColors(this.fillColor, this.drawColor);
                    const ctx = gl.context;
                    ctx.beginPath();
                    ctx.moveTo(per_x, sufficientlyLargeDistance);
                    ctx.moveTo(this.line.x0 - par_x * sufficientlyLargeDistance, this.line.y0 - par_y * sufficientlyLargeDistance);
                    ctx.lineTo(this.line.x0 + par_x * sufficientlyLargeDistance, this.line.y0 + par_y * sufficientlyLargeDistance);
                    ctx.lineTo(this.line.x0 + (par_x - per_x) * sufficientlyLargeDistance, this.line.y0 + (par_y - per_y) * sufficientlyLargeDistance);
                    ctx.lineTo(this.line.x0 - (par_x + per_x) * sufficientlyLargeDistance, this.line.y0 - (par_y + per_y) * sufficientlyLargeDistance);
                    ctx.closePath();
                    ctx.fill();
                }
                super.render(gl);
            }
            /**
             *
             */
            beginObserve() {
                this.rays.clear();
                this.rays2.clear();
            }
            /**
             * Find all images for the rays received by this observer
             */
            endObserve() {
                this.images.clear();
                if (this.showImages) {
                    geom.optics.OpticsUtils.findImages(this, this.rays, this.images, true, this.minIntersectionsNeeded);
                    geom.optics.OpticsUtils.findImages(this, this.rays2, this.images, true, this.minIntersectionsNeeded);
                }
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} ray
             * @param {boolean} reflected
             */
            addRayToObserve(ray, reflected) {
                if (this.showImages) {
                    if (reflected)
                        this.rays2.add(ray);
                    else
                        this.rays.add(ray);
                }
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} opticalray
             * @return {number}
             */
            shot(opticalray) {
                geom.optics.OpticalDevice2D.TMP_RAY_$LI$().set$geom_Line2D(opticalray);
                const t = this.intersection(geom.optics.OpticalDevice2D.TMP_RAY_$LI$());
                if (t > 0) {
                    const rdots = (geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p2.x - geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.x) * (this.line.p2.x - this.line.p1.x) + (geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p2.y - geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.y) * (this.line.p2.y - this.line.p1.y);
                    const ssq = (this.line.p2.x - this.line.p1.x) * (this.line.p2.x - this.line.p1.x) + (this.line.p2.y - this.line.p1.y) * (this.line.p2.y - this.line.p1.y);
                    const normal = new math.Vector2(rdots * (this.line.p2.x - this.line.p1.x) - ssq * (geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p2.x - geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.x), rdots * (this.line.p2.y - this.line.p1.y) - ssq * (geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p2.y - geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.y));
                    let shotType = this.getShotType(geom.optics.OpticalDevice2D.TMP_RAY_$LI$());
                    let n1 = 1;
                    let mu = this.mu.getValue();
                    const w = this.w.getValue();
                    if (w !== 0) {
                        mu = mu - w * (mu - 1) * (opticalray.waveLength - 500) / 400;
                    }
                    if (shotType === 1) {
                        n1 = mu;
                    }
                    else if (shotType === -1) {
                        n1 = 1 / mu;
                    }
                    else {
                        return 0;
                    }
                    if (this.shapesManager.surfaceMergingObjects.size() > 0) {
                        for (let index = this.shapesManager.surfaceMergingObjects.iterator(); index.hasNext();) {
                            let refractor = index.next();
                            {
                                shotType = refractor.getShotType(opticalray);
                                if (shotType === 1) {
                                    n1 *= refractor.getRefractiveIndex();
                                }
                                else if (shotType === -1) {
                                    n1 /= refractor.getRefractiveIndex();
                                }
                                else if (shotType === 0) {
                                }
                                else {
                                    return 0;
                                }
                            }
                        }
                    }
                    return geom.optics.OpticsUtils.refract(opticalray, geom.optics.OpticalDevice2D.TMP_RAY_$LI$(), geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t), normal, n1, this.r.getValue());
                }
                return -1;
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            intersection(ray) {
                return geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(this.line, ray);
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            getShotType(ray) {
                const rcrosss = (ray.p2.x - ray.p1.x) * (this.line.dy) - (ray.p2.y - ray.p1.y) * (this.line.dx);
                if (rcrosss > 0) {
                    return -1;
                }
                if (rcrosss < 0) {
                    return 1;
                }
                return 2;
            }
            /**
             *
             * @return {number}
             */
            getChildrenCount() {
                return 1;
            }
            /**
             *
             * @param {number} index
             * @return {geom.Shape2D}
             */
            getChild(index) {
                if (index === 0)
                    return this.line;
                return null;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Refracting Plane " + this.name;
            }
            /**
             *
             * @param {number} index
             * @return {string}
             */
            getChildInfo(index) {
                if (index === 0)
                    return this.getShapeInfo();
                return null;
            }
            /**
             *
             * @return {number}
             */
            getRefractiveIndex() {
                return this.mu.getValue();
            }
            /**
             *
             * @return {number}
             */
            getDispersivePower() {
                return this.w.getValue();
            }
            /**
             *
             * @return {number}
             */
            getReflectiveIndex() {
                return this.r.getValue();
            }
        }
        optics.OpticalPlane2D = OpticalPlane2D;
        OpticalPlane2D["__class"] = "geom.optics.OpticalPlane2D";
        OpticalPlane2D["__interfaces"] = ["geom.optics.OpticalDevice", "geom.optics.OpticalObserver", "geom.optics.OpticalRefractor"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    var optics;
    (function (optics) {
        class OpticalParabolicArc2D extends geom.optics.OpticalDevice2D {
            constructor(point1, point2, point3, showFocus, showAxis, showImages) {
                if (((point1 != null && point1 instanceof geom.Point2D) || point1 === null) && ((point2 != null && point2 instanceof geom.Point2D) || point2 === null) && ((point3 != null && point3 instanceof geom.Point2D) || point3 === null) && ((typeof showFocus === 'string') || showFocus === null) && ((typeof showAxis === 'string') || showAxis === null) && ((typeof showImages === 'string') || showImages === null)) {
                    let __args = arguments;
                    super();
                    if (this.curve === undefined) {
                        this.curve = null;
                    }
                    this.focus = new geom.Point2D();
                    this.axis = new geom.Line2D();
                    this.DIR_Y = new math.Vector2();
                    this.DIR_X = new math.Vector2();
                    this.curve = new geom.ParabolaArc2D();
                    this.parents = [point1, point2, point3];
                    this.params = [showFocus, showAxis, showImages];
                    let b = javaemul.internal.BooleanHelper.parseBoolean(showFocus);
                    this.focus.setVisible(b);
                    b = javaemul.internal.BooleanHelper.parseBoolean(showAxis);
                    this.axis.setVisible(b);
                    this.axis.setDrawPattern(geom.Shape2D.DrawMode.DASHED);
                    this.showImagesExpr = showImages;
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                    this.minIntersectionsNeeded = 1;
                    this.update();
                }
                else if (((point1 != null && point1 instanceof geom.Point2D) || point1 === null) && ((point2 != null && point2 instanceof geom.Point2D) || point2 === null) && ((point3 != null && point3 instanceof geom.Point2D) || point3 === null) && showFocus === undefined && showAxis === undefined && showImages === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let showFocus = "true";
                        let showAxis = "true";
                        let showImages = "false";
                        super();
                        if (this.curve === undefined) {
                            this.curve = null;
                        }
                        this.focus = new geom.Point2D();
                        this.axis = new geom.Line2D();
                        this.DIR_Y = new math.Vector2();
                        this.DIR_X = new math.Vector2();
                        this.curve = new geom.ParabolaArc2D();
                        this.parents = [point1, point2, point3];
                        this.params = [showFocus, showAxis, showImages];
                        let b = javaemul.internal.BooleanHelper.parseBoolean(showFocus);
                        this.focus.setVisible(b);
                        b = javaemul.internal.BooleanHelper.parseBoolean(showAxis);
                        this.axis.setVisible(b);
                        this.axis.setDrawPattern(geom.Shape2D.DrawMode.DASHED);
                        this.showImagesExpr = showImages;
                        this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                        this.minIntersectionsNeeded = 1;
                        this.update();
                    }
                    if (this.curve === undefined) {
                        this.curve = null;
                    }
                    this.focus = new geom.Point2D();
                    this.axis = new geom.Line2D();
                    this.DIR_Y = new math.Vector2();
                    this.DIR_X = new math.Vector2();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @return {framework.EditInfo}
             */
            getEditInfo(index) {
                if (index === 0)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Show Focus", this.focus.isVisible());
                if (index === 1)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$boolean("Show Axis", this.axis.isVisible());
                if (index === 2)
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Show Images", this.showImagesExpr, null);
                return null;
            }
            /**
             *
             * @param {number} index
             * @param {*} value
             */
            setEditValue(index, value) {
                if (index === 0) {
                    this.params[0] = (value + "");
                    const b = javaemul.internal.BooleanHelper.parseBoolean(this.params[0]);
                    this.focus.setVisible(b);
                }
                else if (index === 1) {
                    this.params[1] = (value + "");
                    const b = javaemul.internal.BooleanHelper.parseBoolean(this.params[1]);
                    this.axis.setVisible(b);
                }
                else if (index === 2) {
                    this.params[2] = (value + "");
                    this.showImagesExpr = this.params[2];
                    this.showImages = math.MathUtils.evaluateBoolean(this.showImagesExpr);
                }
                this.update();
            }
            /**
             *
             */
            update() {
                this.__isDefined = false;
                if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[1].isDefined()) {
                    return;
                }
                const p1 = (this.parents[0]).pt;
                const p2 = (this.parents[1]).pt;
                const p3 = (this.parents[2]).pt;
                const p12d = this.DIR_Y.set$double$double(p2.x - p1.x, p2.y - p1.y).normalize();
                this.DIR_X.set$double$double(this.DIR_Y.y, -this.DIR_Y.x);
                let th = this.DIR_X.getDirection();
                this.axis.set$double$double$double$double((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, this.DIR_X.x, this.DIR_X.y);
                const at_sq = (p3.x - p1.x) * this.DIR_X.x + (p3.y - p1.y) * this.DIR_X.y;
                p3.set$double$double((p1.x + p2.x) * 0.5 + this.DIR_X.x * at_sq, (p1.y + p2.y) * 0.5 + this.DIR_X.y * at_sq);
                const a_2t = p12d / 2;
                let a = -(a_2t * a_2t) / at_sq / 4;
                this.focus.set(p3.x + this.DIR_X.x * a, p3.y + this.DIR_X.y * a);
                const t = this.axis.distance(p1) / 2 / a;
                if (a < 0)
                    th += Math.PI;
                a = Math.abs(a);
                this.curve.set$double$double$double$double$double$double(p3.x, p3.y, a, th, -t, t);
                this.__isDefined = this.curve.isDefined();
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            intersection(ray) {
                if (this.isDefined()) {
                    const t = geom.optics.OpticsUtils.intersection$geom_Conic2D$geom_Ray2D(this.curve, ray);
                    return t == null ? -1 : t[0];
                }
                else {
                    return geom.optics.OpticsUtils.intersection$geom_Line2D$geom_Ray2D(this.axis, ray);
                }
            }
            /**
             *
             * @param {geom.Ray2D} ray
             * @return {number}
             */
            getShotType(ray) {
                return 0;
            }
            /**
             *
             * @param {geom.optics.OpticalRay2D} ray
             * @return {number}
             */
            shot(ray) {
                geom.optics.OpticalDevice2D.TMP_RAY_$LI$().set$geom_Line2D(ray);
                const t = this.intersection(geom.optics.OpticalDevice2D.TMP_RAY_$LI$());
                if (t < geom.Shape2D.ACCURACY)
                    return 0;
                if (this.curve.isDefined() === false) {
                    const p1 = (this.parents[0]).pt;
                    const p2 = (this.parents[1]).pt;
                    const rp = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t);
                    const rx = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.x - rp.x;
                    const ry = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.y - rp.y;
                    const mx = p2.x - p1.x;
                    const my = p2.y - p1.y;
                    geom.Shape2D.TMP_VEC_$LI$().set$double$double(rp.x + rx * (my * my - mx * mx) - 2 * ry * mx * my, rp.y + ry * (mx * mx - my * my) - 2 * rx * mx * my);
                    geom.optics.OpticsUtils.addReflectedRay(ray, rp, geom.Shape2D.TMP_VEC_$LI$(), ray.brightness);
                    return 1;
                }
                else {
                    const rp = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().point(t);
                    const rx = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.x - rp.x;
                    const ry = geom.optics.OpticalDevice2D.TMP_RAY_$LI$().p1.y - rp.y;
                    const dir = this.curve.tangent(this.curve.t(rp));
                    const mx = dir.x;
                    const my = dir.y;
                    geom.Shape2D.TMP_VEC_$LI$().set$double$double(rp.x + rx * (my * my - mx * mx) - 2 * ry * mx * my, rp.y + ry * (mx * mx - my * my) - 2 * rx * mx * my);
                    geom.optics.OpticsUtils.addReflectedRay(ray, rp, geom.Shape2D.TMP_VEC_$LI$(), ray.brightness);
                }
                return 1;
            }
            /**
             *
             * @return {number}
             */
            getChildrenCount() {
                return 3;
            }
            /**
             *
             * @param {number} index
             * @return {geom.Shape2D}
             */
            getChild(index) {
                if (index === 0)
                    return this.curve;
                else if (index === 1)
                    return this.focus;
                else if (index === 2)
                    return this.axis;
                return null;
            }
            /**
             *
             * @return {string}
             */
            getShapeInfo() {
                return "Parabolic Arc " + this.name;
            }
            /**
             *
             * @param {number} index
             * @return {string}
             */
            getChildInfo(index) {
                if (index === 0)
                    return this.getShapeInfo();
                else if (index === 1)
                    return "Focus of " + this.name;
                else if (index === 2)
                    return "Axis of " + this.name;
                return null;
            }
        }
        optics.OpticalParabolicArc2D = OpticalParabolicArc2D;
        OpticalParabolicArc2D["__class"] = "geom.optics.OpticalParabolicArc2D";
        OpticalParabolicArc2D["__interfaces"] = ["geom.optics.OpticalDevice", "geom.optics.OpticalObserver"];
    })(optics = geom.optics || (geom.optics = {}));
})(geom || (geom = {}));
(function (geom) {
    /**
     * A parabola, defined by its vertex, its orientation, and its pedal. Orientation is defined as the orientation of
     * derivative at vertex point, with the second derivative pointing to the top.
     * <p>
     * Following parametric representation is used:
     * <p>
     * <code>x(t)=a*t^2</code>
     * <p>
     * <code>y(t)=2*a*t</code>
     * <p>
     * This is a signed parameter (negative a makes the parabola point to opposite side).
     *
     * @author mahesh kurmi
     * @class
     * @extends geom.Parabola2D
     */
    class ParabolaArc2D extends geom.Parabola2D {
        set$double$double$double$double$double$double(xv, yv, a, theta, t0, t1) {
            if (a < 0) {
                a = -a;
                theta += Math.PI;
            }
            this.set(xv, yv, a, theta);
            this.__t0 = this.clipt0 = Math.min(t0, t1);
            this.__t1 = this.clipt1 = Math.max(t0, t1);
        }
        /**
         * Create new parabola
         *
         * @param {number} xv
         * x coordinate of vertex
         * @param {number} yv
         * y coordinate of vertex
         * @param {number} a
         * focal distance (must be positive, use theta =pi to create parabola in opposite direction
         * @param {number} theta
         * angle axis makes with positive x axis
         * @param {number} t0 clip coordinate
         * @param {number} t1 clip coordinate
         */
        set(xv, yv, a, theta, t0, t1) {
            if (((typeof xv === 'number') || xv === null) && ((typeof yv === 'number') || yv === null) && ((typeof a === 'number') || a === null) && ((typeof theta === 'number') || theta === null) && ((typeof t0 === 'number') || t0 === null) && ((typeof t1 === 'number') || t1 === null)) {
                return this.set$double$double$double$double$double$double(xv, yv, a, theta, t0, t1);
            }
            else if (((typeof xv === 'number') || xv === null) && ((typeof yv === 'number') || yv === null) && ((typeof a === 'number') || a === null) && ((typeof theta === 'number') || theta === null) && t0 === undefined && t1 === undefined) {
                super.set(xv, yv, a, theta);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Returns the parameter of the first point of the line, which is always Double.NEGATIVE_INFINITY.
         * @return {number}
         */
        t0() {
            return this.__t0;
        }
        /**
         * Returns the parameter of the last point of the line, which is always Double.POSITIVE_INFINITY.
         * @return {number}
         */
        t1() {
            return this.__t1;
        }
        /**
         * Returns point on parabola for parametric point t (at^2,2at)
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            if (t < this.__t0 || t > this.__t1)
                return null;
            this.tmpVector = this.tmpTransform.transform$double$double(Math.fround((this.a * t * t)), Math.fround((2 * this.a * t)));
            return new math.Vector2(this.tmpVector.x, this.tmpVector.y);
        }
        /**
         * Returns position of point on the parabola. If point is not on the parabola returns the positions on its
         * "vertical" projection (i.e. its projection parallel to the symetry axis of the parabola).
         * @param {math.Vector2} point
         * @return {number}
         */
        t(point) {
            let t = super.t(point);
            if ( /* isNaN */isNaN(t))
                return t;
            t = math.MathUtils.clamp$double$double$double(t, this.__t0, this.__t1);
            return t;
        }
        intersections(line) {
            const ts = super.intersections(line);
            let i = 0;
            for (let index = 0; index < ts.length; index++) {
                let t = ts[index];
                ts[i++] = t;
            }
            return ts;
        }
        /**
         * Clip the parabola by a box. The result is an instance of CurveSet2D<ParabolaArc2D>, which contains only instances
         * of ParabolaArc2D. If the parabola is not clipped, the result is an instance of CurveSet2D<ParabolaArc2D> which
         * contains 0 curves.
         */
        clip() {
        }
        isSnapped(point) {
            const p2 = this.project(point);
            if (p2 != null && point.distance$math_Vector2(p2) < 2 * geom.Shape2D.SNAP_DISTANCE) {
                return true;
            }
            return false;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.parents != null && (this.parents[0] != null && this.parents[0] instanceof geom.ParentShapeArray2D)) {
                return this.parents[0].getShapeInfo();
            }
            return "ParabolaArc [ a = " + math.MathUtils.formatValue(this.a, false) + ", " + math.Unicode.Theta + " = " + math.MathUtils.formatValue(this.theta, true) + "]";
        }
    }
    geom.ParabolaArc2D = ParabolaArc2D;
    ParabolaArc2D["__class"] = "geom.ParabolaArc2D";
})(geom || (geom = {}));
(function (geom) {
    class ParabolaLinePoint2D extends geom.Parabola2D {
        constructor(line, focus) {
            super();
            this.parents = [line, focus];
            this.update();
        }
        /**
         *
         * @return {string}
         */
        getInfo() {
            return "Parabola from Directrix " + this.parents[0].getName() + "and Focus " + this.parents[1].getName();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined())
                return;
            const line = this.parents[0];
            const focus = this.parents[1].pt;
            const p0 = line.point(line.t(focus));
            const p = p0.distance$math_Vector2(focus) / 2;
            let theta = line.getDirection().getAngleWithPositiveXAxis() + Math.PI / 2;
            if (!line.isInside(focus))
                theta += Math.PI;
            const xv = (focus.x + p0.x) / 2;
            const yv = (focus.y + p0.y) / 2;
            if (p < geom.Shape2D.ACCURACY)
                return;
            this.set(xv, yv, p, theta);
        }
    }
    geom.ParabolaLinePoint2D = ParabolaLinePoint2D;
    ParabolaLinePoint2D["__class"] = "geom.ParabolaLinePoint2D";
})(geom || (geom = {}));
(function (geom) {
    class Parabola2Points2D extends geom.Parabola2D {
        constructor(vertex, focus) {
            super();
            this.parents = [vertex, focus];
            this.update();
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Parabola with Vertex " + this.parents[0].getName() + " and Focus " + this.parents[1].getName();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined())
                return;
            const v = this.parents[0].pt;
            const f = this.parents[1].pt;
            if (v.equals$math_Vector2(f))
                return;
            const theta = geom.AngleUtils.formatAngle(geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(v, f));
            const p = v.distance$math_Vector2(f);
            if (p < geom.Shape2D.ACCURACY)
                return;
            super.set(v.x, v.y, p, theta);
        }
    }
    geom.Parabola2Points2D = Parabola2Points2D;
    Parabola2Points2D["__class"] = "geom.Parabola2Points2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * hyp from centre end of major axis and
     *
     * @author Mahesh
     * @param {geom.Point2D} center
     * @param {geom.Point2D} vertex1
     * @param {geom.Point2D} vertex2
     * @class
     * @extends geom.Hyperbola2D
     */
    class HyperbolaCenter2Points2D extends geom.Hyperbola2D {
        constructor(center, vertex1, vertex2) {
            super();
            this.parents = [center, vertex1, vertex2];
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                return;
            }
            const point1 = (this.parents[0]).pt;
            const point2 = (this.parents[1]).pt;
            const point3 = (this.parents[2]).pt;
            if (math.Vector2.isCollinear(point1, point2, point3))
                return;
            const xc = point1.x;
            const yc = point1.y;
            const axis = point1.to$math_Vector2(point2);
            const r1 = axis.normalize();
            const theta = axis.getAngleWithPositiveXAxis();
            this.r2 = Math.abs(point1.to$math_Vector2(point3).cross$math_Vector2(axis));
            super.set$double$double$double$double$double(xc, yc, r1, this.r2, theta);
        }
    }
    geom.HyperbolaCenter2Points2D = HyperbolaCenter2Points2D;
    HyperbolaCenter2Points2D["__class"] = "geom.HyperbolaCenter2Points2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Hyp with 2 foci passing through a fixed point
     * @author Mahesh
     * @param {geom.Point2D} focus1
     * @param {geom.Point2D} focus2
     * @param {geom.Point2D} pointOnEllipse
     * @class
     * @extends geom.Hyperbola2D
     */
    class Hyperbola2FocusPoint2D extends geom.Hyperbola2D {
        constructor(focus1, focus2, pointOnEllipse) {
            super();
            this.parents = [focus1, focus2, pointOnEllipse];
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                return;
            }
            const focus1 = (this.parents[0]).pt;
            const focus2 = (this.parents[1]).pt;
            const point = (this.parents[2]).pt;
            const ae = focus1.distance$math_Vector2(focus2) / 2;
            const PS1 = focus1.distance$math_Vector2(point);
            const PS2 = focus2.distance$math_Vector2(point);
            const a = Math.abs(PS2 - PS1) / 2;
            const b = Math.sqrt(ae * ae - a * a);
            const theta = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(focus1, focus2);
            const centre = math.Vector2.interpolate(focus1, focus2, 1);
            this.set$double$double$double$double$double(centre.x, centre.y, a, b, theta);
            this.__isDefined = true;
        }
    }
    geom.Hyperbola2FocusPoint2D = Hyperbola2FocusPoint2D;
    Hyperbola2FocusPoint2D["__class"] = "geom.Hyperbola2FocusPoint2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Construct an ellipse from 3 points: the center, the point marking the end of the major semi-axis, and a third point
     * defining the length of the minor semi-axis. Last point also specifies orientation of ellipse.
     * @param {geom.Point2D} focus1
     * @param {geom.Point2D} focus2
     * @param {geom.Point2D} pointOnEllipse
     * @class
     * @extends geom.Ellipse2D
     */
    class Ellipse2FocusPoint2D extends geom.Ellipse2D {
        constructor(focus1, focus2, pointOnEllipse) {
            super();
            this.parents = [focus1, focus2, pointOnEllipse];
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                return;
            }
            const focus1 = (this.parents[0]).pt;
            const focus2 = (this.parents[1]).pt;
            const point = (this.parents[2]).pt;
            const dist1 = focus1.distance$math_Vector2(point);
            const dist2 = focus2.distance$math_Vector2(point);
            const dist = dist1 + dist2;
            const distFocus = focus1.distance$math_Vector2(focus2);
            if (dist < distFocus)
                return;
            super.set$math_Vector2$math_Vector2$double(focus1, focus2, dist);
        }
    }
    geom.Ellipse2FocusPoint2D = Ellipse2FocusPoint2D;
    Ellipse2FocusPoint2D["__class"] = "geom.Ellipse2FocusPoint2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Construct an ellipse from 3 points: the center, the point marking the end
     * of the major semiaxis, and a third point defining the length of the minor
     * semiaxis. Last point also specifies orientation of ellipse.
     * @param {geom.Point2D} center
     * @param {geom.Point2D} vertex1
     * @param {geom.Point2D} vertex2
     * @class
     * @extends geom.Ellipse2D
     */
    class EllipseCenter2Points2D extends geom.Ellipse2D {
        constructor(center, vertex1, vertex2) {
            super();
            this.parents = [center, vertex1, vertex2];
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                return;
            }
            const point1 = (this.parents[0]).pt;
            const point2 = (this.parents[1]).pt;
            const point3 = (this.parents[2]).pt;
            if (math.Vector2.isCollinear(point1, point2, point3))
                return;
            const xc = point1.x;
            const yc = point1.y;
            const axis = point1.to$math_Vector2(point2);
            const r1 = axis.normalize();
            const theta = axis.getAngleWithPositiveXAxis();
            this.r2 = Math.abs(point1.to$math_Vector2(point3).cross$math_Vector2(axis));
            super.set$double$double$double$double$double(xc, yc, r1, this.r2, theta);
        }
    }
    geom.EllipseCenter2Points2D = EllipseCenter2Points2D;
    EllipseCenter2Points2D["__class"] = "geom.EllipseCenter2Points2D";
})(geom || (geom = {}));
(function (geom) {
    class CircleCenterRadius2D extends geom.Circle2D {
        constructor(p, radius) {
            super();
            this.parents = [p];
            this.params = [radius];
            this.update();
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Radius", this.params[0], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                this.update();
            }
        }
        /**
         *
         */
        update() {
            this.expr = null;
            this.__isDefined = false;
            if (!this.parents[0].isDefined()) {
                return;
            }
            let r;
            try {
                r = math.MathUtils.evaluateExpression(this.params[0], this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables);
            }
            catch (e) {
                return;
            }
            if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(r) || r <= 0) {
                return;
            }
            const c = (this.parents[0]).pt;
            super.set(c.x, c.y, r);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Circle with Center " + this.parents[0].getName() + " & radius " + this.params[0];
        }
    }
    geom.CircleCenterRadius2D = CircleCenterRadius2D;
    CircleCenterRadius2D["__class"] = "geom.CircleCenterRadius2D";
})(geom || (geom = {}));
(function (geom) {
    class Circle3Points2D extends geom.Circle2D {
        constructor(p1, p2, p3) {
            super();
            this.parents = [p1, p2, p3];
            this.update();
        }
        /**
         *
         */
        update() {
            this.expr = null;
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                return;
            }
            const p1 = (this.parents[0]).pt;
            const p2 = (this.parents[1]).pt;
            const p3 = (this.parents[2]).pt;
            if (math.Vector2.isCollinear(p1, p2, p3))
                return;
            if (Circle3Points2D.TMP_LINE1 == null) {
                Circle3Points2D.TMP_LINE1 = new geom.Line2D();
                Circle3Points2D.TMP_LINE2 = new geom.Line2D();
                Circle3Points2D.TMP_LINE1.visible = false;
                Circle3Points2D.TMP_LINE2.visible = false;
            }
            Circle3Points2D.TMP_LINE1.set$double$double$double$double((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, p2.y - p1.y, p1.x - p2.x);
            Circle3Points2D.TMP_LINE2.set$double$double$double$double((p2.x + p3.x) / 2, (p2.y + p3.y) / 2, p3.y - p2.y, p2.x - p3.x);
            const inter = geom.CurveUtils.LineLineIntersection$geom_Line2D$geom_Line2D(Circle3Points2D.TMP_LINE1, Circle3Points2D.TMP_LINE2);
            if (inter == null)
                return;
            const c = inter[0];
            super.set(c.x, c.y, c.distance$math_Vector2(p1));
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Arc through Points " + this.parents[0].getName() + " , " + this.parents[1].getName() + " , " + this.parents[2].getName();
        }
    }
    Circle3Points2D.TMP_LINE1 = null;
    Circle3Points2D.TMP_LINE2 = null;
    geom.Circle3Points2D = Circle3Points2D;
    Circle3Points2D["__class"] = "geom.Circle3Points2D";
})(geom || (geom = {}));
(function (geom) {
    class Circle2Points2D extends geom.Circle2D {
        constructor(p1, p2) {
            super();
            this.parents = [p1, p2];
            this.update();
        }
        /**
         *
         */
        update() {
            if (this.parents == null)
                return;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                this.__isDefined = false;
                return;
            }
            const c = (this.parents[0]).pt;
            const v = (this.parents[1]).pt;
            if (c == null || v == null || c.equals$math_Vector2(v)) {
                this.expr = null;
                this.__isDefined = false;
                return;
            }
            super.set(c.x, c.y, v.distance$math_Vector2(c));
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Circle through " + this.parents[1].getName() + " & center " + this.parents[0].getName();
        }
    }
    geom.Circle2Points2D = Circle2Points2D;
    Circle2Points2D["__class"] = "geom.Circle2Points2D";
})(geom || (geom = {}));
(function (geom) {
    class CircleDiameter2D extends geom.Circle2D {
        constructor(p1, p2) {
            super();
            this.parents = [p1, p2];
            this.update();
        }
        /**
         *
         */
        update() {
            this.expr = null;
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined()) {
                return;
            }
            const p1 = (this.parents[0]).pt;
            const p2 = (this.parents[1]).pt;
            if (p1.equals$math_Vector2(p2)) {
                return;
            }
            const c = new math.Vector2((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
            const r = c.distance$math_Vector2(p1);
            super.set(c.x, c.y, r);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Circle with Diameter ends " + this.parents[0].getName() + " & " + this.parents[1].getName();
        }
    }
    geom.CircleDiameter2D = CircleDiameter2D;
    CircleDiameter2D["__class"] = "geom.CircleDiameter2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Tangent to a curve at a given point.
     * @param {geom.Curve2D} curve
     * @param {geom.Point2D} point
     * @class
     * @extends geom.Circle2D
     * @author mahesh kurmi
     */
    class OsculatingCircle2D extends geom.Circle2D {
        constructor(curve, point) {
            super();
            this.parents = [curve, point];
            this.update();
        }
        /**
         *
         * @return {string}
         */
        getInfo() {
            return "Osculating Circle on Curve " + this.parents[0].getName() + " at foot of " + this.parents[1].getName();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined())
                return;
            if (!this.parents[1].isDefined())
                return;
            const curve = this.parents[0];
            const pt = this.parents[1];
            const t = curve.t(pt.pt);
            if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(t))
                return;
            const foot = curve.point(t);
            if (foot == null)
                return;
            let r = curve.curvature(t);
            if ( /* isNaN */isNaN(r) || Math.abs(r) < geom.Shape2D.ACCURACY || Math.abs(r) > 1 / geom.Shape2D.ACCURACY)
                return;
            r = 1 / r;
            let v = curve.tangent(t);
            if (v == null)
                return;
            v.normalize();
            v = new math.Vector2(-r * v.y, r * v.x);
            const centre = foot.sum$math_Vector2(v);
            super.set(centre.x, centre.y, Math.abs(r));
        }
    }
    geom.OsculatingCircle2D = OsculatingCircle2D;
    OsculatingCircle2D["__class"] = "geom.OsculatingCircle2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Creates arc
     *
     * @param {number} xc
     * @param {number} yc
     * @param {number} r
     * @param {number} startAngle
     * start angle in radians (ACW as positive)
     * @param {number} endAngle
     * end angle in radians (ACW as positive)
     * @param {boolean} direct
     * @class
     * @extends geom.Circle2D
     */
    class CircleArc2D extends geom.Circle2D {
        constructor(xc, yc, r, startAngle, endAngle, direct) {
            if (((typeof xc === 'number') || xc === null) && ((typeof yc === 'number') || yc === null) && ((typeof r === 'number') || r === null) && ((typeof startAngle === 'number') || startAngle === null) && ((typeof endAngle === 'number') || endAngle === null) && ((typeof direct === 'boolean') || direct === null)) {
                let __args = arguments;
                super();
                this.startAngle = 0;
                this.angleExtent = 0;
                this.set$double$double$double$double$double$boolean(xc, yc, r, startAngle, endAngle, direct);
            }
            else if (xc === undefined && yc === undefined && r === undefined && startAngle === undefined && endAngle === undefined && direct === undefined) {
                let __args = arguments;
                super();
                this.startAngle = 0;
                this.angleExtent = 0;
            }
            else
                throw new Error('invalid overload');
        }
        set$double$double$double$double$double$boolean(xc, yc, r, startAngle, endAngle, direct) {
            this.startAngle = geom.AngleUtils.formatAngle(startAngle);
            this.angleExtent = endAngle;
            this.angleExtent = geom.AngleUtils.formatAngle(endAngle - startAngle);
            if (!direct)
                this.angleExtent -= 6.283185307179586;
            this.cx = xc;
            this.cy = yc;
            this.__isDefined = /* isFinite */ ((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(r) && r > 0;
            if (!this.__isDefined)
                return;
            this.r = r;
            this.expr = this.expr + " [" + math.MathUtils.roundOffToPreferredSigFigures(/* toDegrees */ (x => x * 180 / Math.PI)(geom.AngleUtils.formatAngle(startAngle))) + math.Unicode.degree_$LI$() + "," + math.MathUtils.roundOffToPreferredSigFigures(/* toDegrees */ (x => x * 180 / Math.PI)(geom.AngleUtils.formatAngle(startAngle + this.angleExtent))) + math.Unicode.degree_$LI$() + "]";
            this.__t0 = 0;
            this.__t1 = Math.abs(this.angleExtent);
            this.__isDefined = true;
        }
        set(xc, yc, r, startAngle, endAngle, direct) {
            if (((typeof xc === 'number') || xc === null) && ((typeof yc === 'number') || yc === null) && ((typeof r === 'number') || r === null) && ((typeof startAngle === 'number') || startAngle === null) && ((typeof endAngle === 'number') || endAngle === null) && ((typeof direct === 'boolean') || direct === null)) {
                return this.set$double$double$double$double$double$boolean(xc, yc, r, startAngle, endAngle, direct);
            }
            else if (((xc != null && xc instanceof math.Vector2) || xc === null) && ((yc != null && yc instanceof math.Vector2) || yc === null) && ((r != null && r instanceof math.Vector2) || r === null) && startAngle === undefined && endAngle === undefined && direct === undefined) {
                return this.set$math_Vector2$math_Vector2$math_Vector2(xc, yc, r);
            }
            else if (((typeof xc === 'number') || xc === null) && ((typeof yc === 'number') || yc === null) && ((typeof r === 'number') || r === null) && startAngle === undefined && endAngle === undefined && direct === undefined) {
                super.set(xc, yc, r);
            }
            else
                throw new Error('invalid overload');
        }
        set$math_Vector2$math_Vector2$math_Vector2(p1, p2, p3) {
            this.__isDefined = false;
            if (math.Vector2.isCollinear(p1, p2, p3)) {
                return;
            }
            if (CircleArc2D.TMP_LINE1 == null) {
                CircleArc2D.TMP_LINE1 = new geom.Line2D();
                CircleArc2D.TMP_LINE2 = new geom.Line2D();
                CircleArc2D.TMP_LINE1.visible = false;
                CircleArc2D.TMP_LINE2.visible = false;
            }
            CircleArc2D.TMP_LINE1.set$double$double$double$double((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, p2.y - p1.y, p1.x - p2.x);
            CircleArc2D.TMP_LINE2.set$double$double$double$double((p2.x + p3.x) / 2, (p2.y + p3.y) / 2, p3.y - p2.y, p2.x - p3.x);
            const inter = geom.CurveUtils.LineLineIntersection$geom_Line2D$geom_Line2D(CircleArc2D.TMP_LINE1, CircleArc2D.TMP_LINE2);
            if (inter == null)
                return;
            const c = inter[0];
            this.r = c.distance$math_Vector2(p1);
            this.cx = c.x;
            this.cy = c.y;
            const a1 = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(c, p1);
            const a2 = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(c, p2);
            const a3 = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(c, p3);
            this.set$double$double$double$double$double$boolean(this.cx, this.cy, this.r, a1, a3, geom.AngleUtils.containsAngle$double$double$double(a1, a3, a2));
        }
        /**
         *
         */
        update() {
        }
        /**
         * returns parametric angle of ellipse
         *
         * @param {number} t
         * algebric parameter of ellipse (a.(1-t^2)/(1+t^2), b.2t/(1+t^2)
         * @return {number} theta in [0,2*PI)
         */
        getTheta_from_t(t) {
            t = 2 * Math.atan(t);
            return this.get_t_from_theta(t);
        }
        isDirect() {
            return (this.angleExtent >= 0.0);
        }
        getStartAngle() {
            return this.startAngle;
        }
        getAngleExtent() {
            return this.angleExtent;
        }
        containsAngle(angle) {
            return geom.AngleUtils.containsAngle$double$double$double$boolean(this.startAngle, this.startAngle + this.angleExtent, angle, this.angleExtent >= 0);
        }
        getAngle(position) {
            if (position < 0.0)
                position = 0.0;
            if (position > Math.abs(this.angleExtent))
                position = Math.abs(this.angleExtent);
            if (this.angleExtent < 0.0)
                position = -position;
            return geom.AngleUtils.formatAngle(this.startAngle + position);
        }
        /*private*/ get_theta_from_t(t) {
            if (t > Math.abs(this.angleExtent))
                t = Math.abs(this.angleExtent);
            if (t < 0.0)
                t = 0.0;
            if (this.angleExtent < 0.0)
                t = -t;
            t += this.startAngle;
            return t;
        }
        /*private*/ get_t_from_theta(theta) {
            theta = geom.AngleUtils.formatAngle(theta);
            if (!this.containsAngle(theta))
                return javaemul.internal.DoubleHelper.NaN;
            if (this.angleExtent > 0)
                return geom.AngleUtils.formatAngle(theta - this.startAngle);
            else
                return geom.AngleUtils.formatAngle(this.startAngle - theta);
        }
        /**
         * Returns the parameter of the first point of the curve.
         * @return {number}
         */
        t0() {
            return 0;
        }
        /**
         * Returns the parameter of the last point of the curve.
         * @return {number}
         */
        t1() {
            return Math.abs(this.angleExtent);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        t(pt) {
            if (pt == null)
                return javaemul.internal.DoubleHelper.NaN;
            const angle = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(this.center(), pt);
            if (this.containsAngle(angle)) {
                if (this.angleExtent > 0)
                    return geom.AngleUtils.formatAngle(angle - this.startAngle);
                else
                    return geom.AngleUtils.formatAngle(this.startAngle - angle);
            }
            return this.firstPoint().distance$math_Vector2(pt) < this.lastPoint().distance$math_Vector2(pt) ? 0 : Math.abs(this.angleExtent);
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        point(t) {
            if ( /* isNaN */isNaN(t))
                return null;
            t = this.get_theta_from_t(t);
            if (!this.containsAngle(t))
                return null;
            return this.center().sum$math_Vector2(math.Vector2.create(this.r, t));
        }
        /**
         *
         * @param {number} t
         * @return {math.Vector2}
         */
        tangent(t) {
            if (!this.__isDefined)
                return null;
            t = this.get_theta_from_t(t);
            return new math.Vector2(t).right();
        }
        /**
         *
         * @param {number} t
         * @return {number}
         */
        derivative(t) {
            if (!this.__isDefined)
                return javaemul.internal.DoubleHelper.NaN;
            t = this.get_theta_from_t(t);
            return -1 / Math.tan(t);
        }
        /**
         *
         * @return {string}
         */
        getEquation() {
            return this.expr;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Arc [" + math.MathUtils.roundOffToPreferredSigFigures(/* toDegrees */ (x => x * 180 / Math.PI)(geom.AngleUtils.formatAngle(this.startAngle))) + math.Unicode.degree_$LI$() + "," + math.MathUtils.roundOffToPreferredSigFigures(/* toDegrees */ (x => x * 180 / Math.PI)(geom.AngleUtils.formatAngle(this.startAngle + this.angleExtent))) + math.Unicode.degree_$LI$() + "]";
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (!this.__isDefined)
                return;
            const c = this.center();
            if (this.fillColor != null) {
            }
            if (this.drawColor != null) {
                g.drawArc(c.x, c.y, this.r, this.startAngle, this.angleExtent, this.angleExtent < 0);
                if (this.showEqn || this.showName) {
                    geom.Circle2D.renderInfo(g, this.getInfo(), c.sum$double$double(this.r, 0), c.difference$double$double(this.r, 0), 1, 0, this.drawColor, null);
                }
            }
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        contains(pt) {
            if (!super.isSnapped(pt))
                return false;
            const angle = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(this.center(), pt);
            return this.containsAngle(angle);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {boolean}
         */
        isSnapped(pt) {
            if (super.isSnapped(pt) === false)
                return false;
            const angle = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(this.center(), pt);
            return this.containsAngle(angle);
        }
        /**
         *
         * @param {math.Vector2} pt
         * @return {number}
         */
        distance(pt) {
            const angle = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(this.center(), pt);
            if (this.containsAngle(angle))
                return Math.abs(this.center().distance$math_Vector2(pt) - this.r);
            return Math.min(this.firstPoint().distance$math_Vector2(pt), this.lastPoint().distance$math_Vector2(pt));
        }
        getFeetOfNormals(point) {
            const c = new math.Vector2(this.cx, this.cy);
            const th = c.to$math_Vector2(point).getAngleWithPositiveXAxis();
            let t = javaemul.internal.DoubleHelper.NaN;
            if (this.containsAngle(th)) {
                t = this.t(super.point(th));
            }
            else if (this.containsAngle(th + Math.PI)) {
                t = this.t(super.point(th + Math.PI));
            }
            if ( /* isNaN */isNaN(t))
                return [];
            return [t];
        }
        /**
         *
         * @param {math.Vector2} point
         * @return {double[]}
         */
        getFeetOfTangents(point) {
            const ths = super.getFeetOfTangents(point);
            for (let i = 0; i < ths.length; i++) {
                {
                    ths[i] = this.get_t_from_theta(ths[i]);
                }
                ;
            }
            return ths;
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelTangents(dir) {
            const th = dir.getAngleWithPositiveXAxis() + Math.PI / 2;
            return [this.get_t_from_theta(th), this.get_t_from_theta(th + Math.PI)];
        }
        /**
         *
         * @param {math.Vector2} dir
         * @return {double[]}
         */
        getFeetOfParallelNormals(dir) {
            const th = dir.getAngleWithPositiveXAxis();
            return [this.get_t_from_theta(th), this.get_t_from_theta(th + Math.PI)];
        }
        /**
         *
         * @param {geom.Line2D} line
         * @return {double[]}
         */
        intersections(line) {
            const pts = geom.CurveUtils.LineCircleIntersection(line, this);
            if (pts == null) {
                return [javaemul.internal.DoubleHelper.NaN, javaemul.internal.DoubleHelper.NaN];
            }
            else if (pts.length === 1) {
                return [this.t(pts[0]), javaemul.internal.DoubleHelper.NaN];
            }
            else {
                return [this.t(pts[0]), this.t(pts[1])];
            }
        }
    }
    CircleArc2D.TMP_LINE1 = null;
    CircleArc2D.TMP_LINE2 = null;
    geom.CircleArc2D = CircleArc2D;
    CircleArc2D["__class"] = "geom.CircleArc2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * @author mahesh
     * @param {string} c1
     * @param {string} c2
     * @param {string} c3
     * @param {string} c4
     * @param {string} c5
     * @param {string} c6
     * @class
     * @extends geom.ConicWrapper2D
     */
    class ConicEqnShape2D extends geom.ConicWrapper2D {
        constructor(c1, c2, c3, c4, c5, c6) {
            if (((typeof c1 === 'string') || c1 === null) && ((typeof c2 === 'string') || c2 === null) && ((typeof c3 === 'string') || c3 === null) && ((typeof c4 === 'string') || c4 === null) && ((typeof c5 === 'string') || c5 === null) && ((typeof c6 === 'string') || c6 === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let coeffs = [c1, c2, c3, c4, c5, c6];
                    super();
                    this.set(coeffs);
                }
            }
            else if (((c1 != null && c1 instanceof Array && (c1.length == 0 || c1[0] == null || (typeof c1[0] === 'string'))) || c1 === null) && c2 === undefined && c3 === undefined && c4 === undefined && c5 === undefined && c6 === undefined) {
                let __args = arguments;
                let coeffs = __args[0];
                super();
                this.set(coeffs);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            switch ((index)) {
                case 0:
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("coeff of x" + math.Unicode.Superscript_2, this.params[0], null);
                case 1:
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("coeff of y" + math.Unicode.Superscript_2, this.params[1], null);
                case 2:
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("coeff of xy", this.params[2], null);
                case 3:
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("coeff of x", this.params[3], null);
                case 4:
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("coeff of y", this.params[4], null);
                case 5:
                    return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("constant term", this.params[5], null);
            }
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index >= 0 && index < 6) {
                this.params[index] = (value + "");
                this.update();
            }
        }
        /**
         * @return {void} the coeff
         * @param {java.lang.String[]} coeffs
         */
        set(coeffs) {
            this.params = coeffs;
            this.update();
        }
        /**
         * returns arrays of parameters needed for construction of this shape for shape if any, else returns null
         *
         * @return
         * @param {number} index
         * @param {string} value
         */
        setParam(index, value) {
            this.params[index] = value;
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            const values = [0, 0, 0, 0, 0, 0];
            try {
                for (let i = 0; i < this.params.length; i++) {
                    {
                        values[i] = math.MathUtils.evaluateExpression(this.params[i], this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables);
                        if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(values[i]))
                            return;
                    }
                    ;
                }
            }
            catch (e) {
                return;
            }
            this.setConic(geom.Conics2D.reduceConic$double_A(values));
            this.getConic().onAddShapeToSimulation(this.shapesManager);
            this.getConic().update();
            this.__isDefined = (this.getConic() != null);
        }
    }
    geom.ConicEqnShape2D = ConicEqnShape2D;
    ConicEqnShape2D["__class"] = "geom.ConicEqnShape2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * Construct a hyperbola from 2 foci and length 2a.
     *
     * @author Mahesh
     * @param {geom.Line2D} line
     * @param {geom.Point2D} point
     * @param {string} expr
     * @class
     * @extends geom.ConicWrapper2D
     */
    class ConicLinePointE2D extends geom.ConicWrapper2D {
        constructor(line, point, expr) {
            super();
            if (this.directrix === undefined) {
                this.directrix = null;
            }
            if (this.e === undefined) {
                this.e = 0;
            }
            this.parents = [line, point];
            this.params = [expr];
            this.directrix = new geom.Line2D();
            this.update();
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Eccentricity", this.params[0], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                this.update();
            }
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined())
                return;
            try {
                this.e = math.MathUtils.evaluateExpression(this.params[0], this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables);
            }
            catch (e) {
                return;
            }
            if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(this.e) || this.e <= 0)
                return;
            const line = this.parents[0];
            this.directrix.set$double$double$double$double(line.x0, line.y0, line.dx, line.dy);
            const focus = this.parents[1].pt;
            if (this.directrix.contains(focus))
                return;
            let conic = null;
            if (this.e === 0) {
                const p0 = line.project(focus);
                const d = p0.distance$math_Vector2(focus);
                conic = new geom.Circle2D(focus.x, focus.y, d);
            }
            else if (this.e === 1) {
                const p0 = line.project(focus);
                const p = p0.distance$math_Vector2(focus) / 2;
                const xv = (focus.x + p0.x) / 2;
                const yv = (focus.y + p0.y) / 2;
                const theta = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(p0, focus);
                conic = new geom.Parabola2D(xv, yv, p, theta);
            }
            else if (this.e > 0 && this.e < 1) {
                const p0 = line.project(focus);
                const d = p0.distance$math_Vector2(focus);
                const otherFocus = math.Vector2.interpolate(p0, focus, (1 + this.e * this.e) / (-2 * this.e * this.e));
                const a = d * this.e / (1 - this.e * this.e);
                conic = new geom.Ellipse2D();
                conic.set$math_Vector2$math_Vector2$double(focus, otherFocus, 2 * a);
            }
            else if (this.e > 1) {
                const p0 = line.project(focus);
                const otherFocus = math.Vector2.interpolate(p0, focus, (1 + this.e * this.e) / (-2 * this.e * this.e));
                const d = p0.distance$math_Vector2(focus);
                const a = -d * this.e / (1 - this.e * this.e);
                const b = Math.sqrt(a * a * this.e * this.e - a * a);
                const centre = math.Vector2.midPoint(focus, otherFocus);
                const theta = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(focus, otherFocus);
                conic = new geom.Hyperbola2D(centre.x, centre.y, a, b, theta);
            }
            this.setConic(conic);
            if (conic != null) {
                conic.onAddShapeToSimulation(this.shapesManager);
                conic.update();
            }
            this.__isDefined = (this.getConic() != null);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return this.getConic().conicType() + " from Directrix " + this.parents[0].getName() + " and focus " + this.parents[1].getName();
        }
    }
    geom.ConicLinePointE2D = ConicLinePointE2D;
    ConicLinePointE2D["__class"] = "geom.ConicLinePointE2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * A conic going through 5 points.
     * @author Legland
     * @param {geom.Point2D} point1
     * @param {geom.Point2D} point2
     * @param {geom.Point2D} point3
     * @param {geom.Point2D} point4
     * @param {geom.Point2D} point5
     * @class
     * @extends geom.ConicWrapper2D
     */
    class Conic5Points2D extends geom.ConicWrapper2D {
        constructor(point1, point2, point3, point4, point5) {
            super(null);
            this.parents = [point1, point2, point3, point4, point5];
            this.showEqn = true;
            this.update();
        }
        /**
         *
         */
        update() {
            this.__isDefined = false;
            for (let index = 0; index < this.parents.length; index++) {
                let s = this.parents[index];
                if (!s.__isDefined)
                    return;
            }
            const points = [null, null, null, null, null];
            for (let i = 0; i < 5; i++) {
                points[i] = this.parents[i].pt;
            }
            const x = [0, 0, 0, 0, 0];
            const y = [0, 0, 0, 0, 0];
            for (let i = 0; i < 5; i++) {
                {
                    x[i] = points[i].x;
                    y[i] = points[i].y;
                }
                ;
            }
            const coefs = geom.Conics2D.findConic(points);
            if (coefs == null)
                return;
            this.setConic(geom.Conics2D.reduceConic$double_A(coefs));
            if (this.getConic() == null)
                return;
            this.getConic().onAddShapeToSimulation(this.shapesManager);
            this.getConic().update();
            this.__isDefined = true;
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            if (this.getConic() == null)
                return "undefined conic";
            const s = geom.ShapesManager.getShapeName(this.getConic().constructor);
            return s + " through " + this.parents[0].getName() + ", " + this.parents[1].getName() + ", " + this.parents[2].getName() + ", " + this.parents[3].getName() + ", " + this.parents[4].getName();
        }
    }
    geom.Conic5Points2D = Conic5Points2D;
    Conic5Points2D["__class"] = "geom.Conic5Points2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * @param {geom.Point2D} point1
     * @param {geom.Point2D} point2
     * @param {geom.Point2D} point3
     * @class
     * @extends geom.CircleArc2D
     * @author mahesh kurmi
     */
    class CircleArc3Points2D extends geom.CircleArc2D {
        constructor(point1, point2, point3) {
            super();
            this.parents = [point1, point2, point3];
            this.update();
        }
        /**
         *
         */
        update() {
            this.expr = null;
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[1].isDefined()) {
                return;
            }
            const p1 = (this.parents[0]).pt;
            const p2 = (this.parents[1]).pt;
            const p3 = (this.parents[2]).pt;
            super.set$math_Vector2$math_Vector2$math_Vector2(p1, p2, p3);
        }
    }
    geom.CircleArc3Points2D = CircleArc3Points2D;
    CircleArc3Points2D["__class"] = "geom.CircleArc3Points2D";
})(geom || (geom = {}));
(function (geom) {
    /**
     * @author mahesh kurmi
     * @param {geom.Point2D} p1
     * @param {geom.Point2D} p2
     * @param {geom.Point2D} p3
     * @class
     * @extends geom.CircleArc2D
     */
    class CircleArcCenter2Points2D extends geom.CircleArc2D {
        constructor(p1, p2, p3) {
            super();
            this.parents = [p1, p2, p3];
            this.params = [true + ""];
            this.update();
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0)
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$java_lang_String$java_lang_String_A("Direct", this.params[0], null);
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            if (index === 0) {
                this.params[0] = (value + "");
                this.update();
            }
        }
        /**
         *
         */
        update() {
            this.expr = null;
            this.__isDefined = false;
            if (!this.parents[0].isDefined() || !this.parents[1].isDefined() || !this.parents[2].isDefined()) {
                return;
            }
            const p1 = (this.parents[0]).pt;
            const p2 = (this.parents[1]).pt;
            const p3 = (this.parents[2]).pt;
            if (p1.equals$math_Vector2(p2) || p1.equals$math_Vector2(p3))
                return;
            const radius = p2.distance$math_Vector2(p1);
            const a1 = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(p1, p2);
            const a2 = geom.AngleUtils.horizontalAngle$math_Vector2$math_Vector2(p1, p3);
            this.startAngle = a1;
            this.angleExtent = Math.abs(geom.AngleUtils.formatAngle(a2 + 2 * Math.PI - a1));
            this.angleExtent = a2 - a1;
            if (this.angleExtent > Math.PI)
                this.angleExtent = this.angleExtent - (2 * Math.PI);
            if (this.angleExtent < -Math.PI)
                this.angleExtent = this.angleExtent + (2 * Math.PI);
            let isDirect = true;
            try {
                if (this.params != null)
                    isDirect = math.MathUtils.evaluateExpression(this.params[0], this.shapesManager == null ? null : this.shapesManager.globalFunctions, this.shapesManager == null ? null : this.shapesManager.globalVariables) !== 0;
            }
            catch (e) {
                console.error(e.message, e);
            }
            this.set$double$double$double$double$double$boolean(p1.x, p1.y, radius, this.startAngle, this.startAngle + this.angleExtent, isDirect);
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Arc with center " + this.parents[0].getName() + " & passing through Points " + this.parents[1].getName() + " , " + this.parents[2].getName();
        }
    }
    geom.CircleArcCenter2Points2D = CircleArcCenter2Points2D;
    CircleArcCenter2Points2D["__class"] = "geom.CircleArcCenter2Points2D";
})(geom || (geom = {}));
(function (geom) {
    class Protractor3Points2D extends geom.CircleArcCenter2Points2D {
        constructor(p1, p2, p3, divSize, numSubDivisions) {
            if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((p3 != null && p3 instanceof geom.Point2D) || p3 === null) && ((typeof divSize === 'string') || divSize === null) && ((typeof numSubDivisions === 'string') || numSubDivisions === null)) {
                let __args = arguments;
                super(p1, p2, p3);
                this.divSize = 5;
                this.numSubDivision = 2;
                this.params = [divSize, numSubDivisions];
                this.divSize = javaemul.internal.DoubleHelper.parseDouble(divSize);
                this.numSubDivision = javaemul.internal.IntegerHelper.parseInt(numSubDivisions);
                this.showEqn = true;
            }
            else if (((p1 != null && p1 instanceof geom.Point2D) || p1 === null) && ((p2 != null && p2 instanceof geom.Point2D) || p2 === null) && ((p3 != null && p3 instanceof geom.Point2D) || p3 === null) && divSize === undefined && numSubDivisions === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let divSize = "5";
                    let numSubDivisions = "5";
                    super(p1, p2, p3);
                    this.divSize = 5;
                    this.numSubDivision = 2;
                    this.params = [divSize, numSubDivisions];
                    this.divSize = javaemul.internal.DoubleHelper.parseDouble(divSize);
                    this.numSubDivision = javaemul.internal.IntegerHelper.parseInt(numSubDivisions);
                    this.showEqn = true;
                }
                this.divSize = 5;
                this.numSubDivision = 2;
            }
            else
                throw new Error('invalid overload');
        }
        /**
         *
         * @param {number} index
         * @return {framework.EditInfo}
         */
        getEditInfo(index) {
            if (index === 0) {
                return geom.Shape2D.editInfo_$LI$().set$java_lang_String$double$double$double("Angular Division Size", this.divSize, javaemul.internal.DoubleHelper.MIN_NORMAL, javaemul.internal.DoubleHelper.MAX_VALUE);
            }
            else if (index === 1) {
                geom.Shape2D.editInfo_$LI$().set$java_lang_String$int$double$double("Division Size", this.numSubDivision, 1, 100);
                geom.Shape2D.editInfo_$LI$().type = framework.EditInfo.TYPE.INTEGER;
                return geom.Shape2D.editInfo_$LI$();
            }
            return null;
        }
        /**
         *
         * @param {number} index
         * @param {*} value
         */
        setEditValue(index, value) {
            const _var = value + "";
            if (index === 0) {
                this.params[0] = _var;
                this.divSize = javaemul.internal.DoubleHelper.parseDouble(this.params[0]);
            }
            else if (index === 1) {
                this.params[1] = _var;
                this.numSubDivision = javaemul.internal.IntegerHelper.parseInt(this.params[1]);
            }
            this.update();
        }
        /**
         *
         * @param {framework.Renderer} g
         */
        render(g) {
            if (this.__isDefined === false)
                return;
            const showInfo = this.showEqn;
            this.showEqn = false;
            super.render(g);
            this.showEqn = showInfo;
            const P = this.parents[0].pt;
            const Q = this.parents[1].pt;
            let th = geom.Shape2D.TMP_VEC_$LI$().set$math_Vector2(P).to$math_Vector2(Q).getDirection();
            const divSizeDegrees = this.divSize / this.numSubDivision;
            const majorTicklength = 16 / g.METER_TO_PIXEL;
            const totalAngleDegrees = (x => x * 180 / Math.PI)(this.angleExtent);
            const textHeight = 16 / g.METER_TO_PIXEL;
            const tickCount = ((totalAngleDegrees / divSizeDegrees) | 0);
            if (tickCount < 2) {
                return;
            }
            g.context.save();
            g.setLineWidth(1);
            g.context.translate(P.x, P.y);
            g.context.rotate(th);
            const minorTickLength = majorTicklength * 0.6;
            let x = 0;
            let y = 0;
            const r1 = this.r - majorTicklength;
            const r2 = this.r - minorTickLength;
            if (this.drawColor != null) {
                g.context.beginPath();
                for (let i = 0; i <= tickCount; i++) {
                    {
                        th = /* toRadians */ (x => x * Math.PI / 180)(i * divSizeDegrees);
                        x = this.r * Math.cos(th);
                        y = this.r * Math.sin(th);
                        if (i % this.numSubDivision === 0) {
                            g.context.moveTo(x, y);
                            g.context.lineTo(x * r1 / this.r, y * r1 / this.r);
                        }
                        else {
                            g.context.moveTo(x, y);
                            g.context.lineTo(x * r2 / this.r, y * r2 / this.r);
                        }
                    }
                    ;
                }
                g.context.stroke();
            }
            if (this.showEqn === false) {
                g.context.restore();
                return;
            }
            x = this.r - majorTicklength - minorTickLength;
            y = -textHeight / 2;
            th = this.numSubDivision * divSizeDegrees;
            th = /* toRadians */ (x => x * Math.PI / 180)(th);
            g.context.textAlign = "right";
            const dh = x * th;
            let gap = 0;
            for (let i = 0; i <= tickCount; i += this.numSubDivision) {
                {
                    const str = math.MathUtils.format(i * divSizeDegrees);
                    if (gap > 0.2) {
                        g.drawLine(x, 0, this.r, 0);
                        g.drawText$java_lang_String$double$double(str, Math.fround(x), Math.fround(y));
                        gap = 0;
                    }
                    g.context.rotate(th);
                    gap += dh;
                }
                ;
            }
            g.context.restore();
        }
        /**
         *
         * @return {string}
         */
        getShapeInfo() {
            return "Pratractor";
        }
    }
    geom.Protractor3Points2D = Protractor3Points2D;
    Protractor3Points2D["__class"] = "geom.Protractor3Points2D";
})(geom || (geom = {}));
geom.optics.OpticalIdealMirror2D.TMP_LINE2_$LI$();
geom.optics.OpticalPathShape2D.TMP_RAY2_$LI$();
geom.optics.OpticalPathShape2D.TMP_SHOT_DATA_$LI$();
geom.optics.OpticalPathShape2D.TMP_SEGMENT_$LI$();
geom.optics.OpticalIdealLens2D.TMP_LINE2_$LI$();
geom.optics.OpticalDevice2D.TMP_LINE_$LI$();
geom.optics.OpticalDevice2D.TMP_RAY_$LI$();
geom.optics.OpticsUtils.TMP_VEC2_$LI$();
geom.optics.OpticsUtils.TMP_VEC_$LI$();
geom.optics.OpticsUtils.TMP_SEGMENT_$LI$();
geom.optics.OpticsUtils.TMP_RAY_$LI$();
geom.RayReflect2PointsCurve2D.TMP_RAY_$LI$();
geom.Conic2D.TMP_SEGMENT_$LI$();
geom.AngleMeasure2D.M_PI_4_$LI$();
geom.AngleMeasure2D.M_3PI_2_$LI$();
geom.AngleMeasure2D.M_PI_2_$LI$();
geom.AngleMeasure2D.M_2PI_$LI$();
geom.AngleMeasure2D.M_PI_$LI$();
geom.Bezier3Points2D.coeff_$LI$();
geom.Bezier4Points2D.coeff_$LI$();
geom.ShapeArray.clazz_$LI$();
geom.Shape2D.editInfo_$LI$();
geom.Shape2D.TMP_TRANSFORM_$LI$();
geom.Shape2D.TMP_VEC_$LI$();
geom.CurveUtils.point_$LI$();
geom.CurveUtils.GOLDEN_SECTION_$LI$();
geom.CurveUtils.lineTerms_$LI$();
geom.CurveUtils.circleTerms_$LI$();
geom.CurveUtils.conicTerms_$LI$();
math.Transform.tmpVector_$LI$();
math.Transform.tmp_Transform_$LI$();
net.objecthunter.exp4j.operator.Operators.builtinOperators_$LI$();
net.objecthunter.exp4j.operator.Operators.__static_initialize();
net.objecthunter.exp4j.__function.Functions.builtinFunctions_$LI$();
net.objecthunter.exp4j.__function.Functions.__static_initialize();
geom.Bounds2D.LARGE_$LI$();
geom.AngleUtils.M_PI_4_$LI$();
geom.AngleUtils.M_3PI_2_$LI$();
geom.AngleUtils.M_PI_2_$LI$();
geom.AngleUtils.M_2PI_$LI$();
geom.AngleUtils.M_PI_$LI$();
math.Vector2.INV_Y_AXIS_$LI$();
math.Vector2.INV_X_AXIS_$LI$();
math.Vector2.Y_AXIS_$LI$();
math.Vector2.X_AXIS_$LI$();
math.Unicode.PI_STRING_$LI$();
math.Unicode.EULER_STRING_$LI$();
math.Unicode.degree_$LI$();
math.Unicode.measuredAngleSpace_$LI$();
math.Unicode.reload_$LI$();
math.Unicode.triangle_$LI$();
math.Unicode.circle_$LI$();
math.Unicode.stop_$LI$();
math.Unicode.reset_$LI$();
math.Unicode.pause_$LI$();
math.Unicode.play_$LI$();
math.MathUtils.matcher_trail_0s_$LI$();
math.MathUtils.nan_$LI$();
math.MathUtils.__random_$LI$();
math.MathUtils.PI2_$LI$();
math.MathUtils.ROOT_7_$LI$();
math.MathUtils.ROOT_6_$LI$();
math.MathUtils.ROOT_5_$LI$();
math.MathUtils.ROOT_3_$LI$();
math.MathUtils.ROOT_2_$LI$();
math.MathUtils.TWO_PI_$LI$();
net.objecthunter.exp4j.operator.Operator.ALLOWED_OPERATOR_CHARS_$LI$();
net.objecthunter.exp4j.operator.Operator.PRECEDENCE_UNARY_PLUS_$LI$();
net.objecthunter.exp4j.operator.Operator.PRECEDENCE_MODULO_$LI$();
net.objecthunter.exp4j.operator.Operator.PRECEDENCE_DIVISION_$LI$();
net.objecthunter.exp4j.operator.Operator.PRECEDENCE_SUBTRACTION_$LI$();
net.objecthunter.exp4j.ValidationResult.SUCCESS_$LI$();
framework.App.main(null);
math.EquationUtils.main(null);
math.Transform.main(null);
