<!doctype html>
<html>
<head>
    <title>Vernier Calliper Simulator</title>
    <style>
        body {
            background: white;
            color: #323232;
            font-weight: 300;
            height: 100vh;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-family: Helvetica neue, roboto;
        }

        img {
            width: 56px;
            height: 48px;
        }

        h1 {
            font-weight: 200;
            font-style: 26px;
            margin: 10px;
        }
    </style>
    <script src="dat.gui.js"></script>
    <style src="dat.gui.css"></style>
</head>

<body>


<div id="canvasdiv" class="container" align="center">
    <canvas id="myCanvas" style="border: 1px solid #c3c3c3;">
             Your browser does not support the HTML5 canvas tag.
    </canvas>
</div>
s
<script type='text/javascript'>
    /*drawing offset*/
    var scale=window.innerWidth/1000;
    var xOffset=0;
    var yOffset=0;
    var dragMode=0;//0==none, 1=world, 2=vernier, 3= object

    var mx, my; //prev mouse positions
    var bgColor = "rgb(0,64,84)";
    var fgColor="rgb(255,255,255)";
    const scaleColor="black";

    var loadedItems=0;
    const itemsToLoad=7;
    //gauge variables
    var imgVernier=new Image();
    imgVernier.src="vernier.png"
    imgVernier.onload=itemloaded;
    var imgVernier1=new Image();
    imgVernier1.src="vernier1.png"
    imgVernier1.onload=itemloaded;
    var imgVernier2=new Image();
    imgVernier2.src="vernier2.png"
    imgVernier2.onload=itemloaded;
    var imgVernier3=new Image();
    imgVernier3.src="vernier3.png"
    imgVernier3.onload=itemloaded;
    var imgBlade=new Image();
    imgBlade.src="blade.png"
    imgBlade.onload=itemloaded;
    var imgBase=new Image();
    imgBase.src="vernier_base.png"
    imgBase.onload=itemloaded;
    var imgSimphy=new Image();
    imgSimphy.src="simphy-logo.png"
    imgSimphy.onload=itemloaded;

    var tickSound = new Audio("tick.wav");
    tickSound.onload=itemloaded;
    //tickSound.preload = 'auto';
    //tickSound.load();
    const scaleOriginX=67; //jaw Left position
    const scaleOriginY0=105; //scale top position
    const scaleOriginY=162; //scale bottom position
    const offsetOriginX=12; //distance of scale origin level from scaleOriginX
    const vernierOriginX=55; //distance of vernier origin in pixel in vernier.png
    const vernierOriginY=161;

    const rulerWidthPixel=915
    const majorTickLengthPixels=22;
    const minorTickLengthPixels=13;
    const vernierMajorTickLengthPixels=10;
    const vernierMinorTickLengthPixels=8;
    const mainScaleLengthPixels=600; //600

    const vernierScaleHeightPixels=354;
    const bladeWidthPixel=716;
    const bladeHeightPixel=20;

    const unit="mm";
    var mainScaleDivisions=50;
    var msdValue=0.1;
    var vernierScaleDivisions=10;
    var msd_pixels=mainScaleLengthPixels/mainScaleDivisions;
    var vsd_pixels=mainScaleLengthPixels/mainScaleDivisions;
    var vernierScaleLengthPixels=180;

    var LC=0;
    var msr=0;
    var vsr=0;
    var zeroError=0;
    var displayInfo=false;
    var objectWidthPixel=25;

    var randomZeroError=true;
    var randomMainScaleDivisions=true;
    var randomVernierScaleDivision=true;
    var randomObjectWidthPixel=true;
    var objectTobeMeasured={x:xOffset+ window.innerWidth-40,y:yOffset+window.innerHeight-110,w:30,h:100,type:0,state:1};//state =0=hide, 1= visible but not snapped, 2=snapped

    //create gui
    var gui = new dat.GUI({name:"MicrometerSimulation"});//,autoPlace: false});
    var deviceFolder=gui.addFolder("Device Settings")
    deviceFolder.add(window, "msdValue").name("MSD").min(0.05).max(5).step(0.5).onChange(update);
    deviceFolder.add(window, "mainScaleDivisions").name("MSD Count").min(20).max(200).step(10).onChange(update);
    deviceFolder.add(window, "vernierScaleDivisions").name("VSD Count").min(5).max(100).step(5).onChange(update);
    deviceFolder.add(window, "zeroError").name("Zero Error").min(-vernierScaleDivisions+1).max(vernierScaleDivisions-1).step(1).onChange(update);
    var displayFolder=gui.addFolder("Display Settings")
    displayFolder.add(window, "scale").name("Scale  ").min(0.1).max(5).step(0.01).onChange(update);
    displayFolder.add(window, "displayInfo").name("Display values").onChange(update);
    displayFolder.addColor(window, "bgColor").name("Backround  ").onChange(update);
    var problemFolder=gui.addFolder("Create problem");
    problemFolder.add(window,"randomZeroError");
    problemFolder.add(window,"randomMainScaleDivisions");
    problemFolder.add(window,"randomVernierScaleDivision");
    problemFolder.add(window,"randomObjectWidthPixel");
    problemFolder.add(window,"createProblem");

    var canvas=document.getElementById("myCanvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    var ctx=canvas.getContext("2d");
    ctx.font = "30px Arial";
    //Add event listeners
    window.addEventListener('resize',function(ev) { return resize(ev); });

    function itemloaded(){
        loadedItems++;
        if(loadedItems==itemsToLoad){
            canvas.addEventListener("mousewheel",mouseWheelMoved);
            canvas.addEventListener("mousemove",mouseDragged);
            canvas.addEventListener("mousedown",mousePressed);
            canvas.addEventListener("mouseup",mouseReleased);
            canvas.addEventListener("touchstart", myTouchStart, false);	// touch handler for iPhones, iPads, and Androids
            canvas.addEventListener("touchmove", myTouchMove, false);	// touch handler for iPhones, iPads, and Androids
            canvas.addEventListener("touchend", myTouchEnd, false);		// touch handler for iPhones, iPads, and Androids
            window.addEventListener('keydown',onKeyEvent,false);
        }
        paint();
    }

    function resize(){
        scale*=window.innerWidth/canvas.width;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        update();
    }

    init();

    function init(){
        resize();
    }

    function createProblem(){
        if(randomVernierScaleDivision)randomVernierScaleDivision=(1+Math.round(Math.random()*9))*10;
        if(randomZeroError)zeroError=Math.round(2*vernierScaleDivisions*(Math.random()-0.5));
        if(randomMainScaleDivisions)mainScaleDivisions=10*(1+Math.round(4*Math.random()));
        if(randomObjectWidthPixel)objectWidthPixel=mainScaleLengthPixels*(1+5*Math.random())/10;
        objectTobeMeasured.state=1;
        objectTobeMeasured.w=objectWidthPixel;
        //objectTobeMeasured.x=xOffset+canvas.width-objectTobeMeasured.w-10;
        //objectTobeMeasured.y=yOffset+canvas.height-objectTobeMeasured.h-10;
        if(Math.abs(objectTobeMeasured.x-spindleOriginX)<200 && Math.abs(objectTobeMeasured.y-scaleOriginY+objectTobeMeasured.h/2)<objectTobeMeasured.h/2+50){
            objectTobeMeasured.x=spindleOriginX;
            objectTobeMeasured.y=scaleOriginY-objectTobeMeasured.h/2;
            objectTobeMeasured.state=2;
        }else if(objectTobeMeasured.x>window.innerWidth-objectTobeMeasured.w||objectTobeMeasured.y>window.innerHeight-objectTobeMeasured.w||objectTobeMeasured.x<objectTobeMeasured.w/2||objectTobeMeasured.y<-objectTobeMeasured.h/2){
            objectTobeMeasured.x = window.innerWidth-objectTobeMeasured.w;
            objectTobeMeasured.y = window.innerHeight-objectTobeMeasured.h
        }
        for (let i in deviceFolder.__controllers) {
            if (deviceFolder.__controllers[i].property == "zeroError"){
                deviceFolder.__controllers[i].min(-vernierScaleDivisions+1).max(vernierScaleDivisions-1).step(1);
            }
            if (deviceFolder.__controllers[i].property == "vernierScaleDivisions"){
                deviceFolder.__controllers[i].min(5).max(mainScaleDivisions/3).step(1);
            }
            deviceFolder.__controllers[i].updateDisplay();

        }
        translateVernier(0);
    }

    function translateVernier(div){
        vsr+=div;
        if (vsr<0) {
            vsr=vernierScaleDivisions+vsr;
            msr-=1;

        }else if(vsr>=vernierScaleDivisions){
            vsr=vsr-vernierScaleDivisions;
            msr+=1;

        }
        let correctedReading=getCorrectedReading();

        if(correctedReading<=0){
            msr=0;
            vsr=0;
            tickSound.muted=false;
            if(tickSound.paused)tickSound.play();
        }
        if(correctedReading>=mainScaleDivisions*msdValue){
            msr=mainScaleDivisions;
            vsr=0;
            tickSound.muted=false;
            if(tickSound.paused)tickSound.play();
        }
        if(objectWidthPixel!=0){
            //if(msr*vernierScaleDivisions+vsr)*mainScaleLengthPixels
        }
        update();
    }

    function update(){
        LC=msdValue/vernierScaleDivisions;
        msd_pixels=mainScaleLengthPixels/mainScaleDivisions;
        vsd_pixels=msd_pixels*(1-1/vernierScaleDivisions);
        vernierScaleLengthPixels=Math.max(imgVernier1.width+imgVernier3.width,50+vsd_pixels*vernierScaleDivisions+50);//imgVernier3.width;

        if(objectTobeMeasured.state==2){
            let v=(msr+vsr/vernierScaleDivisions)*msd_pixels
            if(v<objectTobeMeasured.w){
                msr=Math.floor(objectTobeMeasured.w/msd_pixels);
                vsr=Math.floor((objectTobeMeasured.w/msd_pixels-msr)*vernierScaleDivisions);
                if(tickSound.paused)tickSound.play();
            }
        }
        for (let i in deviceFolder.__controllers) {
            if (deviceFolder.__controllers[i].property == "zeroError"){
                deviceFolder.__controllers[i].min(-vernierScaleDivisions+1).max(vernierScaleDivisions-1).step(1);
            }
            if (deviceFolder.__controllers[i].property == "vernierScaleDivisions"){
                deviceFolder.__controllers[i].min(5).max(mainScaleDivisions/3).step(5   );
            }
            deviceFolder.__controllers[i].updateDisplay();

        }
        paint();
    }


    function paint(){
         //	ctx.clear();

        ctx.fillStyle=bgColor;
        ctx.strokeStyle=fgColor;
        ctx.fillRect(0,0,canvas.width,canvas.height);
        if(loadedItems<itemsToLoad){
           ctx.font = "30px Arial";
           ctx.fillStyle=fgColor;
           outString(canvas.width/2,canvas.height/2,"Loading ..."+(loadedItems*100/itemsToLoad).toFixed(0)+"%",1,1);
           return;
        }
        ctx.font = '10pt sans-serif';

        ctx.scale(scale,scale);
        ctx.translate(xOffset,yOffset);
        ctx.save();

        //draw  blade first
        let shift=(msr+vsr/vernierScaleDivisions)*msd_pixels;
        let x=rulerWidthPixel+shift-bladeWidthPixel;
        let y=(scaleOriginY0+scaleOriginY)/2-bladeHeightPixel/2;
        ctx.drawImage(imgBlade,x,y);

        //draw Base of gauge
        ctx.drawImage(imgBase,0,0);

        //draw ruler on main scale
        ctx.translate(scaleOriginX+offsetOriginX,scaleOriginY);
        //Rectangle2D.Double rect = new Rectangle2D.Double(Xoffset,Yoffset,mainscaleWidth,mainscaleHeight);
        ctx.fillStyle=scaleColor;//"rgb(210,210,210)";
        ctx.strokeStyle=scaleColor;
        x=-msd_pixels*zeroError/vernierScaleDivisions,y=0;
        let ticklength=0;
        let labelGap=0;
        while(msd_pixels*labelGap<50){
            labelGap+=5;
        }
        for (let i=0;i<=mainScaleDivisions;i++){
            ticklength=(i % 5==0)?majorTickLengthPixels:minorTickLengthPixels;
            drawLine(x,y,x,y-ticklength);
            if (i%labelGap==0)outString(x, (y-ticklength-3),i*msdValue,1,2);
            x+=msd_pixels;
        }

        ctx.restore();
        ctx.strokeStyle=scaleColor;
        ctx.fillStyle=scaleColor;

        //ctx.translate(scaleOriginX+shift,scaleOriginY)
        outString(844, 117,"1 MSD = "+msdValue+unit,1,0);

        //draw Vernier scale
        x=scaleOriginX-offsetOriginX+shift-vernierOriginX;
        y=scaleOriginY-vernierOriginY;
        ctx.drawImage(imgVernier1,x,y);
        let w=vernierScaleLengthPixels-imgVernier1.width-imgVernier3.width;
        if(w>0){
            let h=imgVernier1.height;
            ctx.drawImage(imgVernier2,0,0,w,h,x+imgVernier1.width,y,w,h);
        }

        ctx.drawImage(imgVernier3,x+imgVernier1.width+w,y);

        x=scaleOriginX+shift+offsetOriginX  ;
        y=vernierOriginY-1;
        ctx.font = '8pt sans-serif';

        let N=vernierScaleDivisions;
        let dx=msd_pixels*(1-1/N);
        labelGap=0;
        while(vsd_pixels*labelGap<20){
            labelGap+=1;
        }
        for (let i=0;i<=N;i++){
            ticklength=vernierMinorTickLengthPixels;
            if(i%labelGap==0){
                ticklength=vernierMajorTickLengthPixels;
                outString(x,y+ticklength+1,i,1,0 );
            }
            drawLine(x,y,x,y+ticklength);
            x+=dx;
        }
        ctx.fillStyle=fgColor;
        ctx.font = '12pt sans-serif';

        if(objectTobeMeasured.state>0){
            let grd=ctx.createLinearGradient(objectTobeMeasured.x,objectTobeMeasured.y,objectTobeMeasured.x+objectTobeMeasured.w,objectTobeMeasured.y);
            grd.addColorStop(0,"rgb(120,120,120)")
            grd.addColorStop(0.5,"rgb(220,230,210)")
            grd.addColorStop(1,"rgb(120,120,120)")
            ctx.fillStyle=grd;
            ctx.fillRect(objectTobeMeasured.x+1,objectTobeMeasured.y,objectTobeMeasured.w,objectTobeMeasured.h);
            ctx.strokeStyle=scaleColor;
            ctx.strokeRect(objectTobeMeasured.x+1,objectTobeMeasured.y,objectTobeMeasured.w,objectTobeMeasured.h);
            ctx.fillStyle=fgColor;
        }

        if(displayInfo)drawInfo();
        //draw Base of gauge
        ctx.drawImage(imgBase,0,0,64,102,0,0,64,102);

        ctx.resetTransform();

        ctx.drawImage(imgSimphy,5,5,100,30);
    }

    function drawInfo(){
        //draw MSD Info and CSD Info
        ctx.lineWidth=1.5;
        ctx.fillStyle=fgColor;
        ctx.strokeStyle=fgColor;
        //dra MSD Hint
        let x=scaleOriginX-msd_pixels*zeroError/vernierScaleDivisions + getMainScaleReading()*msd_pixels;
        let y=scaleOriginY+2+minorTickLengthPixels;
        let arrowSize=5;
        drawLineWithArrows(x,y,x, y+50,arrowSize,arrowSize,true,false);
        outString(x, y+53,getMainScaleReading()+"MSD = "+formatValue(getMainScaleReading()*msdValue),1,0);

        //Draw CSD Hint
        let gappixel=msd_pixels*(msr+vsr/vernierScaleDivisions);
        x=scaleOriginX+gappixel;
        y=scaleOriginY;
        drawLineWithArrows(x,y,x+40, y,arrowSize,arrowSize,true,false);
        outString(x+47, y,getVernierScaleReading()+"CSD = "+formatValue(msdValue*getVernierScaleReading()/vernierScaleDivisions),0,1);

        //Draw SCrew gauge Reading
        x=spindleOriginX-1;
        y=spindleOriginY-20;
        drawLineWithArrows(x-30,y,x, y,arrowSize,arrowSize,false,true);
        x=spindleOriginX+gappixel+3;
        y=spindleOriginY-20;
        drawLineWithArrows(x,y,x+30, y,arrowSize,arrowSize,true,false);
        let mr=getMeasuredReading();
        let cr=getCorrectedReading();
        let ze=getZeroError();
        y=spindleOriginY-42;
        x=spindleOriginX+gappixel/2;
        if(ze==0){
            outString(x, y,formatValue(cr),1,1);
        }else if(ze>0){
            outString(x, y,formatValue(mr)+' - '+formatValue(ze)+" = "+formatValue(cr),1,1);
        }else{
            outString(x, y,formatValue(mr)+' + '+formatValue(-ze)+" = "+formatValue(cr),1,1);
        }


        /*
        let objw=(objectTobeMeasured.w/msd_pixels)*msdValue;
        outString(20, 550," msr="+getMainScaleReading()+"  vsr="+getVernierScaleReading(),0,2);
        outString(20, 575,"Measured Reading="+mr.toFixed(3)+" ZeroError="+ze.toFixed(3)+ " Corrected Reading ="+cr.toFixed(3),0,2);
        outString(20, 625,"Obj Width pixels="+objectTobeMeasured.w.toFixed(3)+"pixels , msd in pixels =  "+msd_pixels.toFixed(3)+" cm",0,2);
        outString(20, 600,"Actual Object Width = ="+objw.toFixed(3),0,2);
        */
    }


    function getZeroError(){
        return (zeroError/vernierScaleDivisions)*msdValue;
    }

    function formatValue(s){
        return s.toFixed(2)+unit;
    }
    function getMainScaleReading(){
        return Math.floor((msr*vernierScaleDivisions+vsr+zeroError)/vernierScaleDivisions);
    }

    function getVernierScaleReading(){
        return mod(vsr+zeroError,vernierScaleDivisions);
    }

    function getMeasuredReading(){
        return getCorrectedReading()+getZeroError();
    }

    function getCorrectedReading(){
        return (msr+vsr/vernierScaleDivisions)*msdValue;
    }


    /**
     * returns +ve remainder whn a is divided by n
     * */
    function mod(a,n){
        return ((a % n ) + n ) % n;
    }
    function drawLine(x1,y1,x2,y2){
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }

    // x0,y0: the line's starting point
    // x1,y1: the line's ending point
    // width: the distance the arrowhead perpendicularly extends away from the line
    // height: the distance the arrowhead extends backward from the endpoint
    // arrowStart: true/false directing to draw arrowhead at the line's starting point
    // arrowEnd: true/false directing to draw arrowhead at the line's ending point
    function drawLineWithArrows(x0,y0,x1,y1,aWidth,aLength,arrowStart,arrowEnd){
        var dx=x1-x0;
        var dy=y1-y0;
        var angle=Math.atan2(dy,dx);
        var length=Math.sqrt(dx*dx+dy*dy);
        //
        ctx.save();
        ctx.translate(x0,y0);
        ctx.translate(angle);
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(length,0);
        if(arrowStart){
            ctx.moveTo(aLength,-aWidth);
            ctx.lineTo(0,0);
            ctx.lineTo(aLength,aWidth);
        }
        if(arrowEnd){
            ctx.moveTo(length-aLength,-aWidth);
            ctx.lineTo(length,0);
            ctx.lineTo(length-aLength,aWidth);
        }
        //
        ctx.stroke();
        ctx.restore();
    }
    function outString( x,y, s, x_align, y_align) {
        var fm=ctx.measureText(s);
        var h=10;//fm.height not supported in browsers
        switch (y_align) {
            case 0:
                y += h;
                break;
            case 1:
                y += h / 2;
                break;
            case 2:
                break;
        }
        switch (x_align) {
            case 0:
                ctx.fillText(s, x+3, y);
                break;
            case 1:
                ctx.fillText(s, x - fm.width/2, y);
                break;
            case 2:
                ctx.fillText(s, x - fm.width / 2, y);
                break;
        }
    }


    function myTouchMove(te){
        te.preventDefault();
        var touch = te.touches[0];
        var mouseEvent = new MouseEvent("mousemove", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
    }

    function myTouchStart(te){
        te.preventDefault();
        var touch = te.touches[0];
        var mouseEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
    }

    function myTouchEnd(te){
        te.preventDefault();
        var touch = te.touches[0];
        var mouseEvent = new MouseEvent("mouseup", {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
    }

    function getMousePos(event){
        let rect = canvas.getBoundingClientRect();
        return [ event.clientX - rect.left,event.clientY - rect.top];
    }

    function mousePressed( me) {
        let m=getMousePos(me);

        //convert mouse pos in world coordinates taking translation and scale in account
        let x = m[0]/scale-xOffset;
        let y = m[1]/scale-yOffset;
        let shift=scaleOriginX+(msr+vsr/vernierScaleDivisions)*msd_pixels;
        if((x>shift && x<shift+imgVernier1.width && y>scaleOriginY-100 && y<vernierScaleHeightPixels)||
            (x>shift+imgVernier1.width && x<shift+vernierScaleLengthPixels && y>scaleOriginY-100 && y<scaleOriginY+20)) {

            dragMode = 2;
        }else if(objectTobeMeasured.state>0 && x>objectTobeMeasured.x && x<objectTobeMeasured.x+objectTobeMeasured.w && y>objectTobeMeasured.y && y<objectTobeMeasured.y+objectTobeMeasured.h){
            dragMode = 3;
            objectTobeMeasured.state=1;
        }else{
            dragMode=1;
        }
        paint();
        mx = m[0];
        my = m[1];
        me.preventDefault();
    }

    function mouseReleased( me) {
        if(dragMode==3) { //move object
            if(Math.abs(objectTobeMeasured.x-scaleOriginX)<200 && Math.abs(objectTobeMeasured.y-scaleOriginY+objectTobeMeasured.h/2)<objectTobeMeasured.h/2+50){
                objectTobeMeasured.x=spindleOriginX;
                objectTobeMeasured.y=scaleOriginY-objectTobeMeasured.h/2;
                objectTobeMeasured.state=2;
            }
            update();
         }
        dragMode=0;
    }

    function mouseWheelMoved(me) {
        //console.log(e.wheelDelta);
        var scroll=me.wheelDelta>0?1:-1;
        translateVernier(scroll);
        me.preventDefault();
    }

    function mouseDragged( me) {
        if (dragMode==0) return false;
        let m=getMousePos(me);
        //console.log(m);
        let dx,dy;
        dx = (m[0]- mx)/scale;
        dy = (m[1]- my)/scale;
        mx = m[0];
        my = m[1];
        if(dragMode==1) { //move scene
            xOffset += dx;
            yOffset += dy;
            paint();
        }else if(dragMode==3){ //move object
            objectTobeMeasured.x+=dx;
            objectTobeMeasured.y+=dy;
            paint();
        }else if(dragMode==2){ //move vernier

            if (msr>=mainScaleDivisions&&dx>0){
                paint();
                return;
            }
            if (msr== 0&& vsr==0 && (dx<0)){
                paint();
                return;
            }
            translateVernier( Math.round(dx));
        }else{//move object

        }

        //update();
        me.preventDefault();
    }



    /**
     * Runs when widget recieves key event (events are similar to java.awt events).
     * @param keyChar {char} : the character(if any) associated with keyevent
     * @param keyCode {Number} : key code {@see https://docs.oracle.com/javase/7/docs/api/java/awt/event/KeyEvent.html} for keycodes
     * @param key {String} : the identifier of the key (like 'ArrowLeft','a','Enter','F11) that was pressed when a key event occured
     * @param id {Number} : EventType 401(keyPressed), 402(KeyReleased)
     * @return if true is returned event is consumed and not further handled by simphy world*/
    function onKeyEvent(e){
        //if(id==401){
        if(e.keyCode==37 ||e.keyCode==38){
            translateVernier(-1);
        }
        else if (e.keyCode==39||e.keyCode==40){
            translateVernier(1);
        }
        else if (e.keyCode==33){//page up
            scale*=1.04;
            update();
        }
        else if (e.keyCode==34){//page down
            scale*=0.96;
            update();
        }else {
            return false;
        }

        e.preventDefault();
    }
</script>
</body>
</html>