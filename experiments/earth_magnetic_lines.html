<!doctype html>
<head>
    <title>Homopolar Motor</title>
    <meta name="keywords" content="Motor magnetic field homopolar simulation physics">
    <meta name="author" content="Mahesh Kurmi">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <style>
        html, body {
            padding: 0;
            margin: 0;
            background: rgb(0,64,84);
        }

        img {
            width: 56px;
            height: 48px;
        }

        h1 {
            font-weight: 200;
            font-style: 26px;
            margin: 10px;
        }

        #container canvas{
            position: relative;
            touch-action: none;
        }
        #container #overlay {
            position: absolute;
        }

        .hover_bkgr_fricc{
            background:rgba(0,0,0,.4);
            cursor:pointer;
            display:none;
            height:100%;
            position:fixed;
            text-align:center;
            top:0;
            width:100%;
            z-index:10000;
        }
        .hover_bkgr_fricc .helper{
            display:inline-block;
            height:100%;
            vertical-align:middle;
        }
        .hover_bkgr_fricc > div {
            background-color: #fff;
            box-shadow: 10px 10px 60px #555;
            display: inline-block;
            height: auto;
            max-width: 551px;
            min-height: 100px;
            vertical-align: middle;
            width: 60%;
            position: relative;
            border-radius: 8px;
            padding: 15px 5%;
        }
        .popupCloseButton {
            background-color: #fff;
            border: 3px solid #999;
            border-radius: 50px;
            cursor: pointer;
            display: inline-block;
            font-family: arial;
            font-weight: bold;
            position: absolute;
            top: -20px;
            right: -20px;
            font-size: 25px;
            line-height: 30px;
            width: 30px;
            height: 30px;
            text-align: center;
        }
        .popupCloseButton:hover {
            background-color: #ccc;
        }
        .trigger_popup_fricc {
            background-color: #fff;
            border: 3px solid #999;
            border-radius: 50px;
            cursor: pointer;
            font-size: 20px;
            position:absolute;
            font-family: arial;
            font-weight: bold;
            position: absolute;
            top:5px;
            left:5px;
            zindex:2;
            margin: 10px;
            display: inline-block;
            font-weight: bold;
            right: -20px;
            font-size: 25px;
            line-height: 30px;
            width: 30px;
            height: 30px;
            text-align: center;
        }
        #gui {
            font-size: 15px;
            position:absolute;
            font-family: arial;
            transform:scale(1.2);
            transform-origin: top right;
            font-weight: bold;
            position: absolute;
            right:5px;
            margin-left: auto;
            zindex:2;
            font-weight: bold;
            font-size: 25px;
        }
        #loading-screen {
            position: absolute;
            z-index: 2;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgb(0,64,84);
            opacity: 1;
            transition: 1s opacity;
        }

        #loading-screen.fade-out {
            opacity: 0;
        }

        #loader {
            display: block;
            position: relative;
            left: 50%;
            top: 50%;
            width: 150px;
            height: 150px;
            margin: -75px 0 0 -75px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: #9370DB;
            -webkit-animation: spin 2s linear infinite;
            animation: spin 2s linear infinite;
        }
        #loader:before {
            content: "";
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: #BA55D3;
            -webkit-animation: spin 3s linear infinite;
            animation: spin 3s linear infinite;
        }
        #loader:after {
            content: "";
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            bottom: 15px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: #FF00FF;
            -webkit-animation: spin 1.5s linear infinite;
            animation: spin 1.5s linear infinite;
        }
        @-webkit-keyframes spin {
            0%   {
                -webkit-transform: rotate(0deg);
                -ms-transform: rotate(0deg);
                transform: rotate(0deg);
            }
            100% {
                -webkit-transform: rotate(360deg);
                -ms-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }
        @keyframes spin {
            0%   {
                -webkit-transform: rotate(0deg);
                -ms-transform: rotate(0deg);
                transform: rotate(0deg);
            }
            100% {
                -webkit-transform: rotate(360deg);
                -ms-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
<div id="container">
    <div id="gui" style="position: absolute">
    </div>

    <section id="loading-screen">

        <div id="loader"></div>

    </section>


    <a class="trigger_popup_fricc">	&#8505;</a>
    <div id="overlay">

        <div class="hover_bkgr_fricc">
            <span class="helper"></span>
            <div>
                <div class="popupCloseButton">&times;</div>
                <h3>Earth's Magnetic Field</h3>
                <p> The simulation displays the magnetic field of earth in 3D. You can customize line density and optionally show magnetic maeridian.
                <h4>Controls</h4>
                Drag the red ball to visualize B at any point.<br>
                </p>
            </div>
        </div>
    </div>

</div>
<script src="tweakpane3.js"></script>
<script src="https://unpkg.com/three"></script>
<script src="https://unpkg.com/@seregpie/three.text-texture"></script>
<script src="https://unpkg.com/@seregpie/three.text-sprite"></script>


<script type="module">

   // import * as THREE from "https://threejs.org/build/three.module.js";
    import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
    import { Line2 } from 'https://threejs.org/examples/jsm/lines/Line2.js';
    import { LineMaterial } from 'https://threejs.org/examples/jsm/lines/LineMaterial.js';
    import { LineGeometry } from 'https://threejs.org/examples/jsm/lines/LineGeometry.js';
    import { DragControls } from 'https://threejs.org/examples/jsm/controls/DragControls.js';
  // import { MeshLine, MeshLineMaterial, MeshLineRaycast } from 'three.meshline';

    //const loader = new THREE.TextureLoader();
    var renderer, scene, camera;
    var groundTex,earthTex,compassTex;
    var equator,magnet,earth, compass,meridian, compassArrow,planeGM, planeMM, field
    var bgColor=new THREE.Color("rgb(0,64,84)");
    var pane;


    var resourcePaths=['checker.png','earth.jpg'];
    var resources=[];
    var loadedResources=0;
    var src0=new THREE.Vector3(0,0.05,0),src1=new THREE.Vector3(0,-0.05,0);
    var vField=new VectorField();
    var dragControls,orbitControls;
    for(let i=0;i<2;i++){
        resources[i]= document.createElement('img');
        resources[i].src = 'resources/'+resourcePaths[i];
        resources[i].onload=load;
    }

    function load(obj){
        loadedResources++;
        if(loadedResources==resourcePaths.length){
            init();
            const loadingScreen = document.getElementById( 'loading-screen' );
            loadingScreen.classList.add( 'fade-out' );
            // optional: remove loader from DOM via event listener
            loadingScreen.addEventListener( 'transitionend', loadingCompleted );
        }
    }

    function loadingCompleted( event ) {
        event.target.remove();
    }

    function loadTexture(index,repeat,n){
        let texture=new THREE.Texture( resources[index] );
        if(repeat){
            texture.wrapS= THREE.RepeatWrapping;
            texture.wrapT= THREE.RepeatWrapping;
            texture.repeat.set( n,n );
        }
        texture.needsUpdate = true;
        return texture;
    }

    var settings={
        intensity:0.2,
        showEarth:true,
        showMeridian:true,
    }

    function BodyPhysics(mesh){
        this.mesh=mesh;
        this.velocity=new THREE.Vector3();
        this.angularVelocity=new THREE.Vector3();
        this.acceleration=new THREE.Vector3();
        this.angularAcceleration=new THREE.Vector3();
        this.update=function(dt){
            this.velocity.addScaledVector(this.acceleration,dt);
            this.angularVelocity.addScaledVector(this.angularAcceleration,dt);
            this.mesh.position.addScaledVector(this.velocity,dt);
            let v=this.mesh.rotation;
            v=new THREE.Vector3(v.x,v.y,v.z);
            v.addScaledVector(this.angularVelocity,dt);
            this.mesh.rotation.set(v.x,v.y,v.z);
        }
    }



    function init() {
        pane = new Tweakpane.Pane({container:document.getElementById("gui"),title:"Earth's Magnetic Field",expanded: true});
        pane.addInput(settings, "intensity",{label:"Field Intensity",min:0,max:1,step:0.05}).on('change',updateField);
        pane.addInput(settings, "showEarth",{label:"Show Earth"}).on('change',updateParams);
        pane.addInput(settings, "showMeridian",{label:"Show Meridian"}).on('change',updateParams);
       // pane.addInput(settings, "isRunning",{label:"Run"}).on('change',updateParams);
       // pane.addButton({title:"Reset"}).on('click',reset);

        document.querySelector(".trigger_popup_fricc").onclick=function(){
            document.querySelector('.hover_bkgr_fricc').style.display = "block";
        };
        document.querySelector('.hover_bkgr_fricc').onclick =function(){
            document.querySelector('.hover_bkgr_fricc').style.display = "none";
        };
        document.querySelector('.popupCloseButton').onclick=function(){
            document.querySelector('.hover_bkgr_fricc').style.display = "none";
        };
        window.addEventListener( 'resize', onWindowResize, false );

        groundTex=loadTexture(0,true,3,3);
        earthTex=loadTexture(1);

        // renderer
        renderer = new THREE.WebGLRenderer({antialias :true});
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.physicallyBasedShading = true;
        document.body.appendChild( renderer.domElement );

        // scene
        scene = new THREE.Scene();
        scene.background=bgColor;

        // camera
        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 30 );
        camera.position.set( 0, 2, 4 );

        // controls
        orbitControls = new OrbitControls( camera, renderer.domElement );

        // ambient
        scene.add( new THREE.AmbientLight( 0x222222 ) );

        // light
        var light = new THREE.DirectionalLight( 0xaaaaaa, 1);
        light.position.set(1,3,2 ); //20,20,0
        light.castShadow=true;

        light.shadow.camera.left = -2;
        light.shadow.camera.top = 2;
        light.shadow.camera.right = 2;
        light.shadow.camera.bottom = -2;
        light.shadow.camera.near = 1;
        light.shadow.camera.far = 5;
        light.shadow.bias=-0.005;

        	//light.shadowBias = 2;
        	//light.shadowMapWidth = light.shadowMapHeight = 2040;
        light.shadow.darkness = 1;
        //light.shadowCameraVisible = true;
        //scene.add( new THREE.DirectionalLight(light, 2.5) );
        scene.add( light );

        // axes
        //scene.add( new THREE.AxesHelper( 20 ) );

        light = new THREE.PointLight( 0xffffff,0.45 ); // soft white light
        light.position.set(0,0,0);
        camera.add( light );
        scene.add(camera);



        // Batterys


        const magnetGeom = new THREE.BoxGeometry(0.03,0.3,0.05);
        const magnetMat = new THREE.MeshPhongMaterial( {
           // map:batteryTex,
            color: 0xff0000,
            //opacity: 0.5,
        } );
        magnet = new THREE.Mesh( magnetGeom, magnetMat );
        magnet.physics=new BodyPhysics(magnet);
        magnet.castShadow=false;
        scene.add( magnet );


       // meridian=new THREE.Group();


        meridian = new THREE.Group();// meridianGeom, meridianMat );
        const arrowNS = new THREE.ArrowHelper( new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0),2, '#ffffff',1.5*vField.arrowSize,vField.arrowSize);
        magnet.add(arrowNS);

        let instance = new THREE.TextSprite({
            alignment: 'center',
            color: '#ffffff',
            fontFamily: '"Times New Roman", Times, serif',
            fontSize: 0.08,
            fontStyle: 'italic',
            text: "Magnetic Axis",
        });
        instance.position.set(0,1,0);
        //instance.rotation.set(Math.PI/2,0,Math.PI/2);
        magnet.add(meridian);
        magnet.add(instance);

        const compassGeom=new THREE.SphereGeometry(0.02,10,10);
        const compassMat=new THREE.MeshPhongMaterial( {
            // map:earthTex,
            color: 0xff0000,
            opacity: 1,
        } );
        compass = new THREE.Mesh( compassGeom, compassMat );
        compass.position.set(1,0,0);
        magnet.add(compass);



        field = new THREE.Group();
        magnet.add(field);
        //field.castShadow=true;

        const axesHelper = new THREE.AxesHelper( 0.5 );
        scene.add( axesHelper );


        const earthGeom = new THREE.SphereGeometry(0.5,20,20);
        const earthMat = new THREE.MeshPhongMaterial( {
            map:earthTex,
            color: 0xffffff,
            transparent: true,
          //  depthWrite: false,
            opacity: 0.8,
        } );
        earth = new THREE.Mesh( earthGeom, earthMat );
        earth.physics=new BodyPhysics(earth);
       // earth.renderOrder=1;
        // earth.castShadow=true;
        scene.add( earth );


        //Ground
        const  equatorGeo = new THREE.PlaneGeometry(3, 3);
        const equatorMat = new THREE.MeshPhongMaterial({
            map: groundTex,
            shininess:0,
            color:0xAAAABB,
            specular:0x000000
            //side: THREE.DoubleSide,
        });
        equatorMat.color.setRGB(1.5, 1.5, 1.5);
        equator = new THREE.Mesh(equatorGeo, equatorMat);
        equator.rotation.x=-Math.PI/2;


        renderer.sortObjects = true
       // renderer.depth=false;

        let draggables=[compass];
        dragControls = new DragControls( draggables, camera, renderer.domElement );
        dragControls.addEventListener("hoveron", function () {
            orbitControls.enabled = false;
        });
        dragControls.addEventListener("hoveroff", function () {
            orbitControls.enabled = true;
        });
        dragControls.addEventListener("drag", function () {
            updateMeridians();
        });
        updateParams();
        animate();

    }



    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function animate() {
        requestAnimationFrame( animate );
        //controls.update();
        if(settings.isRunning==true) {
            updatePhysics(0.02);//clock.getDelta()/1000);
        }
        renderer.render(scene, camera);
    }

    function updateMeridians(){
        vField.fieldColor="#ffff00";
        vField.arrowLoc=0;
        vField.useTube=true;
        vField.arrowColor="#ffff00";
        let p=compass.position.clone();
        meridian.clear(0);
        compass.clear();

        let q=p.clone().sub(src1);
        let normal=p.clone().sub(src0).cross(q);
        let th=normal.angleTo(new THREE.Vector3(0,0,1));
        //console.log(th);
        if(p.z>0)th=-th;
        const meridianGeom=new THREE.PlaneGeometry(2.5,2.5);
        const meridianMat=new THREE.MeshPhongMaterial( {
            //map:earthTex,
            color: 0xff00ff,
            transparent:true,
            depthWrite: true,
            opacity: 0.4,
            side:THREE.DoubleSide
        } );
        let plane = new THREE.Mesh(meridianGeom,meridianMat);
        plane.rotation.set(0,th,0);
        meridian.add(plane);

        let f1=vField.createField(p,false);
        vField.arrowLoc=0.5;
        vField.step=0.01;
        vField.maxSteps=500;
        p=compass.position.clone();
        //p.applyAxisAngle(new THREE.Vector3(0,1,0),-th);
        let f2=vField.createField(p,true);


        meridian.add(f1);
        meridian.add(f2);

        p=compass.position.clone();
        let B=vField.fieldEvaluator(p);
        let dir=B.clone().normalize();

        let arrowB = new THREE.ArrowHelper(dir, p,B.length(), vField.arrowColor,1.5*vField.arrowSize,vField.arrowSize);
        meridian.add(arrowB);
        let Bv=B.clone().projectOnVector(p);
        let Bh=B.clone().sub(Bv);
        //Add horizontal component
        dir=Bh.clone().normalize();
        const arrowBh = new THREE.ArrowHelper(dir, p,Bv.length(), '#ffffff',1.5*vField.arrowSize,vField.arrowSize);
        meridian.add(arrowBh);
        //Add vertical component
        dir=Bv.clone().normalize();
        const arrowBv = new THREE.ArrowHelper(dir, p,Bv.length(), '#ffffff',1.5*vField.arrowSize,vField.arrowSize);
        meridian.add(arrowBv);

        let instance = new THREE.TextSprite({
            alignment: 'left',
            color: '#24ff00',
            fontFamily: '"Times New Roman", Times, serif',
            fontSize: 0.08,
            fontStyle: 'italic',
            text: "Bnet",
        });
     //   arrowB.add(instance);



    }

    function updateParams(){
       earth.visible=settings.showEarth;
       meridian.visible=settings.showMeridian;
       updateField();
       updateMeridians();
    }

    function updateField(){
        let I=settings.intensity;
        let N= 40*(I);

        vField.fieldColor="#ffffff";
        vField.arrowLoc=0.3;
        vField.step=0.03;
        vField.maxSteps=200;
        vField.useTube=false;
        //vField.arrowColor="#ffffaa";
        // wire.physics.angularVelocity.set(0,2*B,0);
        //create field
        field.clear();
        if(N==0)return;
        //field.add(vField.createField(new THREE.Vector3(0,0.2,0),false));
        //field.add(vField.createField(new THREE.Vector3(0,-0.2,0),true));
        let fields= new THREE.Group();
       // field.add(vField.createField(new THREE.Vector3(0.0,src0.y+0.05,0.0),true));
        //field.add(vField.createField(new THREE.Vector3(0.0,src1.y-0.05,0.0),false));

        // fields.add(vField.createField(new THREE.Vector3(0.01,0.15,0.01),false));
        fields.add(vField.createField(new THREE.Vector3(0.01,src0.y+0.05,0.01),true));
        let f=vField.createField(new THREE.Vector3(0.02,src0.y+0.05,0.02),true);
        //f.rotation.set(0,Math.PI/N,0);
        fields.add(f);
       // fields.add(vField.createField(new THREE.Vector3(0.01,-0.15,0.02),true));
       // f=vField.createField(new THREE.Vector3(0.03,-0.15,0.03),true);
       // f.rotation.set(0,Math.PI/N,0);
       // fields.add(f);

        for(let i=0;i<=N;i++){
            field.add(fields);
            fields = fields.clone();
            fields.rotation.set(0,2*i*Math.PI/N,0);
        }
    }

    function updatePhysics(dt){
        //wire.physics.update(dt);
    }



    /**
     * @param field
     * @param options {minBounds, maxBounds,arrowLoc (0 to 1), arrowSize, stopPoints (array),fieldColor, arrowColor}
     * @constructor
     */
    function VectorField(fieldEvaluator,options){
        this.minBounds=new THREE.Vector3(-2,-3,-2);
        this.maxBounds=new THREE.Vector3(2,3,2);
        this.arrowLoc=0.35;
        this.arrowSize=0.03;
        this.maxSteps=50;
        this.stopPoints=[];
        this.fieldColor="#ffffff";
        this.arrowColor="#ffffff";
        this.min=1E-12;
        this.max=1E12;
        this.step=0.2;
        this.useTube=false;
        /**
         * returns field vector at point p
         */
        this.fieldEvaluator=function(p){

            let AP=p.clone().sub(src0);
            let BP=p.clone().sub(src1);

            let d1=AP.length();
            let d2=BP.length();

            AP=AP.multiplyScalar (1/(d1*d1*d1));
            BP=BP.multiplyScalar (1/(d2*d2*d2));

            BP=BP.sub(AP);
           // console.log(p);
            //console.log(AP);
            return BP;
        }
        if(options){
            if(options.minBounds)this.minBounds=options.minBounds;
            if(options.maxBounds)this.maxBounds=options.maxBounds;
            if(options.arrowLoc)this.arrowLoc=options.arrowLoc;
            if(options.arrowSize)this.arrowSize=options.arrowSize;
            if(options.maxSteps)this.maxSteps=options.maxSteps;
            if(options.fieldColor)this.fieldColor=options.fieldColor;
            if(options.arrowColor)this.arrowColor=options.arrowColor;
            if(options.stopPoints)this.stopPoints=options.stopPoints;
            if(options.fieldEvaluator)this.fieldEvaluator=options.fieldEvaluator;
            if(options.min)this.min=options.min;
            if(options.max)this.max=options.max;
            if(options.step)this.step=options.step;
        }

        this.addStopPoints=function(p){
            this.stopPoints[ this.stopPoints.length]=p;
        }

        this.getFieldAt=function(p){
            return this.fieldEvaluator(p);
        }

        this.createField=function(pt, moveAgainstField,opacity) {
            let vertices = [];
            let dir = this.fieldEvaluator(pt).normalize();
            let prevDir = new THREE.Vector3();
            prevDir.set(dir.x, dir.y, dir.z);
            if (!dir) return;
            vertices[vertices.length] = pt;
            let p = pt.clone();
            let k = moveAgainstField ? -1 : 1;
            let n = 0;
            outer:
                while (n < this.maxSteps) {
                    if (!dir) break;
                    let E = dir.normalize();
                    //avoid abrupt change in field
                    if (dir.dot(prevDir) < -0.5) break;
                    prevDir.set(dir.x, dir.y, dir.z);
                    if (E < this.min || E > this.max) break;
                    dir = dir.multiplyScalar(k * this.step);
                    p.add(dir);
                    if (!withinBounds(p, this.minBounds, this.maxBounds)) break;

                    if (p.distanceTo(pt) < this.step / 2) {
                        vertices[vertices.length] = new THREE.Vector3(pt.x, pt.y, pt.z);
                        break;
                    }
                    for (let i = 0; i < this.stopPoints.length; i++) {
                        let stopPoint = this.stopPoints[i];
                        if (p.distanceTo(stopPoint) < step / 2) {
                            vertices[vertices.length] = new THREE.Vector3(stopPoint.x, stopPoint.y, stopPoint.z);
                            break outer;
                        }
                    }

                    vertices[vertices.length] = new THREE.Vector3(p.x, p.y, p.z);
                    dir = this.fieldEvaluator(p);
                    n++;
                }
            //console.log(vertices);
            if (vertices.length < 2) return;
            let curve = new THREE.CatmullRomCurve3(vertices);
            let geometry;
            let material;
            let curveObject;
            if (this.useTube) {
                geometry = new THREE.TubeGeometry(curve, 40, this.arrowSize/5, 5);
                material=new THREE.MeshPhongMaterial( {
                    color: this.fieldColor,
                } );
                curveObject = new THREE.Mesh(geometry, material);
            } else {
                let points = curve.getPoints(50);
                geometry = new THREE.BufferGeometry().setFromPoints(points);
                material = new THREE.LineBasicMaterial({color: this.fieldColor, linewidth: 4});
                curveObject = new THREE.Line(geometry, material);
                //material = new MeshLineMaterial({
                  //  lineWidth:2.5,
                   // color:this.fieldColor
                //});
                //const line = new MeshLine();
               // line.setPoints(points);
               // curveObject = new THREE.Line(geometry, material);
            }

            let ap1=curve.getPoint(this.arrowLoc);
            //let ap2=curve.getPoint(this.arrowLoc+this.arrowSize);
            dir=this.fieldEvaluator(ap1).normalize();
            const arrowHelper = new THREE.ArrowHelper(dir, ap1, this.arrowSize, this.arrowColor,1.5*this.arrowSize,this.arrowSize);
            curveObject.add(arrowHelper);

            if(opacity)material.opacity=opacity;
            return curveObject;
        }

        function withinBounds(p,minBounds,maxBounds){
            if(p.x<minBounds.x||p.y<minBounds.y||p.z<minBounds.z ||
                p.x>maxBounds.x ||p.y>maxBounds.y||p.z>maxBounds.z)return false;
            return true;
        }
    }


</script>
</body>
</html>