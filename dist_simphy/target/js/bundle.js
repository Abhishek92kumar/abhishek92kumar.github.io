var org;
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Minimal constructor.
             * @param {org.dyn4j.dynamics.World} world the world to iterate over
             * @class
             * @author William Bittle
             */
            class BodyIterator {
                constructor(world) {
                    if (this.world === undefined) {
                        this.world = null;
                    }
                    if (this.index === undefined) {
                        this.index = 0;
                    }
                    this.world = world;
                    this.index = -1;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.index + 1 < this.world.getBodyCount();
                }
                /**
                 *
                 * @return {org.dyn4j.dynamics.Body}
                 */
                next() {
                    if (this.index >= this.world.getBodyCount()) {
                        throw new java.lang.IndexOutOfBoundsException();
                    }
                    try {
                        this.index++;
                        const body = this.world.getBody(this.index);
                        return body;
                    }
                    catch (ex) {
                        throw new java.util.ConcurrentModificationException();
                    }
                }
                /**
                 *
                 */
                remove() {
                    if (this.index < 0) {
                        throw new java.lang.IllegalStateException();
                    }
                    if (this.index >= this.world.getBodyCount()) {
                        throw new java.lang.IndexOutOfBoundsException();
                    }
                    try {
                        this.world.removeBody$int(this.index);
                        this.index--;
                    }
                    catch (ex) {
                        throw new java.util.ConcurrentModificationException();
                    }
                }
                forEachRemaining(action) {
                    java.util.Objects.requireNonNull((((funcInst) => { if (typeof funcInst == 'function') {
                        return funcInst;
                    } return (arg0) => (funcInst['accept'] ? funcInst['accept'] : funcInst).call(funcInst, arg0); })(action)));
                    while ((this.hasNext())) {
                        (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(action);
                    }
                    ;
                }
            }
            dynamics.BodyIterator = BodyIterator;
            BodyIterator["__class"] = "org.dyn4j.dynamics.BodyIterator";
            BodyIterator["__interfaces"] = ["java.util.Iterator"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact_1) {
                /**
                 * Represents an impulse based rigid {@link Body} physics collision resolver.
                 * @author William Bittle
                 * @version 3.4.0
                 * @since 3.2.0
                 * @class
                 */
                class SequentialImpulses {
                    /*private*/ getMassCoefficient$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2(contactConstraint, contact, n) {
                        return this.getMassCoefficient$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(contactConstraint, contact.r1, contact.r2, n);
                    }
                    getMassCoefficient$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(contactConstraint, r1, r2, n) {
                        const m1 = contactConstraint.getBody1().getMassData();
                        const m2 = contactConstraint.getBody2().getMassData();
                        const r1CrossN = r1.cross$org_dyn4j_geometry_Vector2(n);
                        const r2CrossN = r2.cross$org_dyn4j_geometry_Vector2(n);
                        return m1.getInverseMass() + m2.getInverseMass() + m1.getInverseInertia() * r1CrossN * r1CrossN + m2.getInverseInertia() * r2CrossN * r2CrossN;
                    }
                    /**
                     * Compute the mass coefficient for a {@link Contact}.
                     *
                     * @param {org.dyn4j.dynamics.contact.ContactConstraint} contactConstraint The {@link ContactConstraint} of the contact
                     * @param {org.dyn4j.geometry.Vector2} r1 The contact.r1 field
                     * @param {org.dyn4j.geometry.Vector2} r2 The contact.r2 field
                     * @param {org.dyn4j.geometry.Vector2} n The normal
                     * @return {number} The mass coefficient
                     * @since 3.4.0
                     * @private
                     */
                    getMassCoefficient(contactConstraint, r1, r2, n) {
                        if (((contactConstraint != null && contactConstraint instanceof org.dyn4j.dynamics.contact.ContactConstraint) || contactConstraint === null) && ((r1 != null && r1 instanceof org.dyn4j.geometry.Vector2) || r1 === null) && ((r2 != null && r2 instanceof org.dyn4j.geometry.Vector2) || r2 === null) && ((n != null && n instanceof org.dyn4j.geometry.Vector2) || n === null)) {
                            return this.getMassCoefficient$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(contactConstraint, r1, r2, n);
                        }
                        else if (((contactConstraint != null && contactConstraint instanceof org.dyn4j.dynamics.contact.ContactConstraint) || contactConstraint === null) && ((r1 != null && r1 instanceof org.dyn4j.dynamics.contact.Contact) || r1 === null) && ((r2 != null && r2 instanceof org.dyn4j.geometry.Vector2) || r2 === null) && n === undefined) {
                            return this.getMassCoefficient$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2(contactConstraint, r1, r2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /*private*/ updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2(contactConstraint, contact, J) {
                        const b1 = contactConstraint.getBody1();
                        const b2 = contactConstraint.getBody2();
                        const m1 = b1.getMassData();
                        const m2 = b2.getMassData();
                        b1.getLinearVelocity$().add$double$double(b1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J.x * m1.getInverseMass(), b1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J.y * m1.getInverseMass());
                        b1.setAngularVelocity(b1.getAngularVelocity() + m1.getInverseInertia() * contact.r1.cross$org_dyn4j_geometry_Vector2(J));
                        b2.getLinearVelocity$().subtract$double$double(b2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J.x * m2.getInverseMass(), b2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J.y * m2.getInverseMass());
                        b2.setAngularVelocity(b2.getAngularVelocity() - m2.getInverseInertia() * contact.r2.cross$org_dyn4j_geometry_Vector2(J));
                    }
                    /**
                     * Compute the relative velocity to the {@link ContactConstraint}'s normal.
                     *
                     * @param {org.dyn4j.dynamics.contact.ContactConstraint} contactConstraint The {@link ContactConstraint}
                     * @param {org.dyn4j.dynamics.contact.Contact} contact The {@link Contact}
                     * @return {number} double
                     * @since 3.4.0
                     * @private
                     */
                    /*private*/ getRelativeVelocityAlongNormal(contactConstraint, contact) {
                        const rv = this.getRelativeVelocity(contactConstraint, contact);
                        return contactConstraint.normal.dot$org_dyn4j_geometry_Vector2(rv);
                    }
                    /**
                     * Compute the relative velocity of this {@link ContactConstraint}'s bodies.
                     *
                     * @param {org.dyn4j.dynamics.contact.ContactConstraint} contactConstraint The {@link ContactConstraint}
                     * @param {org.dyn4j.dynamics.contact.Contact} contact The {@link Contact}
                     * @return {org.dyn4j.geometry.Vector2} The relative velocity vector
                     * @since 3.4.0
                     * @private
                     */
                    /*private*/ getRelativeVelocity(contactConstraint, contact) {
                        const b1 = contactConstraint.getBody1();
                        const b2 = contactConstraint.getBody2();
                        const lv1 = contact.r1.cross$double(b1.getAngularVelocity()).add$org_dyn4j_geometry_Vector2(b1.getLinearVelocity$());
                        const lv2 = contact.r2.cross$double(b2.getAngularVelocity()).add$org_dyn4j_geometry_Vector2(b2.getLinearVelocity$());
                        const rv = lv1.subtract$org_dyn4j_geometry_Vector2(lv2);
                        return rv;
                    }
                    initialize(contactConstraints, step, settings) {
                        const restitutionVelocity = settings.getRestitutionVelocity();
                        const size = contactConstraints.size();
                        for (let i = 0; i < size; i++) {
                            {
                                const contactConstraint = contactConstraints.get(i);
                                const contacts = contactConstraint.contacts;
                                const cSize = contacts.size();
                                if (cSize === 0)
                                    return;
                                const b1 = contactConstraint.getBody1();
                                const b2 = contactConstraint.getBody2();
                                const t1 = b1.getTransform();
                                const t2 = b2.getTransform();
                                const m1 = b1.getMassData();
                                const m2 = b2.getMassData();
                                const invM1 = m1.getInverseMass();
                                const invM2 = m2.getInverseMass();
                                const invI1 = m1.getInverseInertia();
                                const invI2 = m2.getInverseInertia();
                                const c1 = t1.getTransformed$org_dyn4j_geometry_Vector2(m1.getCenter());
                                const c2 = t2.getTransformed$org_dyn4j_geometry_Vector2(m2.getCenter());
                                const N = contactConstraint.normal;
                                const T = contactConstraint.tangent;
                                for (let j = 0; j < cSize; j++) {
                                    {
                                        const contact = contacts.get(j);
                                        contact.r1 = c1.to$org_dyn4j_geometry_Vector2(contact.p);
                                        contact.r2 = c2.to$org_dyn4j_geometry_Vector2(contact.p);
                                        contact.massN = 1.0 / this.getMassCoefficient$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2(contactConstraint, contact, N);
                                        contact.massT = 1.0 / this.getMassCoefficient$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2(contactConstraint, contact, T);
                                        contact.vb = 0.0;
                                        const rvn = this.getRelativeVelocityAlongNormal(contactConstraint, contact);
                                        if (rvn < -restitutionVelocity) {
                                            contact.vb += -contactConstraint.restitution * rvn;
                                        }
                                    }
                                    ;
                                }
                                if (cSize === 2) {
                                    const contact1 = contacts.get(0);
                                    const contact2 = contacts.get(1);
                                    const rn1A = contact1.r1.cross$org_dyn4j_geometry_Vector2(N);
                                    const rn1B = contact1.r2.cross$org_dyn4j_geometry_Vector2(N);
                                    const rn2A = contact2.r1.cross$org_dyn4j_geometry_Vector2(N);
                                    const rn2B = contact2.r2.cross$org_dyn4j_geometry_Vector2(N);
                                    const K = new org.dyn4j.geometry.Matrix22();
                                    K.m00 = invM1 + invM2 + invI1 * rn1A * rn1A + invI2 * rn1B * rn1B;
                                    K.m01 = invM1 + invM2 + invI1 * rn1A * rn2A + invI2 * rn1B * rn2B;
                                    K.m10 = K.m01;
                                    K.m11 = invM1 + invM2 + invI1 * rn2A * rn2A + invI2 * rn2B * rn2B;
                                    const maxCondition = 1000.0;
                                    if (K.m00 * K.m00 < maxCondition * K.determinant()) {
                                        contactConstraint.K = K;
                                        contactConstraint.invK = K.getInverse();
                                    }
                                    else {
                                        if (contact1.depth > contact2.depth) {
                                            contactConstraint.contacts.remove(1);
                                        }
                                        else {
                                            contactConstraint.contacts.remove(0);
                                        }
                                    }
                                }
                            }
                            ;
                        }
                        this.warmStart(contactConstraints, step, settings);
                    }
                    /**
                     * Performs warm-starting of the contact constraints.
                     * @param {*} contactConstraints the contact constraints to solve
                     * @param {org.dyn4j.dynamics.Step} step the time step information
                     * @param {org.dyn4j.dynamics.Settings} settings the current settings
                     */
                    warmStart(contactConstraints, step, settings) {
                        const ratio = 1.0 / step.getDeltaTimeRatio();
                        const size = contactConstraints.size();
                        for (let i = 0; i < size; i++) {
                            {
                                const contactConstraint = contactConstraints.get(i);
                                const N = contactConstraint.normal;
                                const T = contactConstraint.tangent;
                                const contacts = contactConstraint.getContacts();
                                const cSize = contacts.size();
                                for (let j = 0; j < cSize; j++) {
                                    {
                                        const contact = contacts.get(j);
                                        contact.jn *= ratio;
                                        contact.jt *= ratio;
                                        const J = new org.dyn4j.geometry.Vector2(N.x * contact.jn + T.x * contact.jt, N.y * contact.jn + T.y * contact.jt);
                                        this.updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2(contactConstraint, contact, J);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                    }
                    solveVelocityContraints(contactConstraints, step, settings) {
                        const size = contactConstraints.size();
                        for (let i = 0; i < size; i++) {
                            {
                                const contactConstraint = contactConstraints.get(i);
                                const contacts = contactConstraint.contacts;
                                const cSize = contacts.size();
                                if (cSize === 0)
                                    continue;
                                const N = contactConstraint.normal;
                                const T = contactConstraint.tangent;
                                const tangentSpeed = contactConstraint.tangentSpeed;
                                for (let k = 0; k < cSize; k++) {
                                    {
                                        const contact = contacts.get(k);
                                        const rv = this.getRelativeVelocity(contactConstraint, contact);
                                        const rvt = T.dot$org_dyn4j_geometry_Vector2(rv) - tangentSpeed;
                                        let jt = contact.massT * (-rvt);
                                        const maxJt = contactConstraint.friction * contact.jn;
                                        const Jt0 = contact.jt;
                                        contact.jt = Math.max(-maxJt, Math.min(Jt0 + jt, maxJt));
                                        jt = contact.jt - Jt0;
                                        const J = new org.dyn4j.geometry.Vector2(T.x * jt, T.y * jt);
                                        this.updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2(contactConstraint, contact, J);
                                    }
                                    ;
                                }
                                if (cSize === 1) {
                                    const contact = contacts.get(0);
                                    const rvn = this.getRelativeVelocityAlongNormal(contactConstraint, contact);
                                    let j = -contact.massN * (rvn - contact.vb);
                                    const j0 = contact.jn;
                                    contact.jn = Math.max(j0 + j, 0.0);
                                    j = contact.jn - j0;
                                    const J = new org.dyn4j.geometry.Vector2(N.x * j, N.y * j);
                                    this.updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2(contactConstraint, contact, J);
                                }
                                else {
                                    const contact1 = contacts.get(0);
                                    const contact2 = contacts.get(1);
                                    const a = new org.dyn4j.geometry.Vector2(contact1.jn, contact2.jn);
                                    let rvn1 = this.getRelativeVelocityAlongNormal(contactConstraint, contact1);
                                    let rvn2 = this.getRelativeVelocityAlongNormal(contactConstraint, contact2);
                                    const b = new org.dyn4j.geometry.Vector2();
                                    b.x = rvn1 - contact1.vb;
                                    b.y = rvn2 - contact2.vb;
                                    b.subtract$org_dyn4j_geometry_Vector2(contactConstraint.K.product$org_dyn4j_geometry_Vector2(a));
                                    for (;;) {
                                        {
                                            const x = contactConstraint.invK.product$org_dyn4j_geometry_Vector2(b).negate();
                                            if (x.x >= 0.0 && x.y >= 0.0) {
                                                this.updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(contactConstraint, contact1, contact2, x, a);
                                                break;
                                            }
                                            x.x = -contact1.massN * b.x;
                                            x.y = 0.0;
                                            rvn1 = 0.0;
                                            rvn2 = contactConstraint.K.m10 * x.x + b.y;
                                            if (x.x >= 0.0 && rvn2 >= 0.0) {
                                                this.updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(contactConstraint, contact1, contact2, x, a);
                                                break;
                                            }
                                            x.x = 0.0;
                                            x.y = -contact2.massN * b.y;
                                            rvn1 = contactConstraint.K.m01 * x.y + b.x;
                                            rvn2 = 0.0;
                                            if (x.y >= 0.0 && rvn1 >= 0.0) {
                                                this.updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(contactConstraint, contact1, contact2, x, a);
                                                break;
                                            }
                                            x.x = 0.0;
                                            x.y = 0.0;
                                            rvn1 = b.x;
                                            rvn2 = b.y;
                                            if (rvn1 >= 0.0 && rvn2 >= 0.0) {
                                                this.updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(contactConstraint, contact1, contact2, x, a);
                                                break;
                                            }
                                            break;
                                        }
                                        ;
                                    }
                                }
                            }
                            ;
                        }
                    }
                    updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(contactConstraint, contact1, contact2, x, a) {
                        const b1 = contactConstraint.getBody1();
                        const b2 = contactConstraint.getBody2();
                        const m1 = b1.getMassData();
                        const m2 = b2.getMassData();
                        const N = contactConstraint.normal;
                        const J1 = N.product(x.x - a.x);
                        const J2 = N.product(x.y - a.y);
                        const Jx = J1.x + J2.x;
                        const Jy = J1.y + J2.y;
                        b1.getLinearVelocity$().add$double$double(b1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : Jx * m1.getInverseMass(), b1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : Jy * m1.getInverseMass());
                        b1.setAngularVelocity(b1.getAngularVelocity() + m1.getInverseInertia() * (contact1.r1.cross$org_dyn4j_geometry_Vector2(J1) + contact2.r1.cross$org_dyn4j_geometry_Vector2(J2)));
                        b2.getLinearVelocity$().subtract$double$double(b2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : Jx * m2.getInverseMass(), b2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : Jy * m2.getInverseMass());
                        b2.setAngularVelocity(b2.getAngularVelocity() - m2.getInverseInertia() * (contact1.r2.cross$org_dyn4j_geometry_Vector2(J1) + contact2.r2.cross$org_dyn4j_geometry_Vector2(J2)));
                        contact1.jn = x.x;
                        contact2.jn = x.y;
                    }
                    /**
                     * Helper method to update bodies while performing the solveVelocityContraints step.
                     *
                     * @param {org.dyn4j.dynamics.contact.ContactConstraint} contactConstraint The {@link ContactConstraint} of the contacts
                     * @param {org.dyn4j.dynamics.contact.Contact} contact1 The first contact
                     * @param {org.dyn4j.dynamics.contact.Contact} contact2 The second contact
                     * @param {org.dyn4j.geometry.Vector2} x
                     * @param {org.dyn4j.geometry.Vector2} a
                     * @since 3.4.0
                     * @private
                     */
                    updateBodies(contactConstraint, contact1, contact2, x, a) {
                        if (((contactConstraint != null && contactConstraint instanceof org.dyn4j.dynamics.contact.ContactConstraint) || contactConstraint === null) && ((contact1 != null && contact1 instanceof org.dyn4j.dynamics.contact.Contact) || contact1 === null) && ((contact2 != null && contact2 instanceof org.dyn4j.dynamics.contact.Contact) || contact2 === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && ((a != null && a instanceof org.dyn4j.geometry.Vector2) || a === null)) {
                            return this.updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(contactConstraint, contact1, contact2, x, a);
                        }
                        else if (((contactConstraint != null && contactConstraint instanceof org.dyn4j.dynamics.contact.ContactConstraint) || contactConstraint === null) && ((contact1 != null && contact1 instanceof org.dyn4j.dynamics.contact.Contact) || contact1 === null) && ((contact2 != null && contact2 instanceof org.dyn4j.geometry.Vector2) || contact2 === null) && x === undefined && a === undefined) {
                            return this.updateBodies$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_dynamics_contact_Contact$org_dyn4j_geometry_Vector2(contactConstraint, contact1, contact2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    solvePositionContraints(contactConstraints, step, settings) {
                        if (contactConstraints.isEmpty())
                            return true;
                        let minSeparation = 0.0;
                        const maxLinearCorrection = settings.getMaximumLinearCorrection();
                        const allowedPenetration = settings.getLinearTolerance();
                        const baumgarte = settings.getBaumgarte();
                        const size = contactConstraints.size();
                        for (let i = 0; i < size; i++) {
                            {
                                const contactConstraint = contactConstraints.get(i);
                                const contacts = contactConstraint.contacts;
                                const cSize = contacts.size();
                                if (cSize === 0)
                                    continue;
                                const b1 = contactConstraint.getBody1();
                                const b2 = contactConstraint.getBody2();
                                const t1 = b1.getTransform();
                                const t2 = b2.getTransform();
                                const m1 = b1.getMassData();
                                const m2 = b2.getMassData();
                                const N = contactConstraint.normal;
                                for (let k = 0; k < cSize; k++) {
                                    {
                                        const contact = contacts.get(k);
                                        const c1 = t1.getTransformed$org_dyn4j_geometry_Vector2(m1.getCenter());
                                        const c2 = t2.getTransformed$org_dyn4j_geometry_Vector2(m2.getCenter());
                                        const r1 = contact.p1.difference$org_dyn4j_geometry_Vector2(m1.getCenter());
                                        t1.transformR(r1);
                                        const r2 = contact.p2.difference$org_dyn4j_geometry_Vector2(m2.getCenter());
                                        t2.transformR(r2);
                                        const p1 = c1.sum$org_dyn4j_geometry_Vector2(r1);
                                        const p2 = c2.sum$org_dyn4j_geometry_Vector2(r2);
                                        const dp = p1.subtract$org_dyn4j_geometry_Vector2(p2);
                                        const penetration = dp.dot$org_dyn4j_geometry_Vector2(N) - contact.depth;
                                        minSeparation = Math.min(minSeparation, penetration);
                                        const cp = baumgarte * org.dyn4j.geometry.Interval.clamp(penetration + allowedPenetration, -maxLinearCorrection, 0.0);
                                        const K = this.getMassCoefficient$org_dyn4j_dynamics_contact_ContactConstraint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(contactConstraint, r1, r2, N);
                                        let jp = (K > org.dyn4j.Epsilon.E_$LI$()) ? (-cp / K) : 0.0;
                                        const jp0 = contact.jp;
                                        contact.jp = Math.max(jp0 + jp, 0.0);
                                        jp = contact.jp - jp0;
                                        const J = N.product(jp);
                                        b1.translate$double$double(b1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J.x * m1.getInverseMass(), b1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J.y * m1.getInverseMass());
                                        b1.rotate$double$double$double(m1.getInverseInertia() * r1.cross$org_dyn4j_geometry_Vector2(J), c1.x, c1.y);
                                        b2.translate$double$double(b2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : -J.x * m2.getInverseMass(), b2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : -J.y * m2.getInverseMass());
                                        b2.rotate$double$double$double(-m2.getInverseInertia() * r2.cross$org_dyn4j_geometry_Vector2(J), c2.x, c2.y);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return minSeparation >= -3.0 * allowedPenetration;
                    }
                    constructor() {
                    }
                }
                contact_1.SequentialImpulses = SequentialImpulses;
                SequentialImpulses["__class"] = "org.dyn4j.dynamics.contact.SequentialImpulses";
                SequentialImpulses["__interfaces"] = ["org.dyn4j.dynamics.contact.ContactConstraintSolver"];
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact_2) {
                /**
                 * Full constructor.
                 * <p>
                 * The initial capacity is used to help performance in the event that the developer
                 * knows the number of bodies the world will contain. The {@link ContactManager}
                 * will grow past the initial capacity if necessary.
                 * @param {org.dyn4j.dynamics.Capacity} initialCapacity the estimated number of {@link Body}s
                 * @throws NullPointerException if initialCapacity is null
                 * @class
                 * @author William Bittle
                 */
                class DefaultContactManager {
                    constructor(initialCapacity) {
                        if (((initialCapacity != null && initialCapacity instanceof org.dyn4j.dynamics.Capacity) || initialCapacity === null)) {
                            let __args = arguments;
                            if (this.constraintQueue === undefined) {
                                this.constraintQueue = null;
                            }
                            if (this.constraints === undefined) {
                                this.constraints = null;
                            }
                            if (this.constraints1 === undefined) {
                                this.constraints1 = null;
                            }
                            if (this.warmStartingEnabled === undefined) {
                                this.warmStartingEnabled = false;
                            }
                            if (initialCapacity == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.nullCapacity"));
                            const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionPairs(initialCapacity.getBodyCount());
                            this.constraintQueue = (new java.util.ArrayList(eSize));
                            this.constraints = (new java.util.HashMap((eSize * 4 / 3 | 0) + 1, 0.75));
                            this.constraints1 = (new java.util.HashMap((eSize * 4 / 3 | 0) + 1, 0.75));
                            this.warmStartingEnabled = true;
                        }
                        else if (initialCapacity === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let initialCapacity = org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$();
                                if (this.constraintQueue === undefined) {
                                    this.constraintQueue = null;
                                }
                                if (this.constraints === undefined) {
                                    this.constraints = null;
                                }
                                if (this.constraints1 === undefined) {
                                    this.constraints1 = null;
                                }
                                if (this.warmStartingEnabled === undefined) {
                                    this.warmStartingEnabled = false;
                                }
                                if (initialCapacity == null)
                                    throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.nullCapacity"));
                                const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionPairs(initialCapacity.getBodyCount());
                                this.constraintQueue = (new java.util.ArrayList(eSize));
                                this.constraints = (new java.util.HashMap((eSize * 4 / 3 | 0) + 1, 0.75));
                                this.constraints1 = (new java.util.HashMap((eSize * 4 / 3 | 0) + 1, 0.75));
                                this.warmStartingEnabled = true;
                            }
                            if (this.constraintQueue === undefined) {
                                this.constraintQueue = null;
                            }
                            if (this.constraints === undefined) {
                                this.constraints = null;
                            }
                            if (this.constraints1 === undefined) {
                                this.constraints1 = null;
                            }
                            if (this.warmStartingEnabled === undefined) {
                                this.warmStartingEnabled = false;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.contact.ContactConstraint} constraint
                     */
                    queue(constraint) {
                        this.constraintQueue.add(constraint);
                    }
                    /**
                     *
                     */
                    clear() {
                        this.constraintQueue.clear();
                        this.constraints.clear();
                    }
                    end(contactConstraint) {
                        return this.constraints.remove(contactConstraint.id) != null;
                    }
                    shift(shift) {
                        const it = this.constraints.values().iterator();
                        while ((it.hasNext())) {
                            {
                                const cc = it.next();
                                cc.shift(shift);
                            }
                        }
                        ;
                    }
                    updateAndNotify(listeners, settings) {
                        const size = this.constraintQueue.size();
                        const lsize = listeners != null ? listeners.size() : 0;
                        const warmStartDistanceSquared = settings.getWarmStartDistanceSquared();
                        const newMap = this.constraints1;
                        for (let i = 0; i < size; i++) {
                            {
                                const newContactConstraint = this.constraintQueue.get(i);
                                let oldContactConstraint = null;
                                const contacts = newContactConstraint.contacts;
                                const nsize = contacts.size();
                                oldContactConstraint = this.constraints.remove(newContactConstraint.id);
                                if (oldContactConstraint != null) {
                                    const ocontacts = oldContactConstraint.contacts;
                                    const osize = ocontacts.size();
                                    const persisted = (s => { let a = []; while (s-- > 0)
                                        a.push(false); return a; })(osize);
                                    for (let j = nsize - 1; j >= 0; j--) {
                                        {
                                            const newContact = contacts.get(j);
                                            let found = false;
                                            for (let k = 0; k < osize; k++) {
                                                {
                                                    const oldContact = ocontacts.get(k);
                                                    if ((newContact.id === org.dyn4j.collision.manifold.ManifoldPointId.DISTANCE_$LI$() && newContact.p.distanceSquared$org_dyn4j_geometry_Vector2(oldContact.p) <= warmStartDistanceSquared) || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                                        return o1.equals(o2);
                                                    }
                                                    else {
                                                        return o1 === o2;
                                                    } })(newContact.id, oldContact.id)) {
                                                        if (this.warmStartingEnabled) {
                                                            newContact.jn = oldContact.jn;
                                                            newContact.jt = oldContact.jt;
                                                        }
                                                        const point = new org.dyn4j.dynamics.contact.PersistedContactPoint(newContactConstraint, newContact, oldContactConstraint, oldContact);
                                                        let allow = true;
                                                        for (let l = 0; l < lsize; l++) {
                                                            {
                                                                const listener = listeners.get(l);
                                                                if (!listener.persist(point)) {
                                                                    allow = false;
                                                                }
                                                            }
                                                            ;
                                                        }
                                                        if (!allow) {
                                                            newContactConstraint.enabled = false;
                                                        }
                                                        persisted[k] = true;
                                                        found = true;
                                                        break;
                                                    }
                                                }
                                                ;
                                            }
                                            if (!found) {
                                                const point = new org.dyn4j.dynamics.contact.ContactPoint(newContactConstraint, newContact);
                                                let allow = true;
                                                for (let l = 0; l < lsize; l++) {
                                                    {
                                                        const listener = listeners.get(l);
                                                        newContactConstraint.getBody1().setColliding(true, newContact.depth, newContactConstraint.normal);
                                                        newContactConstraint.getBody2().setColliding(true, newContact.depth, newContactConstraint.normal);
                                                        if (!listener.begin(point)) {
                                                            allow = false;
                                                        }
                                                    }
                                                    ;
                                                }
                                                if (!allow) {
                                                    newContactConstraint.enabled = false;
                                                }
                                            }
                                        }
                                        ;
                                    }
                                    const rsize = persisted.length;
                                    for (let j = 0; j < rsize; j++) {
                                        {
                                            if (!persisted[j]) {
                                                const contact = ocontacts.get(j);
                                                const point = new org.dyn4j.dynamics.contact.ContactPoint(newContactConstraint, contact);
                                                for (let l = 0; l < lsize; l++) {
                                                    {
                                                        const listener = listeners.get(l);
                                                        listener.end(point);
                                                    }
                                                    ;
                                                }
                                                point.getBody1().setColliding(false, 0, null);
                                                point.getBody2().setColliding(false, 0, null);
                                            }
                                        }
                                        ;
                                    }
                                }
                                else {
                                    for (let j = nsize - 1; j >= 0; j--) {
                                        {
                                            const contact = contacts.get(j);
                                            const point = new org.dyn4j.dynamics.contact.ContactPoint(newContactConstraint, contact);
                                            let allow = true;
                                            for (let l = 0; l < lsize; l++) {
                                                {
                                                    const listener = listeners.get(l);
                                                    newContactConstraint.getBody1().setColliding(true, contact.depth, newContactConstraint.normal);
                                                    newContactConstraint.getBody2().setColliding(true, contact.depth, newContactConstraint.normal);
                                                    if (!listener.begin(point)) {
                                                        allow = false;
                                                    }
                                                }
                                                ;
                                            }
                                            if (!allow) {
                                                newContactConstraint.enabled = false;
                                            }
                                        }
                                        ;
                                    }
                                }
                                if (newContactConstraint.contacts.size() > 0) {
                                    newMap.put(newContactConstraint.id, newContactConstraint);
                                }
                            }
                            ;
                        }
                        if (!this.constraints.isEmpty()) {
                            const icc = this.constraints.values().iterator();
                            while ((icc.hasNext())) {
                                {
                                    const contactConstraint = icc.next();
                                    const rsize = contactConstraint.contacts.size();
                                    for (let i = 0; i < rsize; i++) {
                                        {
                                            const contact = contactConstraint.contacts.get(i);
                                            const point = new org.dyn4j.dynamics.contact.ContactPoint(contactConstraint, contact);
                                            for (let l = 0; l < lsize; l++) {
                                                {
                                                    const listener = listeners.get(l);
                                                    listener.end(point);
                                                }
                                                ;
                                            }
                                            point.getBody1().setColliding(false, 0, null);
                                            point.getBody2().setColliding(false, 0, null);
                                        }
                                        ;
                                    }
                                }
                            }
                            ;
                        }
                        if (size > 0) {
                            this.constraints.clear();
                            this.constraints1 = this.constraints;
                            this.constraints = newMap;
                        }
                        else {
                            this.constraints.clear();
                        }
                        this.constraintQueue.clear();
                    }
                    preSolveNotify(listeners) {
                        const lsize = listeners != null ? listeners.size() : 0;
                        const itContactConstraints = this.constraints.values().iterator();
                        while ((itContactConstraints.hasNext())) {
                            {
                                const contactConstraint = itContactConstraints.next();
                                if (!contactConstraint.enabled || contactConstraint.sensor)
                                    continue;
                                const csize = contactConstraint.contacts.size();
                                for (let j = csize - 1; j >= 0; j--) {
                                    {
                                        const contact = contactConstraint.contacts.get(j);
                                        const point = new org.dyn4j.dynamics.contact.ContactPoint(contactConstraint, contact);
                                        let allow = true;
                                        for (let l = 0; l < lsize; l++) {
                                            {
                                                const listener = listeners.get(l);
                                                if (!listener.preSolve(point)) {
                                                    allow = false;
                                                }
                                            }
                                            ;
                                        }
                                        if (!allow) {
                                            contactConstraint.contacts.remove(j);
                                        }
                                    }
                                    ;
                                }
                                if (contactConstraint.contacts.size() === 0) {
                                    itContactConstraints.remove();
                                }
                            }
                        }
                        ;
                    }
                    postSolveNotify(listeners) {
                        const lsize = listeners != null ? listeners.size() : 0;
                        for (let index = this.constraints.values().iterator(); index.hasNext();) {
                            let contactConstraint = index.next();
                            {
                                if (!contactConstraint.enabled || contactConstraint.sensor)
                                    continue;
                                const rsize = contactConstraint.contacts.size();
                                for (let j = 0; j < rsize; j++) {
                                    {
                                        const contact = contactConstraint.contacts.get(j);
                                        const point = new org.dyn4j.dynamics.contact.SolvedContactPoint(contactConstraint, contact);
                                        for (let l = 0; l < lsize; l++) {
                                            {
                                                const listener = listeners.get(l);
                                                listener.postSolve(point);
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                        }
                    }
                    /**
                     * Returns true if warm starting is enabled.
                     * @return {boolean} boolean
                     */
                    isWarmStartingEnabled() {
                        return this.warmStartingEnabled;
                    }
                    /**
                     * Toggles warm starting.
                     * @param {boolean} flag true if warm starting should be enabled
                     */
                    setWarmStartingEnabled(flag) {
                        this.warmStartingEnabled = flag;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getContactCount() {
                        return this.constraints.size();
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getQueueCount() {
                        return this.constraintQueue.size();
                    }
                }
                contact_2.DefaultContactManager = DefaultContactManager;
                DefaultContactManager["__class"] = "org.dyn4j.dynamics.contact.DefaultContactManager";
                DefaultContactManager["__interfaces"] = ["org.dyn4j.dynamics.contact.ContactManager", "org.dyn4j.geometry.Shiftable"];
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact) {
                /**
                 * Convenience class for implementing the {@link ContactListener} interface.
                 * @author William Bittle
                 * @version 3.3.0
                 * @since 1.0.0
                 * @class
                 */
                class ContactAdapter {
                    /**
                     *
                     * @param {org.dyn4j.dynamics.contact.ContactPoint} point
                     */
                    sensed(point) {
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.contact.ContactPoint} point
                     * @return {boolean}
                     */
                    begin(point) {
                        return true;
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.contact.ContactPoint} point
                     */
                    end(point) {
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.contact.PersistedContactPoint} point
                     * @return {boolean}
                     */
                    persist(point) {
                        return true;
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.contact.ContactPoint} point
                     * @return {boolean}
                     */
                    preSolve(point) {
                        return true;
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.contact.SolvedContactPoint} point
                     */
                    postSolve(point) {
                    }
                    constructor() {
                    }
                }
                contact.ContactAdapter = ContactAdapter;
                ContactAdapter["__class"] = "org.dyn4j.dynamics.contact.ContactAdapter";
                ContactAdapter["__interfaces"] = ["org.dyn4j.Listener", "org.dyn4j.dynamics.contact.ContactListener"];
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact_3) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.dynamics.contact.ContactPointId} id the contact point id
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body} in contact
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture1 the first {@link Body}'s {@link BodyFixture}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body} in contact
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture2 the second {@link Body}'s {@link BodyFixture}
                 * @param {org.dyn4j.geometry.Vector2} point the world space contact point
                 * @param {org.dyn4j.geometry.Vector2} normal the world space contact normal
                 * @param {number} depth the penetration depth
                 * @param {boolean} sensor true if the contact is a sensor contact
                 * @class
                 * @author William Bittle
                 */
                class ContactPoint {
                    constructor(id, body1, fixture1, body2, fixture2, point, normal, depth, sensor) {
                        if (((id != null && id instanceof org.dyn4j.dynamics.contact.ContactPointId) || id === null) && ((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((fixture1 != null && fixture1 instanceof org.dyn4j.dynamics.BodyFixture) || fixture1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((fixture2 != null && fixture2 instanceof org.dyn4j.dynamics.BodyFixture) || fixture2 === null) && ((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((normal != null && normal instanceof org.dyn4j.geometry.Vector2) || normal === null) && ((typeof depth === 'number') || depth === null) && ((typeof sensor === 'boolean') || sensor === null)) {
                            let __args = arguments;
                            if (this.id === undefined) {
                                this.id = null;
                            }
                            if (this.body1 === undefined) {
                                this.body1 = null;
                            }
                            if (this.body2 === undefined) {
                                this.body2 = null;
                            }
                            if (this.fixture1 === undefined) {
                                this.fixture1 = null;
                            }
                            if (this.fixture2 === undefined) {
                                this.fixture2 = null;
                            }
                            if (this.point === undefined) {
                                this.point = null;
                            }
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            if (this.depth === undefined) {
                                this.depth = 0;
                            }
                            if (this.sensor === undefined) {
                                this.sensor = false;
                            }
                            this.id = id;
                            this.body1 = body1;
                            this.fixture1 = fixture1;
                            this.body2 = body2;
                            this.fixture2 = fixture2;
                            this.point = point;
                            this.normal = normal;
                            this.depth = depth;
                            this.sensor = sensor;
                        }
                        else if (((id != null && id instanceof org.dyn4j.dynamics.contact.ContactConstraint) || id === null) && ((body1 != null && body1 instanceof org.dyn4j.dynamics.contact.Contact) || body1 === null) && fixture1 === undefined && body2 === undefined && fixture2 === undefined && point === undefined && normal === undefined && depth === undefined && sensor === undefined) {
                            let __args = arguments;
                            let constraint = __args[0];
                            let contact = __args[1];
                            if (this.id === undefined) {
                                this.id = null;
                            }
                            if (this.body1 === undefined) {
                                this.body1 = null;
                            }
                            if (this.body2 === undefined) {
                                this.body2 = null;
                            }
                            if (this.fixture1 === undefined) {
                                this.fixture1 = null;
                            }
                            if (this.fixture2 === undefined) {
                                this.fixture2 = null;
                            }
                            if (this.point === undefined) {
                                this.point = null;
                            }
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            if (this.depth === undefined) {
                                this.depth = 0;
                            }
                            if (this.sensor === undefined) {
                                this.sensor = false;
                            }
                            this.id = new org.dyn4j.dynamics.contact.ContactPointId(constraint.id, contact.id);
                            this.body1 = constraint.getBody1();
                            this.fixture1 = constraint.fixture1;
                            this.body2 = constraint.getBody2();
                            this.fixture2 = constraint.fixture2;
                            this.point = contact.p;
                            this.normal = constraint.normal;
                            this.depth = contact.depth;
                            this.sensor = constraint.sensor;
                        }
                        else if (((id != null && id instanceof org.dyn4j.dynamics.contact.ContactPoint) || id === null) && body1 === undefined && fixture1 === undefined && body2 === undefined && fixture2 === undefined && point === undefined && normal === undefined && depth === undefined && sensor === undefined) {
                            let __args = arguments;
                            let contactPoint = __args[0];
                            if (this.id === undefined) {
                                this.id = null;
                            }
                            if (this.body1 === undefined) {
                                this.body1 = null;
                            }
                            if (this.body2 === undefined) {
                                this.body2 = null;
                            }
                            if (this.fixture1 === undefined) {
                                this.fixture1 = null;
                            }
                            if (this.fixture2 === undefined) {
                                this.fixture2 = null;
                            }
                            if (this.point === undefined) {
                                this.point = null;
                            }
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            if (this.depth === undefined) {
                                this.depth = 0;
                            }
                            if (this.sensor === undefined) {
                                this.sensor = false;
                            }
                            if (contactPoint == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.contact.contactPoint.nullContactPoint"));
                            this.id = contactPoint.id;
                            this.body1 = contactPoint.body1;
                            this.fixture1 = contactPoint.fixture1;
                            this.body2 = contactPoint.body2;
                            this.fixture2 = contactPoint.fixture2;
                            this.point = contactPoint.point;
                            this.normal = contactPoint.normal;
                            this.depth = contactPoint.depth;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("ContactPoint[Id=").append(this.id).append("|Body1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body1)).append("|Fixture1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture1)).append("|Body2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body2)).append("|Fixture2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture2)).append("|Point=").append(this.point).append("|Normal=").append(this.normal).append("|Depth=").append(this.depth).append("|Sensor=").append(this.sensor).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the contact point id.
                     * @return {org.dyn4j.dynamics.contact.ContactPointId} {@link ContactPointId}
                     * @since 3.1.2
                     */
                    getId() {
                        return this.id;
                    }
                    /**
                     * Returns the contact point.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getPoint() {
                        return this.point;
                    }
                    /**
                     * Returns the normal.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getNormal() {
                        return this.normal;
                    }
                    /**
                     * Returns the depth.
                     * @return {number} double
                     */
                    getDepth() {
                        return this.depth;
                    }
                    /**
                     * Returns the first {@link Body}.
                     * @return {org.dyn4j.dynamics.Body} {@link Body}
                     */
                    getBody1() {
                        return this.body1;
                    }
                    /**
                     * Returns the second {@link Body}.
                     * @return {org.dyn4j.dynamics.Body} {@link Body}
                     */
                    getBody2() {
                        return this.body2;
                    }
                    /**
                     * Returns the first {@link Body}'s {@link BodyFixture}.
                     * @return {org.dyn4j.dynamics.BodyFixture} {@link BodyFixture}
                     */
                    getFixture1() {
                        return this.fixture1;
                    }
                    /**
                     * Returns the second {@link Body}'s {@link BodyFixture}.
                     * @return {org.dyn4j.dynamics.BodyFixture} {@link BodyFixture}
                     */
                    getFixture2() {
                        return this.fixture2;
                    }
                    /**
                     * Returns true if this contact point is for a sensor.
                     * @return {boolean} boolean
                     */
                    isSensor() {
                        return this.sensor;
                    }
                }
                contact_3.ContactPoint = ContactPoint;
                ContactPoint["__class"] = "org.dyn4j.dynamics.contact.ContactPoint";
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact) {
                /**
                 * Full constructor.
                 * @param {*} id the manifold point id used for warm starting
                 * @param {org.dyn4j.geometry.Vector2} point the world space collision point
                 * @param {number} depth the penetration depth of this point
                 * @param {org.dyn4j.geometry.Vector2} p1 the collision point in {@link Body}1's local space
                 * @param {org.dyn4j.geometry.Vector2} p2 the collision point in {@link Body}2's local space
                 * @class
                 * @author William Bittle
                 */
                class Contact {
                    constructor(id, point, depth, p1, p2) {
                        if (this.id === undefined) {
                            this.id = null;
                        }
                        if (this.p === undefined) {
                            this.p = null;
                        }
                        if (this.depth === undefined) {
                            this.depth = 0;
                        }
                        if (this.p1 === undefined) {
                            this.p1 = null;
                        }
                        if (this.p2 === undefined) {
                            this.p2 = null;
                        }
                        if (this.r1 === undefined) {
                            this.r1 = null;
                        }
                        if (this.r2 === undefined) {
                            this.r2 = null;
                        }
                        if (this.jn === undefined) {
                            this.jn = 0;
                        }
                        if (this.jt === undefined) {
                            this.jt = 0;
                        }
                        if (this.jp === undefined) {
                            this.jp = 0;
                        }
                        if (this.massN === undefined) {
                            this.massN = 0;
                        }
                        if (this.massT === undefined) {
                            this.massT = 0;
                        }
                        if (this.vb === undefined) {
                            this.vb = 0;
                        }
                        this.id = id;
                        this.p = point;
                        this.depth = depth;
                        this.p1 = p1;
                        this.p2 = p2;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("Contact[Id=").append(this.id).append("|Point=").append(this.p).append("|Depth=").append(this.depth).append("|NormalImpulse=").append(this.jn).append("|TangentImpulse=").append(this.jt).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the manifold point id.
                     * @return {*} {@link ManifoldPointId}
                     * @since 3.1.2
                     */
                    getId() {
                        return this.id;
                    }
                    /**
                     * Returns the world space collision point.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the collision point in world space
                     */
                    getPoint() {
                        return this.p;
                    }
                    /**
                     * Returns the penetration depth of this point.
                     * @return {number} double the penetration depth
                     */
                    getDepth() {
                        return this.depth;
                    }
                    /**
                     * Returns the accumulated normal impulse applied at this point.
                     * @return {number} double the accumulated normal impulse
                     */
                    getNormalImpulse() {
                        return this.jn;
                    }
                    /**
                     * Returns the accumulated tangential impulse applied at this point.
                     * @return {number} double the accumulated tangential impulse
                     */
                    getTangentialImpulse() {
                        return this.jt;
                    }
                }
                contact.Contact = Contact;
                Contact["__class"] = "org.dyn4j.dynamics.contact.Contact";
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact) {
                /**
                 * Represents a position solver for a pair of {@link Body}s who came in
                 * contact during a time step but where not detected by the discrete
                 * collision detectors.
                 * <p>
                 * This class will translate and rotate the {@link Body}s into a collision.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 2.0.0
                 * @class
                 */
                class TimeOfImpactSolver {
                    /**
                     * Moves the given {@link Body}s into collision given the {@link TimeOfImpact}
                     * information.
                     * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                     * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                     * @param {org.dyn4j.collision.continuous.TimeOfImpact} timeOfImpact the {@link TimeOfImpact}
                     * @param {org.dyn4j.dynamics.Settings} settings the current world settings
                     */
                    solve(body1, body2, timeOfImpact, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const maxLinearCorrection = settings.getMaximumLinearCorrection();
                        const c1 = body1.getWorldCenter();
                        const c2 = body2.getWorldCenter();
                        const m1 = body1.getMassData();
                        const m2 = body2.getMassData();
                        const mass1 = m1.getMass();
                        const mass2 = m2.getMass();
                        const invMass1 = mass1 * m1.getInverseMass();
                        const invI1 = mass1 * m1.getInverseInertia();
                        const invMass2 = mass2 * m2.getInverseMass();
                        const invI2 = mass2 * m2.getInverseInertia();
                        const separation = timeOfImpact.getSeparation();
                        const p1w = separation.getPoint1();
                        const p2w = separation.getPoint2();
                        const r1 = c1.to$org_dyn4j_geometry_Vector2(p1w);
                        const r2 = c2.to$org_dyn4j_geometry_Vector2(p2w);
                        const n = separation.getNormal();
                        const d = separation.getDistance();
                        const C = org.dyn4j.geometry.Interval.clamp(d - linearTolerance, -maxLinearCorrection, 0.0);
                        const rn1 = r1.cross$org_dyn4j_geometry_Vector2(n);
                        const rn2 = r2.cross$org_dyn4j_geometry_Vector2(n);
                        const K = invMass1 + invMass2 + invI1 * rn1 * rn1 + invI2 * rn2 * rn2;
                        let impulse = 0.0;
                        if (K > 0.0) {
                            impulse = -C / K;
                        }
                        const J = n.product(impulse);
                        body1.translate$double$double(body1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J.x * invMass1, body1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J.y * invMass1);
                        body1.rotate$double$double$double(invI1 * r1.cross$org_dyn4j_geometry_Vector2(J), c1.x, c1.y);
                        body1.translate$double$double(body2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : -J.x * invMass2, body2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : -J.y * invMass2);
                        body2.rotate$double$double$double(-invI2 * r2.cross$org_dyn4j_geometry_Vector2(J), c2.x, c2.y);
                    }
                }
                contact.TimeOfImpactSolver = TimeOfImpactSolver;
                TimeOfImpactSolver["__class"] = "org.dyn4j.dynamics.contact.TimeOfImpactSolver";
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture1 the first {@link Body}'s {@link BodyFixture}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture2 the second {@link Body}'s {@link BodyFixture}
                 * @class
                 * @author William Bittle
                 */
                class ContactConstraintId {
                    constructor(body1, fixture1, body2, fixture2) {
                        if (this.body1 === undefined) {
                            this.body1 = null;
                        }
                        if (this.body2 === undefined) {
                            this.body2 = null;
                        }
                        if (this.fixture1 === undefined) {
                            this.fixture1 = null;
                        }
                        if (this.fixture2 === undefined) {
                            this.fixture2 = null;
                        }
                        this.body1 = body1;
                        this.body2 = body2;
                        this.fixture1 = fixture1;
                        this.fixture2 = fixture2;
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {boolean}
                     */
                    equals(other) {
                        if (other == null)
                            return false;
                        if (other === this)
                            return true;
                        if (other != null && other instanceof org.dyn4j.dynamics.contact.ContactConstraintId) {
                            const o = other;
                            if ((this.body1 === o.body1 && this.body2 === o.body2 && this.fixture1 === o.fixture1 && this.fixture2 === o.fixture2) || (this.body1 === o.body2 && this.body2 === o.body1 && this.fixture1 === o.fixture2 && this.fixture2 === o.fixture1)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let hash = 1;
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body1) + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body2);
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture1) + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture2);
                        return hash;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("ContactConstraintId[Body1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body1)).append("|Body2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body2)).append("|Fixture1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture1)).append("|Fixture2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture2)).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the id of the first body.
                     * @deprecated ID schemes should be implemented by the user where needed; since 3.4.0
                     * @return {org.dyn4j.RandomUUID} UUID
                     * @since 3.1.2
                     */
                    getBody1Id() {
                        return this.body1.getId();
                    }
                    /**
                     * Returns the id of the second body.
                     * @deprecated ID schemes should be implemented by the user where needed; since 3.4.0
                     * @return {org.dyn4j.RandomUUID} UUID
                     * @since 3.1.2
                     */
                    getBody2Id() {
                        return this.body2.getId();
                    }
                    /**
                     * Returns the id of the fixture on the first body.
                     * @deprecated ID schemes should be implemented by the user where needed; since 3.4.0
                     * @return {org.dyn4j.RandomUUID} UUID
                     * @since 3.1.2
                     */
                    getFixture1Id() {
                        return this.fixture1.getId();
                    }
                    /**
                     * Returns the id of the fixture on the second body.
                     * @deprecated ID schemes should be implemented by the user where needed; since 3.4.0
                     * @return {org.dyn4j.RandomUUID} UUID
                     * @since 3.1.2
                     */
                    getFixture2Id() {
                        return this.fixture2.getId();
                    }
                    /**
                     * Returns the first body.
                     * @return {org.dyn4j.dynamics.Body} Body
                     * @since 3.4.0
                     */
                    getBody1() {
                        return this.body1;
                    }
                    /**
                     * Returns the second body.
                     * @return {org.dyn4j.dynamics.Body} Body
                     * @since 3.4.0
                     */
                    getBody2() {
                        return this.body2;
                    }
                    /**
                     * Returns the fixture on the first body.
                     * @return {org.dyn4j.dynamics.BodyFixture} BodyFixture
                     * @since 3.4.0
                     */
                    getFixture1() {
                        return this.fixture1;
                    }
                    /**
                     * Returns the fixture on the second body.
                     * @return {org.dyn4j.dynamics.BodyFixture} BodyFixture
                     * @since 3.4.0
                     */
                    getFixture2() {
                        return this.fixture2;
                    }
                }
                contact.ContactConstraintId = ContactConstraintId;
                ContactConstraintId["__class"] = "org.dyn4j.dynamics.contact.ContactConstraintId";
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.dynamics.contact.ContactConstraintId} contactConstraintId the contact constraint id
                 * @param {*} manifoldPointId the manifold point id
                 * @class
                 * @author William Bittle
                 */
                class ContactPointId {
                    constructor(contactConstraintId, manifoldPointId) {
                        if (this.contactConstraintId === undefined) {
                            this.contactConstraintId = null;
                        }
                        if (this.manifoldPointId === undefined) {
                            this.manifoldPointId = null;
                        }
                        this.contactConstraintId = contactConstraintId;
                        this.manifoldPointId = manifoldPointId;
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {boolean}
                     */
                    equals(other) {
                        if (other == null)
                            return false;
                        if (other === this)
                            return true;
                        if (other != null && other instanceof org.dyn4j.dynamics.contact.ContactPointId) {
                            const id = other;
                            if (id.contactConstraintId.equals(this.contactConstraintId) && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(id.manifoldPointId, this.manifoldPointId)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let hash = 1;
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.contactConstraintId);
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.manifoldPointId);
                        return hash;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("ContactPointId[ContactConstraintId=").append(this.contactConstraintId).append("|ManifoldPointId=").append(this.manifoldPointId).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the {@link ContactConstraintId} for this contact.
                     * @return {org.dyn4j.dynamics.contact.ContactConstraintId} {@link ContactConstraintId}
                     */
                    getContactConstraintId() {
                        return this.contactConstraintId;
                    }
                    /**
                     * Returns the {@link ManifoldPointId} for this contact.
                     * @return {*} {@link ManifoldPointId}
                     */
                    getManifoldPointId() {
                        return this.manifoldPointId;
                    }
                }
                contact.ContactPointId = ContactPointId;
                ContactPointId["__class"] = "org.dyn4j.dynamics.contact.ContactPointId";
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Convenience class for implementing the {@link DetectListener} interface.
             * <p>
             * This class can be used to implement only the methods desired instead of all
             * the methods contained in the {@link DetectListener} interface.
             * @author William Bittle
             * @version 3.2.0
             * @since 3.1.9
             * @class
             */
            class DetectAdapter {
                allow$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(aabb, body, fixture) {
                    return false;
                }
                allow$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body(convex, transform, body) {
                    return true;
                }
                allow$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(convex, transform, body, fixture) {
                    return true;
                }
                /**
                 *
                 * @param {*} convex
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @param {org.dyn4j.dynamics.Body} body
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture
                 * @return {boolean}
                 */
                allow(convex, transform, body, fixture) {
                    if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null)) {
                        return this.allow$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(convex, transform, body, fixture);
                    }
                    else if (((convex != null && convex instanceof org.dyn4j.geometry.AABB) || convex === null) && ((transform != null && transform instanceof org.dyn4j.dynamics.Body) || transform === null) && ((body != null && body instanceof org.dyn4j.dynamics.BodyFixture) || body === null) && fixture === undefined) {
                        return this.allow$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(convex, transform, body);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && fixture === undefined) {
                        return this.allow$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body(convex, transform, body);
                    }
                    else
                        throw new Error('invalid overload');
                }
                constructor() {
                }
            }
            dynamics.DetectAdapter = DetectAdapter;
            DetectAdapter["__class"] = "org.dyn4j.dynamics.DetectAdapter";
            DetectAdapter["__interfaces"] = ["org.dyn4j.Listener", "org.dyn4j.dynamics.DetectListener"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Convenience class for implementing the {@link CollisionListener} interface.
             * <p>
             * This class can be used to implement only the methods desired instead of all
             * the methods contained in the {@link CollisionListener} interface.
             * <p>
             * By default this class allows processing to continue for all collision events.
             * @author William Bittle
             * @version 3.2.0
             * @since 1.0.0
             * @class
             */
            class CollisionAdapter {
                collision$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(body1, fixture1, body2, fixture2) {
                    return true;
                }
                collision$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_manifold_Manifold(body1, fixture1, body2, fixture2, manifold) {
                    return true;
                }
                /**
                 *
                 * @param {org.dyn4j.dynamics.Body} body1
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture1
                 * @param {org.dyn4j.dynamics.Body} body2
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture2
                 * @param {org.dyn4j.collision.manifold.Manifold} manifold
                 * @return {boolean}
                 */
                collision(body1, fixture1, body2, fixture2, manifold) {
                    if (((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((fixture1 != null && fixture1 instanceof org.dyn4j.dynamics.BodyFixture) || fixture1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((fixture2 != null && fixture2 instanceof org.dyn4j.dynamics.BodyFixture) || fixture2 === null) && ((manifold != null && manifold instanceof org.dyn4j.collision.manifold.Manifold) || manifold === null)) {
                        return this.collision$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_manifold_Manifold(body1, fixture1, body2, fixture2, manifold);
                    }
                    else if (((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((fixture1 != null && fixture1 instanceof org.dyn4j.dynamics.BodyFixture) || fixture1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((fixture2 != null && fixture2 instanceof org.dyn4j.dynamics.BodyFixture) || fixture2 === null) && ((manifold != null && manifold instanceof org.dyn4j.collision.narrowphase.Penetration) || manifold === null)) {
                        return this.collision$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_narrowphase_Penetration(body1, fixture1, body2, fixture2, manifold);
                    }
                    else if (((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((fixture1 != null && fixture1 instanceof org.dyn4j.dynamics.BodyFixture) || fixture1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((fixture2 != null && fixture2 instanceof org.dyn4j.dynamics.BodyFixture) || fixture2 === null) && manifold === undefined) {
                        return this.collision$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(body1, fixture1, body2, fixture2);
                    }
                    else if (((body1 != null && body1 instanceof org.dyn4j.dynamics.contact.ContactConstraint) || body1 === null) && fixture1 === undefined && body2 === undefined && fixture2 === undefined && manifold === undefined) {
                        return this.collision$org_dyn4j_dynamics_contact_ContactConstraint(body1);
                    }
                    else
                        throw new Error('invalid overload');
                }
                collision$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_narrowphase_Penetration(body1, fixture1, body2, fixture2, penetration) {
                    return true;
                }
                collision$org_dyn4j_dynamics_contact_ContactConstraint(contactConstraint) {
                    return true;
                }
                constructor() {
                }
            }
            dynamics.CollisionAdapter = CollisionAdapter;
            CollisionAdapter["__class"] = "org.dyn4j.dynamics.CollisionAdapter";
            CollisionAdapter["__interfaces"] = ["org.dyn4j.Listener", "org.dyn4j.dynamics.CollisionListener"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             *
             * Full constructor.
             * @param {org.dyn4j.dynamics.Body} body the body
             * @param {org.dyn4j.dynamics.BodyFixture} fixture the fixture
             * @param {org.dyn4j.collision.continuous.TimeOfImpact} timeOfImpact the time of impact
             * @class
             * @author William Bittle
             */
            class ConvexCastResult {
                constructor(body, fixture, timeOfImpact) {
                    if (((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null) && ((timeOfImpact != null && timeOfImpact instanceof org.dyn4j.collision.continuous.TimeOfImpact) || timeOfImpact === null)) {
                        let __args = arguments;
                        if (this.body === undefined) {
                            this.body = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        if (this.timeOfImpact === undefined) {
                            this.timeOfImpact = null;
                        }
                        this.body = body;
                        this.fixture = fixture;
                        this.timeOfImpact = timeOfImpact;
                    }
                    else if (body === undefined && fixture === undefined && timeOfImpact === undefined) {
                        let __args = arguments;
                        if (this.body === undefined) {
                            this.body = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        if (this.timeOfImpact === undefined) {
                            this.timeOfImpact = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {org.dyn4j.dynamics.ConvexCastResult} o
                 * @return {number}
                 */
                compareTo(o) {
                    return ((f => { if (f > 0) {
                        return 1;
                    }
                    else if (f < 0) {
                        return -1;
                    }
                    else {
                        return 0;
                    } })(this.timeOfImpact.getTime() - o.timeOfImpact.getTime()) | 0);
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("ConvexCastResult[Body=").append(this.body).append("|Fixture=").append(this.fixture).append("|TimeOfImpact=").append(this.timeOfImpact).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the body.
                 * @return {org.dyn4j.dynamics.Body} {@link Body}
                 */
                getBody() {
                    return this.body;
                }
                /**
                 * Sets the body.
                 * @param {org.dyn4j.dynamics.Body} body the {@link Body}
                 */
                setBody(body) {
                    this.body = body;
                }
                /**
                 * Returns the fixture on the body with the smallest
                 * time of impact.
                 * @return {org.dyn4j.dynamics.BodyFixture} {@link BodyFixture}
                 */
                getFixture() {
                    return this.fixture;
                }
                /**
                 * Returns the time of impact information.
                 * @return {org.dyn4j.collision.continuous.TimeOfImpact} {@link TimeOfImpact}
                 */
                getTimeOfImpact() {
                    return this.timeOfImpact;
                }
                /**
                 * Sets the fixture with the smallest time of impact.
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture the fixture
                 */
                setFixture(fixture) {
                    this.fixture = fixture;
                }
                /**
                 * Sets the time of impact information.
                 * @param {org.dyn4j.collision.continuous.TimeOfImpact} timeOfImpact the time of impact
                 */
                setTimeOfImpact(timeOfImpact) {
                    this.timeOfImpact = timeOfImpact;
                }
            }
            dynamics.ConvexCastResult = ConvexCastResult;
            ConvexCastResult["__class"] = "org.dyn4j.dynamics.ConvexCastResult";
            ConvexCastResult["__interfaces"] = ["java.lang.Comparable"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * @param {org.dyn4j.dynamics.Body} other the other {@link Body} in contact
             * @param {*} interaction the interaction
             * @class
             * @author William Bittle
             */
            class InteractionEdge {
                constructor(other, interaction) {
                    if (this.other === undefined) {
                        this.other = null;
                    }
                    if (this.interaction === undefined) {
                        this.interaction = null;
                    }
                    this.other = other;
                    this.interaction = interaction;
                }
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("InteractionEdge[Interaction=").append(this.interaction).append("|Body=").append(this.other).append("]");
                    return sb.toString();
                }
            }
            dynamics.InteractionEdge = InteractionEdge;
            InteractionEdge["__class"] = "org.dyn4j.dynamics.InteractionEdge";
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Default implementation of the {@link RaycastListener} interface.
             * @author William Bittle
             * @version 3.2.0
             * @since 2.0.0
             * @class
             */
            class RaycastAdapter {
                allow$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(ray, body, fixture) {
                    return true;
                }
                allow$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_narrowphase_Raycast(ray, body, fixture, raycast) {
                    return true;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Ray} ray
                 * @param {org.dyn4j.dynamics.Body} body
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture
                 * @param {org.dyn4j.collision.narrowphase.Raycast} raycast
                 * @return {boolean}
                 */
                allow(ray, body, fixture, raycast) {
                    if (((ray != null && ray instanceof org.dyn4j.geometry.Ray) || ray === null) && ((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null) && ((raycast != null && raycast instanceof org.dyn4j.collision.narrowphase.Raycast) || raycast === null)) {
                        return this.allow$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_narrowphase_Raycast(ray, body, fixture, raycast);
                    }
                    else if (((ray != null && ray instanceof org.dyn4j.geometry.Ray) || ray === null) && ((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null) && raycast === undefined) {
                        return this.allow$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(ray, body, fixture);
                    }
                    else
                        throw new Error('invalid overload');
                }
                constructor() {
                }
            }
            dynamics.RaycastAdapter = RaycastAdapter;
            RaycastAdapter["__class"] = "org.dyn4j.dynamics.RaycastAdapter";
            RaycastAdapter["__interfaces"] = ["org.dyn4j.Listener", "org.dyn4j.dynamics.RaycastListener"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Creates a {@link Torque} using specified torque value.
             * @param {number} torque the torque
             * @class
             * @author William Bittle
             */
            class Torque {
                constructor(torque) {
                    if (((torque != null && torque instanceof org.dyn4j.dynamics.Torque) || torque === null)) {
                        let __args = arguments;
                        if (this.torque === undefined) {
                            this.torque = 0;
                        }
                        if (torque == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.torque.nullTorque"));
                        this.torque = torque.torque;
                    }
                    else if (((typeof torque === 'number') || torque === null)) {
                        let __args = arguments;
                        if (this.torque === undefined) {
                            this.torque = 0;
                        }
                        this.torque = torque;
                    }
                    else if (torque === undefined) {
                        let __args = arguments;
                        if (this.torque === undefined) {
                            this.torque = 0;
                        }
                        this.torque = 0.0;
                    }
                    else
                        throw new Error('invalid overload');
                }
                set$double(torque) {
                    this.torque = torque;
                }
                set$org_dyn4j_dynamics_Torque(torque) {
                    if (torque == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.torque.setNullTorque"));
                    this.torque = torque.torque;
                }
                /**
                 * Sets this {@link Torque} to the given {@link Torque}.
                 * @param {org.dyn4j.dynamics.Torque} torque the {@link Torque} to copy
                 * @throws NullPointerException if torque is null
                 */
                set(torque) {
                    if (((torque != null && torque instanceof org.dyn4j.dynamics.Torque) || torque === null)) {
                        return this.set$org_dyn4j_dynamics_Torque(torque);
                    }
                    else if (((typeof torque === 'number') || torque === null)) {
                        return this.set$double(torque);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns true if this torque should be removed.
                 * <p>
                 * Implement this method to create {@link Torque} objects
                 * that are not cleared each iteration by the {@link World}.
                 * <p>
                 * The default implementation always returns true.
                 * @param {number} elapsedTime the elapsed time since the last call to this method
                 * @return {boolean} boolean true if this torque should be removed
                 * @since 3.1.0
                 */
                isComplete(elapsedTime) {
                    return true;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return /* valueOf */ String(this.torque).toString();
                }
                /**
                 * Returns the torque value.
                 * @return {number} double
                 */
                getTorque() {
                    return this.torque;
                }
            }
            dynamics.Torque = Torque;
            Torque["__class"] = "org.dyn4j.dynamics.Torque";
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Creates a new {@link Force} using the x and y components.
             * @param {number} x the x component
             * @param {number} y the y component
             * @class
             * @author William Bittle
             */
            class Force {
                constructor(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        let __args = arguments;
                        if (this.force === undefined) {
                            this.force = null;
                        }
                        this.force = new org.dyn4j.geometry.Vector2(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        let __args = arguments;
                        let force = __args[0];
                        if (this.force === undefined) {
                            this.force = null;
                        }
                        if (force == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.force.nullVector"));
                        this.force = force;
                    }
                    else if (((x != null && x instanceof org.dyn4j.dynamics.Force) || x === null) && y === undefined) {
                        let __args = arguments;
                        let force = __args[0];
                        if (this.force === undefined) {
                            this.force = null;
                        }
                        if (force == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.force.nullForce"));
                        this.force = force.force.copy();
                    }
                    else if (x === undefined && y === undefined) {
                        let __args = arguments;
                        if (this.force === undefined) {
                            this.force = null;
                        }
                        this.force = new org.dyn4j.geometry.Vector2();
                    }
                    else
                        throw new Error('invalid overload');
                }
                set$double$double(x, y) {
                    this.force.set$double$double(x, y);
                }
                /**
                 * Sets this {@link Force} to the given components.
                 * @param {number} x the x component
                 * @param {number} y the y component
                 */
                set(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.set$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.set$org_dyn4j_geometry_Vector2(x);
                    }
                    else if (((x != null && x instanceof org.dyn4j.dynamics.Force) || x === null) && y === undefined) {
                        return this.set$org_dyn4j_dynamics_Force(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                set$org_dyn4j_geometry_Vector2(force) {
                    if (force == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.force.setNullVector"));
                    this.force.set$org_dyn4j_geometry_Vector2(force);
                }
                set$org_dyn4j_dynamics_Force(force) {
                    if (force == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.force.setNullForce"));
                    this.force.set$org_dyn4j_geometry_Vector2(force.force);
                }
                /**
                 * Returns true if this force should be removed.
                 * <p>
                 * Implement this method to create {@link Force} objects
                 * that are not cleared each iteration by the {@link World}.
                 * <p>
                 * The default implementation always returns true.
                 * @param {number} elapsedTime the elapsed time since the last call to this method
                 * @return {boolean} boolean true if this force should be removed
                 * @since 3.1.0
                 */
                isComplete(elapsedTime) {
                    return true;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return this.force.toString();
                }
                /**
                 * Returns the force vector.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getForce() {
                    return this.force;
                }
            }
            dynamics.Force = Force;
            Force["__class"] = "org.dyn4j.dynamics.Force";
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Minimal constructor.
             * @param {org.dyn4j.dynamics.World} world the world to iterate over
             * @class
             * @author William Bittle
             */
            class JointIterator {
                constructor(world) {
                    if (this.world === undefined) {
                        this.world = null;
                    }
                    if (this.index === undefined) {
                        this.index = 0;
                    }
                    this.world = world;
                    this.index = -1;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.index + 1 < this.world.getJointCount();
                }
                /**
                 *
                 * @return {org.dyn4j.dynamics.joint.Joint}
                 */
                next() {
                    if (this.index >= this.world.getJointCount()) {
                        throw new java.lang.IndexOutOfBoundsException();
                    }
                    try {
                        this.index++;
                        const joint = this.world.getJoint(this.index);
                        return joint;
                    }
                    catch (ex) {
                        throw new java.util.ConcurrentModificationException();
                    }
                }
                /**
                 *
                 */
                remove() {
                    if (this.index < 0) {
                        throw new java.lang.IllegalStateException();
                    }
                    if (this.index >= this.world.getJointCount()) {
                        throw new java.lang.IndexOutOfBoundsException();
                    }
                    try {
                        this.world.removeJoint$int(this.index);
                        this.index--;
                    }
                    catch (ex) {
                        throw new java.util.ConcurrentModificationException();
                    }
                }
                forEachRemaining(action) {
                    java.util.Objects.requireNonNull((((funcInst) => { if (typeof funcInst == 'function') {
                        return funcInst;
                    } return (arg0) => (funcInst['accept'] ? funcInst['accept'] : funcInst).call(funcInst, arg0); })(action)));
                    while ((this.hasNext())) {
                        (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(action);
                    }
                    ;
                }
            }
            dynamics.JointIterator = JointIterator;
            JointIterator["__class"] = "org.dyn4j.dynamics.JointIterator";
            JointIterator["__interfaces"] = ["java.util.Iterator"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Enumeration of Continuous Collision Detection modes.
             * @author William Bittle
             * @version 2.2.3
             * @since 2.2.3
             * @enum
             * @property {org.dyn4j.dynamics.ContinuousDetectionMode} NONE
             * CCD is not performed at all
             * @property {org.dyn4j.dynamics.ContinuousDetectionMode} BULLETS_ONLY
             *
             * CCD is performed on bodies flagged as bullets only.
             * <p>
             * More precisely, the following pairs are tested:
             * <ul>
             * <li>Bullet vs. Dynamic</li>
             * <li>Bullet vs. Static</li>
             * </ul>
             * @property {org.dyn4j.dynamics.ContinuousDetectionMode} ALL
             *
             * CCD is performed on all bodies against static bodies.
             * <p>
             * More precisely, the following pairs are tested:
             * <ul>
             * <li>Dynamic vs. Static</li>
             * <li>Bullet vs. Static</li>
             * <li>Bullet vs. Dynamic</li>
             * </ul>
             * @class
             */
            let ContinuousDetectionMode;
            (function (ContinuousDetectionMode) {
                /**
                 * CCD is not performed at all
                 */
                ContinuousDetectionMode[ContinuousDetectionMode["NONE"] = 0] = "NONE";
                /**
                 *
                 * CCD is performed on bodies flagged as bullets only.
                 * <p>
                 * More precisely, the following pairs are tested:
                 * <ul>
                 * <li>Bullet vs. Dynamic</li>
                 * <li>Bullet vs. Static</li>
                 * </ul>
                 */
                ContinuousDetectionMode[ContinuousDetectionMode["BULLETS_ONLY"] = 1] = "BULLETS_ONLY";
                /**
                 *
                 * CCD is performed on all bodies against static bodies.
                 * <p>
                 * More precisely, the following pairs are tested:
                 * <ul>
                 * <li>Dynamic vs. Static</li>
                 * <li>Bullet vs. Static</li>
                 * <li>Bullet vs. Dynamic</li>
                 * </ul>
                 */
                ContinuousDetectionMode[ContinuousDetectionMode["ALL"] = 2] = "ALL";
            })(ContinuousDetectionMode = dynamics.ContinuousDetectionMode || (dynamics.ContinuousDetectionMode = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * @param {org.dyn4j.dynamics.Capacity} initialCapacity the initial capacity of the island
             * @throws NullPointerException if initialCapacity is null
             * @since 3.2.0
             * @class
             * @author William Bittle
             */
            class Island {
                constructor(initialCapacity) {
                    if (((initialCapacity != null && initialCapacity instanceof org.dyn4j.dynamics.Capacity) || initialCapacity === null)) {
                        let __args = arguments;
                        if (this.bodies === undefined) {
                            this.bodies = null;
                        }
                        if (this.joints === undefined) {
                            this.joints = null;
                        }
                        if (this.contactConstraints === undefined) {
                            this.contactConstraints = null;
                        }
                        if (initialCapacity == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.nullCapacity"));
                        this.bodies = (new java.util.ArrayList(initialCapacity.getBodyCount()));
                        this.joints = (new java.util.ArrayList(initialCapacity.getJointCount()));
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionPairs(initialCapacity.getBodyCount());
                        this.contactConstraints = (new java.util.ArrayList(eSize));
                    }
                    else if (initialCapacity === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let initialCapacity = org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$();
                            if (this.bodies === undefined) {
                                this.bodies = null;
                            }
                            if (this.joints === undefined) {
                                this.joints = null;
                            }
                            if (this.contactConstraints === undefined) {
                                this.contactConstraints = null;
                            }
                            if (initialCapacity == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.nullCapacity"));
                            this.bodies = (new java.util.ArrayList(initialCapacity.getBodyCount()));
                            this.joints = (new java.util.ArrayList(initialCapacity.getJointCount()));
                            const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionPairs(initialCapacity.getBodyCount());
                            this.contactConstraints = (new java.util.ArrayList(eSize));
                        }
                        if (this.bodies === undefined) {
                            this.bodies = null;
                        }
                        if (this.joints === undefined) {
                            this.joints = null;
                        }
                        if (this.contactConstraints === undefined) {
                            this.contactConstraints = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Clears the island.
                 */
                clear() {
                    this.bodies.clear();
                    this.joints.clear();
                    this.contactConstraints.clear();
                }
                add$org_dyn4j_dynamics_Body(body) {
                    this.bodies.add(body);
                }
                /**
                 * Adds the given {@link Body} to the {@link Body} list.
                 * @param {org.dyn4j.dynamics.Body} body the {@link Body}
                 */
                add(body) {
                    if (((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null)) {
                        return this.add$org_dyn4j_dynamics_Body(body);
                    }
                    else if (((body != null && body instanceof org.dyn4j.dynamics.contact.ContactConstraint) || body === null)) {
                        return this.add$org_dyn4j_dynamics_contact_ContactConstraint(body);
                    }
                    else if (((body != null && body instanceof org.dyn4j.dynamics.joint.Joint) || body === null)) {
                        return this.add$org_dyn4j_dynamics_joint_Joint(body);
                    }
                    else
                        throw new Error('invalid overload');
                }
                add$org_dyn4j_dynamics_contact_ContactConstraint(contactConstraint) {
                    this.contactConstraints.add(contactConstraint);
                }
                add$org_dyn4j_dynamics_joint_Joint(joint) {
                    this.joints.add(joint);
                }
                /**
                 * Integrates the {@link Body}s, solves all {@link ContactConstraint}s and
                 * {@link Joint}s, and attempts to sleep motionless {@link Body}s.
                 * @param {*} solver the contact constraint solver
                 * @param {org.dyn4j.geometry.Vector2} gravity the gravity vector
                 * @param {org.dyn4j.dynamics.Step} step the time step information
                 * @param {org.dyn4j.dynamics.Settings} settings the current world settings
                 */
                solve(solver, gravity, step, settings) {
                    const velocitySolverIterations = settings.getVelocityConstraintSolverIterations();
                    const positionSolverIterations = settings.getPositionConstraintSolverIterations();
                    const sleepAngularVelocitySquared = settings.getSleepAngularVelocitySquared();
                    const sleepLinearVelocitySquared = settings.getSleepLinearVelocitySquared();
                    const sleepTime = settings.getSleepTime();
                    const size = this.bodies.size();
                    const jSize = this.joints.size();
                    const dt = step.dt;
                    let invM;
                    let invI;
                    for (let i = 0; i < size; i++) {
                        {
                            const body = this.bodies.get(i);
                            if (!body.isDynamic())
                                continue;
                            body.averageVelocity.set$org_dyn4j_geometry_Vector2(body.velocity);
                            body.accumulate(dt);
                            invM = body.mass.getInverseMass();
                            invI = body.mass.getInverseInertia();
                            if (invM > org.dyn4j.Epsilon.E_$LI$()) {
                                if (body.isColliding()) {
                                }
                                body.velocity.x += (body.force.x * invM + gravity.x * body.gravityScale) * dt;
                                body.velocity.y += (body.force.y * invM + gravity.y * body.gravityScale) * dt;
                            }
                            if (invI > org.dyn4j.Epsilon.E_$LI$()) {
                                body.angularVelocity += dt * invI * body.torque;
                            }
                            if (body.linearDamping !== 0.0) {
                                let linear = 1.0 - dt * body.linearDamping;
                                linear = org.dyn4j.geometry.Interval.clamp(linear, 0.0, 1.0);
                                body.velocity.x *= linear;
                                body.velocity.y *= linear;
                            }
                            let angular = 1.0 - dt * body.angularDamping;
                            angular = org.dyn4j.geometry.Interval.clamp(angular, 0.0, 1.0);
                            body.angularVelocity *= angular;
                            body.averageVelocity.set$double$double(0.5 * (body.averageVelocity.x + body.velocity.x), 0.5 * (body.averageVelocity.y + body.velocity.y));
                            body.averageAngularVelocity = 0.5 * (body.averageAngularVelocity + body.getAngularVelocity());
                        }
                        ;
                    }
                    solver.initialize(this.contactConstraints, step, settings);
                    for (let i = 0; i < jSize; i++) {
                        {
                            const joint = this.joints.get(i);
                            joint.initializeConstraints(step, settings);
                        }
                        ;
                    }
                    if (!this.contactConstraints.isEmpty() || !this.joints.isEmpty()) {
                        for (let i = 0; i < velocitySolverIterations; i++) {
                            {
                                for (let j = 0; j < jSize; j++) {
                                    {
                                        const joint = this.joints.get(j);
                                        joint.solveVelocityConstraints(step, settings);
                                    }
                                    ;
                                }
                                solver.solveVelocityContraints(this.contactConstraints, step, settings);
                            }
                            ;
                        }
                    }
                    const maxTranslation = settings.getMaximumTranslation();
                    const maxRotation = settings.getMaximumRotation();
                    const maxTranslationSqrd = settings.getMaximumTranslationSquared();
                    for (let i = 0; i < size; i++) {
                        {
                            const body = this.bodies.get(i);
                            if (body.isStatic())
                                continue;
                            let translationX = body.averageVelocity.x * dt;
                            let translationY = body.averageVelocity.y * dt;
                            const translationMagnitudeSquared = translationX * translationX + translationY * translationY;
                            if (translationMagnitudeSquared > maxTranslationSqrd) {
                                const translationMagnitude = Math.sqrt(translationMagnitudeSquared);
                                const ratio = maxTranslation / translationMagnitude;
                                body.velocity.multiply(ratio);
                                translationX *= ratio;
                                translationY *= ratio;
                            }
                            let rotation = body.averageAngularVelocity * dt;
                            if (rotation > maxRotation) {
                                const ratio = maxRotation / Math.abs(rotation);
                                body.angularVelocity *= ratio;
                                rotation *= ratio;
                            }
                            if (body.mass.getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY) {
                                translationY = 0;
                                body.velocity.y = 0;
                            }
                            else if (body.mass.getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY) {
                                translationX = 0;
                                body.velocity.x = 0;
                            }
                            body.translate$double$double(translationX, translationY);
                            body.rotateAboutCenter(rotation);
                        }
                        ;
                    }
                    let positionConstraintsSolved = false;
                    for (let i = 0; i < positionSolverIterations; i++) {
                        {
                            const contactsSolved = solver.solvePositionContraints(this.contactConstraints, step, settings);
                            let jointsSolved = true;
                            for (let j = 0; j < jSize; j++) {
                                {
                                    const joint = this.joints.get(j);
                                    const jointSolved = joint.solvePositionConstraints(step, settings);
                                    jointsSolved = jointsSolved && jointSolved;
                                }
                                ;
                            }
                            if (contactsSolved && jointsSolved) {
                                positionConstraintsSolved = true;
                                break;
                            }
                        }
                        ;
                    }
                    if (settings.isAutoSleepingEnabled()) {
                        let minSleepTime = javaemul.internal.DoubleHelper.MAX_VALUE;
                        for (let i = 0; i < size; i++) {
                            {
                                const body = this.bodies.get(i);
                                if (body.isStatic())
                                    continue;
                                if (body.isAutoSleepingEnabled()) {
                                    if (body.velocity.getMagnitudeSquared() > sleepLinearVelocitySquared || body.angularVelocity * body.angularVelocity > sleepAngularVelocitySquared) {
                                        body.sleepTime = 0.0;
                                        minSleepTime = 0.0;
                                    }
                                    else {
                                        body.sleepTime += step.dt;
                                        minSleepTime = Math.min(minSleepTime, body.sleepTime);
                                    }
                                }
                                else {
                                    body.sleepTime = 0.0;
                                    minSleepTime = 0.0;
                                }
                            }
                            ;
                        }
                        if (minSleepTime >= sleepTime && positionConstraintsSolved) {
                            for (let i = 0; i < size; i++) {
                                {
                                    const body = this.bodies.get(i);
                                    body.setAsleep(true);
                                }
                                ;
                            }
                        }
                    }
                }
            }
            dynamics.Island = Island;
            Island["__class"] = "org.dyn4j.dynamics.Island";
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * @param {org.dyn4j.dynamics.Body} body the body
             * @param {org.dyn4j.dynamics.BodyFixture} fixture the fixture
             * @param {org.dyn4j.collision.narrowphase.Raycast} raycast the raycast
             * @class
             * @author William Bittle
             */
            class RaycastResult {
                constructor(body, fixture, raycast) {
                    if (((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null) && ((raycast != null && raycast instanceof org.dyn4j.collision.narrowphase.Raycast) || raycast === null)) {
                        let __args = arguments;
                        if (this.body === undefined) {
                            this.body = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        if (this.raycast === undefined) {
                            this.raycast = null;
                        }
                        this.body = body;
                        this.fixture = fixture;
                        this.raycast = raycast;
                    }
                    else if (body === undefined && fixture === undefined && raycast === undefined) {
                        let __args = arguments;
                        if (this.body === undefined) {
                            this.body = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        if (this.raycast === undefined) {
                            this.raycast = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {org.dyn4j.dynamics.RaycastResult} o
                 * @return {number}
                 */
                compareTo(o) {
                    return ((f => { if (f > 0) {
                        return 1;
                    }
                    else if (f < 0) {
                        return -1;
                    }
                    else {
                        return 0;
                    } })(this.raycast.getDistance() - o.raycast.getDistance()) | 0);
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("RaycastResult[Body=").append(this.body).append("|Fixture=").append(this.fixture).append("|Raycast=").append(this.raycast).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the {@link Body} detected.
                 * @return {org.dyn4j.dynamics.Body} {@link Body}
                 */
                getBody() {
                    return this.body;
                }
                /**
                 * Sets the {@link Body} detected.
                 * @param {org.dyn4j.dynamics.Body} body the {@link Body}
                 */
                setBody(body) {
                    this.body = body;
                }
                /**
                 * Returns the {@link BodyFixture} of the {@link Body} detected.
                 * @return {org.dyn4j.dynamics.BodyFixture} {@link BodyFixture}
                 */
                getFixture() {
                    return this.fixture;
                }
                /**
                 * Sets the {@link BodyFixture} of the {@link Body} detected.
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture the {@link BodyFixture}
                 */
                setFixture(fixture) {
                    this.fixture = fixture;
                }
                /**
                 * Returns the {@link Raycast} result information.
                 * @return {org.dyn4j.collision.narrowphase.Raycast} {@link Raycast}
                 */
                getRaycast() {
                    return this.raycast;
                }
                /**
                 * Sets the {@link Raycast} result information.
                 * @param {org.dyn4j.collision.narrowphase.Raycast} raycast the {@link Raycast}
                 */
                setRaycast(raycast) {
                    this.raycast = raycast;
                }
            }
            dynamics.RaycastResult = RaycastResult;
            RaycastResult["__class"] = "org.dyn4j.dynamics.RaycastResult";
            RaycastResult["__interfaces"] = ["java.lang.Comparable"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * @param {org.dyn4j.dynamics.Body} body the body
             * @param {org.dyn4j.dynamics.BodyFixture} fixture the fixture
             * @param {org.dyn4j.collision.narrowphase.Penetration} penetration the penetration; can be null
             * @class
             * @author William Bittle
             */
            class DetectResult {
                constructor(body, fixture, penetration) {
                    if (((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null) && ((penetration != null && penetration instanceof org.dyn4j.collision.narrowphase.Penetration) || penetration === null)) {
                        let __args = arguments;
                        if (this.body === undefined) {
                            this.body = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        if (this.penetration === undefined) {
                            this.penetration = null;
                        }
                        this.body = body;
                        this.fixture = fixture;
                        this.penetration = penetration;
                    }
                    else if (((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null) && penetration === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let penetration = null;
                            if (this.body === undefined) {
                                this.body = null;
                            }
                            if (this.fixture === undefined) {
                                this.fixture = null;
                            }
                            if (this.penetration === undefined) {
                                this.penetration = null;
                            }
                            this.body = body;
                            this.fixture = fixture;
                            this.penetration = penetration;
                        }
                        if (this.body === undefined) {
                            this.body = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        if (this.penetration === undefined) {
                            this.penetration = null;
                        }
                    }
                    else if (body === undefined && fixture === undefined && penetration === undefined) {
                        let __args = arguments;
                        if (this.body === undefined) {
                            this.body = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        if (this.penetration === undefined) {
                            this.penetration = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("DetectResult[Body=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                    } })(this.body)).append("|Fixture=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                    } })(this.fixture)).append("|Penetration=").append(this.penetration).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the overlapping body.
                 * @return {org.dyn4j.dynamics.Body} {@link Body}
                 */
                getBody() {
                    return this.body;
                }
                /**
                 * Sets the overlapping body.
                 * @param {org.dyn4j.dynamics.Body} body the {@link Body}
                 */
                setBody(body) {
                    this.body = body;
                }
                /**
                 * Returns the overlapping fixture.
                 * @return {org.dyn4j.dynamics.BodyFixture} {@link BodyFixture}
                 */
                getFixture() {
                    return this.fixture;
                }
                /**
                 * Sets the overlapping fixture.
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture the {@link BodyFixture}
                 */
                setFixture(fixture) {
                    this.fixture = fixture;
                }
                /**
                 * Returns the overlap penetration (collision data).
                 * <p>
                 * This will return null if the collision data was flagged to not be included.
                 * @return {org.dyn4j.collision.narrowphase.Penetration} {@link Penetration}
                 */
                getPenetration() {
                    return this.penetration;
                }
                /**
                 * Sets the overlap penetration (collision data).
                 * @param {org.dyn4j.collision.narrowphase.Penetration} penetration the {@link Penetration}; can be null
                 */
                setPenetration(penetration) {
                    this.penetration = penetration;
                }
            }
            dynamics.DetectResult = DetectResult;
            DetectResult["__class"] = "org.dyn4j.dynamics.DetectResult";
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * @param {number} bodyCount the estimated number of bodies
             * @param {number} jointCount the estimated number of joints
             * @param {number} listenerCount the estimated number of listeners
             * @throws IllegalArgumentException if any count is less than zero
             * @class
             * @author William Bittle
             */
            class Capacity {
                constructor(bodyCount, jointCount, listenerCount) {
                    if (((typeof bodyCount === 'number') || bodyCount === null) && ((typeof jointCount === 'number') || jointCount === null) && ((typeof listenerCount === 'number') || listenerCount === null)) {
                        let __args = arguments;
                        if (this.bodyCount === undefined) {
                            this.bodyCount = 0;
                        }
                        if (this.jointCount === undefined) {
                            this.jointCount = 0;
                        }
                        if (this.listenerCount === undefined) {
                            this.listenerCount = 0;
                        }
                        this.bodyCount = bodyCount > 0 ? bodyCount : Capacity.DEFAULT_BODY_COUNT;
                        this.jointCount = jointCount > 0 ? jointCount : Capacity.DEFAULT_JOINT_COUNT;
                        this.listenerCount = listenerCount > 0 ? listenerCount : Capacity.DEFAULT_LISTENER_COUNT;
                    }
                    else if (bodyCount === undefined && jointCount === undefined && listenerCount === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let bodyCount = Capacity.DEFAULT_BODY_COUNT;
                            let jointCount = Capacity.DEFAULT_JOINT_COUNT;
                            let listenerCount = Capacity.DEFAULT_LISTENER_COUNT;
                            if (this.bodyCount === undefined) {
                                this.bodyCount = 0;
                            }
                            if (this.jointCount === undefined) {
                                this.jointCount = 0;
                            }
                            if (this.listenerCount === undefined) {
                                this.listenerCount = 0;
                            }
                            this.bodyCount = bodyCount > 0 ? bodyCount : Capacity.DEFAULT_BODY_COUNT;
                            this.jointCount = jointCount > 0 ? jointCount : Capacity.DEFAULT_JOINT_COUNT;
                            this.listenerCount = listenerCount > 0 ? listenerCount : Capacity.DEFAULT_LISTENER_COUNT;
                        }
                        if (this.bodyCount === undefined) {
                            this.bodyCount = 0;
                        }
                        if (this.jointCount === undefined) {
                            this.jointCount = 0;
                        }
                        if (this.listenerCount === undefined) {
                            this.listenerCount = 0;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                static DEFAULT_CAPACITY_$LI$() { if (Capacity.DEFAULT_CAPACITY == null) {
                    Capacity.DEFAULT_CAPACITY = new Capacity();
                } return Capacity.DEFAULT_CAPACITY; }
                /**
                 *
                 * @param {*} obj
                 * @return {boolean}
                 */
                equals(obj) {
                    if (obj == null)
                        return false;
                    if (obj === this)
                        return true;
                    if (obj != null && obj instanceof org.dyn4j.dynamics.Capacity) {
                        const capacity = obj;
                        return capacity.bodyCount === this.bodyCount && capacity.jointCount === this.jointCount && capacity.listenerCount === this.listenerCount;
                    }
                    return false;
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    let hash = 17;
                    hash = hash * 31 + this.bodyCount;
                    hash = hash * 31 + this.jointCount;
                    hash = hash * 31 + this.listenerCount;
                    return hash;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Capacity[BodyCount=").append(this.bodyCount).append("|JointCount=").append(this.jointCount).append("|ListenerCount=").append(this.listenerCount).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the estimated number of bodies.
                 * @return {number} int
                 */
                getBodyCount() {
                    return this.bodyCount;
                }
                /**
                 * Returns the estimated number of joints.
                 * @return {number} int
                 */
                getJointCount() {
                    return this.jointCount;
                }
                /**
                 * Returns the estimated number of listeners.
                 * @return {number} int
                 */
                getListenerCount() {
                    return this.listenerCount;
                }
            }
            /**
             * The default {@link Body} count
             */
            Capacity.DEFAULT_BODY_COUNT = 32;
            /**
             * The default {@link Joint} count
             */
            Capacity.DEFAULT_JOINT_COUNT = 16;
            /**
             * The default {@link Listener} count
             */
            Capacity.DEFAULT_LISTENER_COUNT = 16;
            dynamics.Capacity = Capacity;
            Capacity["__class"] = "org.dyn4j.dynamics.Capacity";
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Enumeration for the limit states a joint can have.
                 * @author William Bittle
                 * @version 1.0.3
                 * @since 1.0.0
                 * @enum
                 * @property {org.dyn4j.dynamics.joint.LimitState} EQUAL
                 * The state if the upper and lower limits are equal within tolerance
                 * @property {org.dyn4j.dynamics.joint.LimitState} AT_LOWER
                 * The state if the joint has reached or passed the lower limit
                 * @property {org.dyn4j.dynamics.joint.LimitState} AT_UPPER
                 * The state if the joint has reached or passed the upper limit
                 * @property {org.dyn4j.dynamics.joint.LimitState} INACTIVE
                 * The state if the joint limits are disabled or if the joint is between the limits
                 * @class
                 */
                let LimitState;
                (function (LimitState) {
                    /**
                     * The state if the upper and lower limits are equal within tolerance
                     */
                    LimitState[LimitState["EQUAL"] = 0] = "EQUAL";
                    /**
                     * The state if the joint has reached or passed the lower limit
                     */
                    LimitState[LimitState["AT_LOWER"] = 1] = "AT_LOWER";
                    /**
                     * The state if the joint has reached or passed the upper limit
                     */
                    LimitState[LimitState["AT_UPPER"] = 2] = "AT_UPPER";
                    /**
                     * The state if the joint limits are disabled or if the joint is between the limits
                     */
                    LimitState[LimitState["INACTIVE"] = 3] = "INACTIVE";
                })(LimitState = joint.LimitState || (joint.LimitState = {}));
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * @param {org.dyn4j.dynamics.Body} body1 the first participating {@link Body}
             * @param {org.dyn4j.dynamics.Body} body2 the second participating {@link Body}
             * @throws NullPointerException if body1 or body2 is null
             * @class
             * @author William Bittle
             */
            class Constraint {
                constructor(body1, body2) {
                    if (this.body1 === undefined) {
                        this.body1 = null;
                    }
                    if (this.body2 === undefined) {
                        this.body2 = null;
                    }
                    if (this.onIsland === undefined) {
                        this.onIsland = false;
                    }
                    if (this.world === undefined) {
                        this.world = null;
                    }
                    if (body1 == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.constraint.nullBody1"));
                    if (body2 == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.constraint.nullBody2"));
                    this.body1 = body1;
                    this.body2 = body2;
                    this.onIsland = false;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Body1=").append(this.body1).append("|Body2=").append(this.body2);
                    return sb.toString();
                }
                /**
                 * Returns the first {@link Body}.
                 * @return {org.dyn4j.dynamics.Body} {@link Body}
                 */
                getBody1() {
                    return this.body1;
                }
                /**
                 * Returns the second {@link Body}.
                 * @return {org.dyn4j.dynamics.Body} {@link Body}
                 */
                getBody2() {
                    return this.body2;
                }
                /**
                 * Sets the first {@link Body}.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @throws NullPointerException if body1 is null
                 */
                setBody1(body1) {
                    if (body1 == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.constraint.nullBody1"));
                    this.body1 = body1;
                }
                /**
                 * Sets the second {@link Body}.
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @throws NullPointerException if body2 is null
                 */
                setBody2(body2) {
                    if (body2 == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.constraint.nullBody2"));
                    this.body2 = body2;
                }
                /**
                 * Sets the on {@link Island} flag to the given value.
                 * @param {boolean} onIsland true if the {@link Constraint} has been added to an {@link Island}
                 */
                setOnIsland(onIsland) {
                    this.onIsland = onIsland;
                }
                /**
                 * Returns true if this {@link Constraint} has been added
                 * to an {@link Island}
                 * @return {boolean} boolean
                 */
                isOnIsland() {
                    return this.onIsland;
                }
            }
            dynamics.Constraint = Constraint;
            Constraint["__class"] = "org.dyn4j.dynamics.Constraint";
            Constraint["__interfaces"] = ["org.dyn4j.geometry.Shiftable"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Convenience class for implementing the {@link TimeOfImpactListener} interface.
             * @author William Bittle
             * @version 3.1.5
             * @since 1.2.0
             * @class
             */
            class TimeOfImpactAdapter {
                /**
                 *
                 * @param {org.dyn4j.dynamics.Body} body1
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture1
                 * @param {org.dyn4j.dynamics.Body} body2
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture2
                 * @param {org.dyn4j.collision.continuous.TimeOfImpact} toi
                 * @return {boolean}
                 */
                collision(body1, fixture1, body2, fixture2, toi) {
                    return true;
                }
                constructor() {
                }
            }
            dynamics.TimeOfImpactAdapter = TimeOfImpactAdapter;
            TimeOfImpactAdapter["__class"] = "org.dyn4j.dynamics.TimeOfImpactAdapter";
            TimeOfImpactAdapter["__interfaces"] = ["org.dyn4j.Listener", "org.dyn4j.dynamics.TimeOfImpactListener"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Default constructor.
             * @param {number} dt the initial delta time; in seconds<sup>-1</sup>
             * @class
             * @author William Bittle
             */
            class Step {
                constructor(dt) {
                    if (this.dt0 === undefined) {
                        this.dt0 = 0;
                    }
                    if (this.invdt0 === undefined) {
                        this.invdt0 = 0;
                    }
                    if (this.dt === undefined) {
                        this.dt = 0;
                    }
                    if (this.invdt === undefined) {
                        this.invdt = 0;
                    }
                    if (this.dtRatio === undefined) {
                        this.dtRatio = 0;
                    }
                    this.dt = dt;
                    this.invdt = 1.0 / dt;
                    this.dt0 = this.dt;
                    this.invdt0 = this.invdt;
                    this.dtRatio = 1.0;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Step[DeltaTime=").append(this.dt).append("|InverseDeltaTime=").append(this.invdt).append("|PreviousDeltaTime=").append(this.dt0).append("|PreviousInverseDeltaTime=").append(this.invdt0).append("|DeltaTimeRatio=").append(this.dtRatio).append("]");
                    return sb.toString();
                }
                /**
                 * Updates the current {@link Step} using the new elapsed time.
                 * @param {number} dt in seconds.
                 */
                update(dt) {
                    this.dt0 = this.dt;
                    this.invdt0 = this.invdt;
                    this.dt = dt;
                    this.invdt = 1.0 / dt;
                    this.dtRatio = this.invdt0 * dt;
                }
                /**
                 * Returns the elapsed time since the last time step in seconds.
                 * @return {number} double
                 */
                getDeltaTime() {
                    return this.dt;
                }
                /**
                 * Returns the inverse of the elapsed time (in seconds) since the last time step.
                 * @return {number} double
                 */
                getInverseDeltaTime() {
                    return this.invdt;
                }
                /**
                 * Returns the ratio of the last elapsed time to the current
                 * elapsed time.
                 * <p>
                 * This is used to cope with a variable time step.
                 * @return {number} double
                 */
                getDeltaTimeRatio() {
                    return this.dtRatio;
                }
                /**
                 * Returns the previous frame's elapsed time in seconds.
                 * @return {number} double
                 */
                getPrevousDeltaTime() {
                    return this.dt0;
                }
                /**
                 * Returns the previous frame's inverse elapsed time (in seconds).
                 * @return {number} double
                 */
                getPreviousInverseDeltaTime() {
                    return this.invdt0;
                }
            }
            dynamics.Step = Step;
            Step["__class"] = "org.dyn4j.dynamics.Step";
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Default constructor
             * @class
             * @author William Bittle
             */
            class Settings {
                constructor() {
                    this.stepFrequency = Settings.DEFAULT_STEP_FREQUENCY;
                    this.maximumTranslation = Settings.DEFAULT_MAXIMUM_TRANSLATION;
                    this.maximumTranslationSquared = Settings.DEFAULT_MAXIMUM_TRANSLATION * Settings.DEFAULT_MAXIMUM_TRANSLATION;
                    this.maximumRotation = Settings.DEFAULT_MAXIMUM_ROTATION_$LI$();
                    this.maximumRotationSquared = Settings.DEFAULT_MAXIMUM_ROTATION_$LI$() * Settings.DEFAULT_MAXIMUM_ROTATION_$LI$();
                    this.autoSleepingEnabled = true;
                    this.sleepLinearVelocity = Settings.DEFAULT_SLEEP_LINEAR_VELOCITY;
                    this.sleepLinearVelocitySquared = Settings.DEFAULT_SLEEP_LINEAR_VELOCITY * Settings.DEFAULT_SLEEP_LINEAR_VELOCITY;
                    this.sleepAngularVelocity = Settings.DEFAULT_SLEEP_ANGULAR_VELOCITY_$LI$();
                    this.sleepAngularVelocitySquared = Settings.DEFAULT_SLEEP_ANGULAR_VELOCITY_$LI$() * Settings.DEFAULT_SLEEP_ANGULAR_VELOCITY_$LI$();
                    this.sleepTime = Settings.DEFAULT_SLEEP_TIME;
                    this.velocityConstraintSolverIterations = Settings.DEFAULT_SOLVER_ITERATIONS;
                    this.positionConstraintSolverIterations = Settings.DEFAULT_SOLVER_ITERATIONS;
                    this.warmStartDistance = Settings.DEFAULT_WARM_START_DISTANCE;
                    this.warmStartDistanceSquared = Settings.DEFAULT_WARM_START_DISTANCE * Settings.DEFAULT_WARM_START_DISTANCE;
                    this.restitutionVelocity = Settings.DEFAULT_RESTITUTION_VELOCITY;
                    this.restitutionVelocitySquared = Settings.DEFAULT_RESTITUTION_VELOCITY * Settings.DEFAULT_RESTITUTION_VELOCITY;
                    this.linearTolerance = Settings.DEFAULT_LINEAR_TOLERANCE;
                    this.linearToleranceSquared = Settings.DEFAULT_LINEAR_TOLERANCE * Settings.DEFAULT_LINEAR_TOLERANCE;
                    this.angularTolerance = Settings.DEFAULT_ANGULAR_TOLERANCE_$LI$();
                    this.angularToleranceSquared = Settings.DEFAULT_ANGULAR_TOLERANCE_$LI$() * Settings.DEFAULT_ANGULAR_TOLERANCE_$LI$();
                    this.maximumLinearCorrection = Settings.DEFAULT_MAXIMUM_LINEAR_CORRECTION;
                    this.maximumLinearCorrectionSquared = Settings.DEFAULT_MAXIMUM_LINEAR_CORRECTION * Settings.DEFAULT_MAXIMUM_LINEAR_CORRECTION;
                    this.maximumAngularCorrection = Settings.DEFAULT_MAXIMUM_ANGULAR_CORRECTION_$LI$();
                    this.maximumAngularCorrectionSquared = Settings.DEFAULT_MAXIMUM_ANGULAR_CORRECTION_$LI$() * Settings.DEFAULT_MAXIMUM_ANGULAR_CORRECTION_$LI$();
                    this.baumgarte = Settings.DEFAULT_BAUMGARTE;
                    this.continuousDetectionMode = org.dyn4j.dynamics.ContinuousDetectionMode.ALL;
                }
                static DEFAULT_MAXIMUM_ROTATION_$LI$() { if (Settings.DEFAULT_MAXIMUM_ROTATION == null) {
                    Settings.DEFAULT_MAXIMUM_ROTATION = 0.5 * Math.PI;
                } return Settings.DEFAULT_MAXIMUM_ROTATION; }
                static DEFAULT_SLEEP_ANGULAR_VELOCITY_$LI$() { if (Settings.DEFAULT_SLEEP_ANGULAR_VELOCITY == null) {
                    Settings.DEFAULT_SLEEP_ANGULAR_VELOCITY = /* toRadians */ (x => x * Math.PI / 180)(2.0);
                } return Settings.DEFAULT_SLEEP_ANGULAR_VELOCITY; }
                static DEFAULT_ANGULAR_TOLERANCE_$LI$() { if (Settings.DEFAULT_ANGULAR_TOLERANCE == null) {
                    Settings.DEFAULT_ANGULAR_TOLERANCE = /* toRadians */ (x => x * Math.PI / 180)(2.0);
                } return Settings.DEFAULT_ANGULAR_TOLERANCE; }
                static DEFAULT_MAXIMUM_ANGULAR_CORRECTION_$LI$() { if (Settings.DEFAULT_MAXIMUM_ANGULAR_CORRECTION == null) {
                    Settings.DEFAULT_MAXIMUM_ANGULAR_CORRECTION = /* toRadians */ (x => x * Math.PI / 180)(8.0);
                } return Settings.DEFAULT_MAXIMUM_ANGULAR_CORRECTION; }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Settings[StepFrequency=").append(this.stepFrequency).append("|MaximumTranslation=").append(this.maximumTranslation).append("|MaximumRotation=").append(this.maximumRotation).append("|AutoSleepingEnabled=").append(this.autoSleepingEnabled).append("|SleepLinearVelocity=").append(this.sleepLinearVelocity).append("|SleepAngularVelocity=").append(this.sleepAngularVelocity).append("|SleepTime=").append(this.sleepTime).append("|VelocityConstraintSolverIterations=").append(this.velocityConstraintSolverIterations).append("|PositionConstraintSolverIterations=").append(this.positionConstraintSolverIterations).append("|WarmStartDistance=").append(this.warmStartDistance).append("|RestitutionVelocity=").append(this.restitutionVelocity).append("|LinearTolerance=").append(this.linearTolerance).append("|AngularTolerance=").append(this.angularTolerance).append("|MaximumLinearCorrection=").append(this.maximumLinearCorrection).append("|MaximumAngularCorrection=").append(this.maximumAngularCorrection).append("|Baumgarte=").append(this.baumgarte).append("|ContinuousDetectionMode=").append(this.continuousDetectionMode).append("]");
                    return sb.toString();
                }
                /**
                 * Resets the settings back to defaults.
                 */
                reset() {
                    this.stepFrequency = Settings.DEFAULT_STEP_FREQUENCY;
                    this.maximumTranslation = Settings.DEFAULT_MAXIMUM_TRANSLATION;
                    this.maximumTranslationSquared = Settings.DEFAULT_MAXIMUM_TRANSLATION * Settings.DEFAULT_MAXIMUM_TRANSLATION;
                    this.maximumRotation = Settings.DEFAULT_MAXIMUM_ROTATION_$LI$();
                    this.maximumRotationSquared = Settings.DEFAULT_MAXIMUM_ROTATION_$LI$() * Settings.DEFAULT_MAXIMUM_ROTATION_$LI$();
                    this.autoSleepingEnabled = true;
                    this.sleepLinearVelocity = Settings.DEFAULT_SLEEP_LINEAR_VELOCITY;
                    this.sleepLinearVelocitySquared = Settings.DEFAULT_SLEEP_LINEAR_VELOCITY * Settings.DEFAULT_SLEEP_LINEAR_VELOCITY;
                    this.sleepAngularVelocity = Settings.DEFAULT_SLEEP_ANGULAR_VELOCITY_$LI$();
                    this.sleepAngularVelocitySquared = Settings.DEFAULT_SLEEP_ANGULAR_VELOCITY_$LI$() * Settings.DEFAULT_SLEEP_ANGULAR_VELOCITY_$LI$();
                    this.sleepTime = Settings.DEFAULT_SLEEP_TIME;
                    this.velocityConstraintSolverIterations = Settings.DEFAULT_SOLVER_ITERATIONS;
                    this.positionConstraintSolverIterations = Settings.DEFAULT_SOLVER_ITERATIONS;
                    this.warmStartDistance = Settings.DEFAULT_WARM_START_DISTANCE;
                    this.warmStartDistanceSquared = Settings.DEFAULT_WARM_START_DISTANCE * Settings.DEFAULT_WARM_START_DISTANCE;
                    this.restitutionVelocity = Settings.DEFAULT_RESTITUTION_VELOCITY;
                    this.restitutionVelocitySquared = Settings.DEFAULT_RESTITUTION_VELOCITY * Settings.DEFAULT_RESTITUTION_VELOCITY;
                    this.linearTolerance = Settings.DEFAULT_LINEAR_TOLERANCE;
                    this.linearToleranceSquared = Settings.DEFAULT_LINEAR_TOLERANCE * Settings.DEFAULT_LINEAR_TOLERANCE;
                    this.maximumLinearCorrection = Settings.DEFAULT_MAXIMUM_LINEAR_CORRECTION;
                    this.maximumLinearCorrectionSquared = Settings.DEFAULT_MAXIMUM_LINEAR_CORRECTION * Settings.DEFAULT_MAXIMUM_LINEAR_CORRECTION;
                    this.angularTolerance = Settings.DEFAULT_ANGULAR_TOLERANCE_$LI$();
                    this.angularToleranceSquared = Settings.DEFAULT_ANGULAR_TOLERANCE_$LI$() * Settings.DEFAULT_ANGULAR_TOLERANCE_$LI$();
                    this.baumgarte = Settings.DEFAULT_BAUMGARTE;
                    this.continuousDetectionMode = org.dyn4j.dynamics.ContinuousDetectionMode.ALL;
                }
                /**
                 * Returns the step frequency of the dynamics engine in seconds.
                 * <p>
                 * @return {number} double the step frequency
                 * @see #setStepFrequency(double)
                 */
                getStepFrequency() {
                    return this.stepFrequency;
                }
                /**
                 * Sets the step frequency of the dynamics engine.  This value determines how often to
                 * update the dynamics engine in seconds (every 1/60th of a second for example).
                 * <p>
                 * Valid values are in the range (0, &infin;] seconds.
                 * <p>
                 * Versions before 3.1.1 would convert the stepFrequency parameter from seconds<sup>-1</sup> to
                 * seconds (60 to 1/60 for example) automatically.  This automatic conversion has been removed
                 * in versions 3.1.1 and higher.  Instead pass in the value in seconds (1/60 for example).
                 * @param {number} stepFrequency the step frequency
                 * @throws IllegalArgumentException if stepFrequency is less than or equal to zero
                 */
                setStepFrequency(stepFrequency) {
                    if (stepFrequency <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidStepFrequency"));
                    this.stepFrequency = stepFrequency;
                }
                /**
                 * Returns the maximum translation a {@link Body} can have in one time step.
                 * @return {number} double the maximum translation in meters
                 * @see #setMaximumTranslation(double)
                 */
                getMaximumTranslation() {
                    return this.maximumTranslation;
                }
                /**
                 * Returns the maximum translation squared.
                 * @see #getMaximumTranslation()
                 * @see #setMaximumTranslation(double)
                 * @return {number} double
                 */
                getMaximumTranslationSquared() {
                    return this.maximumTranslationSquared;
                }
                /**
                 * Sets the maximum translation a {@link Body} can have in one time step.
                 * <p>
                 * Valid values are in the range [0, &infin;] meters
                 * @param {number} maximumTranslation the maximum translation
                 * @throws IllegalArgumentException if maxTranslation is less than zero
                 */
                setMaximumTranslation(maximumTranslation) {
                    if (maximumTranslation < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidMaximumTranslation"));
                    this.maximumTranslation = maximumTranslation;
                    this.maximumTranslationSquared = maximumTranslation * maximumTranslation;
                }
                /**
                 * Returns the maximum rotation a {@link Body} can have in one time step.
                 * @return {number} double the maximum rotation in radians
                 * @see #setMaximumRotation(double)
                 */
                getMaximumRotation() {
                    return this.maximumRotation;
                }
                /**
                 * Returns the max rotation squared.
                 * @see #getMaximumRotation()
                 * @see #setMaximumRotation(double)
                 * @return {number} double
                 */
                getMaximumRotationSquared() {
                    return this.maximumRotationSquared;
                }
                /**
                 * Sets the maximum rotation a {@link Body} can have in one time step.
                 * <p>
                 * Valid values are in the range [0, &infin;] radians
                 * @param {number} maximumRotation the maximum rotation
                 * @throws IllegalArgumentException if maxRotation is less than zero
                 */
                setMaximumRotation(maximumRotation) {
                    if (maximumRotation < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidMaximumRotation"));
                    this.maximumRotation = maximumRotation;
                    this.maximumRotationSquared = maximumRotation * maximumRotation;
                }
                /**
                 * Returns true if the engine automatically puts {@link Body}s to sleep.
                 * @return {boolean} boolean
                 */
                isAutoSleepingEnabled() {
                    return this.autoSleepingEnabled;
                }
                /**
                 * Sets whether the engine automatically puts {@link Body}s to sleep.
                 * @param {boolean} flag true if {@link Body}s should be put to sleep automatically
                 */
                setAutoSleepingEnabled(flag) {
                    this.autoSleepingEnabled = flag;
                }
                /**
                 * Returns the sleep linear velocity.
                 * @return {number} double the sleep velocity.
                 * @see #setSleepLinearVelocity(double)
                 */
                getSleepLinearVelocity() {
                    return this.sleepLinearVelocity;
                }
                /**
                 * Returns the sleep linear velocity squared.
                 * @see #getSleepLinearVelocity()
                 * @see #setSleepLinearVelocity(double)
                 * @return {number} double
                 */
                getSleepLinearVelocitySquared() {
                    return this.sleepLinearVelocitySquared;
                }
                /**
                 * Sets the sleep linear velocity.
                 * <p>
                 * The sleep linear velocity is the maximum velocity a {@link Body} can have
                 * to be put to sleep.
                 * <p>
                 * Valid values are in the range [0, &infin;] meters/second
                 * @param {number} sleepLinearVelocity the sleep linear velocity
                 * @throws IllegalArgumentException if sleepLinearVelocity is less than zero
                 */
                setSleepLinearVelocity(sleepLinearVelocity) {
                    if (sleepLinearVelocity < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidSleepLinearVelocity"));
                    this.sleepLinearVelocity = sleepLinearVelocity;
                    this.sleepLinearVelocitySquared = sleepLinearVelocity * sleepLinearVelocity;
                }
                /**
                 * Returns the sleep angular velocity.
                 * @return {number} double the sleep angular velocity.
                 * @see #setSleepAngularVelocity(double)
                 */
                getSleepAngularVelocity() {
                    return this.sleepAngularVelocity;
                }
                /**
                 * Returns the sleep angular velocity squared.
                 * @see #getSleepAngularVelocity()
                 * @see #setSleepAngularVelocity(double)
                 * @return {number} double
                 */
                getSleepAngularVelocitySquared() {
                    return this.sleepAngularVelocitySquared;
                }
                /**
                 * Sets the sleep angular velocity.
                 * <p>
                 * The sleep angular velocity is the maximum angular velocity a {@link Body} can have
                 * to be put to sleep.
                 * <p>
                 * Valid values are in the range [0, &infin;] radians/second
                 * @param {number} sleepAngularVelocity the sleep angular velocity
                 * @throws IllegalArgumentException if sleepAngularVelocity is less than zero
                 */
                setSleepAngularVelocity(sleepAngularVelocity) {
                    if (sleepAngularVelocity < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidSleepAngularVelocity"));
                    this.sleepAngularVelocity = sleepAngularVelocity;
                    this.sleepAngularVelocitySquared = sleepAngularVelocity * sleepAngularVelocity;
                }
                /**
                 * Returns the sleep time.
                 * @return {number} double the sleep time
                 * @see #setSleepTime(double)
                 */
                getSleepTime() {
                    return this.sleepTime;
                }
                /**
                 * Sets the sleep time.
                 * <p>
                 * The sleep time is the amount of time a body must be motionless
                 * before being put to sleep.
                 * <p>
                 * Valid values are in the range [0, &infin;] seconds
                 * @param {number} sleepTime the sleep time
                 * @throws IllegalArgumentException if sleepTime is less than zero
                 */
                setSleepTime(sleepTime) {
                    if (sleepTime < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidSleepTime"));
                    this.sleepTime = sleepTime;
                }
                /**
                 * Returns the number of iterations used to solve velocity constraints.
                 * @return {number} int
                 */
                getVelocityConstraintSolverIterations() {
                    return this.velocityConstraintSolverIterations;
                }
                /**
                 * Sets the number of iterations used to solve velocity constraints.
                 * <p>
                 * Increasing the number will increase accuracy but decrease performance.
                 * <p>
                 * Valid values are in the range [1, &infin;]
                 * @param {number} velocityConstraintSolverIterations the number of iterations used to solve velocity constraints
                 * @throws IllegalArgumentException if velocityConstraintSolverIterations is less than 5
                 */
                setVelocityConstraintSolverIterations(velocityConstraintSolverIterations) {
                    if (velocityConstraintSolverIterations < 1)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidVelocityIterations"));
                    this.velocityConstraintSolverIterations = velocityConstraintSolverIterations;
                }
                /**
                 * Returns the number of iterations used to solve position constraints.
                 * @return {number} int
                 */
                getPositionConstraintSolverIterations() {
                    return this.positionConstraintSolverIterations;
                }
                /**
                 * Sets the number of iterations used to solve position constraints.
                 * <p>
                 * Increasing the number will increase accuracy but decrease performance.
                 * <p>
                 * Valid values are in the range [1, &infin;]
                 * @param {number} positionConstraintSolverIterations the number of iterations used to solve position constraints
                 * @throws IllegalArgumentException if positionConstraintSolverIterations is less than 5
                 */
                setPositionConstraintSolverIterations(positionConstraintSolverIterations) {
                    if (positionConstraintSolverIterations < 1)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidPositionIterations"));
                    this.positionConstraintSolverIterations = positionConstraintSolverIterations;
                }
                /**
                 * Returns the warm start distance.
                 * @return {number} double the warm start distance
                 * @see #setWarmStartDistance(double)
                 */
                getWarmStartDistance() {
                    return this.warmStartDistance;
                }
                /**
                 * Returns the warm start distance squared.
                 * @see #getWarmStartDistance()
                 * @see #setWarmStartDistance(double)
                 * @return {number} double
                 */
                getWarmStartDistanceSquared() {
                    return this.warmStartDistanceSquared;
                }
                /**
                 * Sets the warm start distance.
                 * <p>
                 * The maximum distance from one point to another to consider the points to be the
                 * same.  This distance is used to determine if the points can carry over another
                 * point's accumulated impulses to be used for warm starting the constraint solver.
                 * <p>
                 * Valid values are in the range [0, &infin;] meters
                 * @param {number} warmStartDistance the warm start distance
                 * @throws IllegalArgumentException if warmStartDistance is less than zero
                 */
                setWarmStartDistance(warmStartDistance) {
                    if (warmStartDistance < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidWarmStartDistance"));
                    this.warmStartDistance = warmStartDistance;
                    this.warmStartDistanceSquared = this.warmStartDistance * this.warmStartDistance;
                }
                /**
                 * Returns the restitution velocity.
                 * @return {number} double the restitution velocity
                 * @see #setRestitutionVelocity(double)
                 */
                getRestitutionVelocity() {
                    return this.restitutionVelocity;
                }
                /**
                 * Returns the restitution velocity squared.
                 * @see #getRestitutionVelocity()
                 * @see #setRestitutionVelocity(double)
                 * @return {number} double
                 */
                getRestitutionVelocitySquared() {
                    return this.restitutionVelocitySquared;
                }
                /**
                 * Sets the restitution velocity.
                 * <p>
                 * The relative velocity in the direction of the contact normal which determines
                 * whether to handle the collision as an inelastic or elastic collision.
                 * <p>
                 * Valid values are in the range [0, &infin;] meters/second
                 * @param {number} restitutionVelocity the restitution velocity
                 * @throws IllegalArgumentException if restitutionVelocity is less than zero
                 */
                setRestitutionVelocity(restitutionVelocity) {
                    if (restitutionVelocity < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidRestitutionVelocity"));
                    this.restitutionVelocity = restitutionVelocity;
                    this.restitutionVelocitySquared = restitutionVelocity * restitutionVelocity;
                }
                /**
                 * Returns the linear tolerance.
                 * @return {number} double the allowed penetration
                 * @see #setLinearTolerance(double)
                 */
                getLinearTolerance() {
                    return this.linearTolerance;
                }
                /**
                 * Returns the linear tolerance squared.
                 * @see #getLinearTolerance()
                 * @see #setLinearTolerance(double)
                 * @return {number} double
                 */
                getLinearToleranceSquared() {
                    return this.linearToleranceSquared;
                }
                /**
                 * Sets the linear tolerance.
                 * <p>
                 * Used to avoid jitter and facilitate stacking.
                 * <p>
                 * Valid values are in the range (0, &infin;] meters
                 * @param {number} linearTolerance the linear tolerance
                 * @throws IllegalArgumentException if linearTolerance is less than zero
                 */
                setLinearTolerance(linearTolerance) {
                    if (linearTolerance < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidLinearTolerance"));
                    this.linearTolerance = linearTolerance;
                    this.linearToleranceSquared = linearTolerance * linearTolerance;
                }
                /**
                 * Returns the angular tolerance.
                 * @see #setAngularTolerance(double)
                 * @return {number} double
                 */
                getAngularTolerance() {
                    return this.angularTolerance;
                }
                /**
                 * Returns the angular tolerance squared.
                 * @see #getAngularTolerance()
                 * @see #setAngularTolerance(double)
                 * @return {number} double
                 */
                getAngularToleranceSquared() {
                    return this.angularToleranceSquared;
                }
                /**
                 * Sets the angular tolerance.
                 * <p>
                 * Used to avoid jitter and facilitate stacking.
                 * <p>
                 * Valid values are in the range (0, &infin;] radians
                 * @param {number} angularTolerance the angular tolerance
                 * @throws IllegalArgumentException if angularTolerance is less than zero
                 */
                setAngularTolerance(angularTolerance) {
                    if (angularTolerance < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidAngularTolerance"));
                    this.angularTolerance = angularTolerance;
                    this.angularToleranceSquared = angularTolerance * angularTolerance;
                }
                /**
                 * Returns the maximum linear correction.
                 * @return {number} double the maximum linear correction
                 * @see #setMaximumLinearCorrection(double)
                 */
                getMaximumLinearCorrection() {
                    return this.maximumLinearCorrection;
                }
                /**
                 * Returns the maximum linear correction squared.
                 * @see #getMaximumLinearCorrection()
                 * @see #setMaximumLinearCorrection(double)
                 * @return {number} double
                 */
                getMaximumLinearCorrectionSquared() {
                    return this.maximumLinearCorrectionSquared;
                }
                /**
                 * Sets the maximum linear correction.
                 * <p>
                 * The maximum linear correction used when estimating the current penetration depth
                 * during the position constraint solving step.
                 * <p>
                 * This is used to avoid large corrections.
                 * <p>
                 * Valid values are in the range (0, &infin;] meters
                 * @param {number} maximumLinearCorrection the maximum linear correction
                 * @throws IllegalArgumentException if maxLinearCorrection is less than zero
                 */
                setMaximumLinearCorrection(maximumLinearCorrection) {
                    if (maximumLinearCorrection < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidMaximumLinearCorrection"));
                    this.maximumLinearCorrection = maximumLinearCorrection;
                    this.maximumLinearCorrectionSquared = maximumLinearCorrection * maximumLinearCorrection;
                }
                /**
                 * Returns the maximum angular correction.
                 * @see #setMaximumAngularCorrection(double)
                 * @return {number} double
                 */
                getMaximumAngularCorrection() {
                    return this.maximumAngularCorrection;
                }
                /**
                 * Returns the maximum angular correction squared.
                 * @see #getMaximumAngularCorrection()
                 * @see #setMaximumAngularCorrection(double)
                 * @return {number} double
                 */
                getMaximumAngularCorrectionSquared() {
                    return this.maximumAngularCorrectionSquared;
                }
                /**
                 * Sets the maximum angular correction.
                 * <p>
                 * This is used to prevent large angular corrections.
                 * <p>
                 * Valid values are in the range [0, &infin;] radians
                 * @param {number} maximumAngularCorrection the maximum angular correction
                 * @throws IllegalArgumentException if maxAngularCorrection is less than zero
                 */
                setMaximumAngularCorrection(maximumAngularCorrection) {
                    if (maximumAngularCorrection < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidMaximumAngularCorrection"));
                    this.maximumAngularCorrection = maximumAngularCorrection;
                    this.maximumAngularCorrectionSquared = maximumAngularCorrection * maximumAngularCorrection;
                }
                /**
                 * Returns the baumgarte factor.
                 * @return {number} double baumgarte
                 * @see #setBaumgarte(double)
                 */
                getBaumgarte() {
                    return this.baumgarte;
                }
                /**
                 * Sets the baumgarte factor.
                 * <p>
                 * The position correction bias factor that determines the rate at which the position constraints are solved.
                 * <p>
                 * Valid values are in the range [0, &infin;].
                 * @param {number} baumgarte the baumgarte factor
                 * @throws IllegalArgumentException if baumgarte is less than zero
                 */
                setBaumgarte(baumgarte) {
                    if (baumgarte < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidBaumgarte"));
                    this.baumgarte = baumgarte;
                }
                /**
                 * Returns the continuous collision detection mode.
                 * @return {org.dyn4j.dynamics.ContinuousDetectionMode} {@link ContinuousDetectionMode}
                 * @since 2.2.3
                 */
                getContinuousDetectionMode() {
                    return this.continuousDetectionMode;
                }
                /**
                 * Sets the continuous collision detection mode.
                 * @param {org.dyn4j.dynamics.ContinuousDetectionMode} mode the CCD mode
                 * @throws NullPointerException if mode is null
                 * @since 2.2.3
                 */
                setContinuousDetectionMode(mode) {
                    if (mode == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.settings.invalidCCDMode"));
                    this.continuousDetectionMode = mode;
                }
                static invalidParticleIndex_$LI$() { if (Settings.invalidParticleIndex == null) {
                    Settings.invalidParticleIndex = (-1);
                } return Settings.invalidParticleIndex; }
                static maxTriadDistanceSquared_$LI$() { if (Settings.maxTriadDistanceSquared == null) {
                    Settings.maxTriadDistanceSquared = (Settings.maxTriadDistance * Settings.maxTriadDistance);
                } return Settings.maxTriadDistanceSquared; }
                static angularSlop_$LI$() { if (Settings.angularSlop == null) {
                    Settings.angularSlop = Math.fround((Math.fround(2.0 / 180.0) * Math.PI));
                } return Settings.angularSlop; }
            }
            /**
             * The default step frequency of the dynamics engine; in seconds
             */
            Settings.DEFAULT_STEP_FREQUENCY = 1.0 / 60.0;
            /**
             * The default maximum translation a {@link Body} can have in one time step; in meters
             */
            Settings.DEFAULT_MAXIMUM_TRANSLATION = 2.0;
            /**
             * The default maximum velocity for a {@link Body} to go to sleep; in meters/second
             */
            Settings.DEFAULT_SLEEP_LINEAR_VELOCITY = 0.01;
            /**
             * The default required time a {@link Body} must maintain small motion so that its put to sleep; in seconds
             */
            Settings.DEFAULT_SLEEP_TIME = 0.5;
            /**
             * The default number of solver iterations
             */
            Settings.DEFAULT_SOLVER_ITERATIONS = 10;
            /**
             * The default warm starting distance; in meters<sup>2</sup>
             */
            Settings.DEFAULT_WARM_START_DISTANCE = 0.01;
            /**
             * The default restitution velocity; in meters/second
             */
            Settings.DEFAULT_RESTITUTION_VELOCITY = 1.0;
            /**
             * The default linear tolerance; in meters
             */
            Settings.DEFAULT_LINEAR_TOLERANCE = 0.005;
            /**
             * The default maximum linear correction; in meters
             */
            Settings.DEFAULT_MAXIMUM_LINEAR_CORRECTION = 0.2;
            /**
             * The default baumgarte
             */
            Settings.DEFAULT_BAUMGARTE = 0.2;
            /**
             * The standard distance between particles, divided by the particle radius.
             */
            Settings.particleStride = 0.75;
            /**
             * The minimum particle weight that produces pressure.
             */
            Settings.minParticleWeight = 1.0;
            /**
             * The upper limit for particle pressure.
             */
            Settings.b2_maxParticlePressure = 0.25;
            /**
             * The upper limit for force between particles.
             */
            Settings.b2_maxParticleForce = 0.5;
            /**
             * The maximum distance between particles in a triad, divided by the particle radius.
             */
            Settings.maxTriadDistance = 2;
            /**
             * The initial size of particle data buffers.
             */
            Settings.minParticleBufferCapacity = 256;
            /**
             * A small length used as a collision and constraint tolerance. Usually it is chosen to be
             * numerically significant, but visually insignificant.
             */
            Settings.linearSlop = 0.005;
            /**
             * The time into the future that collisions against barrier particles will be detected.
             */
            Settings.b2_barrierCollisionTime = 2.5;
            dynamics.Settings = Settings;
            Settings["__class"] = "org.dyn4j.dynamics.Settings";
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Default implementation of the {@link ConvexCastListener} interface.
             * <p>
             * Inherit from this class to only implement the desired methods.
             * <p>
             * By default all methods return true.
             * @author William Bittle
             * @version 3.2.0
             * @since 3.1.5
             * @class
             */
            class ConvexCastAdapter {
                allow$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(convex, body, fixture) {
                    return true;
                }
                allow$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_continuous_TimeOfImpact(convex, body, fixture, toi) {
                    return true;
                }
                /**
                 *
                 * @param {*} convex
                 * @param {org.dyn4j.dynamics.Body} body
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture
                 * @param {org.dyn4j.collision.continuous.TimeOfImpact} toi
                 * @return {boolean}
                 */
                allow(convex, body, fixture, toi) {
                    if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null) && ((toi != null && toi instanceof org.dyn4j.collision.continuous.TimeOfImpact) || toi === null)) {
                        return this.allow$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_continuous_TimeOfImpact(convex, body, fixture, toi);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null) && toi === undefined) {
                        return this.allow$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(convex, body, fixture);
                    }
                    else
                        throw new Error('invalid overload');
                }
                constructor() {
                }
            }
            dynamics.ConvexCastAdapter = ConvexCastAdapter;
            ConvexCastAdapter["__class"] = "org.dyn4j.dynamics.ConvexCastAdapter";
            ConvexCastAdapter["__interfaces"] = ["org.dyn4j.dynamics.ConvexCastListener", "org.dyn4j.Listener"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            let CoefficientMixer;
            (function (CoefficientMixer) {
                function DEFAULT_MIXER_$LI$() { if (CoefficientMixer.DEFAULT_MIXER == null) {
                    CoefficientMixer.DEFAULT_MIXER = new CoefficientMixer.CoefficientMixer$0(this);
                } return CoefficientMixer.DEFAULT_MIXER; }
                CoefficientMixer.DEFAULT_MIXER_$LI$ = DEFAULT_MIXER_$LI$;
                ;
            })(CoefficientMixer = dynamics.CoefficientMixer || (dynamics.CoefficientMixer = {}));
            (function (CoefficientMixer) {
                class CoefficientMixer$0 {
                    constructor(__parent) {
                        this.__parent = __parent;
                    }
                    /**
                     *
                     * @param {number} friction1
                     * @param {number} friction2
                     * @return {number}
                     */
                    mixFriction(friction1, friction2) {
                        return Math.sqrt(friction1 * friction2);
                    }
                    /**
                     *
                     * @param {number} restitution1
                     * @param {number} restitution2
                     * @return {number}
                     */
                    mixRestitution(restitution1, restitution2) {
                        return Math.min(restitution1, restitution2);
                    }
                }
                CoefficientMixer.CoefficientMixer$0 = CoefficientMixer$0;
                CoefficientMixer$0["__interfaces"] = ["org.dyn4j.dynamics.CoefficientMixer"];
            })(CoefficientMixer = dynamics.CoefficientMixer || (dynamics.CoefficientMixer = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Convenience class for implementing the {@link DestructionListener} interface.
             * <p>
             * This class can be used to implement only the methods desired instead of all
             * the methods contained in the {@link DestructionListener} interface.
             * @author William Bittle
             * @version 3.1.0
             * @since 1.0.0
             * @class
             */
            class DestructionAdapter {
                destroyed$org_dyn4j_dynamics_contact_ContactPoint(contactPoint) {
                }
                /**
                 *
                 * @param {org.dyn4j.dynamics.contact.ContactPoint} contactPoint
                 */
                destroyed(contactPoint) {
                    if (((contactPoint != null && contactPoint instanceof org.dyn4j.dynamics.contact.ContactPoint) || contactPoint === null)) {
                        return this.destroyed$org_dyn4j_dynamics_contact_ContactPoint(contactPoint);
                    }
                    else if (((contactPoint != null && contactPoint instanceof org.dyn4j.dynamics.joint.Joint) || contactPoint === null)) {
                        return this.destroyed$org_dyn4j_dynamics_joint_Joint(contactPoint);
                    }
                    else if (((contactPoint != null && contactPoint instanceof org.dyn4j.dynamics.Body) || contactPoint === null)) {
                        return this.destroyed$org_dyn4j_dynamics_Body(contactPoint);
                    }
                    else
                        throw new Error('invalid overload');
                }
                destroyed$org_dyn4j_dynamics_joint_Joint(joint) {
                }
                destroyed$org_dyn4j_dynamics_Body(body) {
                }
                constructor() {
                }
            }
            dynamics.DestructionAdapter = DestructionAdapter;
            DestructionAdapter["__class"] = "org.dyn4j.dynamics.DestructionAdapter";
            DestructionAdapter["__interfaces"] = ["org.dyn4j.dynamics.DestructionListener", "org.dyn4j.Listener"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Convenience class for implementing the {@link StepListener} interface.
             * @author William Bittle
             * @version 3.1.0
             * @since 1.0.0
             * @class
             */
            class StepAdapter {
                /**
                 *
                 * @param {org.dyn4j.dynamics.Step} step
                 * @param {org.dyn4j.dynamics.World} world
                 */
                begin(step, world) {
                }
                /**
                 *
                 * @param {org.dyn4j.dynamics.Step} step
                 * @param {org.dyn4j.dynamics.World} world
                 */
                updatePerformed(step, world) {
                }
                /**
                 *
                 * @param {org.dyn4j.dynamics.Step} step
                 * @param {org.dyn4j.dynamics.World} world
                 */
                postSolve(step, world) {
                }
                /**
                 *
                 * @param {org.dyn4j.dynamics.Step} step
                 * @param {org.dyn4j.dynamics.World} world
                 */
                end(step, world) {
                }
                constructor() {
                }
            }
            dynamics.StepAdapter = StepAdapter;
            StepAdapter["__class"] = "org.dyn4j.dynamics.StepAdapter";
            StepAdapter["__interfaces"] = ["org.dyn4j.dynamics.StepListener", "org.dyn4j.Listener"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        /**
         * Full constructor.
         * @param {*} comparable the comparable object
         * @param {org.dyn4j.BinarySearchTreeNode} parent the parent node
         * @param {org.dyn4j.BinarySearchTreeNode} left the left node
         * @param {org.dyn4j.BinarySearchTreeNode} right the right node
         * @throws NullPointerException if comparable is null
         * @class
         * @author William Bittle
         */
        class BinarySearchTreeNode {
            constructor(comparable, parent, left, right) {
                if (((comparable != null) || comparable === null) && ((parent != null && parent instanceof org.dyn4j.BinarySearchTreeNode) || parent === null) && ((left != null && left instanceof org.dyn4j.BinarySearchTreeNode) || left === null) && ((right != null && right instanceof org.dyn4j.BinarySearchTreeNode) || right === null)) {
                    let __args = arguments;
                    if (this.comparable === undefined) {
                        this.comparable = null;
                    }
                    if (this.parent === undefined) {
                        this.parent = null;
                    }
                    if (this.left === undefined) {
                        this.left = null;
                    }
                    if (this.right === undefined) {
                        this.right = null;
                    }
                    if (comparable == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("binarySearchTree.nullComparable"));
                    this.comparable = comparable;
                    this.parent = parent;
                    this.left = left;
                    this.right = right;
                }
                else if (((comparable != null) || comparable === null) && parent === undefined && left === undefined && right === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let parent = null;
                        let left = null;
                        let right = null;
                        if (this.comparable === undefined) {
                            this.comparable = null;
                        }
                        if (this.parent === undefined) {
                            this.parent = null;
                        }
                        if (this.left === undefined) {
                            this.left = null;
                        }
                        if (this.right === undefined) {
                            this.right = null;
                        }
                        if (comparable == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("binarySearchTree.nullComparable"));
                        this.comparable = comparable;
                        this.parent = parent;
                        this.left = left;
                        this.right = right;
                    }
                    if (this.comparable === undefined) {
                        this.comparable = null;
                    }
                    if (this.parent === undefined) {
                        this.parent = null;
                    }
                    if (this.left === undefined) {
                        this.left = null;
                    }
                    if (this.right === undefined) {
                        this.right = null;
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.comparable.toString();
            }
            /**
             *
             * @param {org.dyn4j.BinarySearchTreeNode} other
             * @return {number}
             */
            compareTo(other) {
                return this.comparable.compareTo(other.comparable);
            }
            /**
             * Returns the comparable object.
             * @return {*} E
             */
            getComparable() {
                return this.comparable;
            }
            /**
             * Returns true if this node is the left child of
             * its parent node.
             * <p>
             * Returns false if this node does not have a parent.
             * @return {boolean} boolean
             */
            isLeftChild() {
                if (this.parent == null)
                    return false;
                return (this.parent.left === this);
            }
        }
        dyn4j.BinarySearchTreeNode = BinarySearchTreeNode;
        BinarySearchTreeNode["__class"] = "org.dyn4j.BinarySearchTreeNode";
        BinarySearchTreeNode["__interfaces"] = ["java.lang.Comparable"];
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var resources;
        (function (resources) {
            /**
             * Helper class that returns messages from the property file.
             * <p>
             * Primarily used for exception messages.
             * @author William Bittle
             * @version 3.0.2
             * @since 3.0.2
             * @class
             */
            class Messages {
                constructor() {
                }
                /**
                 * Returns the value for the specified key.
                 * @param {string} key the key
                 * @return {string} String
                 */
                static getString(key) {
                    return key;
                }
            }
            resources.Messages = Messages;
            Messages["__class"] = "org.dyn4j.resources.Messages";
        })(resources = dyn4j.resources || (dyn4j.resources = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        /**
         * Class used to convert units.
         * <p>
         * dyn4j uses meters-kilograms-seconds (MKS) units by default.  This class can be used
         * to convert to and from MKS.
         * @author William Bittle
         * @version 3.2.0
         * @since 1.0.0
         * @class
         */
        class UnitConversion {
            constructor() {
            }
            static METER_TO_FOOT_$LI$() { if (UnitConversion.METER_TO_FOOT == null) {
                UnitConversion.METER_TO_FOOT = 1.0 / UnitConversion.FOOT_TO_METER;
            } return UnitConversion.METER_TO_FOOT; }
            static KILOGRAM_TO_SLUG_$LI$() { if (UnitConversion.KILOGRAM_TO_SLUG == null) {
                UnitConversion.KILOGRAM_TO_SLUG = 1.0 / UnitConversion.SLUG_TO_KILOGRAM;
            } return UnitConversion.KILOGRAM_TO_SLUG; }
            static KILOGRAM_TO_POUND_$LI$() { if (UnitConversion.KILOGRAM_TO_POUND == null) {
                UnitConversion.KILOGRAM_TO_POUND = 1.0 / UnitConversion.POUND_TO_KILOGRAM;
            } return UnitConversion.KILOGRAM_TO_POUND; }
            static NEWTON_TO_POUND_$LI$() { if (UnitConversion.NEWTON_TO_POUND == null) {
                UnitConversion.NEWTON_TO_POUND = 1.0 / UnitConversion.POUND_TO_NEWTON;
            } return UnitConversion.NEWTON_TO_POUND; }
            static NEWTON_METER_TO_FOOT_POUND_$LI$() { if (UnitConversion.NEWTON_METER_TO_FOOT_POUND == null) {
                UnitConversion.NEWTON_METER_TO_FOOT_POUND = 1.0 / UnitConversion.FOOT_POUND_TO_NEWTON_METER;
            } return UnitConversion.NEWTON_METER_TO_FOOT_POUND; }
            /**
             * Converts feet to meters.
             * @param {number} feet the length value in feet
             * @return {number} double the length value in meters
             */
            static feetToMeters(feet) {
                return feet * UnitConversion.FOOT_TO_METER;
            }
            /**
             * Converts slugs to kilograms.
             * @param {number} slugs the mass value in slugs
             * @return {number} double the mass value in kilograms
             */
            static slugsToKilograms(slugs) {
                return slugs * UnitConversion.SLUG_TO_KILOGRAM;
            }
            /**
             * Converts pound-mass to kilograms.
             * @param {number} pound the mass value in pound-masses
             * @return {number} double the mass value in kilograms
             */
            static poundsToKilograms(pound) {
                return pound * UnitConversion.POUND_TO_KILOGRAM;
            }
            /**
             * Converts feet per second to meters per second.
             * @param {number} feetPerSecond the velocity in feet per second
             * @return {number} double the velocity in meters per second
             */
            static feetPerSecondToMetersPerSecond(feetPerSecond) {
                return feetPerSecond * UnitConversion.METER_TO_FOOT_$LI$();
            }
            /**
             * Converts pound-force to newtons.
             * @param {number} pound the force value in pound-force
             * @return {number} double the force value in newtons
             */
            static poundsToNewtons(pound) {
                return pound * UnitConversion.POUND_TO_NEWTON;
            }
            /**
             * Converts foot-pounds to newton-meters.
             * @param {number} footPound the torque value in foot-pounds
             * @return {number} double the torque value in newton-meters
             */
            static footPoundsToNewtonMeters(footPound) {
                return footPound * UnitConversion.FOOT_POUND_TO_NEWTON_METER;
            }
            /**
             * Converts meters to feet.
             * @param {number} meters the length value in meters
             * @return {number} double the length value in feet
             */
            static metersToFeet(meters) {
                return meters * UnitConversion.METER_TO_FOOT_$LI$();
            }
            /**
             * Converts kilograms to slugs.
             * @param {number} kilograms the mass value in kilograms
             * @return {number} double the mass value in slugs
             */
            static kilogramsToSlugs(kilograms) {
                return kilograms * UnitConversion.KILOGRAM_TO_SLUG_$LI$();
            }
            /**
             * Converts kilograms to pound-mass.
             * @param {number} kilograms the mass value in kilograms
             * @return {number} double the mass value in pound-masses
             */
            static kilogramsToPounds(kilograms) {
                return kilograms * UnitConversion.KILOGRAM_TO_POUND_$LI$();
            }
            /**
             * Converts meters per second to feet per second.
             * @param {number} metersPerSecond the velocity in meters per second
             * @return {number} double the velocity in feet per second
             */
            static metersPerSecondToFeetPerSecond(metersPerSecond) {
                return metersPerSecond * UnitConversion.FOOT_TO_METER;
            }
            /**
             * Converts newtons to pound-force.
             * @param {number} newtons the force value in newtons
             * @return {number} double the force value in pound-force
             */
            static newtonsToPounds(newtons) {
                return newtons * UnitConversion.NEWTON_TO_POUND_$LI$();
            }
            /**
             * Converts newton-meters to foot-pounds.
             * @param {number} newtonMeters the torque value in newton-meters
             * @return {number} double the torque value in foot-pounds
             */
            static newtonMetersToFootPounds(newtonMeters) {
                return newtonMeters * UnitConversion.NEWTON_METER_TO_FOOT_POUND_$LI$();
            }
        }
        /**
         * 1 foot = {@link #FOOT_TO_METER} meters
         */
        UnitConversion.FOOT_TO_METER = 0.0254 * 12.0;
        /**
         * 1 slug = {@link #SLUG_TO_KILOGRAM} kilograms
         */
        UnitConversion.SLUG_TO_KILOGRAM = 14.5939029;
        /**
         * 1 pound-mass = {@link #POUND_TO_KILOGRAM} kilograms
         */
        UnitConversion.POUND_TO_KILOGRAM = 0.45359237;
        /**
         * 1 pound-force = {@link #POUND_TO_NEWTON} newtons
         */
        UnitConversion.POUND_TO_NEWTON = 4.448222;
        /**
         * 1 foot-pound = {@link #FOOT_POUND_TO_NEWTON_METER} newton-meters
         */
        UnitConversion.FOOT_POUND_TO_NEWTON_METER = 0.7375621;
        dyn4j.UnitConversion = UnitConversion;
        UnitConversion["__class"] = "org.dyn4j.UnitConversion";
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        /**
         * Full constructor.
         * @param {*} initialValue the initial value
         * @class
         * @author William Bittle
         */
        class Reference {
            constructor(initialValue) {
                if (((initialValue != null) || initialValue === null)) {
                    let __args = arguments;
                    if (this.value === undefined) {
                        this.value = null;
                    }
                    this.value = initialValue;
                }
                else if (initialValue === undefined) {
                    let __args = arguments;
                    if (this.value === undefined) {
                        this.value = null;
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {string}
             */
            toString() {
                if (this.value == null)
                    return "null";
                return this.value.toString();
            }
            /**
             *
             * @param {*} obj
             * @return {boolean}
             */
            equals(obj) {
                if (obj == null)
                    return false;
                if (obj === this)
                    return true;
                if (obj != null && obj instanceof org.dyn4j.Reference) {
                    const ref = obj;
                    if (ref.value == null && this.value != null)
                        return false;
                    if (ref.value === this.value || /* equals */ ((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(ref.value, this.value)) {
                        return true;
                    }
                }
                return false;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return this.value == null ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                    return o.hashCode();
                }
                else {
                    return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                } })(this.value);
            }
        }
        dyn4j.Reference = Reference;
        Reference["__class"] = "org.dyn4j.Reference";
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        /**
         * Copy constructor.
         * <p>
         * This performs a deep copy of the elements in the tree.  The values contained
         * in the tree are shallow copied.
         * @param {org.dyn4j.BinarySearchTree} tree the tree to copy
         * @param {boolean} selfBalancing true if the tree should self balance
         * @since 3.0.0
         * @class
         * @author William Bittle
         */
        class BinarySearchTree {
            constructor(tree, selfBalancing) {
                if (((tree != null && tree instanceof org.dyn4j.BinarySearchTree) || tree === null) && ((typeof selfBalancing === 'boolean') || selfBalancing === null)) {
                    let __args = arguments;
                    if (this.root === undefined) {
                        this.root = null;
                    }
                    if (this.__size === undefined) {
                        this.__size = 0;
                    }
                    if (this.selfBalancing === undefined) {
                        this.selfBalancing = false;
                    }
                    this.selfBalancing = selfBalancing;
                    this.insertSubtree$org_dyn4j_BinarySearchTree(tree);
                }
                else if (((tree != null && tree instanceof org.dyn4j.BinarySearchTree) || tree === null) && selfBalancing === undefined) {
                    let __args = arguments;
                    if (this.root === undefined) {
                        this.root = null;
                    }
                    if (this.__size === undefined) {
                        this.__size = 0;
                    }
                    if (this.selfBalancing === undefined) {
                        this.selfBalancing = false;
                    }
                    this.selfBalancing = tree.selfBalancing;
                    this.insertSubtree$org_dyn4j_BinarySearchTree(tree);
                }
                else if (((typeof tree === 'boolean') || tree === null) && selfBalancing === undefined) {
                    let __args = arguments;
                    let selfBalancing = __args[0];
                    if (this.root === undefined) {
                        this.root = null;
                    }
                    if (this.__size === undefined) {
                        this.__size = 0;
                    }
                    if (this.selfBalancing === undefined) {
                        this.selfBalancing = false;
                    }
                    this.root = null;
                    this.__size = 0;
                    this.selfBalancing = selfBalancing;
                }
                else if (tree === undefined && selfBalancing === undefined) {
                    let __args = arguments;
                    if (this.root === undefined) {
                        this.root = null;
                    }
                    if (this.__size === undefined) {
                        this.__size = 0;
                    }
                    if (this.selfBalancing === undefined) {
                        this.selfBalancing = false;
                    }
                    this.root = null;
                    this.__size = 0;
                    this.selfBalancing = false;
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Returns true if this tree is self balancing.
             * @return {boolean} boolean
             * @since 3.0.0
             */
            isSelfBalancing() {
                return this.selfBalancing;
            }
            /**
             * Sets whether this tree should self balance.
             * <p>
             * When self balancing is enabled, adding and removing elements will perform a post
             * step to make sure the tree stays balanced. Balancing minimizes the tree's depth,
             * thereby increasing search performance.
             * <p>
             * If enabled and the tree contains more than 2 elements, the tree will be balanced
             * before this method returns.
             * @param {boolean} flag true if the tree should self balance
             * @since 3.0.0
             */
            setSelfBalancing(flag) {
                if (flag && !this.selfBalancing) {
                    if (this.__size > 2) {
                        this.balanceTree$();
                    }
                }
                this.selfBalancing = flag;
            }
            insert$java_lang_Comparable(comparable) {
                if (comparable == null)
                    return false;
                const node = (new org.dyn4j.BinarySearchTreeNode(comparable));
                return this.insert$org_dyn4j_BinarySearchTreeNode(node);
            }
            remove$java_lang_Comparable(comparable) {
                if (comparable == null)
                    return false;
                if (this.root == null)
                    return false;
                return this.remove(this.root, comparable) != null;
            }
            removeMinimum$() {
                if (this.root == null)
                    return null;
                return this.removeMinimum$org_dyn4j_BinarySearchTreeNode(this.root).comparable;
            }
            removeMaximum$() {
                if (this.root == null)
                    return null;
                return this.removeMaximum$org_dyn4j_BinarySearchTreeNode(this.root).comparable;
            }
            getMinimum$() {
                if (this.root == null)
                    return null;
                return this.getMinimum$org_dyn4j_BinarySearchTreeNode(this.root).comparable;
            }
            getMaximum$() {
                if (this.root == null)
                    return null;
                return this.getMaximum$org_dyn4j_BinarySearchTreeNode(this.root).comparable;
            }
            contains$java_lang_Comparable(comparable) {
                if (comparable == null)
                    return false;
                if (this.root == null)
                    return false;
                return this.contains(this.root, comparable) != null;
            }
            /**
             * Performs a binary search on this tree given the criteria.
             * @param {*} criteria the criteria
             * @param <T> the {@link BinarySearchTreeSearchCriteria} type
             * @return {*} the criteria for chaining
             * @since 3.2.0
             */
            search(criteria) {
                if (this.root == null)
                    return criteria;
                let node = this.root;
                while ((node != null)) {
                    {
                        const result = criteria.evaluate(node.comparable);
                        if (result < 0) {
                            node = node.left;
                        }
                        else if (result > 0) {
                            node = node.right;
                        }
                        else {
                            break;
                        }
                    }
                }
                ;
                return criteria;
            }
            /**
             * Returns the root of the tree.
             * @return {*} E the root value; null if the tree is empty
             */
            getRoot() {
                if (this.root == null)
                    return null;
                return this.root.comparable;
            }
            /**
             * Empties this tree.
             */
            clear() {
                this.root = null;
                this.__size = 0;
            }
            /**
             * Returns true if this tree is empty.
             * @return {boolean} boolean true if empty
             */
            isEmpty() {
                return this.root == null;
            }
            getHeight$() {
                return this.getHeight$org_dyn4j_BinarySearchTreeNode(this.root);
            }
            size$() {
                return this.__size;
            }
            /**
             * Returns the in-order (ascending) iterator.
             * @return {*} Iterator&lt;E&gt;
             */
            iterator() {
                return this.inOrderIterator();
            }
            /**
             * Returns the in-order (ascending) iterator starting from the given node.
             * @param {*} from the starting value
             * @return {*} Iterator&lt;E&gt;
             */
            tailIterator(from) {
                return (new org.dyn4j.BinarySearchTreeIterator(this.root, from, null));
            }
            /**
             * Returns the in-order (ascending) iterator.
             * @param {*} to the ending value
             * @return {*} Iterator&lt;E&gt;
             */
            headIterator(to) {
                return (new org.dyn4j.BinarySearchTreeIterator(this.root, null, to));
            }
            /**
             * Returns the in-order (ascending) iterator.
             * @param {*} from the starting value
             * @param {*} to the ending value
             * @return {*} Iterator&lt;E&gt;
             */
            subsetIterator(from, to) {
                return (new org.dyn4j.BinarySearchTreeIterator(this.root, from, to));
            }
            /**
             * Returns a new iterator for traversing the tree in order.
             * @return {*} Iterator&lt;E&gt;
             */
            inOrderIterator() {
                return (new org.dyn4j.BinarySearchTreeIterator(this.root, true));
            }
            /**
             * Returns a new iterator for traversing the tree in reverse order.
             * @return {*} Iterator&lt;E&gt;
             */
            reverseOrderIterator() {
                return (new org.dyn4j.BinarySearchTreeIterator(this.root, false));
            }
            toString() {
                const sb = new java.lang.StringBuilder();
                const iterator = this.inOrderIterator();
                sb.append("BinarySearchTree[");
                while ((iterator.hasNext())) {
                    {
                        sb.append(iterator.next());
                        if (iterator.hasNext()) {
                            sb.append(",");
                        }
                    }
                }
                ;
                sb.append("]");
                return sb.toString();
            }
            getMinimum$org_dyn4j_BinarySearchTreeNode(node) {
                if (node == null)
                    return null;
                while ((node.left != null)) {
                    {
                        node = node.left;
                    }
                }
                ;
                return node;
            }
            /**
             * Returns the minimum value of the subtree of the given node.
             * @param {org.dyn4j.BinarySearchTreeNode} node the subtree root node
             * @return {org.dyn4j.BinarySearchTreeNode} {@link BinarySearchTreeNode} the node found; null if subtree is empty
             */
            getMinimum(node) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null)) {
                    return this.getMinimum$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (node === undefined) {
                    return this.getMinimum$();
                }
                else
                    throw new Error('invalid overload');
            }
            getMaximum$org_dyn4j_BinarySearchTreeNode(node) {
                if (node == null)
                    return null;
                while ((node.right != null)) {
                    {
                        node = node.right;
                    }
                }
                ;
                return node;
            }
            /**
             * Returns the maximum value of the subtree of the given node.
             * @param {org.dyn4j.BinarySearchTreeNode} node the subtree root node
             * @return {org.dyn4j.BinarySearchTreeNode} {@link BinarySearchTreeNode} the node found; null if subtree is empty
             */
            getMaximum(node) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null)) {
                    return this.getMaximum$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (node === undefined) {
                    return this.getMaximum$();
                }
                else
                    throw new Error('invalid overload');
            }
            removeMinimum$org_dyn4j_BinarySearchTreeNode(node) {
                node = this.getMinimum$org_dyn4j_BinarySearchTreeNode(node);
                if (node == null)
                    return null;
                if (node === this.root) {
                    this.root = node.right;
                }
                else if (node.parent.right === node) {
                    node.parent.right = node.right;
                }
                else {
                    node.parent.left = node.right;
                }
                this.__size--;
                return node;
            }
            /**
             * Removes the minimum value node from the subtree of the given node.
             * @param {org.dyn4j.BinarySearchTreeNode} node the subtree root node
             * @return {org.dyn4j.BinarySearchTreeNode} {@link BinarySearchTreeNode} the node removed
             */
            removeMinimum(node) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null)) {
                    return this.removeMinimum$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (node === undefined) {
                    return this.removeMinimum$();
                }
                else
                    throw new Error('invalid overload');
            }
            removeMaximum$org_dyn4j_BinarySearchTreeNode(node) {
                node = this.getMaximum$org_dyn4j_BinarySearchTreeNode(node);
                if (node == null)
                    return null;
                if (node === this.root) {
                    this.root = node.left;
                }
                else if (node.parent.right === node) {
                    node.parent.right = node.left;
                }
                else {
                    node.parent.left = node.left;
                }
                this.__size--;
                return node;
            }
            /**
             * Removes the maximum value node from the subtree of the given node.
             * @param {org.dyn4j.BinarySearchTreeNode} node the subtree root node
             * @return {org.dyn4j.BinarySearchTreeNode} {@link BinarySearchTreeNode} the node removed
             */
            removeMaximum(node) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null)) {
                    return this.removeMaximum$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (node === undefined) {
                    return this.removeMaximum$();
                }
                else
                    throw new Error('invalid overload');
            }
            getHeight$org_dyn4j_BinarySearchTreeNode(node) {
                if (node == null)
                    return 0;
                if (node.left == null && node.right == null)
                    return 1;
                return 1 + Math.max(this.getHeight$org_dyn4j_BinarySearchTreeNode(node.left), this.getHeight$org_dyn4j_BinarySearchTreeNode(node.right));
            }
            /**
             * Returns the maximum depth of the subtree of the given node.
             * @param {org.dyn4j.BinarySearchTreeNode} node the root node of the subtree
             * @return {number} int the maximum depth
             * @since 3.0.0
             */
            getHeight(node) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null)) {
                    return this.getHeight$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (node === undefined) {
                    return this.getHeight$();
                }
                else
                    throw new Error('invalid overload');
            }
            size$org_dyn4j_BinarySearchTreeNode(node) {
                if (node == null)
                    return 0;
                if (node.left == null && node.right == null)
                    return 1;
                return 1 + this.size$org_dyn4j_BinarySearchTreeNode(node.left) + this.size$org_dyn4j_BinarySearchTreeNode(node.right);
            }
            /**
             * Returns the number of elements in the subtree.
             * @param {org.dyn4j.BinarySearchTreeNode} node the root node of the subtree
             * @return {number} int
             */
            size(node) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null)) {
                    return this.size$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (node === undefined) {
                    return this.size$();
                }
                else
                    throw new Error('invalid overload');
            }
            contains$org_dyn4j_BinarySearchTreeNode(node) {
                if (node == null)
                    return false;
                if (this.root == null)
                    return false;
                if (node === this.root)
                    return true;
                let curr = this.root;
                while ((curr != null)) {
                    {
                        if (curr === node)
                            return true;
                        const diff = node.compareTo(curr);
                        if (diff === 0) {
                            return curr === node;
                        }
                        else if (diff < 0) {
                            curr = curr.left;
                        }
                        else {
                            curr = curr.right;
                        }
                    }
                }
                ;
                return false;
            }
            /**
             * Returns the node that contains the given value or null if the
             * value is not found.
             * @param {*} comparable the comparable value
             * @return {org.dyn4j.BinarySearchTreeNode} {@link BinarySearchTreeNode} the node containing the given value; null if its not found
             */
            get(comparable) {
                if (comparable == null)
                    return null;
                if (this.root == null)
                    return null;
                return this.contains(this.root, comparable);
            }
            insertSubtree$org_dyn4j_BinarySearchTreeNode(node) {
                if (node == null)
                    return false;
                const iterator = (new org.dyn4j.BinarySearchTreeIterator(node));
                while ((iterator.hasNext())) {
                    {
                        const newNode = (new org.dyn4j.BinarySearchTreeNode(iterator.next()));
                        this.insert$org_dyn4j_BinarySearchTreeNode(newNode);
                    }
                }
                ;
                return true;
            }
            /**
             * Inserts the given subtree into this binary tree.
             * <p>
             * This method copies the elements from the given subtree.
             * @return {boolean} boolean true if the insertion was successful
             * @param {org.dyn4j.BinarySearchTreeNode} node the subtree root node
             */
            insertSubtree(node) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null)) {
                    return this.insertSubtree$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (((node != null && node instanceof org.dyn4j.BinarySearchTree) || node === null)) {
                    return this.insertSubtree$org_dyn4j_BinarySearchTree(node);
                }
                else
                    throw new Error('invalid overload');
            }
            insertSubtree$org_dyn4j_BinarySearchTree(tree) {
                if (tree == null)
                    return false;
                if (tree.root == null)
                    return true;
                const iterator = tree.inOrderIterator();
                while ((iterator.hasNext())) {
                    {
                        const newNode = (new org.dyn4j.BinarySearchTreeNode(iterator.next()));
                        this.insert$org_dyn4j_BinarySearchTreeNode(newNode);
                    }
                }
                ;
                return true;
            }
            removeSubtree$java_lang_Comparable(comparable) {
                if (comparable == null)
                    return false;
                if (this.root == null)
                    return false;
                let node = this.root;
                while ((node != null)) {
                    {
                        const diff = comparable.compareTo(node.comparable);
                        if (diff < 0) {
                            node = node.left;
                        }
                        else if (diff > 0) {
                            node = node.right;
                        }
                        else {
                            if (node.comparable.equals(comparable)) {
                                if (node.isLeftChild()) {
                                    node.parent.left = null;
                                }
                                else {
                                    node.parent.right = null;
                                }
                                this.__size -= this.size$org_dyn4j_BinarySearchTreeNode(node);
                                if (this.selfBalancing)
                                    this.balanceTree$org_dyn4j_BinarySearchTreeNode(node.parent);
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                    }
                }
                ;
                return false;
            }
            removeSubtree$org_dyn4j_BinarySearchTreeNode(node) {
                if (node == null)
                    return false;
                if (this.root == null)
                    return false;
                if (this.root === node) {
                    this.root = null;
                }
                else {
                    if (this.contains$org_dyn4j_BinarySearchTreeNode(node)) {
                        if (node.isLeftChild()) {
                            node.parent.left = null;
                        }
                        else {
                            node.parent.right = null;
                        }
                        this.__size -= this.size$org_dyn4j_BinarySearchTreeNode(node);
                        if (this.selfBalancing)
                            this.balanceTree$org_dyn4j_BinarySearchTreeNode(node.parent);
                        return true;
                    }
                }
                return false;
            }
            /**
             * Removes the given node (not the node's comparable) and the corresponding subtree from this tree.
             * @param {org.dyn4j.BinarySearchTreeNode} node the node and subtree to remove
             * @return {boolean} boolean true if the node was found and removed successfully
             */
            removeSubtree(node) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null)) {
                    return this.removeSubtree$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (((node != null) || node === null)) {
                    return this.removeSubtree$java_lang_Comparable(node);
                }
                else
                    throw new Error('invalid overload');
            }
            insert$org_dyn4j_BinarySearchTreeNode(item) {
                if (this.root == null) {
                    this.root = item;
                    this.__size++;
                    return true;
                }
                else {
                    return this.insert$org_dyn4j_BinarySearchTreeNode$org_dyn4j_BinarySearchTreeNode(item, this.root);
                }
            }
            insert$org_dyn4j_BinarySearchTreeNode$org_dyn4j_BinarySearchTreeNode(item, node) {
                if (node == null)
                    return false;
                while ((node != null)) {
                    {
                        if (item.compareTo(node) < 0) {
                            if (node.left == null) {
                                node.left = item;
                                item.parent = node;
                                break;
                            }
                            else {
                                node = node.left;
                            }
                        }
                        else {
                            if (node.right == null) {
                                node.right = item;
                                item.parent = node;
                                break;
                            }
                            else {
                                node = node.right;
                            }
                        }
                    }
                }
                ;
                this.__size++;
                if (this.selfBalancing)
                    this.balanceTree$org_dyn4j_BinarySearchTreeNode(node);
                return true;
            }
            /**
             * Internal insertion method.
             * <p>
             * This method cannot insert into the tree if the given node parameter is null.  Use the
             * {@link #insert(BinarySearchTreeNode)} method instead to ensure that the node is inserted.
             * @param {org.dyn4j.BinarySearchTreeNode} item the node to insert
             * @param {org.dyn4j.BinarySearchTreeNode} node the subtree root node to start the search
             * @return {boolean} true if the insertion was successful
             * @see #insert(BinarySearchTreeNode)
             */
            insert(item, node) {
                if (((item != null && item instanceof org.dyn4j.BinarySearchTreeNode) || item === null) && ((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null)) {
                    return this.insert$org_dyn4j_BinarySearchTreeNode$org_dyn4j_BinarySearchTreeNode(item, node);
                }
                else if (((item != null && item instanceof org.dyn4j.BinarySearchTreeNode) || item === null) && node === undefined) {
                    return this.insert$org_dyn4j_BinarySearchTreeNode(item);
                }
                else if (((item != null) || item === null) && node === undefined) {
                    return this.insert$java_lang_Comparable(item);
                }
                else
                    throw new Error('invalid overload');
            }
            remove$org_dyn4j_BinarySearchTreeNode(node) {
                if (node == null)
                    return false;
                if (this.root == null)
                    return false;
                if (this.contains$org_dyn4j_BinarySearchTreeNode(node)) {
                    this.removeNode(node);
                    return true;
                }
                return false;
            }
            remove$org_dyn4j_BinarySearchTreeNode$java_lang_Comparable(node, comparable) {
                while ((node != null)) {
                    {
                        const diff = comparable.compareTo(node.comparable);
                        if (diff < 0) {
                            node = node.left;
                        }
                        else if (diff > 0) {
                            node = node.right;
                        }
                        else {
                            if (node.comparable.equals(comparable)) {
                                this.removeNode(node);
                                return node;
                            }
                            else {
                                return null;
                            }
                        }
                    }
                }
                ;
                return null;
            }
            /**
             * Returns the node removed if the comparable is found, null otherwise.
             * @param {org.dyn4j.BinarySearchTreeNode} node the subtree node to start the search
             * @param {*} comparable the comparable object to remove
             * @return {org.dyn4j.BinarySearchTreeNode} {@link BinarySearchTreeNode} null if the given comparable was not found
             */
            remove(node, comparable) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null) && ((comparable != null) || comparable === null)) {
                    return this.remove$org_dyn4j_BinarySearchTreeNode$java_lang_Comparable(node, comparable);
                }
                else if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null) && comparable === undefined) {
                    return this.remove$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (((node != null) || node === null) && comparable === undefined) {
                    return this.remove$java_lang_Comparable(node);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Internal method to remove the given node from the tree retaining
             * all the subtree nodes.
             * <p>
             * This method assumes that the node is contained in this tree.
             * @param {org.dyn4j.BinarySearchTreeNode} node the node to remove
             */
            removeNode(node) {
                const isLeftChild = node.isLeftChild();
                if (node.left != null && node.right != null) {
                    const min = this.getMinimum$org_dyn4j_BinarySearchTreeNode(node.right);
                    if (min !== node.right) {
                        min.parent.left = min.right;
                        if (min.right != null) {
                            min.right.parent = min.parent;
                        }
                        min.right = node.right;
                    }
                    if (node.right != null)
                        node.right.parent = min;
                    if (node.left != null)
                        node.left.parent = min;
                    if (node === this.root) {
                        this.root = min;
                    }
                    else if (isLeftChild) {
                        node.parent.left = min;
                    }
                    else {
                        node.parent.right = min;
                    }
                    min.left = node.left;
                    min.parent = node.parent;
                    if (this.selfBalancing)
                        this.balanceTree$org_dyn4j_BinarySearchTreeNode(min.parent);
                }
                else if (node.left != null) {
                    if (node === this.root) {
                        this.root = node.left;
                    }
                    else if (isLeftChild) {
                        node.parent.left = node.left;
                    }
                    else {
                        node.parent.right = node.left;
                    }
                    if (node.left != null) {
                        node.left.parent = node.parent;
                    }
                }
                else if (node.right != null) {
                    if (node === this.root) {
                        this.root = node.right;
                    }
                    else if (isLeftChild) {
                        node.parent.left = node.right;
                    }
                    else {
                        node.parent.right = node.right;
                    }
                    if (node.right != null) {
                        node.right.parent = node.parent;
                    }
                }
                else {
                    if (node === this.root) {
                        this.root = null;
                    }
                    else if (isLeftChild) {
                        node.parent.left = null;
                    }
                    else {
                        node.parent.right = null;
                    }
                }
                this.__size--;
            }
            contains$org_dyn4j_BinarySearchTreeNode$java_lang_Comparable(node, comparable) {
                while ((node != null)) {
                    {
                        const nodeData = node.comparable;
                        const diff = comparable.compareTo(nodeData);
                        if (diff === 0) {
                            if (node.comparable.equals(comparable)) {
                                return node;
                            }
                            else {
                                return null;
                            }
                        }
                        else if (diff < 0) {
                            node = node.left;
                        }
                        else {
                            node = node.right;
                        }
                    }
                }
                ;
                return null;
            }
            /**
             * Internal iterative method to find an item in the tree.
             * @param {org.dyn4j.BinarySearchTreeNode} node the subtree root node
             * @param {*} comparable the comparable to find
             * @return {org.dyn4j.BinarySearchTreeNode} {@link BinarySearchTreeNode} the node found; null if not found
             */
            contains(node, comparable) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null) && ((comparable != null) || comparable === null)) {
                    return this.contains$org_dyn4j_BinarySearchTreeNode$java_lang_Comparable(node, comparable);
                }
                else if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null) && comparable === undefined) {
                    return this.contains$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (((node != null) || node === null) && comparable === undefined) {
                    return this.contains$java_lang_Comparable(node);
                }
                else
                    throw new Error('invalid overload');
            }
            balanceTree$() {
                const root = this.root;
                const balancing = this.selfBalancing;
                this.root = null;
                this.__size = 0;
                this.selfBalancing = true;
                const iterator = (new org.dyn4j.BinarySearchTreeIterator(root));
                while ((iterator.hasNext())) {
                    {
                        const node = (new org.dyn4j.BinarySearchTreeNode(iterator.next()));
                        this.insert$org_dyn4j_BinarySearchTreeNode(node);
                    }
                }
                ;
                this.selfBalancing = balancing;
            }
            balanceTree$org_dyn4j_BinarySearchTreeNode(node) {
                while ((node != null)) {
                    {
                        node = this.balance(node);
                        node = node.parent;
                    }
                }
                ;
            }
            /**
             * Balances the tree iteratively to the root starting at the given node.
             * @param {org.dyn4j.BinarySearchTreeNode} node the node to begin balancing
             * @since 3.0.0
             */
            balanceTree(node) {
                if (((node != null && node instanceof org.dyn4j.BinarySearchTreeNode) || node === null)) {
                    return this.balanceTree$org_dyn4j_BinarySearchTreeNode(node);
                }
                else if (node === undefined) {
                    return this.balanceTree$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Balances the given node's subtree.
             * @param {org.dyn4j.BinarySearchTreeNode} node the root node of the subtree
             * @return {org.dyn4j.BinarySearchTreeNode} {@link BinarySearchTreeNode} the new root
             * @since 3.0.0
             */
            balance(node) {
                if (node == null)
                    return null;
                if (this.getHeight$org_dyn4j_BinarySearchTreeNode(node) < 2)
                    return node;
                const p = node.parent;
                const a = node.left;
                const b = node.right;
                const ah = this.getHeight$org_dyn4j_BinarySearchTreeNode(a);
                const bh = this.getHeight$org_dyn4j_BinarySearchTreeNode(b);
                const balance = ah - bh;
                if (balance > 1) {
                    const ach = this.getHeight$org_dyn4j_BinarySearchTreeNode(a.right);
                    if (ach > 1) {
                        const c = a.right;
                        a.right = c.left;
                        if (c.left != null)
                            c.left.parent = a;
                        c.left = a;
                        a.parent = c;
                        node.left = c;
                        c.parent = node;
                    }
                    const c = node.left;
                    node.left = c.right;
                    if (c.right != null)
                        c.right.parent = node;
                    c.right = node;
                    c.parent = node.parent;
                    node.parent = c;
                    if (p != null) {
                        if (p.left === node) {
                            p.left = c;
                        }
                        else {
                            p.right = c;
                        }
                    }
                    else {
                        this.root = c;
                    }
                    return c;
                }
                if (balance < -1) {
                    const bch = this.getHeight$org_dyn4j_BinarySearchTreeNode(b.left);
                    if (bch > 1) {
                        const d = b.left;
                        b.left = d.right;
                        if (d.right != null)
                            d.right.parent = b;
                        d.right = b;
                        b.parent = d;
                        node.right = d;
                        d.parent = node;
                    }
                    const d = node.right;
                    node.right = d.left;
                    if (d.left != null)
                        d.left.parent = node;
                    d.left = node;
                    d.parent = node.parent;
                    node.parent = d;
                    if (p != null) {
                        if (p.left === node) {
                            p.left = d;
                        }
                        else {
                            p.right = d;
                        }
                    }
                    else {
                        this.root = d;
                    }
                    return d;
                }
                return node;
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((((funcInst) => { if (typeof funcInst == 'function') {
                    return funcInst;
                } return (arg0) => (funcInst['accept'] ? funcInst['accept'] : funcInst).call(funcInst, arg0); })(action)));
                for (let index = this.iterator(); index.hasNext();) {
                    let t = index.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
        }
        dyn4j.BinarySearchTree = BinarySearchTree;
        BinarySearchTree["__class"] = "org.dyn4j.BinarySearchTree";
        BinarySearchTree["__interfaces"] = ["java.lang.Iterable"];
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                var input;
                (function (input) {
                    class AbstractInputHandler {
                        constructor() {
                            if (this.enabled === undefined) {
                                this.enabled = false;
                            }
                            if (this.additive === undefined) {
                                this.additive = false;
                            }
                            if (this.dependentBehaviors === undefined) {
                                this.dependentBehaviors = null;
                            }
                            this.enabled = true;
                            this.additive = false;
                            this.dependentBehaviors = (new java.util.ArrayList());
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isEnabled() {
                            return this.enabled;
                        }
                        /**
                         *
                         * @param {boolean} flag
                         */
                        setEnabled(flag) {
                            this.enabled = flag;
                        }
                        getDependentBehaviors() {
                            return this.dependentBehaviors;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isDependentBehaviorActive() {
                            let result = false;
                            for (let index = this.dependentBehaviors.iterator(); index.hasNext();) {
                                let behavior = index.next();
                                {
                                    if (behavior.isActive()) {
                                        result = true;
                                    }
                                }
                            }
                            if (this.additive)
                                return !result;
                            return result;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isDependentBehaviorsAdditive() {
                            return this.additive;
                        }
                        /**
                         *
                         * @param {boolean} flag
                         */
                        setDependentBehaviorsAdditive(flag) {
                            this.additive = flag;
                        }
                    }
                    input.AbstractInputHandler = AbstractInputHandler;
                    AbstractInputHandler["__class"] = "org.dyn4j.samples.framework.input.AbstractInputHandler";
                    AbstractInputHandler["__interfaces"] = ["org.dyn4j.samples.framework.input.InputHandler"];
                })(input = framework.input || (framework.input = {}));
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                var input;
                (function (input) {
                    /**
                     * A simple example of how you might serialize the state of a world.
                     * @author William Bittle
                     * @version 4.2.0
                     * @since 4.1.1
                     * @class
                     */
                    class CodeExporter {
                        static NEW_LINE_$LI$() { if (CodeExporter.NEW_LINE == null) {
                            CodeExporter.NEW_LINE = java.lang.System.getProperty("line.separator");
                        } return CodeExporter.NEW_LINE; }
                        static TAB2_$LI$() { if (CodeExporter.TAB2 == null) {
                            CodeExporter.TAB2 = CodeExporter.TAB1 + CodeExporter.TAB1;
                        } return CodeExporter.TAB2; }
                        static TAB3_$LI$() { if (CodeExporter.TAB3 == null) {
                            CodeExporter.TAB3 = CodeExporter.TAB1 + CodeExporter.TAB1 + CodeExporter.TAB1;
                        } return CodeExporter.TAB3; }
                        static export$java_lang_String$org_dyn4j_dynamics_World(name, world) {
                            const sb = new java.lang.StringBuilder();
                            const idNameMap = (new java.util.HashMap());
                            sb.append("import java.util.*;").append(CodeExporter.NEW_LINE_$LI$()).append("import org.dyn4j.collision.*;").append(CodeExporter.NEW_LINE_$LI$()).append("import org.dyn4j.collision.broadphase.*;").append(CodeExporter.NEW_LINE_$LI$()).append("import org.dyn4j.collision.continuous.*;").append(CodeExporter.NEW_LINE_$LI$()).append("import org.dyn4j.collision.manifold.*;").append(CodeExporter.NEW_LINE_$LI$()).append("import org.dyn4j.collision.narrowphase.*;").append(CodeExporter.NEW_LINE_$LI$()).append("import org.dyn4j.dynamics.*;").append(CodeExporter.NEW_LINE_$LI$()).append("import org.dyn4j.dynamics.joint.*;").append(CodeExporter.NEW_LINE_$LI$()).append("import org.dyn4j.geometry.*;").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.NEW_LINE_$LI$()).append("// ").append(world.getUserData()).append(CodeExporter.NEW_LINE_$LI$()).append("// generated for dyn4j v").append(org.dyn4j.Version.getVersion()).append(CodeExporter.NEW_LINE_$LI$()).append("public class ").append(name).append(" { ").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB1).append("private ").append(name).append("() {}").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB1).append("public static final void setup(World world) {").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("Settings settings = world.getSettings();").append(CodeExporter.NEW_LINE_$LI$());
                            sb.append(CodeExporter.export$org_dyn4j_dynamics_Settings(world.getSettings()));
                            sb.append(CodeExporter.NEW_LINE_$LI$());
                            const g = world.getGravity();
                            if (g === org.dyn4j.dynamics.World.EARTH_GRAVITY_$LI$() || g.equals$double$double(0.0, -9.8)) {
                            }
                            else if (g === org.dyn4j.dynamics.World.ZERO_GRAVITY_$LI$() || g.isZero()) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("world.setGravity(World.ZERO_GRAVITY);").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            else {
                                sb.append(CodeExporter.TAB2_$LI$()).append("world.setGravity(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(g)).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            sb.append(CodeExporter.TAB2_$LI$()).append("CollisionItemBroadphaseDetector<Body, BodyFixture> bpd = new CollisionItemBroadphaseDetectorAdapter<Body, BodyFixture>(bp);").append(CodeExporter.NEW_LINE_$LI$());
                            sb.append(CodeExporter.TAB2_$LI$()).append("world.setBroadphaseDetector(bpd);").append(CodeExporter.NEW_LINE_$LI$());
                            const npd = world.getNarrowphaseDetector();
                            if (npd != null && npd instanceof org.dyn4j.collision.narrowphase.Sat) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("world.setNarrowphaseDetector(new Sat());").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            else if (npd != null && npd instanceof org.dyn4j.collision.narrowphase.Gjk) {
                            }
                            else {
                            }
                            const msr = world.getManifoldSolver();
                            if (msr != null && msr instanceof org.dyn4j.collision.manifold.ClippingManifoldSolver) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("world.setManifoldSolver(new ClippingManifoldSolver());").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            else {
                            }
                            const tid = world.getTimeOfImpactDetector();
                            if (tid != null && tid instanceof org.dyn4j.collision.continuous.ConservativeAdvancement) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("world.setTimeOfImpactDetector(new ConservativeAdvancement());").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            else {
                            }
                            const bounds = world.getBounds();
                            if (bounds == null) {
                            }
                            else if (bounds != null && bounds instanceof org.dyn4j.collision.AxisAlignedBounds) {
                                const aab = bounds;
                                const w = aab.getWidth();
                                const h = aab.getHeight();
                                sb.append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("AxisAlignedBounds bounds = new AxisAlignedBounds(").append(w).append(", ").append(h).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                if (!aab.getTranslation().isZero()) {
                                    sb.append(CodeExporter.TAB2_$LI$()).append("bounds.translate(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(aab.getTranslation())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                }
                                sb.append(CodeExporter.TAB2_$LI$()).append("world.setBounds(bounds);").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.NEW_LINE_$LI$());
                            }
                            else {
                            }
                            const bSize = world.getBodyCount();
                            for (let i = 1; i < bSize + 1; i++) {
                                {
                                    const body = world.getBody(i - 1);
                                    idNameMap.put(body, "body" + i);
                                    const mass = body.getMassData();
                                    sb.append(CodeExporter.TAB2_$LI$()).append("// body user data: ").append(body.getUserData()).append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("GameObject body").append(i).append(" = new GameObject();").append(CodeExporter.NEW_LINE_$LI$());
                                    const fSize = body.getFixtureCount();
                                    for (let j = 0; j < fSize; j++) {
                                        {
                                            const bf = body.getFixture$int(j);
                                            sb.append(CodeExporter.TAB2_$LI$()).append("{// fixture user data: ").append(bf.getUserData()).append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.export$org_dyn4j_geometry_Convex$java_lang_String(bf.getShape(), CodeExporter.TAB3_$LI$())).append(CodeExporter.TAB3_$LI$()).append("BodyFixture bf = new BodyFixture(c);").append(CodeExporter.NEW_LINE_$LI$());
                                            if (bf.isSensor()) {
                                                sb.append(CodeExporter.TAB3_$LI$()).append("bf.setSensor(").append(bf.isSensor()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                            }
                                            if (bf.getDensity() !== org.dyn4j.dynamics.BodyFixture.DEFAULT_DENSITY) {
                                                sb.append(CodeExporter.TAB3_$LI$()).append("bf.setDensity(").append(bf.getDensity()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                            }
                                            if (bf.getFriction() !== org.dyn4j.dynamics.BodyFixture.DEFAULT_FRICTION) {
                                                sb.append(CodeExporter.TAB3_$LI$()).append("bf.setFriction(").append(bf.getFriction()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                            }
                                            if (bf.getRestitution() !== org.dyn4j.dynamics.BodyFixture.DEFAULT_RESTITUTION) {
                                                sb.append(CodeExporter.TAB3_$LI$()).append("bf.setRestitution(").append(bf.getRestitution()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                            }
                                            sb.append(CodeExporter.export$org_dyn4j_collision_Filter$java_lang_String(bf.getFilter(), CodeExporter.TAB3_$LI$())).append(CodeExporter.TAB3_$LI$()).append("body").append(i).append(".addFixture(bf);").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("}").append(CodeExporter.NEW_LINE_$LI$());
                                        }
                                        ;
                                    }
                                    if (Math.abs(body.getTransform().getRotationAngle()) > org.dyn4j.Epsilon.E_$LI$()) {
                                        sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".rotate(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(body.getTransform().getRotationAngle())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    if (!body.getTransform().getTranslation().isZero()) {
                                        sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".translate(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(body.getTransform().getTranslation())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    if (!body.getLinearVelocity$().isZero()) {
                                        sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".setLinearVelocity(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(body.getLinearVelocity$())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    if (Math.abs(body.getAngularVelocity()) > org.dyn4j.Epsilon.E_$LI$()) {
                                        sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".setAngularVelocity(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(body.getAngularVelocity())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    if (body.isBullet()) {
                                        sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".setBullet(true);").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    if (body.getLinearDamping() !== org.dyn4j.dynamics.Body.DEFAULT_LINEAR_DAMPING) {
                                        sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".setLinearDamping(").append(body.getLinearDamping()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    if (body.getAngularDamping() !== org.dyn4j.dynamics.Body.DEFAULT_ANGULAR_DAMPING) {
                                        sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".setAngularDamping(").append(body.getAngularDamping()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    if (body.getGravityScale() !== 1.0) {
                                        sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".setGravityScale(").append(body.getGravityScale()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".setMass(").append(CodeExporter.export$org_dyn4j_geometry_Mass(mass)).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".setMassType(MassType.").append(mass.getType()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    if (!body.getAccumulatedForce().isZero()) {
                                        sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".applyForce(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(body.getAccumulatedForce())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    if (Math.abs(body.getAccumulatedTorque()) > org.dyn4j.Epsilon.E_$LI$()) {
                                        sb.append(CodeExporter.TAB2_$LI$()).append("body").append(i).append(".applyTorque(").append(body.getAccumulatedTorque()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    sb.append(CodeExporter.TAB2_$LI$()).append("world.addBody(body").append(i).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.NEW_LINE_$LI$());
                                }
                                ;
                            }
                            const jSize = world.getJointCount();
                            for (let i = 1; i < jSize + 1; i++) {
                                {
                                    const joint = world.getJoint(i - 1);
                                    const body1 = joint.getBody1();
                                    const body2 = joint.getBody2();
                                    sb.append(CodeExporter.TAB2_$LI$()).append("// ").append(joint.getUserData()).append(CodeExporter.NEW_LINE_$LI$());
                                    if (joint != null && joint instanceof org.dyn4j.dynamics.joint.AngleJoint) {
                                        const aj = joint;
                                        sb.append(CodeExporter.TAB2_$LI$()).append("AngleJoint joint").append(i).append(" = new AngleJoint(").append(idNameMap.get(body1)).append(", ").append(idNameMap.get(body2)).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setLimits(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(aj.getLowerLimit())).append("), Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(aj.getUpperLimit())).append("));").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setLimitEnabled(").append(aj.isLimitEnabled()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setReferenceAngle(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(aj.getReferenceAngle())).append("));").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setRatio(").append(aj.getRatio()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.DistanceJoint) {
                                        const dj = joint;
                                        sb.append(CodeExporter.TAB2_$LI$()).append("DistanceJoint joint").append(i).append(" = new DistanceJoint(").append(idNameMap.get(body1)).append(", ").append(idNameMap.get(body2)).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(dj.getAnchor1())).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(dj.getAnchor2())).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setFrequency(").append(dj.getFrequency()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setDampingRatio(").append(dj.getDampingRatio()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setDistance(").append(dj.getDistance()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.FrictionJoint) {
                                        const fj = joint;
                                        sb.append(CodeExporter.TAB2_$LI$()).append("FrictionJoint joint").append(i).append(" = new FrictionJoint(").append(idNameMap.get(body1)).append(", ").append(idNameMap.get(body2)).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(fj.getAnchor1())).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMaximumForce(").append(fj.getMaximumForce()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMaximumTorque(").append(fj.getMaximumTorque()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.PinJoint) {
                                        const mj = joint;
                                        sb.append(CodeExporter.TAB2_$LI$()).append("PinJoint joint").append(i).append(" = new PinJoint(").append(idNameMap.get(body1)).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(mj.getAnchor2())).append(", ").append(mj.getFrequency()).append(", ").append(mj.getDampingRatio()).append(", ").append(mj.getMaximumForce()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setTarget(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(mj.getAnchor1())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.PrismaticJoint) {
                                        const pj = joint;
                                        sb.append(CodeExporter.TAB2_$LI$()).append("PrismaticJoint joint").append(i).append(" = new PrismaticJoint(").append(idNameMap.get(body1)).append(", ").append(idNameMap.get(body2)).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(pj.getAnchor1())).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(pj.getAxis())).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setLimitEnabled(").append(pj.isLimitEnabled()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setLimits(").append(pj.getLowerLimit()).append(", ").append(pj.getUpperLimit()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setReferenceAngle(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(pj.getReferenceAngle())).append("));").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMotorEnabled(").append(pj.isMotorEnabled()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMotorSpeed(").append(pj.getMotorSpeed()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMaximumMotorForce(").append(pj.getMaximumMotorForce()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.PulleyJoint) {
                                        const pj = joint;
                                        sb.append(CodeExporter.TAB2_$LI$()).append("PulleyJoint joint").append(i).append(" = new PulleyJoint(").append(idNameMap.get(body1)).append(", ").append(idNameMap.get(body2)).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(pj.getPulleyAnchor1())).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(pj.getPulleyAnchor2())).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(pj.getAnchor1())).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(pj.getAnchor2())).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setRatio(").append(pj.getRatio()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.RevoluteJoint) {
                                        const rj = joint;
                                        sb.append(CodeExporter.TAB2_$LI$()).append("RevoluteJoint joint").append(i).append(" = new RevoluteJoint(").append(idNameMap.get(body1)).append(", ").append(idNameMap.get(body2)).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(rj.getAnchor1())).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setLimitEnabled(").append(rj.isLimitEnabled()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setLimits(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(rj.getLowerLimit())).append("), Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(rj.getUpperLimit())).append("));").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setReferenceAngle(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(rj.getReferenceAngle())).append("));").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMotorEnabled(").append(rj.isMotorEnabled()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMotorSpeed(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(rj.getMotorSpeed())).append("));").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMaximumMotorTorque(").append(rj.getMaximumMotorTorque()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.WeldJoint) {
                                        const wj = joint;
                                        sb.append(CodeExporter.TAB2_$LI$()).append("WeldJoint joint").append(i).append(" = new WeldJoint(").append(idNameMap.get(body1)).append(", ").append(idNameMap.get(body2)).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(wj.getAnchor1())).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setFrequency(").append(wj.getFrequency()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setDampingRatio(").append(wj.getDampingRatio()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setReferenceAngle(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(wj.getReferenceAngle())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.WheelJoint) {
                                        const wj = joint;
                                        sb.append(CodeExporter.TAB2_$LI$()).append("WheelJoint joint").append(i).append(" = new WheelJoint(").append(idNameMap.get(body1)).append(", ").append(idNameMap.get(body2)).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(wj.getAnchor1())).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(wj.getAxis())).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setFrequency(").append(wj.getFrequency()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setDampingRatio(").append(wj.getDampingRatio()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMotorEnabled(").append(wj.isMotorEnabled()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMotorSpeed(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(wj.getMotorSpeed())).append("));").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMaximumMotorTorque(").append(wj.getMaximumMotorTorque()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.MotorJoint) {
                                        const mj = joint;
                                        sb.append(CodeExporter.TAB2_$LI$()).append("MotorJoint joint").append(i).append(" = new MotorJoint(").append(idNameMap.get(body1)).append(", ").append(idNameMap.get(body2)).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setLinearTarget(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(mj.getLinearTarget())).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setAngularTarget(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(mj.getAngularTarget())).append("));").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setCorrectionFactor(").append(mj.getCorrectionFactor()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMaximumForce(").append(mj.getMaximumForce()).append(");").append(CodeExporter.NEW_LINE_$LI$()).append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setMaximumTorque(").append(mj.getMaximumTorque()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    }
                                    else {
                                    }
                                    sb.append(CodeExporter.TAB2_$LI$()).append("joint").append(i).append(".setCollisionAllowed(").append(joint.isCollisionAllowed()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                    sb.append(CodeExporter.TAB2_$LI$()).append("world.addJoint(joint").append(i).append(");");
                                    sb.append(CodeExporter.NEW_LINE_$LI$());
                                }
                                ;
                            }
                            sb.append(CodeExporter.TAB1).append("}").append(CodeExporter.NEW_LINE_$LI$()).append("}").append(CodeExporter.NEW_LINE_$LI$());
                            return sb.toString();
                        }
                        /**
                         * Exports the given world and settings to Java code.
                         * <p>
                         * Returns a string containing the code for the export.
                         * @param {string} name the name of the generated class
                         * @param simulation the simulation to export
                         * @return {string} String
                         * @param {org.dyn4j.dynamics.World} world
                         */
                        static export(name, world) {
                            if (((typeof name === 'string') || name === null) && ((world != null && world instanceof org.dyn4j.dynamics.World) || world === null)) {
                                return org.dyn4j.samples.framework.input.CodeExporter.export$java_lang_String$org_dyn4j_dynamics_World(name, world);
                            }
                            else if (((name != null && (name.constructor != null && name.constructor["__interfaces"] != null && name.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || name === null) && ((typeof world === 'string') || world === null)) {
                                return org.dyn4j.samples.framework.input.CodeExporter.export$org_dyn4j_geometry_Convex$java_lang_String(name, world);
                            }
                            else if (((name != null && (name.constructor != null && name.constructor["__interfaces"] != null && name.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || name === null) && ((typeof world === 'string') || world === null)) {
                                return org.dyn4j.samples.framework.input.CodeExporter.export$org_dyn4j_collision_Filter$java_lang_String(name, world);
                            }
                            else if (((name != null && name instanceof org.dyn4j.dynamics.Settings) || name === null) && world === undefined) {
                                return org.dyn4j.samples.framework.input.CodeExporter.export$org_dyn4j_dynamics_Settings(name);
                            }
                            else if (((name != null && name instanceof org.dyn4j.geometry.Mass) || name === null) && world === undefined) {
                                return org.dyn4j.samples.framework.input.CodeExporter.export$org_dyn4j_geometry_Mass(name);
                            }
                            else if (((name != null && name instanceof org.dyn4j.geometry.Vector2) || name === null) && world === undefined) {
                                return org.dyn4j.samples.framework.input.CodeExporter.export$org_dyn4j_geometry_Vector2(name);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /*private*/ static export$org_dyn4j_dynamics_Settings(settings) {
                            const sb = new java.lang.StringBuilder();
                            if (settings.getStepFrequency() !== org.dyn4j.dynamics.Settings.DEFAULT_STEP_FREQUENCY) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setStepFrequency(").append(1.0 / settings.getStepFrequency()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            if (settings.getMaximumTranslation() !== org.dyn4j.dynamics.Settings.DEFAULT_MAXIMUM_TRANSLATION) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setMaximumTranslation(").append(settings.getMaximumTranslation()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            if (settings.getMaximumRotation() !== org.dyn4j.dynamics.Settings.DEFAULT_MAXIMUM_ROTATION_$LI$()) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setMaximumRotation(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(settings.getMaximumRotation())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            if (settings.getVelocityConstraintSolverIterations() !== org.dyn4j.dynamics.Settings.DEFAULT_SOLVER_ITERATIONS) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setVelocityConstraintSolverIterations(").append(settings.getVelocityConstraintSolverIterations()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            if (settings.getPositionConstraintSolverIterations() !== org.dyn4j.dynamics.Settings.DEFAULT_SOLVER_ITERATIONS) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setPositionConstraintSolverIterations(").append(settings.getPositionConstraintSolverIterations()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            if (settings.getLinearTolerance() !== org.dyn4j.dynamics.Settings.DEFAULT_LINEAR_TOLERANCE) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setLinearTolerance(").append(settings.getLinearTolerance()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            if (settings.getAngularTolerance() !== org.dyn4j.dynamics.Settings.DEFAULT_ANGULAR_TOLERANCE_$LI$()) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setAngularTolerance(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(settings.getAngularTolerance())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            if (settings.getMaximumLinearCorrection() !== org.dyn4j.dynamics.Settings.DEFAULT_MAXIMUM_LINEAR_CORRECTION) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setMaximumLinearCorrection(").append(settings.getMaximumLinearCorrection()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            if (settings.getMaximumAngularCorrection() !== org.dyn4j.dynamics.Settings.DEFAULT_MAXIMUM_ANGULAR_CORRECTION_$LI$()) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setMaximumAngularCorrection(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(settings.getMaximumAngularCorrection())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            if (settings.getBaumgarte() !== org.dyn4j.dynamics.Settings.DEFAULT_BAUMGARTE) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setBaumgarte(").append(settings.getBaumgarte()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            if (settings.getContinuousDetectionMode() !== org.dyn4j.dynamics.ContinuousDetectionMode.ALL) {
                                sb.append(CodeExporter.TAB2_$LI$()).append("settings.setContinuousDetectionMode(Settings.ContinuousDetectionMode.").append(settings.getContinuousDetectionMode()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            return sb.toString();
                        }
                        /*private*/ static export$org_dyn4j_geometry_Mass(mass) {
                            const sb = new java.lang.StringBuilder();
                            const temp = new org.dyn4j.geometry.Mass(mass);
                            temp.setType(org.dyn4j.geometry.MassType.NORMAL);
                            sb.append("new Mass(new Vector2(").append(temp.getCenter().x).append(", ").append(temp.getCenter().y).append("), ").append(temp.getMass()).append(", ").append(temp.getInertia()).append(")");
                            return sb.toString();
                        }
                        /*private*/ static export$org_dyn4j_geometry_Vector2(v) {
                            const sb = new java.lang.StringBuilder();
                            sb.append("new Vector2(").append(v.x).append(", ").append(v.y).append(")");
                            return sb.toString();
                        }
                        /*private*/ static export$org_dyn4j_geometry_Convex$java_lang_String(c, tabs) {
                            const sb = new java.lang.StringBuilder();
                            if (c != null && c instanceof org.dyn4j.geometry.Circle) {
                                const circle = c;
                                sb.append(tabs).append("Convex c = Geometry.createCircle(").append(circle.getRadius$()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                if (!circle.getCenter().isZero()) {
                                    sb.append(tabs).append("c.translate(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(circle.getCenter())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                }
                            }
                            else if (c != null && c instanceof org.dyn4j.geometry.Rectangle) {
                                const rectangle = c;
                                sb.append(tabs).append("Convex c = Geometry.createRectangle(").append(rectangle.getWidth()).append(", ").append(rectangle.getHeight()).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                if (Math.abs(rectangle.getRotationAngle()) > org.dyn4j.Epsilon.E_$LI$()) {
                                    sb.append(tabs).append("c.rotate(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(rectangle.getRotationAngle())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                                }
                                if (!rectangle.getCenter().isZero()) {
                                    sb.append(tabs).append("c.translate(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(rectangle.getCenter())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                }
                            }
                            else if (c != null && c instanceof org.dyn4j.geometry.Triangle) {
                                const triangle = c;
                                sb.append(tabs).append("Convex c = Geometry.createTriangle(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(triangle.getVertices()[0])).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(triangle.getVertices()[1])).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(triangle.getVertices()[2])).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            else if (c != null && c instanceof org.dyn4j.geometry.Polygon) {
                                const polygon = c;
                                sb.append(tabs).append("Convex c = Geometry.createPolygon(");
                                const vSize = polygon.getVertices().length;
                                for (let i = 0; i < vSize; i++) {
                                    {
                                        const v = polygon.getVertices()[i];
                                        if (i !== 0)
                                            sb.append(", ");
                                        sb.append(CodeExporter.export$org_dyn4j_geometry_Vector2(v));
                                    }
                                    ;
                                }
                                sb.append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            else if (c != null && c instanceof org.dyn4j.geometry.Segment) {
                                const segment = c;
                                sb.append(tabs).append("Convex c = Geometry.createSegment(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(segment.getVertices()[0])).append(", ").append(CodeExporter.export$org_dyn4j_geometry_Vector2(segment.getVertices()[1])).append(");").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            else if (c != null && c instanceof org.dyn4j.geometry.Capsule) {
                                const capsule = c;
                                sb.append(tabs).append("Convex c = Geometry.createCapsule(").append(capsule.getLength()).append(", ").append(capsule.getCapRadius() * 2.0).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                if (Math.abs(capsule.getRotationAngle()) > org.dyn4j.Epsilon.E_$LI$()) {
                                    sb.append(tabs).append("c.rotate(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(capsule.getRotationAngle())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                                }
                                if (!capsule.getCenter().isZero()) {
                                    sb.append(tabs).append("c.translate(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(capsule.getCenter())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                }
                            }
                            else if (c != null && c instanceof org.dyn4j.geometry.Ellipse) {
                                const ellipse = c;
                                sb.append(tabs).append("Convex c = Geometry.createEllipse(").append(ellipse.getHalfWidth() * 2.0).append(", ").append(ellipse.getHalfHeight() * 2.0).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                if (Math.abs(ellipse.getRotationAngle()) > org.dyn4j.Epsilon.E_$LI$()) {
                                    sb.append(tabs).append("c.rotate(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(ellipse.getRotationAngle())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                                }
                                if (!ellipse.getCenter().isZero()) {
                                    sb.append(tabs).append("c.translate(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(ellipse.getCenter())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                }
                            }
                            else if (c != null && c instanceof org.dyn4j.geometry.HalfEllipse) {
                                const halfEllipse = c;
                                const width = halfEllipse.getHalfWidth() * 2.0;
                                const height = halfEllipse.getHeight();
                                const originalY = (4.0 * height) / (3.0 * Math.PI);
                                sb.append(tabs).append("Convex c = Geometry.createHalfEllipse(").append(width).append(", ").append(height).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                if (Math.abs(halfEllipse.getRotationAngle()) > org.dyn4j.Epsilon.E_$LI$()) {
                                    sb.append(tabs).append("c.rotate(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(halfEllipse.getRotationAngle())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                                }
                                if (halfEllipse.getCenter().y !== originalY) {
                                    sb.append(tabs).append("c.translate(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(halfEllipse.getCenter())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                }
                            }
                            else if (c != null && c instanceof org.dyn4j.geometry.Slice) {
                                const slice = c;
                                const theta = slice.getTheta();
                                const radius = slice.getSliceRadius();
                                const originalX = 2.0 * radius * Math.sin(theta * 0.5) / (1.5 * theta);
                                sb.append(tabs).append("Convex c = Geometry.createSlice(").append(radius).append(", Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(theta)).append("));").append(CodeExporter.NEW_LINE_$LI$());
                                if (Math.abs(slice.getRotationAngle()) > org.dyn4j.Epsilon.E_$LI$()) {
                                    sb.append(tabs).append("c.rotate(Math.toRadians(").append(/* toDegrees */ (x => x * 180 / Math.PI)(slice.getRotationAngle())).append("));").append(CodeExporter.NEW_LINE_$LI$());
                                }
                                if (slice.getCenter().x !== originalX) {
                                    sb.append(tabs).append("c.translate(").append(CodeExporter.export$org_dyn4j_geometry_Vector2(slice.getCenter())).append(");").append(CodeExporter.NEW_LINE_$LI$());
                                }
                            }
                            else {
                            }
                            return sb.toString();
                        }
                        /*private*/ static export$org_dyn4j_collision_Filter$java_lang_String(f, tabs) {
                            const sb = new java.lang.StringBuilder();
                            if (f === org.dyn4j.collision.Filter.DEFAULT_FILTER_$LI$()) {
                            }
                            else if (f != null && f instanceof org.dyn4j.collision.CategoryFilter) {
                                const cf = f;
                                sb.append(tabs).append("bf.setFilter(new CategoryFilter(").append(cf.getCategory()).append(", ").append(cf.getMask()).append("));").append(CodeExporter.NEW_LINE_$LI$());
                            }
                            else {
                            }
                            return sb.toString();
                        }
                    }
                    /**
                     * One tab
                     */
                    CodeExporter.TAB1 = "  ";
                    input.CodeExporter = CodeExporter;
                    CodeExporter["__class"] = "org.dyn4j.samples.framework.input.CodeExporter";
                })(input = framework.input || (framework.input = {}));
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                /**
                 * Constructor.
                 * <p>
                 * By default creates a 800x600 canvas.
                 *
                 * @param name  the frame name
                 * @param scale the pixels per meter scale factor
                 * @class
                 */
                class SimulationFrame {
                    constructor() {
                        if (this.canvas === undefined) {
                            this.canvas = null;
                        }
                        if (this.context === undefined) {
                            this.context = null;
                        }
                        if (this.world === undefined) {
                            this.world = null;
                        }
                        if (this.stopped === undefined) {
                            this.stopped = false;
                        }
                        if (this.last === undefined) {
                            this.last = 0;
                        }
                        if (this.stepNumber === undefined) {
                            this.stepNumber = 0;
                        }
                        if (this.camera === undefined) {
                            this.camera = null;
                        }
                        this.paused = true;
                        if (this.__step === undefined) {
                            this.__step = false;
                        }
                        if (this.picking === undefined) {
                            this.picking = null;
                        }
                        if (this.panning === undefined) {
                            this.panning = null;
                        }
                        if (this.zoom === undefined) {
                            this.zoom = null;
                        }
                        if (this.cameraKey === undefined) {
                            this.cameraKey = null;
                        }
                        if (this.controlsKey === undefined) {
                            this.controlsKey = null;
                        }
                        this.renderContacts = false;
                        this.renderBodyAABBs = true;
                        this.renderBodyRotationRadius = false;
                        this.renderFixtureAABBs = false;
                        this.renderFixtureRotationRadius = false;
                        if (this.printStepNumber === undefined) {
                            this.printStepNumber = false;
                        }
                        this.printSimulation = false;
                        this.DPI_FACTOR = 2;
                        if (this.worldPopulator === undefined) {
                            this.worldPopulator = null;
                        }
                        console.info("creating canvas drawing example");
                        this.canvas = document.getElementById("canvas");
                        const body = document.querySelector("body");
                        const size = Math.min(body.clientHeight, body.clientWidth);
                        this.canvas.width = this.DPI_FACTOR * body.clientWidth;
                        this.canvas.height = this.DPI_FACTOR * body.clientHeight;
                        this.canvas.style.top = "0px";
                        this.canvas.style.left = "0px";
                        this.canvas.style.width = body.clientWidth + "px";
                        this.canvas.style.height = body.clientHeight + "px";
                        this.context = this.canvas.getContext("2d");
                        org.dyn4j.samples.framework.Graphics2DRenderer.initialize(this.context);
                        console.log("frame created");
                        this.world = new org.dyn4j.dynamics.World();
                        this.worldPopulator = new org.dyn4j.samples.Concave();
                        this.worldPopulator.populateWorld(this.world);
                        console.log("World populated with num bodies=" + this.world.getBodyCount());
                        this.camera = new org.dyn4j.samples.framework.Camera();
                        this.camera.scale = 100;
                        this.picking = new org.dyn4j.samples.framework.input.MousePickingInputHandler(this.canvas, this.camera, this.world);
                        this.picking.install();
                        this.panning = new org.dyn4j.samples.framework.input.MousePanningInputHandler(this.canvas, this.camera);
                        this.panning.install();
                        this.picking.getDependentBehaviors().add(this.panning);
                        this.panning.getDependentBehaviors().add(this.picking);
                        this.cameraKey = new org.dyn4j.samples.framework.input.KeyBoardCameraHandler(this.canvas, this.camera);
                        this.cameraKey.install();
                        this.controlsKey = new org.dyn4j.samples.framework.input.KeyBoardControlsHandler(this.canvas, this, this.camera);
                        this.controlsKey.install();
                        this.zoom = new org.dyn4j.samples.framework.input.MouseZoomInputHandler(this.canvas, this.camera, 0);
                        this.zoom.install();
                        this.start();
                    }
                    static main(args) {
                        window.onload = (e) => {
                            return new SimulationFrame();
                        };
                    }
                    /**
                     * Start active rendering the simulation.
                     * <p>
                     * This should be called after the JFrame has been shown.
                     * @private
                     */
                    /*private*/ start() {
                        this.last = java.lang.System.currentTimeMillis();
                        this.context.textAlign = "center";
                        this.context.textBaseline = "middle";
                        this.context.lineJoin = "round";
                        //this.context.shadowOffsetX = 6;
                       // this.context.shadowOffsetY = 6;
                       // this.context.shadowColor = "rgba(125, 125, 125, 0.5)"; // Transparent grey
                        window.requestAnimationFrame((time) => {
                            console.log("Simulation started");
                            this.gameLoop();
                        });
                        for (let i = 0; i < this.world.getBodyCount(); i++) {
                            {
                                const body = this.world.getBody(i);
                                for (let index = body.getFixtures$().iterator(); index.hasNext();) {
                                    let fixture = index.next();
                                    {
                                        const convex = fixture.getShape();
                                        console.log(convex);
                                    }
                                }
                            }
                            ;
                        }
                        const rect = new org.dyn4j.geometry.Rectangle(2, 1);
                        console.log("test react=" + rect);
                        const v = [new org.dyn4j.geometry.Vector2(0, 0), new org.dyn4j.geometry.Vector2(2, 0), new org.dyn4j.geometry.Vector2(1, 1)];
                        const p = new org.dyn4j.geometry.Polygon(v);
                        console.log("test pol=" + p);
                    }
                    /**
                     * The method calling the necessary methods to update the game, graphics, and
                     * poll for input.
                     * @private
                     */
                    /*private*/ gameLoop() {
                        const width = this.canvas.width / this.DPI_FACTOR;
                        const height = this.canvas.height / this.DPI_FACTOR;
                        const time = java.lang.System.currentTimeMillis();
                        const diff = time - this.last;
                        this.last = time;
                        const elapsedTime = diff / SimulationFrame.MILLI_TO_BASE;
                        this.context.save();
                        this.context.scale(this.DPI_FACTOR, this.DPI_FACTOR);
                        this.context.clearRect(0, 0, width, height);
                        this.context.fillText("FPS=" + Math.round(1 / elapsedTime) + " ms", 40, 40);
                        this.context.translate(width / 2, height / 2);
                        this.context.translate(this.camera.offsetX, -this.camera.offsetY);
                        this.context.fillText("Origin", 0, 0);
                        this.context.scale(this.camera.scale, -this.camera.scale);
                        this.context.lineWidth = 1 / this.camera.scale;
                        this.render(elapsedTime);
                        this.context.restore();
                        if (!this.paused) {
                            this.world.update$double(elapsedTime);
                        }
                        else if (this.__step) {
                            this.world.step$int(1);
                            this.stepNumber++;
                        }
                        this.handleEvents();
                        window.requestAnimationFrame((t) => {
                            this.gameLoop();
                        });
                    }
                    /**
                     * Renders the example.
                     *
                     * @param g           the graphics object to render to
                     * @param {number} elapsedTime the elapsed time from the last update
                     */
                    render(elapsedTime) {
                        const bounds = this.world.getBounds();
                        if (bounds != null && (bounds != null && bounds instanceof org.dyn4j.collision.AxisAlignedBounds)) {
                            const aab = bounds;
                            const aabb = aab.getBounds();
                            this.context.strokeStyle = "grey";
                            this.context.strokeRect(aabb.getMinX(), aabb.getMinY(), aabb.getWidth(), aabb.getHeight());
                        }
                        for (let i = 0; i < this.world.getBodyCount(); i++) {
                            {
                                const body = this.world.getBody(i);
                                this.renderBody(body);
                                if (this.renderBodyAABBs) {
                                    const aabb = this.world.getBroadphaseDetector().getAABB(body);
                                    this.context.strokeStyle = "red";
                                    this.context.strokeRect(aabb.getMinX(), aabb.getMinY(), aabb.getWidth(), aabb.getHeight());
                                }
                                if (this.renderBodyRotationRadius) {
                                    const c = body.getWorldCenter();
                                    const r = body.getRotationDiscRadius();
                                    this.context.beginPath();
                                    this.context.arc(c.x, c.y, r, 0, Math.PI * 2);
                                    this.context.strokeStyle = "blue";
                                    this.context.stroke();
                                }
                                for (let index = body.getFixtures$().iterator(); index.hasNext();) {
                                    let fixture = index.next();
                                    {
                                        if (this.renderFixtureAABBs) {
                                            const aabb = this.world.getBroadphaseDetector().getAABB(body, fixture);
                                            this.context.strokeStyle = "magenta";
                                            this.context.strokeRect(aabb.getMinX(), aabb.getMinY(), aabb.getWidth(), aabb.getHeight());
                                        }
                                        if (this.renderFixtureRotationRadius) {
                                            const tx = body.getTransform();
                                            const c = tx.getTransformed$org_dyn4j_geometry_Vector2(fixture.getShape().getCenter());
                                            const r = fixture.getShape()['getRadius$']();
                                            this.context.beginPath();
                                            this.context.arc(c.x, c.y, r, 0, Math.PI * 2);
                                            this.context.strokeStyle = "red";
                                            this.context.stroke();
                                        }
                                    }
                                }
                            }
                            ;
                        }
                        for (let i = 0; i < this.world.getJointCount(); i++) {
                            {
                                const j = this.world.getJoint(i);
                                this.renderJoint(j);
                            }
                            ;
                        }
                        if (this.renderContacts) {
                            this.drawContacts();
                        }
                    }
                    /*private*/ drawContacts() {
                        const cm = this.world.getContactManager();
                        cm.getContactCount();
                    }
                    renderJoint(joint) {
                        const selected = false;
                        if (joint != null && joint instanceof org.dyn4j.dynamics.joint.DistanceJoint) {
                            const dj = joint;
                            const target = dj.getDistance();
                            const val = Math.abs(target - dj.getAnchor1().distance$org_dyn4j_geometry_Vector2(dj.getAnchor2())) * 100;
                            const red = (Math.floor(Math.min(val, 255)) | 0);
                            this.context.strokeStyle = (("rgb(" + red + ",0,0)"));
                            org.dyn4j.samples.framework.Graphics2DRenderer.drawDistanceJoint(dj, false);
                        }
                        else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.PinJoint) {
                            const pj = joint;
                            const max = pj.getMaximumForce();
                            const val = pj.getReactionForce(this.world.getStep().getInverseDeltaTime()).getMagnitude();
                            const red = (Math.floor((val / max) * 255) | 0);
                            this.context.strokeStyle = (("rgb(" + red + ",0,0)"));
                        }
                        else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.PrismaticJoint) {
                            org.dyn4j.samples.framework.Graphics2DRenderer.drawPrismaticJoint(joint, selected);
                        }
                        else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.RevoluteJoint) {
                            org.dyn4j.samples.framework.Graphics2DRenderer.drawRevoluteJoint(joint, selected);
                        }
                        else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.RopeJoint) {
                            org.dyn4j.samples.framework.Graphics2DRenderer.drawRopeJoint(joint, selected);
                        }
                        else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.SpindleJoint) {
                            org.dyn4j.samples.framework.Graphics2DRenderer.drawSpindleJoint(joint, selected);
                        }
                        else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.WeldJoint) {
                            org.dyn4j.samples.framework.Graphics2DRenderer.drawWeldJoint(joint, selected);
                        }
                        else if (joint != null && joint instanceof org.dyn4j.dynamics.joint.SpringJoint) {
                            org.dyn4j.samples.framework.Graphics2DRenderer.drawSpringJoint(joint, selected);
                        }
                        else {
                            this.context.strokeStyle = "black";
                        }
                        const anchor1 = joint.getAnchor1();
                        const anchor2 = joint.getAnchor2();
                        this.context.strokeStyle = "black";
                        this.context.beginPath();
                        this.context.moveTo(anchor1.x, anchor1.y);
                        this.context.lineTo(anchor2.x, anchor2.y);
                        this.context.stroke();
                        this.context.fillStyle = "grey";
                        const dw = 0.05;
                        this.context.fillRect(anchor1.x - dw / 2, anchor1.y - dw / 2, dw, dw);
                        this.context.fillRect(anchor2.x - dw / 2, anchor2.y - dw / 2, dw, dw);
                    }
                    renderBody(body) {
                        const pr = 4;
                        this.context.save();
                        this.context.translate(body.getWorldCenter().x, body.getWorldCenter().y);
                        this.context.rotate(body.getTransform().getRotationAngle());
                        let color = body.getColor();
                        if (body.isAsleep()) {
                            color = color.brighter();
                        }
                        for (let index = body.getFixtures$().iterator(); index.hasNext();) {
                            let fixture = index.next();
                            {
                                const convex = fixture.getShape();
                                org.dyn4j.samples.framework.Graphics2DRenderer.render$org_dyn4j_geometry_Shape$org_dyn4j_samples_framework_Color(convex, color);
                            }
                        }
                        this.context.fillRect(0, 0, 0.02, 0.02);
                        this.context.restore();
                    }
                    toWorldCoordinates(p) {
                        return this.camera.toWorldCoordinates(this.canvas.width / this.DPI_FACTOR, this.canvas.height / this.DPI_FACTOR, p);
                    }
                    /**
                     * Used to handle any input events or custom code.
                     */
                    handleEvents() {
                        if (this.printSimulation) {
                            this.printSimulation = false;
                            console.log(this.toCode());
                        }
                        if (this.printStepNumber) {
                            this.printSimulation = false;
                            console.log("Step #" + this.stepNumber);
                        }
                    }
                    /**
                     * Stops the simulation.
                     */
                    stop() {
                        this.stopped = true;
                    }
                    /**
                     * Returns true if the simulation is stopped.
                     *
                     * @return {boolean} boolean true if stopped
                     */
                    isStopped() {
                        return this.stopped;
                    }
                    /**
                     * Pauses the simulation.
                     */
                    pause() {
                        this.paused = true;
                    }
                    /**
                     * Pauses the simulation.
                     */
                    resume() {
                        this.last = java.lang.System.currentTimeMillis();
                        this.paused = false;
                    }
                    /**
                     * Pauses the simulation.
                     */
                    step() {
                        this.paused = true;
                        this.__step = true;
                    }
                    /**
                     * Returns true if the simulation is paused.
                     *
                     * @return {boolean} boolean true if paused
                     */
                    isPaused() {
                        return this.paused;
                    }
                    /**
                     * Returns true if mouse picking is enabled.
                     *
                     * @return {boolean} boolean
                     */
                    isMousePickingEnabled() {
                        return this.picking.isEnabled();
                    }
                    /**
                     * Sets mouse picking enabled.
                     *
                     * @param {boolean} flag true if mouse picking should be enabled
                     */
                    setMousePickingEnabled(flag) {
                        this.picking.setEnabled(flag);
                    }
                    /**
                     * Returns true if mouse panning is enabled.
                     *
                     * @return {boolean} boolean
                     */
                    isMousePanningEnabled() {
                        return this.panning.isEnabled();
                    }
                    /**
                     * Sets mouse panning enabled.
                     *
                     * @param {boolean} flag true if mouse panning should be enabled
                     */
                    setMousePanningEnabled(flag) {
                        this.panning.setEnabled(flag);
                    }
                    /**
                     * Returns true if fixture AABB drawing is enabled.
                     *
                     * @return {boolean} boolean
                     */
                    isFixtureAABBDrawingEnabled() {
                        return this.renderFixtureAABBs;
                    }
                    /**
                     * Sets whether fixture AABB drawing is enabled.
                     *
                     * @param {boolean} flag true if drawing should be enabled
                     */
                    setFixtureAABBDrawingEnabled(flag) {
                        this.renderFixtureAABBs = flag;
                    }
                    /**
                     * Returns true if body AABB drawing is enabled.
                     *
                     * @return {boolean} boolean
                     */
                    isBodyAABBDrawingEnabled() {
                        return this.renderBodyAABBs;
                    }
                    /**
                     * Sets whether body AABB drawing is enabled.
                     *
                     * @param {boolean} flag true if drawing should be enabled
                     */
                    setBodyAABBDrawingEnabled(flag) {
                        this.renderBodyAABBs = flag;
                    }
                    /**
                     * Returns true if fixture rotation radius drawing is enabled.
                     *
                     * @return {boolean} boolean
                     */
                    isFixtureRotationRadiusDrawingEnabled() {
                        return this.renderFixtureRotationRadius;
                    }
                    /**
                     * Sets whether fixture rotation radius drawing is enabled.
                     *
                     * @param {boolean} flag true if drawing should be enabled
                     */
                    setFixtureRotationRadiusDrawingEnabled(flag) {
                        this.renderFixtureRotationRadius = flag;
                    }
                    /**
                     * Returns true if body rotation radius drawing is enabled.
                     *
                     * @return {boolean} boolean
                     */
                    isBodyRotationRadiusDrawingEnabled() {
                        return this.renderBodyRotationRadius;
                    }
                    /**
                     * Sets whether body rotation radius drawing is enabled.
                     *
                     * @param {boolean} flag true if drawing should be enabled
                     */
                    setBodyRotationRadiusDrawingEnabled(flag) {
                        this.renderBodyRotationRadius = flag;
                    }
                    /**
                     * Returns true if contact drawing is enabled.
                     *
                     * @return {boolean} boolean
                     */
                    isContactDrawingEnabled() {
                        return this.renderContacts;
                    }
                    /**
                     * Sets if contact drawing is enabled.
                     *
                     * @param {boolean} flag true if contact drawing should be enabled
                     */
                    setContactDrawingEnabled(flag) {
                        this.renderContacts = flag;
                    }
                    /**
                     * Returns the current scale (x pixels / meter)
                     *
                     * @return {number} double
                     */
                    getScale() {
                        return this.camera.scale;
                    }
                    /**
                     * Sets the scale (zoom).
                     *
                     * @param {number} scale the number of pixels per meter
                     */
                    setScale(scale) {
                        this.camera.scale = scale;
                    }
                    /**
                     * Returns the x offset (pan-x).
                     *
                     * @return {number} double
                     */
                    getOffsetX() {
                        return this.camera.offsetX;
                    }
                    /**
                     * Sets the x offset (pan-x).
                     *
                     * @param {number} offsetX the x offset in pixels
                     */
                    setOffsetX(offsetX) {
                        this.camera.offsetX = offsetX;
                    }
                    /**
                     * Returns the y offset (pan-y).
                     *
                     * @return {number} double
                     */
                    getOffsetY() {
                        return this.camera.offsetY;
                    }
                    /**
                     * Sets the y offset (pan-y).
                     *
                     * @param {number} offsetY the y offset in pixels
                     */
                    setOffsetY(offsetY) {
                        this.camera.offsetY = offsetY;
                    }
                    /**
                     * Generates Java code for the current state of the world.
                     *
                     * @return {string} String
                     */
                    toCode() {
                        return org.dyn4j.samples.framework.input.CodeExporter.export$java_lang_String$org_dyn4j_dynamics_World("World", this.world);
                    }
                }
                /**
                 * The conversion factor from nano to base
                 */
                SimulationFrame.MILLI_TO_BASE = 1000.0;
                framework.SimulationFrame = SimulationFrame;
                SimulationFrame["__class"] = "org.dyn4j.samples.framework.SimulationFrame";
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                /**
                 * Graphics2D renderer for dyn4j shape types.
                 * @class
                 */
                class Graphics2DRenderer {
                    static initialize(ctx) {
                        Graphics2DRenderer.context = ctx;
                    }
                    static render$org_dyn4j_geometry_Shape$org_dyn4j_samples_framework_Color(shape, color) {
                        if (shape == null)
                            return;
                        if (color == null)
                            color = new org.dyn4j.samples.framework.Color(200, 200, 0);
                        if (shape != null && shape instanceof org.dyn4j.geometry.Circle) {
                            Graphics2DRenderer.render$org_dyn4j_geometry_Circle$org_dyn4j_samples_framework_Color(shape, color);
                        }
                        else if (shape != null && shape instanceof org.dyn4j.geometry.Polygon) {
                            Graphics2DRenderer.render$org_dyn4j_geometry_Polygon$org_dyn4j_samples_framework_Color(shape, color);
                        }
                        else if (shape != null && shape instanceof org.dyn4j.geometry.Segment) {
                            Graphics2DRenderer.render$org_dyn4j_geometry_Segment$org_dyn4j_samples_framework_Color(shape, color);
                        }
                        else if (shape != null && shape instanceof org.dyn4j.geometry.Capsule) {
                            Graphics2DRenderer.render$org_dyn4j_geometry_Shape$org_dyn4j_samples_framework_Color(shape, color);
                        }
                        else if (shape != null && shape instanceof org.dyn4j.geometry.Ellipse) {
                            Graphics2DRenderer.render$org_dyn4j_geometry_Ellipse$org_dyn4j_samples_framework_Color(shape, color);
                        }
                        else if (shape != null && shape instanceof org.dyn4j.geometry.Slice) {
                            Graphics2DRenderer.render$org_dyn4j_geometry_Slice$org_dyn4j_samples_framework_Color(shape, color);
                        }
                        else if (shape != null && shape instanceof org.dyn4j.geometry.HalfEllipse) {
                            Graphics2DRenderer.render$org_dyn4j_geometry_HalfEllipse$org_dyn4j_samples_framework_Color(shape, color);
                        }
                        else {
                        }
                    }
                    static fillAndStroke(color) {
                        if (color != null)
                            Graphics2DRenderer.context.fillStyle = color.toString();
                        Graphics2DRenderer.context.fill();
                        if (color != null)
                            Graphics2DRenderer.context.strokeStyle = color.darker().toString();
                        Graphics2DRenderer.context.stroke();
                    }
                    static render$org_dyn4j_geometry_Circle$org_dyn4j_samples_framework_Color(circle, color) {
                        const radius = circle.getRadius$();
                        const center = circle.getCenter();
                        Graphics2DRenderer.drawCircle(center.x, center.y, radius, true, color);
                    }
                    /**
                     * Renders the given {@link Circle} to the given graphics context using the
                     * given scale and color.
                     *
                     * @param g      the graphics context
                     * @param circle the circle to render
                     * @param scale  the scale to render the shape (pixels per dyn4j unit (typically
                     * meter))
                     * @param {org.dyn4j.samples.framework.Color} color  the color
                     * @param {number} cx
                     * @param {number} cy
                     * @param {number} r
                     * @param {boolean} drawLine
                     */
                    static drawCircle(cx, cy, r, drawLine, color) {
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.arc(cx, cy, r, 0, Math.PI * 2, false);
                        if (drawLine) {
                            Graphics2DRenderer.context.moveTo(cx, cy);
                            Graphics2DRenderer.context.lineTo(cx + r, cy);
                        }
                        Graphics2DRenderer.fillAndStroke(color);
                    }
                    /**
                     * Draws a arrow with open lines from the given start in the direction of (dx, dy) with length l.
                     * @param gl the OpenGL context
                     * @param {number} sx the x coordinate of the start point
                     * @param {number} sy the y coordinate of the start point
                     * @param {number} dx the x value of the direction
                     * @param {number} dy the y value of the direction
                     * @param {number} l the length
                     */
                    static drawArrow(sx, sy, dx, dy, l) {
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.moveTo(sx, sy);
                        Graphics2DRenderer.context.lineTo(sx + dx * l, sy + dy * l);
                        Graphics2DRenderer.context.stroke();
                        let arrowhead = 0.05;
                        if (l < 2 * arrowhead)
                            arrowhead = l / 2;
                        sx = sx - dx * l / 4;
                        sy = sy - dy * l / 4;
                        Graphics2DRenderer.context.lineTo(sx + dx * (l - arrowhead) + 0.5 * arrowhead * dy, sy + dy * (l - arrowhead) - 0.5 * arrowhead * dx);
                        Graphics2DRenderer.context.lineTo(sx + dx * (l - arrowhead) - 0.5 * arrowhead * dy, sy + dy * (l - arrowhead) + 0.5 * arrowhead * dx);
                        Graphics2DRenderer.context.fill();
                    }
                    static render$org_dyn4j_geometry_Polygon$org_dyn4j_samples_framework_Color(polygon, color) {
                        const vertices = polygon.getVertices();
                        const l = vertices.length;
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.moveTo(vertices[0].x, vertices[0].y);
                        for (let i = 1; i < l; i++) {
                            {
                                Graphics2DRenderer.context.lineTo(vertices[i].x, vertices[i].y);
                            }
                            ;
                        }
                        Graphics2DRenderer.context.closePath();
                        Graphics2DRenderer.fillAndStroke(color);
                    }
                    static render$org_dyn4j_geometry_Segment$org_dyn4j_samples_framework_Color(segment, color) {
                        const vertices = segment.getVertices();
                        const l = vertices.length;
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.moveTo(vertices[0].x, vertices[0].y);
                        for (let i = 1; i < l; i++) {
                            {
                                Graphics2DRenderer.context.lineTo(vertices[i].x, vertices[i].y);
                            }
                            ;
                        }
                        Graphics2DRenderer.context.closePath();
                        Graphics2DRenderer.fillAndStroke(color);
                    }
                    static render$org_dyn4j_geometry_Capsule$double$org_dyn4j_samples_framework_Color(capsule, scale, color) {
                        const rotation = capsule.getRotationAngle();
                        const center = capsule.getCenter();
                        Graphics2DRenderer.context.save();
                        Graphics2DRenderer.context.translate(center.x, center.y);
                        Graphics2DRenderer.context.rotate(rotation);
                        const width = capsule.getLength();
                        const radius = capsule.getCapRadius();
                        const radius2 = radius * 2.0;
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.arc(-(width * 0.5), 0, radius2, Math.PI / 2, 3 * Math.PI / 2, true);
                        Graphics2DRenderer.context.moveTo(-(width * 0.5), -radius);
                        Graphics2DRenderer.context.arc((width * 0.5), 0, radius2, -Math.PI / 2, Math.PI / 2, true);
                        Graphics2DRenderer.fillAndStroke(color);
                        Graphics2DRenderer.context.restore();
                    }
                    /**
                     * Renders the given {@link Capsule} to the given graphics context using the
                     * given scale and color.
                     *
                     * @param g       the graphics context
                     * @param {org.dyn4j.geometry.Capsule} capsule the capsule to render
                     * @param {number} scale   the scale to render the shape (pixels per dyn4j unit
                     * (typically meter))
                     * @param {org.dyn4j.samples.framework.Color} color   the color
                     */
                    static render(capsule, scale, color) {
                        if (((capsule != null && capsule instanceof org.dyn4j.geometry.Capsule) || capsule === null) && ((typeof scale === 'number') || scale === null) && ((color != null && color instanceof org.dyn4j.samples.framework.Color) || color === null)) {
                            return org.dyn4j.samples.framework.Graphics2DRenderer.render$org_dyn4j_geometry_Capsule$double$org_dyn4j_samples_framework_Color(capsule, scale, color);
                        }
                        else if (((capsule != null && capsule instanceof org.dyn4j.geometry.Circle) || capsule === null) && ((scale != null && scale instanceof org.dyn4j.samples.framework.Color) || scale === null) && color === undefined) {
                            return org.dyn4j.samples.framework.Graphics2DRenderer.render$org_dyn4j_geometry_Circle$org_dyn4j_samples_framework_Color(capsule, scale);
                        }
                        else if (((capsule != null && capsule instanceof org.dyn4j.geometry.Polygon) || capsule === null) && ((scale != null && scale instanceof org.dyn4j.samples.framework.Color) || scale === null) && color === undefined) {
                            return org.dyn4j.samples.framework.Graphics2DRenderer.render$org_dyn4j_geometry_Polygon$org_dyn4j_samples_framework_Color(capsule, scale);
                        }
                        else if (((capsule != null && capsule instanceof org.dyn4j.geometry.Segment) || capsule === null) && ((scale != null && scale instanceof org.dyn4j.samples.framework.Color) || scale === null) && color === undefined) {
                            return org.dyn4j.samples.framework.Graphics2DRenderer.render$org_dyn4j_geometry_Segment$org_dyn4j_samples_framework_Color(capsule, scale);
                        }
                        else if (((capsule != null && capsule instanceof org.dyn4j.geometry.Ellipse) || capsule === null) && ((scale != null && scale instanceof org.dyn4j.samples.framework.Color) || scale === null) && color === undefined) {
                            return org.dyn4j.samples.framework.Graphics2DRenderer.render$org_dyn4j_geometry_Ellipse$org_dyn4j_samples_framework_Color(capsule, scale);
                        }
                        else if (((capsule != null && capsule instanceof org.dyn4j.geometry.Slice) || capsule === null) && ((scale != null && scale instanceof org.dyn4j.samples.framework.Color) || scale === null) && color === undefined) {
                            return org.dyn4j.samples.framework.Graphics2DRenderer.render$org_dyn4j_geometry_Slice$org_dyn4j_samples_framework_Color(capsule, scale);
                        }
                        else if (((capsule != null && capsule instanceof org.dyn4j.geometry.HalfEllipse) || capsule === null) && ((scale != null && scale instanceof org.dyn4j.samples.framework.Color) || scale === null) && color === undefined) {
                            return org.dyn4j.samples.framework.Graphics2DRenderer.render$org_dyn4j_geometry_HalfEllipse$org_dyn4j_samples_framework_Color(capsule, scale);
                        }
                        else if (((capsule != null && (capsule.constructor != null && capsule.constructor["__interfaces"] != null && capsule.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Shape") >= 0)) || capsule === null) && ((scale != null && scale instanceof org.dyn4j.samples.framework.Color) || scale === null) && color === undefined) {
                            return org.dyn4j.samples.framework.Graphics2DRenderer.render$org_dyn4j_geometry_Shape$org_dyn4j_samples_framework_Color(capsule, scale);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static render$org_dyn4j_geometry_Ellipse$org_dyn4j_samples_framework_Color(ellipse, color) {
                        const rotation = ellipse.getRotationAngle();
                        const center = ellipse.getCenter();
                        const width = ellipse.getWidth();
                        const height = ellipse.getHeight();
                        Graphics2DRenderer.context.save();
                        Graphics2DRenderer.context.translate(center.x, center.y);
                        Graphics2DRenderer.context.rotate(rotation);
                        Graphics2DRenderer.context.scale(width, height);
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.arc(0, 0, 1, 0, Math.PI * 2, false);
                        Graphics2DRenderer.fillAndStroke(color);
                        Graphics2DRenderer.context.restore();
                    }
                    static render$org_dyn4j_geometry_Slice$org_dyn4j_samples_framework_Color(slice, color) {
                    }
                    static render$org_dyn4j_geometry_HalfEllipse$org_dyn4j_samples_framework_Color(halfEllipse, color) {
                    }
                    /**
                     * Returns a random color.
                     *
                     * @return {org.dyn4j.samples.framework.Color} Color
                     */
                    static getRandomColor() {
                        return new org.dyn4j.samples.framework.Color(((Math.random() * 255) | 0), ((Math.random() * 255) | 0), ((Math.random() * 255) | 0));
                    }
                    /**
                     * Renders a RevoluteJoint to the given graphics object.
                     * @param gl the OpenGL graphics context
                     * @param {org.dyn4j.dynamics.joint.RevoluteJoint} joint the joint
                     * @param {boolean} selected
                     */
                    static drawRevoluteJoint(joint, selected) {
                        const r1 = Math.fround(0.06 * joint.getSize());
                        let r = Math.fround(0.025 * joint.getSize());
                        const r2 = Math.fround(r1 + Math.fround(3 * r));
                        Graphics2DRenderer.context.save();
                        Graphics2DRenderer.context.translate(joint.getAnchor1().x, joint.getAnchor1().y);
                        Graphics2DRenderer.context.rotate(joint.getBody1().getTransform().getRotationAngle());
                        Graphics2DRenderer.context.globalAlpha = 0.6;
                        Graphics2DRenderer.drawCircle(0, 0, r2, false, null);
                        Graphics2DRenderer.context.globalAlpha = 0.5;
                        Graphics2DRenderer.drawCircle(0, 0, r1, false, null);
                        r = Math.fround(Math.fround(r1 + r) + Math.fround(r / 2));
                        const rad = 0.025 * joint.getSize();
                        Graphics2DRenderer.context.globalAlpha = 0.35;
                        Graphics2DRenderer.drawCircle(r, 0, rad, false, null);
                        Graphics2DRenderer.drawCircle(-r, 0, rad, false, null);
                        Graphics2DRenderer.drawCircle(0, r, rad, false, null);
                        Graphics2DRenderer.drawCircle(0, -r, rad, false, null);
                        Graphics2DRenderer.context.restore();
                    }
                    /**
                     * Renders a WeldJoint to the given graphics object.
                     * @param gl the OpenGL graphics context
                     * @param {org.dyn4j.dynamics.joint.WeldJoint} joint the joint
                     * @param {boolean} selected
                     */
                    static drawWeldJoint(joint, selected) {
                        const anchor = joint.getAnchor1();
                        const d = 0.05 * joint.getSize();
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.moveTo(anchor.x - d, anchor.y - d);
                        Graphics2DRenderer.context.lineTo(anchor.x + d, anchor.y + d);
                        Graphics2DRenderer.context.moveTo(anchor.x - d, anchor.y + d);
                        Graphics2DRenderer.context.lineTo(anchor.x + d, anchor.y - d);
                        Graphics2DRenderer.context.stroke();
                    }
                    /**
                     * Renders a RopeJoint to the given graphics object.
                     * @param gl the OpenGL graphics context
                     * @param {org.dyn4j.dynamics.joint.SpindleJoint} joint the joint
                     * @param {boolean} selected
                     */
                    static drawSpindleJoint(joint, selected) {
                        const lw = Graphics2DRenderer.context.lineWidth;
                        Graphics2DRenderer.context.lineWidth = 2;
                        const v1 = joint.getAnchor1();
                        const v2 = joint.getAnchor2();
                        if (joint.getRadius1() === 0 || joint.getBody1().getWorld() == null || joint.getBody1().getFixtureCount() === 0) {
                            Graphics2DRenderer.context.fillRect(v1.x, v1.y, 0.03, 0.03);
                        }
                        else {
                            Graphics2DRenderer.drawCircle(joint.getBody1().getWorldCenter().x, joint.getBody1().getWorldCenter().y, joint.getRadius1(), false, null);
                        }
                        if (joint.getRadius2() === 0 || joint.getBody2().getWorld() == null || joint.getBody1().getFixtureCount() === 0) {
                            Graphics2DRenderer.context.fillRect(v2.x, v2.y, 0.03, 0.03);
                        }
                        else {
                            Graphics2DRenderer.drawCircle(joint.getBody2().getWorldCenter().x, joint.getBody2().getWorldCenter().y, joint.getRadius2(), true, null);
                        }
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.moveTo(v1.x, v1.y);
                        Graphics2DRenderer.context.lineTo(v2.x, v2.y);
                        Graphics2DRenderer.context.stroke();
                        Graphics2DRenderer.context.lineWidth = lw;
                    }
                    /**
                     * Draws the given distance joint.
                     * @param gl the OpenGL context
                     * @param {org.dyn4j.dynamics.joint.SpringJoint} joint the joint
                     * @param {boolean} selected
                     */
                    static drawSpringJoint(joint, selected) {
                        const lw = Graphics2DRenderer.context.lineWidth;
                        Graphics2DRenderer.context.lineWidth = 0.02;
                        const v1 = joint.getAnchor1();
                        const v2 = joint.getAnchor2();
                        const h = 0.025;
                        const w = 0.18;
                        const offset = h * 3.0;
                        let loops = (Math.ceil(5 * (joint.getNaturalLength() - offset * 2.0) / w) | 0);
                        if (loops < 10)
                            loops = 10;
                        const n = v1.to$org_dyn4j_geometry_Vector2(v2);
                        const x = n.normalize();
                        const t = n.getRightHandOrthogonalVector();
                        const d = (x - offset * 2.0) / (loops - 1);
                        const d1 = n.product(offset).add$org_dyn4j_geometry_Vector2(v1);
                        Graphics2DRenderer.context.fillRect(v1.x - 0.03, v1.y + 0.03, 0.06, 0.06);
                        Graphics2DRenderer.context.fillRect(v2.x - 0.03, v2.y + 0.03, 0.06, 0.06);
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.moveTo(v1.x, v1.y);
                        Graphics2DRenderer.context.lineTo(d1.x, d1.y);
                        let ct = t.product(w * 0.4);
                        let cn = n.product(d * 0.4);
                        const first = ct.sum$org_dyn4j_geometry_Vector2(cn).add$org_dyn4j_geometry_Vector2(d1);
                        Graphics2DRenderer.context.lineTo(first.x, first.y);
                        let prev = first;
                        for (let i = 1; i < loops - 1; i++) {
                            {
                                ct = t.product(w * 0.5 * ((i + 1) % 2 === 1 ? 1.0 : -1.0));
                                if ((i + 1) % 2 === 1)
                                    Graphics2DRenderer.context.globalAlpha = 0.3;
                                else
                                    Graphics2DRenderer.context.globalAlpha = 0.8;
                                cn = n.product(d * (i + 0.5) + offset);
                                const p2 = ct.sum$org_dyn4j_geometry_Vector2(cn).add$org_dyn4j_geometry_Vector2(v1);
                                Graphics2DRenderer.context.lineTo(p2.x, p2.y);
                                prev = p2;
                            }
                            ;
                        }
                        const d2 = n.product(-offset).add$org_dyn4j_geometry_Vector2(v2);
                        Graphics2DRenderer.context.lineTo(d2.x, d2.y);
                        Graphics2DRenderer.context.lineTo(v2.x, v2.y);
                        Graphics2DRenderer.context.stroke();
                        Graphics2DRenderer.context.lineWidth = lw;
                    }
                    /**
                     * Draws the given distance joint.
                     * @param gl the OpenGL context
                     * @param {org.dyn4j.dynamics.joint.DistanceJoint} joint the joint
                     * @param {boolean} selected
                     */
                    static drawDistanceJoint(joint, selected) {
                        const v1 = joint.getAnchor1();
                        const v2 = joint.getAnchor2();
                        const t = v1.to$org_dyn4j_geometry_Vector2(v2);
                        t.normalize();
                        t.left();
                        t.multiply(0.015);
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.moveTo(v1.x - t.x, v1.y - t.y);
                        Graphics2DRenderer.context.lineTo(v1.x + t.x, v1.y + t.y);
                        Graphics2DRenderer.context.lineTo(v2.x + t.x, v2.y + t.y);
                        Graphics2DRenderer.context.lineTo(v2.x - t.x, v2.y - t.y);
                        Graphics2DRenderer.context.closePath();
                        Graphics2DRenderer.fillAndStroke(null);
                        Graphics2DRenderer.drawCircle(v1.x, v1.y, 0.03, false, null);
                        Graphics2DRenderer.drawCircle(v2.x, v2.y, 0.03, false, null);
                    }
                    /**
                     * Renders a PrismaticJoint to the given graphics object.
                     * @param gl the OpenGL graphics context
                     * @param {org.dyn4j.dynamics.joint.PrismaticJoint} joint the joint
                     * @param {boolean} selected
                     */
                    static drawPrismaticJoint(joint, selected) {
                        const lf = 0.75;
                        const w = 0.1;
                        const hw = w * 0.5;
                        const b1 = joint.getBody1();
                        const b2 = joint.getBody2();
                        const c1 = joint.getAnchor1();
                        const c2 = joint.getAnchor2();
                        const c3 = b1.getWorldCenter();
                        const c4 = b2.getWorldCenter();
                        const n = c1.to$org_dyn4j_geometry_Vector2(c2);
                        const l = n.normalize();
                        let L = joint.getUpperLimit();
                        if (L > 2 * l)
                            L = 2 * l;
                        let t = n.product(w * 0.25).left();
                        let v = c1.sum$org_dyn4j_geometry_Vector2(n.product(L * 0.5 + (1 / 100 | 0)));
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.moveTo(c1.x - t.x, c1.y - t.y);
                        Graphics2DRenderer.context.lineTo(c1.x + t.x, c1.y + t.y);
                        Graphics2DRenderer.context.lineTo(v.x + t.x, v.y + t.y);
                        Graphics2DRenderer.context.lineTo(v.x - t.x, v.y - t.y);
                        Graphics2DRenderer.context.closePath();
                        Graphics2DRenderer.fillAndStroke(null);
                        Graphics2DRenderer.drawCircle(c1.x, c1.y, w / 3, false, null);
                        v = c2.sum$org_dyn4j_geometry_Vector2(n.product(-L * 0.5 - (1 / 100 | 0)));
                        Graphics2DRenderer.context.beginPath();
                        t = n.cross$double(1.0);
                        Graphics2DRenderer.context.moveTo(c2.x + t.x * hw, c2.y + t.y * hw);
                        Graphics2DRenderer.context.lineTo(v.x + t.x * hw, v.y + t.y * hw);
                        Graphics2DRenderer.context.lineTo(v.x - t.x * hw, v.y - t.y * hw);
                        Graphics2DRenderer.context.lineTo(c2.x - t.x * hw, c2.y - t.y * hw);
                        Graphics2DRenderer.context.closePath();
                        Graphics2DRenderer.fillAndStroke(null);
                        Graphics2DRenderer.context.beginPath();
                        t = n.cross$double(1.0);
                        Graphics2DRenderer.context.moveTo(c2.x + t.x * hw, c2.y + t.y * hw);
                        Graphics2DRenderer.context.lineTo(v.x + t.x * hw, v.y + t.y * hw);
                        Graphics2DRenderer.context.lineTo(v.x - t.x * hw, v.y - t.y * hw);
                        Graphics2DRenderer.context.lineTo(c2.x - t.x * hw, c2.y - t.y * hw);
                        Graphics2DRenderer.context.closePath();
                        Graphics2DRenderer.fillAndStroke(null);
                    }
                    /**
                     * Renders a RopeJoint to the given graphics object.
                     * @param gl the OpenGL graphics context
                     * @param {org.dyn4j.dynamics.joint.RopeJoint} joint the joint
                     * @param {boolean} selected
                     */
                    static drawRopeJoint(joint, selected) {
                        const lw = Graphics2DRenderer.context.lineWidth;
                        Graphics2DRenderer.context.lineWidth = 1.8;
                        const v1 = joint.getAnchor1();
                        const v2 = joint.getAnchor2();
                        Graphics2DRenderer.drawRope(v1, v2, joint.getUpperLimit());
                        Graphics2DRenderer.context.lineWidth = lw;
                    }
                    /*private*/ static drawRope(v1, v2, naturalLength) {
                        Graphics2DRenderer.context.fillRect(v1.x - 0.03, v1.y + 0.03, 0.03, 0.03);
                        Graphics2DRenderer.context.fillRect(v2.x - 0.03, v2.y + 0.03, 0.03, 0.03);
                        const h = 0.03;
                        const offset = 3 * h;
                        const loops = (Math.ceil((naturalLength - offset * 2.0) / h) | 0);
                        const numSegments = 12;
                        const n = v1.to$org_dyn4j_geometry_Vector2(v2);
                        const x = n.normalize();
                        const t = n.getRightHandOrthogonalVector();
                        const d = (x - offset * 2.0) / (loops - 1);
                        let delta = naturalLength - x;
                        if (delta <= 0) {
                            Graphics2DRenderer.context.beginPath();
                            Graphics2DRenderer.context.moveTo(v1.x, v1.y);
                            Graphics2DRenderer.context.lineTo(v2.x, v2.y);
                            Graphics2DRenderer.context.stroke();
                            return;
                        }
                        delta = delta * 0.8;
                        const amp = 0.8 * Math.sqrt(delta * delta + 2 * delta * x) / numSegments;
                        const d1 = n.product(offset).add$org_dyn4j_geometry_Vector2(v1);
                        Graphics2DRenderer.context.beginPath();
                        Graphics2DRenderer.context.moveTo(v1.x, v1.y);
                        Graphics2DRenderer.context.lineTo(d1.x, d1.y);
                        let ct = t.product(0);
                        let cn = n.product(d * 0.5);
                        const first = ct.sum$org_dyn4j_geometry_Vector2(cn).add$org_dyn4j_geometry_Vector2(d1);
                        Graphics2DRenderer.context.moveTo(d1.x, d1.y);
                        Graphics2DRenderer.context.lineTo(first.x, first.y);
                        let prev = first;
                        for (let i = 1; i < loops - 1; i++) {
                            {
                                ct = t.product(amp * Math.sin(numSegments * i * Math.PI / loops));
                                cn = n.product(d * (i + 0.5) + offset);
                                const p2 = ct.sum$org_dyn4j_geometry_Vector2(cn).add$org_dyn4j_geometry_Vector2(v1);
                                Graphics2DRenderer.context.moveTo(prev.x, prev.y);
                                Graphics2DRenderer.context.lineTo(p2.x, p2.y);
                                prev = p2;
                            }
                            ;
                        }
                        const d2 = n.product(-offset).add$org_dyn4j_geometry_Vector2(v2);
                        Graphics2DRenderer.context.moveTo(prev.x, prev.y);
                        Graphics2DRenderer.context.lineTo(d2.x, d2.y);
                        Graphics2DRenderer.context.moveTo(d2.x, d2.y);
                        Graphics2DRenderer.context.lineTo(v2.x, v2.y);
                        Graphics2DRenderer.context.stroke();
                    }
                }
                Graphics2DRenderer.context = null;
                Graphics2DRenderer.world = null;
                framework.Graphics2DRenderer = Graphics2DRenderer;
                Graphics2DRenderer["__class"] = "org.dyn4j.samples.framework.Graphics2DRenderer";
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                /**
                 * Stores the zoom and panning state of the camera.
                 * @author William Bittle
                 * @version 4.1.1
                 * @since 4.1.1
                 * @class
                 */
                class Camera {
                    constructor() {
                        this.scale = 100;
                        this.offsetX = 0;
                        this.offsetY = 0;
                    }
                    /**
                     * Returns World coordinates for the given point given the width/height of the viewport.
                     * @param {number} width the viewport width
                     * @param {number} height the viewport height
                     * @param {org.dyn4j.geometry.Vector2} p the point
                     * @return {org.dyn4j.geometry.Vector2} Vector2
                     */
                    toWorldCoordinates(width, height, p) {
                        if (p != null) {
                            const v = new org.dyn4j.geometry.Vector2();
                            width /= 2;
                            height /= 2;
                            v.x = (p.x - width * 0.5 - this.offsetX) / this.scale;
                            v.y = -(p.y - height * 0.5 + this.offsetY) / this.scale;
                            return v;
                        }
                        return null;
                    }
                }
                framework.Camera = Camera;
                Camera["__class"] = "org.dyn4j.samples.framework.Camera";
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                /**
                 * Constructs a new Color with all components set to 0.
                 * @param {number} red
                 * @param {number} green
                 * @param {number} blue
                 * @class
                 */
                class Color {
                    constructor(red, green, blue) {
                        if (this.r === undefined) {
                            this.r = 0;
                        }
                        if (this.g === undefined) {
                            this.g = 0;
                        }
                        if (this.b === undefined) {
                            this.b = 0;
                        }
                        this.FACTOR = 1.1;
                        this.r = red;
                        this.g = green;
                        this.b = blue;
                    }
                    brighter() {
                        if (this.r === 255 && this.g === 255 && this.b === 255) {
                            return new Color(255, 255, 255);
                        }
                        let r = ((this.r * this.FACTOR) | 0);
                        let g = ((this.g * this.FACTOR) | 0);
                        let b = ((this.b * this.FACTOR) | 0);
                        if (r > 255)
                            r = 255;
                        if (g > 255)
                            g = 255;
                        if (b > 255)
                            b = 255;
                        return new Color(r, g, b);
                    }
                    darker() {
                        if (this.r === 0 && this.g === 0 && this.b === 0) {
                            return new Color(0, 0, 0);
                        }
                        const r = ((this.r / this.FACTOR) | 0);
                        const g = ((this.g / this.FACTOR) | 0);
                        const b = ((this.b / this.FACTOR) | 0);
                        return new Color(r, g, b);
                    }
                    /**
                     * Returns the color encoded as hex string with the format RRGGBBAA.
                     * @return {string}
                     */
                    toString() {
                        let value = javaemul.internal.IntegerHelper.toHexString((this.r << 24) | (this.g << 16) | (this.b));
                        while ((value.length < 8)) {
                            value = "0" + value;
                        }
                        ;
                        return "#" + value;
                    }
                }
                framework.Color = Color;
                Color["__class"] = "org.dyn4j.samples.framework.Color";
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            class WorldCreator {
            }
            samples.WorldCreator = WorldCreator;
            WorldCreator["__class"] = "org.dyn4j.samples.WorldCreator";
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        /**
         * Class containing an approximation of machine epsilon.
         * @author William Bittle
         * @version 2.0.0
         * @since 2.0.0
         * @class
         */
        class Epsilon {
            constructor() {
            }
            static E_$LI$() { if (Epsilon.E == null) {
                Epsilon.E = Epsilon.compute();
            } return Epsilon.E; }
            /**
             * Computes an approximation of machine epsilon.
             * @return {number} double
             */
            static compute() {
                let e = 0.5;
                while ((1.0 + e > 1.0)) {
                    {
                        e *= 0.5;
                    }
                }
                ;
                return e;
            }
        }
        dyn4j.Epsilon = Epsilon;
        Epsilon["__class"] = "org.dyn4j.Epsilon";
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            class ResolverRadialChaikin {
                static tmp_$LI$() { if (ResolverRadialChaikin.tmp == null) {
                    ResolverRadialChaikin.tmp = (new java.util.ArrayList());
                } return ResolverRadialChaikin.tmp; }
                static resolve(input, output) {
                    output.clear();
                    if (input.size() <= 2) {
                        output.addAll(input);
                        return;
                    }
                    if (ResolverRadialChaikin.simplifyTolerance > 0 && input.size() > 3) {
                        ResolverRadialChaikin.simplify(input, Math.fround(ResolverRadialChaikin.simplifyTolerance * ResolverRadialChaikin.simplifyTolerance), ResolverRadialChaikin.tmp_$LI$());
                        input = ResolverRadialChaikin.tmp_$LI$();
                    }
                    if (ResolverRadialChaikin.iterations <= 0) {
                        output.addAll(input);
                    }
                    else if (ResolverRadialChaikin.iterations === 1) {
                        ResolverRadialChaikin.smooth(input, output);
                    }
                    else {
                        let iters = ResolverRadialChaikin.iterations;
                        do {
                            {
                                ResolverRadialChaikin.smooth(input, output);
                                ResolverRadialChaikin.tmp_$LI$().clear();
                                ResolverRadialChaikin.tmp_$LI$().addAll(output);
                                const old = output;
                                input = ResolverRadialChaikin.tmp_$LI$();
                                output = old;
                            }
                        } while ((--iters > 0));
                    }
                }
                static smooth(input, output) {
                    output.clear();
                    output.ensureCapacity(input.size() * 2);
                    output.add(input.get(0));
                    for (let i = 0; i < input.size() - 1; i++) {
                        {
                            const p0 = input.get(i);
                            const p1 = input.get(i + 1);
                            const Q = new org.dyn4j.geometry.Vector2(0.75 * p0.x + 0.25 * p1.x, 0.75 * p0.y + 0.25 * p1.y);
                            const R = new org.dyn4j.geometry.Vector2(0.25 * p0.x + 0.75 * p1.x, 0.25 * p0.y + 0.75 * p1.y);
                            output.add(Q);
                            output.add(R);
                        }
                        ;
                    }
                    output.add(input.get(input.size() - 1));
                }
                static simplify(points, sqTolerance, out) {
                    const len = points.size();
                    let point = new org.dyn4j.geometry.Vector2();
                    let prevPoint = points.get(0);
                    out.clear();
                    out.add(prevPoint);
                    for (let i = 1; i < len; i++) {
                        {
                            point = points.get(i);
                            if (ResolverRadialChaikin.distSq(point, prevPoint) > sqTolerance) {
                                out.add(point);
                                prevPoint = point;
                            }
                        }
                        ;
                    }
                    if (!prevPoint.equals$org_dyn4j_geometry_Vector2(point)) {
                        out.add(point);
                    }
                }
                static distSq(p1, p2) {
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    return dx * dx + dy * dy;
                }
            }
            ResolverRadialChaikin.iterations = 2;
            ResolverRadialChaikin.simplifyTolerance = 0.1;
            geometry.ResolverRadialChaikin = ResolverRadialChaikin;
            ResolverRadialChaikin["__class"] = "org.dyn4j.geometry.ResolverRadialChaikin";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Public copy constructor constructor
             * @param {org.dyn4j.geometry.Transform} transform the transform to copy
             * @since 3.4.0
             * @class
             * @author William Bittle
             */
            class Transform {
                constructor(cost, sint, x, y) {
                    if (((typeof cost === 'number') || cost === null) && ((typeof sint === 'number') || sint === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        let __args = arguments;
                        this.cost = 1.0;
                        this.sint = 0.0;
                        this.x = 0.0;
                        this.y = 0.0;
                        this.cost = cost;
                        this.sint = sint;
                        this.x = x;
                        this.y = y;
                    }
                    else if (((cost != null && cost instanceof org.dyn4j.geometry.Transform) || cost === null) && sint === undefined && x === undefined && y === undefined) {
                        let __args = arguments;
                        let transform = __args[0];
                        this.cost = 1.0;
                        this.sint = 0.0;
                        this.x = 0.0;
                        this.y = 0.0;
                        this.cost = transform.cost;
                        this.sint = transform.sint;
                        this.x = transform.x;
                        this.y = transform.y;
                    }
                    else if (cost === undefined && sint === undefined && x === undefined && y === undefined) {
                        let __args = arguments;
                        this.cost = 1.0;
                        this.sint = 0.0;
                        this.x = 0.0;
                        this.y = 0.0;
                    }
                    else
                        throw new Error('invalid overload');
                }
                static IDENTITY_$LI$() { if (Transform.IDENTITY == null) {
                    Transform.IDENTITY = new Transform();
                } return Transform.IDENTITY; }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("[").append(this.cost).append(" ").append(-this.sint).append(" | ").append(this.x).append("]").append("[").append(this.sint).append(" ").append(this.cost).append(" | ").append(this.y).append("]");
                    return sb.toString();
                }
                rotate$double$double(c, s) {
                    const cost = c * this.cost - s * this.sint;
                    const sint = s * this.cost + c * this.sint;
                    const x = c * this.x - s * this.y;
                    const y = s * this.x + c * this.y;
                    this.cost = cost;
                    this.sint = sint;
                    this.x = x;
                    this.y = y;
                }
                rotate$double(theta) {
                    this.rotate$double$double(Math.cos(theta), Math.sin(theta));
                }
                rotate$org_dyn4j_geometry_Rotation(rotation) {
                    this.rotate$double$double(rotation.cost, rotation.sint);
                }
                rotate$double$double$double$double(c, s, x, y) {
                    let cost = c * this.cost - s * this.sint;
                    let sint = s * this.cost + c * this.sint;
                    if (cost > 1) {
                        cost = 1;
                        sint = 0;
                    }
                    else if (cost < -1) {
                        cost = -1;
                        sint = 0;
                    }
                    this.cost = cost;
                    this.sint = sint;
                    const cx = this.x - x;
                    const cy = this.y - y;
                    this.x = c * cx - s * cy + x;
                    this.y = s * cx + c * cy + y;
                }
                /**
                 * Internal helper method to rotate this {@link Transform} by an angle &thetasym; around a point
                 * @param {number} c cos(&thetasym;)
                 * @param {number} s sin(&thetasym;)
                 * @param {number} x the x coordinate of the point
                 * @param {number} y the y coordinate of the point
                 * @since 3.4.0
                 */
                rotate(c, s, x, y) {
                    if (((typeof c === 'number') || c === null) && ((typeof s === 'number') || s === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double$double(c, s, x, y);
                    }
                    else if (((c != null && c instanceof org.dyn4j.geometry.Rotation) || c === null) && ((typeof s === 'number') || s === null) && ((typeof x === 'number') || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$double$double(c, s, x);
                    }
                    else if (((typeof c === 'number') || c === null) && ((typeof s === 'number') || s === null) && ((typeof x === 'number') || x === null) && y === undefined) {
                        return this.rotate$double$double$double(c, s, x);
                    }
                    else if (((c != null && c instanceof org.dyn4j.geometry.Rotation) || c === null) && ((s != null && s instanceof org.dyn4j.geometry.Vector2) || s === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(c, s);
                    }
                    else if (((typeof c === 'number') || c === null) && ((s != null && s instanceof org.dyn4j.geometry.Vector2) || s === null) && x === undefined && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(c, s);
                    }
                    else if (((typeof c === 'number') || c === null) && ((typeof s === 'number') || s === null) && x === undefined && y === undefined) {
                        return this.rotate$double$double(c, s);
                    }
                    else if (((c != null && c instanceof org.dyn4j.geometry.Rotation) || c === null) && s === undefined && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(c);
                    }
                    else if (((typeof c === 'number') || c === null) && s === undefined && x === undefined && y === undefined) {
                        return this.rotate$double(c);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$double$double$double(theta, x, y) {
                    this.rotate$double$double$double$double(Math.cos(theta), Math.sin(theta), x, y);
                }
                rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    this.rotate$double$double$double$double(rotation.cost, rotation.sint, x, y);
                }
                rotate$double$org_dyn4j_geometry_Vector2(theta, point) {
                    this.rotate$double$double$double(theta, point.x, point.y);
                }
                rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, point) {
                    this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, point.x, point.y);
                }
                translate$double$double(x, y) {
                    this.x += x;
                    this.y += y;
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$org_dyn4j_geometry_Vector2(vector) {
                    this.x += vector.x;
                    this.y += vector.y;
                }
                /**
                 * Copies this {@link Transform}.
                 * @return {org.dyn4j.geometry.Transform} {@link Transform}
                 */
                copy() {
                    return new Transform(this);
                }
                /**
                 * Sets this transform to the given transform.
                 * @param {org.dyn4j.geometry.Transform} transform the transform to copy
                 * @since 1.1.0
                 */
                set(transform) {
                    this.cost = transform.cost;
                    this.sint = transform.sint;
                    this.x = transform.x;
                    this.y = transform.y;
                }
                /**
                 * Sets this {@link Transform} to the identity.
                 */
                identity() {
                    this.cost = 1;
                    this.sint = 0;
                    this.x = 0;
                    this.y = 0;
                }
                /**
                 * Transforms only the x coordinate of the given {@link Vector2} and returns the result.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 * @return {number} the transformed x coordinate
                 * @since 3.4.0
                 */
                getTransformedX(vector) {
                    return this.cost * vector.x - this.sint * vector.y + this.x;
                }
                /**
                 * Transforms only the y coordinate of the given {@link Vector2} and returns the result.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 * @return {number} the transformed y coordinate
                 * @since 3.4.0
                 */
                getTransformedY(vector) {
                    return this.sint * vector.x + this.cost * vector.y + this.y;
                }
                /**
                 * Transforms only the x coordinate of the given {@link Vector2} and places the result in the x field of the given {@link Vector2}.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 * @since 3.4.0
                 */
                transformX(vector) {
                    vector.x = this.cost * vector.x - this.sint * vector.y + this.x;
                }
                /**
                 * Transforms only the y coordinate of the given {@link Vector2} and places the result in the y field of the given {@link Vector2}.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 * @since 3.4.0
                 */
                transformY(vector) {
                    vector.y = this.sint * vector.x + this.cost * vector.y + this.y;
                }
                getTransformed$org_dyn4j_geometry_Vector2(vector) {
                    const tv = new org.dyn4j.geometry.Vector2();
                    const x = vector.x;
                    const y = vector.y;
                    tv.x = this.cost * x - this.sint * y + this.x;
                    tv.y = this.sint * x + this.cost * y + this.y;
                    return tv;
                }
                getTransformed$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(vector, destination) {
                    const x = vector.x;
                    const y = vector.y;
                    destination.x = this.cost * x - this.sint * y + this.x;
                    destination.y = this.sint * x + this.cost * y + this.y;
                }
                /**
                 * Transforms the given {@link Vector2} and returns the result in dest.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 * @param {org.dyn4j.geometry.Vector2} destination the {@link Vector2} containing the result
                 */
                getTransformed(vector, destination) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((destination != null && destination instanceof org.dyn4j.geometry.Vector2) || destination === null)) {
                        return this.getTransformed$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(vector, destination);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && destination === undefined) {
                        return this.getTransformed$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Transforms the given {@link Vector2} and places the result in the given {@link Vector2}.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 */
                transform(vector) {
                    const x = vector.x;
                    const y = vector.y;
                    vector.x = this.cost * x - this.sint * y + this.x;
                    vector.y = this.sint * x + this.cost * y + this.y;
                }
                getInverseTransformed$org_dyn4j_geometry_Vector2(vector) {
                    const tv = new org.dyn4j.geometry.Vector2();
                    const tx = vector.x - this.x;
                    const ty = vector.y - this.y;
                    tv.x = this.cost * tx + this.sint * ty;
                    tv.y = -this.sint * tx + this.cost * ty;
                    return tv;
                }
                getInverseTransformed$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(vector, destination) {
                    const tx = vector.x - this.x;
                    const ty = vector.y - this.y;
                    destination.x = this.cost * tx + this.sint * ty;
                    destination.y = -this.sint * tx + this.cost * ty;
                }
                /**
                 * Inverse transforms the given {@link Vector2} and returns the result in the destination {@link Vector2}.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 * @param {org.dyn4j.geometry.Vector2} destination the {@link Vector2} containing the result
                 */
                getInverseTransformed(vector, destination) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((destination != null && destination instanceof org.dyn4j.geometry.Vector2) || destination === null)) {
                        return this.getInverseTransformed$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(vector, destination);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && destination === undefined) {
                        return this.getInverseTransformed$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Inverse transforms the given {@link Vector2} and places the result in the given {@link Vector2}.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 */
                inverseTransform(vector) {
                    const x = vector.x - this.x;
                    const y = vector.y - this.y;
                    vector.x = this.cost * x + this.sint * y;
                    vector.y = -this.sint * x + this.cost * y;
                }
                getTransformedR$org_dyn4j_geometry_Vector2(vector) {
                    const v = new org.dyn4j.geometry.Vector2();
                    const x = vector.x;
                    const y = vector.y;
                    v.x = this.cost * x - this.sint * y;
                    v.y = this.sint * x + this.cost * y;
                    return v;
                }
                getTransformedR$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(vector, destination) {
                    const x = vector.x;
                    const y = vector.y;
                    destination.x = this.cost * x - this.sint * y;
                    destination.y = this.sint * x + this.cost * y;
                }
                /**
                 * Transforms the given {@link Vector2} only by the rotation and returns the result in the
                 * destination {@link Vector2}.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 * @param {org.dyn4j.geometry.Vector2} destination the {@link Vector2} containing the result
                 * @since 3.1.5
                 */
                getTransformedR(vector, destination) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((destination != null && destination instanceof org.dyn4j.geometry.Vector2) || destination === null)) {
                        return this.getTransformedR$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(vector, destination);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && destination === undefined) {
                        return this.getTransformedR$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Transforms the given {@link Vector2} only by the rotation and returns the
                 * result in the given {@link Vector2}.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 */
                transformR(vector) {
                    const x = vector.x;
                    const y = vector.y;
                    vector.x = this.cost * x - this.sint * y;
                    vector.y = this.sint * x + this.cost * y;
                }
                getInverseTransformedR$org_dyn4j_geometry_Vector2(vector) {
                    const v = new org.dyn4j.geometry.Vector2();
                    const x = vector.x;
                    const y = vector.y;
                    v.x = this.cost * x + this.sint * y;
                    v.y = -this.sint * x + this.cost * y;
                    return v;
                }
                getInverseTransformedR$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(vector, destination) {
                    const x = vector.x;
                    const y = vector.y;
                    destination.x = this.cost * x + this.sint * y;
                    destination.y = -this.sint * x + this.cost * y;
                }
                /**
                 * Transforms the given {@link Vector2} only by the rotation and returns the result in the
                 * destination {@link Vector2}.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 * @param {org.dyn4j.geometry.Vector2} destination the {@link Vector2} containing the result
                 * @since 3.1.5
                 */
                getInverseTransformedR(vector, destination) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((destination != null && destination instanceof org.dyn4j.geometry.Vector2) || destination === null)) {
                        return this.getInverseTransformedR$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(vector, destination);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && destination === undefined) {
                        return this.getInverseTransformedR$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Transforms the given {@link Vector2} only by the rotation and returns the
                 * result in the given {@link Vector2}.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to transform
                 */
                inverseTransformR(vector) {
                    const x = vector.x;
                    const y = vector.y;
                    vector.x = this.cost * x + this.sint * y;
                    vector.y = -this.sint * x + this.cost * y;
                }
                /**
                 * Returns the x translation.
                 * @return {number} double
                 */
                getTranslationX() {
                    return this.x;
                }
                /**
                 * Sets the translation along the x axis.
                 * @param {number} x the translation along the x axis
                 * @since 1.2.0
                 */
                setTranslationX(x) {
                    this.x = x;
                }
                /**
                 * Returns the x translation.
                 * @return {number} double
                 */
                getTranslationY() {
                    return this.y;
                }
                /**
                 * Sets the translation along the y axis.
                 * @param {number} y the translation along the y axis
                 * @since 1.2.0
                 */
                setTranslationY(y) {
                    this.y = y;
                }
                /**
                 * Returns the translation {@link Vector2}.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getTranslation() {
                    return new org.dyn4j.geometry.Vector2(this.x, this.y);
                }
                setTranslation$double$double(x, y) {
                    this.x = x;
                    this.y = y;
                }
                /**
                 * Sets the translation.
                 * @param {number} x the translation along the x axis
                 * @param {number} y the translation along the y axis
                 * @since 1.2.0
                 */
                setTranslation(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.setTranslation$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.setTranslation$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                setTranslation$org_dyn4j_geometry_Vector2(translation) {
                    this.setTranslation$double$double(translation.x, translation.y);
                }
                /**
                 * Returns a new {@link Transform} including only the
                 * translation of this {@link Transform}.
                 * @return {org.dyn4j.geometry.Transform} {@link Transform}
                 */
                getTranslationTransform() {
                    const t = new Transform(1.0, 0.0, this.x, this.y);
                    return t;
                }
                /**
                 * Returns the rotation.
                 * @return {number} double angle in the range [-&pi;, &pi;]
                 */
                getRotationAngle() {
                    const acos = Math.acos(this.cost);
                    const angle = (this.sint >= 0) ? acos : -acos;
                    return angle;
                }
                /**
                 * @return {org.dyn4j.geometry.Rotation} the {@link Rotation} object representing the rotation of this {@link Transform}
                 * @since 3.4.0
                 */
                getRotation() {
                    return org.dyn4j.geometry.Rotation.of$org_dyn4j_geometry_Transform(this);
                }
                setRotation$double(theta) {
                    const r = this.getRotationAngle();
                    this.cost = Math.cos(theta);
                    this.sint = Math.sin(theta);
                    return r;
                }
                setRotation$org_dyn4j_geometry_Rotation(rotation) {
                    const r = this.getRotation();
                    this.cost = rotation.cost;
                    this.sint = rotation.sint;
                    return r;
                }
                /**
                 * Sets the rotation and returns the previous
                 * rotation.
                 * @param {org.dyn4j.geometry.Rotation} rotation the {@link Rotation}
                 * @return {org.dyn4j.geometry.Rotation} A new {@link Rotation} object representing the old rotation of this {@link Transform}
                 * @since 3.4.0
                 */
                setRotation(rotation) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null)) {
                        return this.setRotation$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null)) {
                        return this.setRotation$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns a new {@link Transform} including only the
                 * rotation of this {@link Transform}.
                 * @return {org.dyn4j.geometry.Transform} {@link Transform}
                 */
                getRotationTransform() {
                    const t = new Transform(this.cost, this.sint, 0, 0);
                    return t;
                }
                /**
                 * Returns the values stored in this transform.
                 * <p>
                 * The values are in the order of 00, 01, x, 10, 11, y.
                 * @return {double[]} double[]
                 * @since 3.0.1
                 */
                getValues() {
                    return [this.cost, -this.sint, this.x, this.sint, this.cost, this.y];
                }
                lerp$org_dyn4j_geometry_Transform$double(end, alpha) {
                    const x = this.x + alpha * (end.x - this.x);
                    const y = this.y + alpha * (end.y - this.y);
                    const rs = this.getRotationAngle();
                    const re = end.getRotationAngle();
                    let diff = re - rs;
                    if (diff < -Math.PI)
                        diff += org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                    if (diff > Math.PI)
                        diff -= org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                    const a = diff * alpha + rs;
                    this.cost = Math.cos(a);
                    this.sint = Math.sin(a);
                    this.x = x;
                    this.y = y;
                }
                lerp$org_dyn4j_geometry_Transform$double$org_dyn4j_geometry_Transform(end, alpha, result) {
                    const x = this.x + alpha * (end.x - this.x);
                    const y = this.y + alpha * (end.y - this.y);
                    const rs = this.getRotationAngle();
                    const re = end.getRotationAngle();
                    let diff = re - rs;
                    if (diff < -Math.PI)
                        diff += org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                    if (diff > Math.PI)
                        diff -= org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                    const a = diff * alpha + rs;
                    result.cost = Math.cos(a);
                    result.sint = Math.sin(a);
                    result.x = x;
                    result.y = y;
                }
                /**
                 * Helper method for the lerp methods below.
                 * Performs rotation but leaves translation intact.
                 * @param {number} theta the angle of rotation in radians
                 * @since 3.4.0
                 * @private
                 */
                /*private*/ rotateOnly(theta) {
                    const cos = Math.cos(theta);
                    const sin = Math.sin(theta);
                    const cost = cos * this.cost - sin * this.sint;
                    const sint = sin * this.cost + cos * this.sint;
                    this.cost = cost;
                    this.sint = sint;
                }
                lerp$org_dyn4j_geometry_Vector2$double$double$org_dyn4j_geometry_Transform(dp, da, alpha, result) {
                    result.set(this);
                    result.rotateOnly(da * alpha);
                    result.translate$double$double(dp.x * alpha, dp.y * alpha);
                }
                /**
                 * Interpolates this transform linearly, by alpha, given the change in
                 * position (&Delta;p) and the change in angle (&Delta;a) and places it into result.
                 * @param {org.dyn4j.geometry.Vector2} dp the change in position
                 * @param {number} da the change in angle
                 * @param {number} alpha the amount to interpolate
                 * @param {org.dyn4j.geometry.Transform} result the transform to place the result
                 * @since 3.1.5
                 */
                lerp(dp, da, alpha, result) {
                    if (((dp != null && dp instanceof org.dyn4j.geometry.Vector2) || dp === null) && ((typeof da === 'number') || da === null) && ((typeof alpha === 'number') || alpha === null) && ((result != null && result instanceof org.dyn4j.geometry.Transform) || result === null)) {
                        return this.lerp$org_dyn4j_geometry_Vector2$double$double$org_dyn4j_geometry_Transform(dp, da, alpha, result);
                    }
                    else if (((dp != null && dp instanceof org.dyn4j.geometry.Transform) || dp === null) && ((typeof da === 'number') || da === null) && ((alpha != null && alpha instanceof org.dyn4j.geometry.Transform) || alpha === null) && result === undefined) {
                        return this.lerp$org_dyn4j_geometry_Transform$double$org_dyn4j_geometry_Transform(dp, da, alpha);
                    }
                    else if (((dp != null && dp instanceof org.dyn4j.geometry.Vector2) || dp === null) && ((typeof da === 'number') || da === null) && ((typeof alpha === 'number') || alpha === null) && result === undefined) {
                        return this.lerp$org_dyn4j_geometry_Vector2$double$double(dp, da, alpha);
                    }
                    else if (((dp != null && dp instanceof org.dyn4j.geometry.Transform) || dp === null) && ((typeof da === 'number') || da === null) && alpha === undefined && result === undefined) {
                        return this.lerp$org_dyn4j_geometry_Transform$double(dp, da);
                    }
                    else
                        throw new Error('invalid overload');
                }
                lerp$org_dyn4j_geometry_Vector2$double$double(dp, da, alpha) {
                    this.rotateOnly(da * alpha);
                    this.translate$double$double(dp.x * alpha, dp.y * alpha);
                }
                lerped$org_dyn4j_geometry_Vector2$double$double(dp, da, alpha) {
                    const result = new Transform(this);
                    result.rotateOnly(da * alpha);
                    result.translate$double$double(dp.x * alpha, dp.y * alpha);
                    return result;
                }
                /**
                 * Interpolates this transform linearly, by alpha, given the change in
                 * position (&Delta;p) and the change in angle (&Delta;a) and returns the result.
                 * @param {org.dyn4j.geometry.Vector2} dp the change in position
                 * @param {number} da the change in angle
                 * @param {number} alpha the amount to interpolate
                 * @return {org.dyn4j.geometry.Transform} {@link Transform}
                 * @since 3.1.5
                 */
                lerped(dp, da, alpha) {
                    if (((dp != null && dp instanceof org.dyn4j.geometry.Vector2) || dp === null) && ((typeof da === 'number') || da === null) && ((typeof alpha === 'number') || alpha === null)) {
                        return this.lerped$org_dyn4j_geometry_Vector2$double$double(dp, da, alpha);
                    }
                    else if (((dp != null && dp instanceof org.dyn4j.geometry.Transform) || dp === null) && ((typeof da === 'number') || da === null) && alpha === undefined) {
                        return this.lerped$org_dyn4j_geometry_Transform$double(dp, da);
                    }
                    else
                        throw new Error('invalid overload');
                }
                lerped$org_dyn4j_geometry_Transform$double(end, alpha) {
                    const x = this.x + alpha * (end.x - this.x);
                    const y = this.y + alpha * (end.y - this.y);
                    const rs = this.getRotationAngle();
                    const re = end.getRotationAngle();
                    let diff = re - rs;
                    if (diff < -Math.PI)
                        diff += org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                    if (diff > Math.PI)
                        diff -= org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                    const a = diff * alpha + rs;
                    const tx = new Transform(Math.cos(a), Math.sin(a), x, y);
                    return tx;
                }
            }
            geometry.Transform = Transform;
            Transform["__class"] = "org.dyn4j.geometry.Transform";
            Transform["__interfaces"] = ["org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Creates a new {@link AdaptiveDecimal} with the specified length.
             * The initial {@link AdaptiveDecimal} created does not contains any components.
             *
             * @param {number} length The maximum number of components this {@link AdaptiveDecimal} can store
             * @class
             * @author Manolis Tsamis
             */
            class AdaptiveDecimal {
                constructor(a0, a1) {
                    if (((typeof a0 === 'number') || a0 === null) && ((typeof a1 === 'number') || a1 === null)) {
                        let __args = arguments;
                        if (this.components === undefined) {
                            this.components = null;
                        }
                        if (this.__size === undefined) {
                            this.__size = 0;
                        }
                        this.components = [a0, a1];
                        this.__size = 2;
                    }
                    else if (((a0 != null && a0 instanceof org.dyn4j.geometry.AdaptiveDecimal) || a0 === null) && a1 === undefined) {
                        let __args = arguments;
                        let other = __args[0];
                        if (this.components === undefined) {
                            this.components = null;
                        }
                        if (this.__size === undefined) {
                            this.__size = 0;
                        }
                        this.components = java.util.Arrays.copyOf(other.components, other.capacity());
                        this.__size = other.__size;
                    }
                    else if (((typeof a0 === 'number') || a0 === null) && a1 === undefined) {
                        let __args = arguments;
                        let length = __args[0];
                        if (this.components === undefined) {
                            this.components = null;
                        }
                        if (this.__size === undefined) {
                            this.__size = 0;
                        }
                        if (length <= 0) {
                            throw new java.lang.IllegalArgumentException();
                        }
                        this.components = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(length);
                        this.__size = 0;
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * @return {number} The number of components this {@link AdaptiveDecimal} currently has
                 */
                size() {
                    return this.__size;
                }
                /**
                 * @return {number} The maximum number of components this {@link AdaptiveDecimal} can hold
                 */
                capacity() {
                    return this.components.length;
                }
                /**
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} A deep copy of this {@link AdaptiveDecimal}
                 */
                copy() {
                    return new AdaptiveDecimal(this);
                }
                /**
                 * Copies the components of another {@link AdaptiveDecimal} into this.
                 * The capacity of the this {@link AdaptiveDecimal} is not modified and it should
                 * be enough to hold all the components.
                 *
                 * @param {org.dyn4j.geometry.AdaptiveDecimal} other The {@link AdaptiveDecimal} to copy from
                 */
                copyFrom(other) {
                    java.lang.System.arraycopy(other.components, 0, this.components, 0, other.size());
                    this.__size = other.__size;
                }
                /**
                 * @param {number} index index of the component to return
                 * @return {number} the component at the specified position
                 * @throws IndexOutOfBoundsException if the index is not in the range [0, size)
                 */
                get(index) {
                    if (index < 0 || index >= this.size()) {
                        throw new java.lang.IndexOutOfBoundsException();
                    }
                    return this.components[index];
                }
                /**
                 * Appends a new component after all the existing components.
                 *
                 * @param {number} value The component
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} this {@link AdaptiveDecimal}
                 * @throws IndexOutOfBoundsException if this {@link AdaptiveDecimal} has no capacity for more components
                 */
                append(value) {
                    if (this.__size >= this.capacity()) {
                        throw new java.lang.IndexOutOfBoundsException();
                    }
                    this.components[this.__size++] = value;
                    return this;
                }
                /**
                 * Appends a new component after all the existing components, but only
                 * if it has a non zero value.
                 *
                 * @param {number} value The component
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} this {@link AdaptiveDecimal}
                 */
                appendNonZero(value) {
                    if (value !== 0.0) {
                        this.append(value);
                    }
                    return this;
                }
                /**
                 * Returns a boolean value describing if this {@link AdaptiveDecimal} is a valid
                 * representation as described in the header of this class.
                 * Checks for the magnitude and non-overlapping property.
                 * The invariants can be violated if bad input components are appended to this {@link AdaptiveDecimal}.
                 * The append methods do not check for those conditions because there is a big overhead for the check.
                 * The output of the exposed operations must satisfy the invariants, given that their input also does so.
                 *
                 * @return {boolean} true iff this {@link AdaptiveDecimal} satisfies the described invariants
                 */
                checkInvariants() {
                    if (this.__size === 0) {
                        return true;
                    }
                    let lastValue = this.get(0);
                    for (let i = 1; i < this.__size; i++) {
                        {
                            const currentValue = this.get(i);
                            if (currentValue !== 0) {
                                if (Math.abs(currentValue) < Math.abs(lastValue)) {
                                    return false;
                                }
                                const exp1 = (Math.floor(/* log10 */ (x => Math.log(x) * Math.LOG10E)(lastValue)) | 0);
                                const exp2 = (Math.floor(/* log10 */ (x => Math.log(x) * Math.LOG10E)(currentValue)) | 0);
                                const mantissa1 = (javaemul.internal.DoubleHelper.doubleToLongBits(lastValue) & AdaptiveDecimal.SIGNIF_BIT_MASK) | AdaptiveDecimal.IMPLICIT_MANTISSA_BIT;
                                const mantissa2 = (javaemul.internal.DoubleHelper.doubleToLongBits(currentValue) & AdaptiveDecimal.SIGNIF_BIT_MASK) | AdaptiveDecimal.IMPLICIT_MANTISSA_BIT;
                                let msd1 = javaemul.internal.LongHelper.numberOfLeadingZeros(mantissa1);
                                let lsd2 = javaemul.internal.LongHelper.SIZE - javaemul.internal.LongHelper.numberOfTrailingZeros(mantissa2) - 1;
                                msd1 -= exp1;
                                lsd2 -= exp2;
                                if (!(lsd2 < msd1)) {
                                    return false;
                                }
                                lastValue = currentValue;
                            }
                        }
                        ;
                    }
                    return true;
                }
                /**
                 * @throws IllegalStateException iff {@link #checkInvariants()} returns false
                 */
                ensureInvariants() {
                    if (!this.checkInvariants()) {
                        throw new java.lang.IllegalStateException();
                    }
                }
                /**
                 * Removes the components of this {@link AdaptiveDecimal}.
                 *
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} this {@link AdaptiveDecimal}
                 */
                clear() {
                    this.__size = 0;
                    return this;
                }
                /**
                 * Removes all the components with zero value from this {@link AdaptiveDecimal}.
                 *
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} this {@link AdaptiveDecimal}
                 */
                removeZeros() {
                    const oldSize = this.__size;
                    this.clear();
                    for (let i = 0; i < oldSize; i++) {
                        {
                            this.appendNonZero(this.components[i]);
                        }
                        ;
                    }
                    return this;
                }
                /**
                 * Ensures this {@link AdaptiveDecimal} has at least one component.
                 * That is, appends the zero value if there are currently zero components.
                 *
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} this {@link AdaptiveDecimal}
                 */
                normalize() {
                    if (this.__size === 0) {
                        this.append(0.0);
                    }
                    return this;
                }
                /**
                 * Negates the logical value of this {@link AdaptiveDecimal}.
                 * This can be used with sum to perform subtraction .
                 *
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} this {@link AdaptiveDecimal}
                 */
                negate() {
                    for (let i = 0; i < this.__size; i++) {
                        {
                            this.components[i] = -this.components[i];
                        }
                        ;
                    }
                    return this;
                }
                /**
                 * Computes an approximation for the value of this {@link AdaptiveDecimal} that fits in a double.
                 *
                 * @return {number} The approximation
                 */
                getEstimation() {
                    let value = 0.0;
                    for (let i = 0; i < this.__size; i++) {
                        {
                            value += this.components[i];
                        }
                        ;
                    }
                    return value;
                }
                sum$org_dyn4j_geometry_AdaptiveDecimal(f) {
                    return this.sum$org_dyn4j_geometry_AdaptiveDecimal$org_dyn4j_geometry_AdaptiveDecimal(f, null);
                }
                /**
                 * Helper method to implement the sum procedure.
                 * Sums the remaining components of a single {@link AdaptiveDecimal} to the result
                 * and the initial carry value from previous computations
                 *
                 * @param {number} carry The carry from previous computations
                 * @param {org.dyn4j.geometry.AdaptiveDecimal} e The {@link AdaptiveDecimal} that probably has more components
                 * @param {number} eIndex The index to the next component of e that has to be examined
                 * @param {org.dyn4j.geometry.AdaptiveDecimal} result The {@link AdaptiveDecimal} in which the result is stored
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} The result
                 */
                sumEpilogue(carry, e, eIndex, result) {
                    for (; eIndex < e.size(); eIndex++) {
                        {
                            const enow = e.get(eIndex);
                            const sum = carry + enow;
                            const error = AdaptiveDecimal.getErrorComponentFromSum(carry, enow, sum);
                            carry = sum;
                            result.appendNonZero(error);
                        }
                        ;
                    }
                    result.appendNonZero(carry);
                    result.normalize();
                    return result;
                }
                sum$org_dyn4j_geometry_AdaptiveDecimal$org_dyn4j_geometry_AdaptiveDecimal(f, result) {
                    if (result == null) {
                        result = new AdaptiveDecimal(this.size() + f.size());
                    }
                    else {
                        result.clear();
                    }
                    const e = this;
                    let eIndex = 0;
                    let fIndex = 0;
                    let enow = e.get(eIndex);
                    let fnow = f.get(fIndex);
                    let carry;
                    let sum;
                    let error;
                    if (Math.abs(enow) <= Math.abs(fnow)) {
                        carry = enow;
                        eIndex++;
                        if (eIndex >= e.size()) {
                            return this.sumEpilogue(carry, f, fIndex, result);
                        }
                        enow = e.get(eIndex);
                    }
                    else {
                        carry = fnow;
                        fIndex++;
                        if (fIndex >= f.size()) {
                            return this.sumEpilogue(carry, e, eIndex, result);
                        }
                        fnow = f.get(fIndex);
                    }
                    while ((true)) {
                        {
                            if (Math.abs(enow) <= Math.abs(fnow)) {
                                error = AdaptiveDecimal.getErrorComponentFromSum(carry, enow, sum = carry + enow);
                                eIndex++;
                                carry = sum;
                                result.appendNonZero(error);
                                if (eIndex >= e.size()) {
                                    return this.sumEpilogue(carry, f, fIndex, result);
                                }
                                enow = e.get(eIndex);
                            }
                            else {
                                error = AdaptiveDecimal.getErrorComponentFromSum(carry, fnow, sum = carry + fnow);
                                fIndex++;
                                carry = sum;
                                result.appendNonZero(error);
                                if (fIndex >= f.size()) {
                                    return this.sumEpilogue(carry, e, eIndex, result);
                                }
                                fnow = f.get(fIndex);
                            }
                        }
                    }
                    ;
                }
                /**
                 * Performs the addition of this {@link AdaptiveDecimal} with the given {@link AdaptiveDecimal} f
                 * and stores the result in the provided {@link AdaptiveDecimal} {@code result}.
                 * If {@code result} is null it allocates a new {@link AdaptiveDecimal} with the
                 * appropriate capacity to store the result. Otherwise the components of {@code result}
                 * are cleared and the resulting value is stored there, assuming there is enough capacity.
                 *
                 * Be careful that it must be {@code f} &ne; {@code result} &ne; {@code this}.
                 *
                 * @param {org.dyn4j.geometry.AdaptiveDecimal} f The {@link AdaptiveDecimal} to sum with this {@link AdaptiveDecimal}
                 * @param {org.dyn4j.geometry.AdaptiveDecimal} result The {@link AdaptiveDecimal} in which the sum is stored or null to allocate a new one
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} The result
                 */
                sum(f, result) {
                    if (((f != null && f instanceof org.dyn4j.geometry.AdaptiveDecimal) || f === null) && ((result != null && result instanceof org.dyn4j.geometry.AdaptiveDecimal) || result === null)) {
                        return this.sum$org_dyn4j_geometry_AdaptiveDecimal$org_dyn4j_geometry_AdaptiveDecimal(f, result);
                    }
                    else if (((f != null && f instanceof org.dyn4j.geometry.AdaptiveDecimal) || f === null) && result === undefined) {
                        return this.sum$org_dyn4j_geometry_AdaptiveDecimal(f);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder(this.__size * 10);
                    sb.append('[');
                    for (let i = 0; i < this.__size; i++) {
                        {
                            sb.append(this.components[i]);
                            if (i < this.__size - 1) {
                                sb.append(", ");
                            }
                        }
                        ;
                    }
                    sb.append("] ~= ");
                    sb.append(this.getEstimation());
                    return sb.toString();
                }
                /**
                 * Creates a {@link AdaptiveDecimal} with only a single component.
                 *
                 * @param {number} value The component
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} {@link AdaptiveDecimal}
                 */
                static valueOf(value) {
                    return new AdaptiveDecimal(1).append(value);
                }
                /**
                 * Creates a {@link AdaptiveDecimal} that holds the result of the
                 * addition of two double values.
                 *
                 * @param {number} a The first value
                 * @param {number} b The second value
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} A new {@link AdaptiveDecimal} that holds the resulting sum
                 */
                static fromSum(a, b) {
                    const sum = a + b;
                    return new AdaptiveDecimal(AdaptiveDecimal.getErrorComponentFromSum(a, b, sum), sum);
                }
                static fromDiff$double$double(a, b) {
                    const diff = a - b;
                    return new AdaptiveDecimal(AdaptiveDecimal.getErrorComponentFromDifference(a, b, diff), diff);
                }
                static fromDiff$double$double$double$double$org_dyn4j_geometry_AdaptiveDecimal(a0, a1, b0, b1, result) {
                    if (result == null) {
                        result = new AdaptiveDecimal(4);
                    }
                    else {
                        result.clear();
                    }
                    let x0;
                    let x1;
                    let x2;
                    let x3;
                    let imm;
                    let imm1;
                    let imm2;
                    x0 = AdaptiveDecimal.getErrorComponentFromDifference(a0, b0, imm = a0 - b0);
                    imm1 = AdaptiveDecimal.getErrorComponentFromSum(a1, imm, imm2 = a1 + imm);
                    x1 = AdaptiveDecimal.getErrorComponentFromDifference(imm1, b1, imm = imm1 - b1);
                    x2 = AdaptiveDecimal.getErrorComponentFromSum(imm2, imm, x3 = imm2 + imm);
                    result.append(x0);
                    result.append(x1);
                    result.append(x2);
                    result.append(x3);
                    return result;
                }
                /**
                 * Given two unrolled expansions (a0, a1) and (b0, b1) performs the difference
                 * (a0, a1) - (b0, b1) and stores the 4 component result in the given {@link AdaptiveDecimal} {@code result}.
                 * In the same way as with {@link AdaptiveDecimal#sum(AdaptiveDecimal, AdaptiveDecimal)} if {@code result} is null
                 * a new one is allocated, otherwise the existing is cleared and used.
                 * Does not perform zero elimination.
                 * This is also a helper method to allow fast computation of the cross product
                 * without the overhead of creating new {@link AdaptiveDecimal} and performing
                 * the generalized sum procedure.
                 *
                 * @param {number} a0 The first component of a
                 * @param {number} a1 The second component of a
                 * @param {number} b0 The first component of b
                 * @param {number} b1 The second component of b
                 * @param {org.dyn4j.geometry.AdaptiveDecimal} result The {@link AdaptiveDecimal} in which the difference is stored or null to allocate a new one
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} The result
                 */
                static fromDiff(a0, a1, b0, b1, result) {
                    if (((typeof a0 === 'number') || a0 === null) && ((typeof a1 === 'number') || a1 === null) && ((typeof b0 === 'number') || b0 === null) && ((typeof b1 === 'number') || b1 === null) && ((result != null && result instanceof org.dyn4j.geometry.AdaptiveDecimal) || result === null)) {
                        return org.dyn4j.geometry.AdaptiveDecimal.fromDiff$double$double$double$double$org_dyn4j_geometry_AdaptiveDecimal(a0, a1, b0, b1, result);
                    }
                    else if (((typeof a0 === 'number') || a0 === null) && ((typeof a1 === 'number') || a1 === null) && b0 === undefined && b1 === undefined && result === undefined) {
                        return org.dyn4j.geometry.AdaptiveDecimal.fromDiff$double$double(a0, a1);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Creates a {@link AdaptiveDecimal} that holds the result of the
                 * product of two double values.
                 *
                 * @param {number} a The first value
                 * @param {number} b The second value
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} A new {@link AdaptiveDecimal} that holds the resulting product
                 */
                static fromProduct(a, b) {
                    const product = a * b;
                    return new AdaptiveDecimal(AdaptiveDecimal.getErrorComponentFromProduct(a, b, product), a * b);
                }
                /**
                 * Given two values a, b and their sum = fl(a + b) calculates the value error for which
                 * fl(a) + fl(b) = fl(a + b) + fl(error).
                 *
                 * @param {number} a The first value
                 * @param {number} b The second value
                 * @param {number} sum Their sum, must always be sum = fl(a + b)
                 * @return {number} The error described above
                 */
                static getErrorComponentFromSum(a, b, sum) {
                    const bvirt = sum - a;
                    const avirt = sum - bvirt;
                    const bround = b - bvirt;
                    const around = a - avirt;
                    const error = around + bround;
                    return error;
                }
                /**
                 * Given two values a, b and their difference = fl(a - b) calculates the value error for which
                 * fl(a) - fl(b) = fl(a - b) + fl(error).
                 *
                 * @param {number} a The first value
                 * @param {number} b The second value
                 * @param {number} diff Their difference, must always be diff = fl(a - b)
                 * @return {number} The error described above
                 */
                static getErrorComponentFromDifference(a, b, diff) {
                    const bvirt = a - diff;
                    const avirt = diff + bvirt;
                    const bround = bvirt - b;
                    const around = a - avirt;
                    const error = around + bround;
                    return error;
                }
                /**
                 * Given two values a, b and their product = fl(a * b) calculates the value error for which
                 * fl(a) * fl(b) = fl(a * b) + fl(error).
                 *
                 * @param {number} a The first value
                 * @param {number} b The second value
                 * @param {number} product Their product, must always be product = fl(a * b)
                 * @return {number} The error described above
                 */
                static getErrorComponentFromProduct(a, b, product) {
                    const ac = org.dyn4j.geometry.RobustGeometry.SPLITTER_$LI$() * a;
                    const abig = ac - a;
                    const ahi = ac - abig;
                    const alo = a - ahi;
                    const bc = org.dyn4j.geometry.RobustGeometry.SPLITTER_$LI$() * b;
                    const bbig = bc - b;
                    const bhi = bc - bbig;
                    const blo = b - bhi;
                    const error1 = product - (ahi * bhi);
                    const error2 = error1 - (alo * bhi);
                    const error3 = error2 - (ahi * blo);
                    const error = alo * blo - error3;
                    return error;
                }
            }
            /**
             * The mask to get the mantissa of a double as per the standard; Taken from {@link DoubleConsts#SIGN_BIT_MASK}
             */
            AdaptiveDecimal.SIGNIF_BIT_MASK = 4503599627370495;
            /**
             * The implicit bit in the mantissa of a double
             */
            AdaptiveDecimal.IMPLICIT_MANTISSA_BIT = 4503599627370496;
            geometry.AdaptiveDecimal = AdaptiveDecimal;
            AdaptiveDecimal["__class"] = "org.dyn4j.geometry.AdaptiveDecimal";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * @param {number} min the minimum value
             * @param {number} max the maximum value
             * @throws IllegalArgumentException if min &gt; max
             * @class
             * @author William Bittle
             */
            class Interval {
                constructor(min, max) {
                    if (((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                        let __args = arguments;
                        if (this.min === undefined) {
                            this.min = 0;
                        }
                        if (this.max === undefined) {
                            this.max = 0;
                        }
                        if (min > max)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.interval.invalid"));
                        this.min = min;
                        this.max = max;
                    }
                    else if (((min != null && min instanceof org.dyn4j.geometry.Interval) || min === null) && max === undefined) {
                        let __args = arguments;
                        let interval = __args[0];
                        if (this.min === undefined) {
                            this.min = 0;
                        }
                        if (this.max === undefined) {
                            this.max = 0;
                        }
                        this.min = interval.min;
                        this.max = interval.max;
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("[").append(this.min).append(", ").append(this.max).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the minimum value for this {@link Interval}.
                 * @return {number} double
                 */
                getMin() {
                    return this.min;
                }
                /**
                 * Returns the maximum value for this {@link Interval}.
                 * @return {number} double
                 */
                getMax() {
                    return this.max;
                }
                /**
                 * Sets the minimum for this interval.
                 * @param {number} min the minimum value
                 * @throws IllegalArgumentException if min &gt; max
                 */
                setMin(min) {
                    if (min > this.max)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.interval.invalidMinimum"));
                    this.min = min;
                }
                /**
                 * Sets the maximum for this interval.
                 * @param {number} max the maximum value
                 * @throws IllegalArgumentException if max &lt; min
                 */
                setMax(max) {
                    if (max < this.min)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.interval.invalidMaximum"));
                    this.max = max;
                }
                /**
                 * Returns true if the given value is within this {@link Interval}
                 * including the maximum and minimum.
                 * @param {number} value the test value
                 * @return {boolean} boolean
                 */
                includesInclusive(value) {
                    return value <= this.max && value >= this.min;
                }
                /**
                 * Returns true if the given value is within this {@link Interval}
                 * exlcuding the maximum and minimum.
                 * @param {number} value the test value
                 * @return {boolean} boolean
                 */
                includesExclusive(value) {
                    return value < this.max && value > this.min;
                }
                /**
                 * Returns true if the given value is within this {@link Interval}
                 * including the minimum and excluding the maximum.
                 * @param {number} value the test value
                 * @return {boolean} boolean
                 */
                includesInclusiveMin(value) {
                    return value < this.max && value >= this.min;
                }
                /**
                 * Returns true if the given value is within this {@link Interval}
                 * including the maximum and excluding the minimum.
                 * @param {number} value the test value
                 * @return {boolean} boolean
                 */
                includesInclusiveMax(value) {
                    return value <= this.max && value > this.min;
                }
                /**
                 * Returns true if the two {@link Interval}s overlap.
                 * @param {org.dyn4j.geometry.Interval} interval the {@link Interval}
                 * @return {boolean} boolean
                 */
                overlaps(interval) {
                    return !(this.min > interval.max || interval.min > this.max);
                }
                /**
                 * Returns the amount of overlap between this {@link Interval} and the given
                 * {@link Interval}.
                 * <p>
                 * This method tests to if the {@link Interval}s overlap first.  If they do then
                 * the overlap is returned, if they do not then 0 is returned.
                 * @param {org.dyn4j.geometry.Interval} interval the {@link Interval}
                 * @return {number} double
                 */
                getOverlap(interval) {
                    if (this.overlaps(interval)) {
                        return Math.min(this.max, interval.max) - Math.max(this.min, interval.min);
                    }
                    return 0;
                }
                /**
                 * If the value is within this {@link Interval}, inclusive, then return the value, else
                 * return either the max or minimum value.
                 * @param {number} value the value to clamp
                 * @return {number} double
                 */
                clamp(value) {
                    return Interval.clamp(value, this.min, this.max);
                }
                /**
                 * Returns a number clamped between two other numbers.
                 * <p>
                 * This method assumes that min &le; max.
                 * @param {number} value the value to clamp
                 * @param {number} min the min value
                 * @param {number} max the max value
                 * @return {number} double
                 */
                static clamp(value, min, max) {
                    if (value <= max && value >= min) {
                        return value;
                    }
                    else if (max < value) {
                        return max;
                    }
                    else {
                        return min;
                    }
                }
                isDegenerate$() {
                    return this.min === this.max;
                }
                isDegenerate$double(error) {
                    return Math.abs(this.max - this.min) <= error;
                }
                /**
                 * Returns true if this {@link Interval} is degenerate
                 * given the allowed error.
                 * <p>
                 * An {@link Interval} is degenerate given some error if
                 * max - min &lt;= error.
                 * @param {number} error the allowed error
                 * @return {boolean} boolean
                 */
                isDegenerate(error) {
                    if (((typeof error === 'number') || error === null)) {
                        return this.isDegenerate$double(error);
                    }
                    else if (error === undefined) {
                        return this.isDegenerate$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns true if the given {@link Interval} is contained in this {@link Interval}.
                 * @param {org.dyn4j.geometry.Interval} interval the {@link Interval}
                 * @return {boolean} boolean
                 */
                contains(interval) {
                    return interval.min > this.min && interval.max < this.max;
                }
                /**
                 * Sets this {@link Interval} to the union of this {@link Interval} and the given {@link Interval}.
                 * <p>
                 * If the two {@link Interval}s are not overlapping then this method will
                 * return one {@link Interval} that represents an {@link Interval} enclosing both
                 * {@link Interval}s.
                 * @param {org.dyn4j.geometry.Interval} interval the {@link Interval}
                 */
                union(interval) {
                    this.min = Math.min(interval.min, this.min);
                    this.max = Math.max(interval.max, this.max);
                }
                /**
                 * Returns the union of the given {@link Interval} and this {@link Interval}.
                 * @see Interval#union(Interval)
                 * @param {org.dyn4j.geometry.Interval} interval the {@link Interval}
                 * @return {org.dyn4j.geometry.Interval} {@link Interval}
                 */
                getUnion(interval) {
                    return new Interval(Math.min(interval.min, this.min), Math.max(interval.max, this.max));
                }
                /**
                 * Sets this {@link Interval} to the intersection of this {@link Interval} and the given {@link Interval}.
                 * <p>
                 * If the two {@link Interval}s are not overlapping then this method will make this {@link Interval}
                 * the a zero degenerate {@link Interval}, [0, 0].
                 * @param {org.dyn4j.geometry.Interval} interval the {@link Interval}
                 */
                intersection(interval) {
                    if (this.overlaps(interval)) {
                        this.min = Math.max(interval.min, this.min);
                        this.max = Math.min(interval.max, this.max);
                    }
                    else {
                        this.min = 0;
                        this.max = 0;
                    }
                }
                /**
                 * Returns the intersection of the given {@link Interval} and this {@link Interval}.
                 * @see Interval#intersection(Interval)
                 * @param {org.dyn4j.geometry.Interval} interval the {@link Interval}
                 * @return {org.dyn4j.geometry.Interval} {@link Interval}
                 */
                getIntersection(interval) {
                    if (this.overlaps(interval)) {
                        return new Interval(Math.max(interval.min, this.min), Math.min(interval.max, this.max));
                    }
                    return new Interval(0, 0);
                }
                /**
                 * Returns the distance between the two {@link Interval}s.
                 * <p>
                 * If the given interval overlaps this interval, zero is returned.
                 * @param {org.dyn4j.geometry.Interval} interval the {@link Interval}
                 * @return {number} double
                 */
                distance(interval) {
                    if (!this.overlaps(interval)) {
                        if (this.max < interval.min) {
                            return interval.min - this.max;
                        }
                        else {
                            return this.min - interval.max;
                        }
                    }
                    return 0;
                }
                /**
                 * Expands this {@link Interval} by half the given amount in both directions.
                 * <p>
                 * The value can be negative to shrink the interval.  However, if the value is
                 * greater than the current length of the interval, the interval can become
                 * invalid.  In this case, the interval will become a degenerate interval at
                 * the mid point of the min and max.
                 * @param {number} value the value
                 */
                expand(value) {
                    const e = value * 0.5;
                    this.min -= e;
                    this.max += e;
                    if (value < 0.0 && this.min > this.max) {
                        const p = (this.min + this.max) * 0.5;
                        this.min = p;
                        this.max = p;
                    }
                }
                /**
                 * Returns a new {@link Interval} of this interval expanded by half the given amount
                 * in both directions.
                 * <p>
                 * The value can be negative to shrink the interval.  However, if the value is
                 * greater than the current length of the interval, the interval will be
                 * invalid.  In this case, the interval returned will be a degenerate interval at
                 * the mid point of the min and max.
                 * @param {number} value the value
                 * @return {org.dyn4j.geometry.Interval} {@link Interval}
                 * @since 3.1.1
                 */
                getExpanded(value) {
                    const e = value * 0.5;
                    let min = this.min - e;
                    let max = this.max + e;
                    if (value < 0.0 && min > max) {
                        const p = (min + max) * 0.5;
                        min = p;
                        max = p;
                    }
                    return new Interval(min, max);
                }
                /**
                 * Returns the length of this interval from its min to its max.
                 * @return {number} double
                 * @since 3.1.1
                 */
                getLength() {
                    return this.max - this.min;
                }
            }
            geometry.Interval = Interval;
            Interval["__class"] = "org.dyn4j.geometry.Interval";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var hull;
            (function (hull) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.geometry.Vector2} point the point
                 * @class
                 * @author William Bittle
                 */
                class LinkedVertex {
                    constructor(point) {
                        if (this.point === undefined) {
                            this.point = null;
                        }
                        if (this.next === undefined) {
                            this.next = null;
                        }
                        if (this.prev === undefined) {
                            this.prev = null;
                        }
                        this.point = point;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return this.point.toString();
                    }
                }
                hull.LinkedVertex = LinkedVertex;
                LinkedVertex["__class"] = "org.dyn4j.geometry.hull.LinkedVertex";
            })(hull = geometry.hull || (geometry.hull = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var hull;
            (function (hull_1) {
                /**
                 * Implementation of the Gift Wrapping convex hull algorithm.
                 * <p>
                 * This algorithm handles coincident and colinear points by ignoring them during processing. This ensures
                 * the produced hull will not have coincident or colinear vertices.
                 * <p>
                 * This algorithm is O(nh) worst case where n is the number of points and h is the
                 * number of sides in the resulting convex hull.
                 * @author William Bittle
                 * @version 3.4.0
                 * @since 2.2.0
                 * @class
                 */
                class GiftWrap {
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2[]} points
                     * @return {org.dyn4j.geometry.Vector2[]}
                     */
                    generate(...points) {
                        if (points == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.hull.nullArray"));
                        const size = points.length;
                        if (size <= 2)
                            return points;
                        let x = javaemul.internal.DoubleHelper.MAX_VALUE;
                        let y = javaemul.internal.DoubleHelper.MAX_VALUE;
                        let leftMost = null;
                        for (let i = 0; i < size; i++) {
                            {
                                const p = points[i];
                                if (p == null)
                                    throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.hull.nullPoints"));
                                if (p.x < x) {
                                    x = p.x;
                                    leftMost = p;
                                    y = p.y;
                                }
                                else if (p.x === x && p.y < y) {
                                    x = p.x;
                                    leftMost = p;
                                    y = p.y;
                                }
                            }
                            ;
                        }
                        let current = leftMost;
                        const hull = (new java.util.LinkedHashSet());
                        do {
                            {
                                hull.add(current);
                                let next = points[0];
                                if (current === next)
                                    next = points[1];
                                for (let j = 1; j < size; j++) {
                                    {
                                        const test = points[j];
                                        if (test === current)
                                            continue;
                                        if (test === next)
                                            continue;
                                        const location = org.dyn4j.geometry.RobustGeometry.getLocation(test, current, next);
                                        if (location < 0.0) {
                                            next = test;
                                        }
                                        else if (location === 0.0) {
                                            const d1 = test.distanceSquared$org_dyn4j_geometry_Vector2(current);
                                            const d2 = next.distanceSquared$org_dyn4j_geometry_Vector2(current);
                                            const dot = current.to$org_dyn4j_geometry_Vector2(next).dot$org_dyn4j_geometry_Vector2(current.to$org_dyn4j_geometry_Vector2(test));
                                            if (d1 > d2 && dot >= 0) {
                                                next = test;
                                            }
                                            else {
                                                const l1 = current.to$org_dyn4j_geometry_Vector2(next);
                                                const l2 = next.to$org_dyn4j_geometry_Vector2(test);
                                                const cross = l1.cross$org_dyn4j_geometry_Vector2(l2);
                                                if (cross < 0.0) {
                                                    next = test;
                                                }
                                            }
                                        }
                                    }
                                    ;
                                }
                                current = next;
                            }
                        } while ((leftMost !== current));
                        const hullPoints = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(hull.size());
                        hull.toArray(hullPoints);
                        return hullPoints;
                    }
                    constructor() {
                    }
                }
                hull_1.GiftWrap = GiftWrap;
                GiftWrap["__class"] = "org.dyn4j.geometry.hull.GiftWrap";
                GiftWrap["__interfaces"] = ["org.dyn4j.geometry.hull.HullGenerator"];
            })(hull = geometry.hull || (geometry.hull = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var hull;
            (function (hull) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.geometry.Vector2} reference the reference point for finding angles
                 * @class
                 * @author William Bittle
                 */
                class ReferencePointComparator {
                    constructor(reference) {
                        if (this.reference === undefined) {
                            this.reference = null;
                        }
                        this.reference = reference;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} p1
                     * @param {org.dyn4j.geometry.Vector2} p2
                     * @return {number}
                     */
                    compare(p1, p2) {
                        const sign = ((f => { if (f > 0) {
                            return 1;
                        }
                        else if (f < 0) {
                            return -1;
                        }
                        else {
                            return 0;
                        } })(org.dyn4j.geometry.RobustGeometry.getLocation(p2, p1, this.reference)) | 0);
                        if (sign === 0) {
                            return /* compare */ (this.reference.distanceSquared$org_dyn4j_geometry_Vector2(p1) - this.reference.distanceSquared$org_dyn4j_geometry_Vector2(p2));
                        }
                        return sign;
                    }
                }
                hull.ReferencePointComparator = ReferencePointComparator;
                ReferencePointComparator["__class"] = "org.dyn4j.geometry.hull.ReferencePointComparator";
                ReferencePointComparator["__interfaces"] = ["java.util.Comparator"];
            })(hull = geometry.hull || (geometry.hull = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var hull;
            (function (hull_2) {
                /**
                 * Implementation of the Andrew's Monotone Chain convex hull algorithm.
                 * <p>
                 * This implementation is not sensitive to colinear points and returns only
                 * the points of the convex hull.
                 * <p>
                 * This algorithm is O(n log n) worst case where n is the number of points.
                 * @author William Bittle
                 * @version 3.4.0
                 * @since 2.2.0
                 * @class
                 */
                class MonotoneChain {
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2[]} points
                     * @return {org.dyn4j.geometry.Vector2[]}
                     */
                    generate(...points) {
                        if (points == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.hull.nullArray"));
                        const size = points.length;
                        if (size <= 2)
                            return points;
                        try {
                            java.util.Arrays.sort(points, ((funcInst) => { if (typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(new org.dyn4j.geometry.hull.MinXYPointComparator()));
                        }
                        catch (e) {
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.hull.nullPoints"));
                        }
                        let minmin = 0;
                        let minmax = 0;
                        let maxmin = 0;
                        let maxmax = 0;
                        for (let i = 1; i < size; i++) {
                            {
                                const minxminy = points[minmin];
                                const minxmaxy = points[minmax];
                                const maxxminy = points[maxmin];
                                const maxxmaxy = points[maxmax];
                                const p = points[i];
                                if (p.x < minxminy.x) {
                                    minmin = i;
                                    minmax = i;
                                }
                                else if (p.x === minxminy.x) {
                                    if (p.y > minxmaxy.y) {
                                        minmax = i;
                                    }
                                    else if (p.y < minxminy.y) {
                                        minmin = i;
                                    }
                                }
                                if (p.x > maxxminy.x) {
                                    maxmin = i;
                                    maxmax = i;
                                }
                                else if (p.x === maxxminy.x) {
                                    if (p.y > maxxmaxy.y) {
                                        maxmax = i;
                                    }
                                    else if (p.y < maxxminy.y) {
                                        maxmin = i;
                                    }
                                }
                            }
                            ;
                        }
                        const lower = (new java.util.ArrayList());
                        const lp1 = points[maxmin];
                        const lp2 = points[minmin];
                        lower.add(points[minmin]);
                        for (let i = minmax + 1; i <= maxmin; i++) {
                            {
                                const p = points[i];
                                if (org.dyn4j.geometry.RobustGeometry.getLocation(p, lp1, lp2) >= 0.0) {
                                    let lSize = lower.size();
                                    while ((lSize >= 2)) {
                                        {
                                            const p1 = lower.get(lSize - 1);
                                            const p2 = lower.get(lSize - 2);
                                            if (org.dyn4j.geometry.RobustGeometry.getLocation(p, p2, p1) > 0.0) {
                                                break;
                                            }
                                            lower.remove(lSize - 1);
                                            lSize--;
                                        }
                                    }
                                    ;
                                    lower.add(p);
                                }
                            }
                            ;
                        }
                        const upper = (new java.util.ArrayList());
                        const up1 = points[minmax];
                        const up2 = points[maxmax];
                        upper.add(points[maxmax]);
                        for (let i = maxmax - 1; i >= minmax; i--) {
                            {
                                const p = points[i];
                                if (org.dyn4j.geometry.RobustGeometry.getLocation(p, up1, up2) >= 0.0) {
                                    let uSize = upper.size();
                                    while ((uSize >= 2)) {
                                        {
                                            const p1 = upper.get(uSize - 1);
                                            const p2 = upper.get(uSize - 2);
                                            if (org.dyn4j.geometry.RobustGeometry.getLocation(p, p2, p1) > 0.0) {
                                                break;
                                            }
                                            upper.remove(uSize - 1);
                                            uSize--;
                                        }
                                    }
                                    ;
                                    upper.add(p);
                                }
                            }
                            ;
                        }
                        if (upper.get(0) === lower.get(lower.size() - 1)) {
                            upper.remove(0);
                        }
                        if (lower.get(0) === upper.get(upper.size() - 1)) {
                            lower.remove(0);
                        }
                        lower.addAll(upper);
                        const hull = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(lower.size());
                        lower.toArray(hull);
                        return hull;
                    }
                    constructor() {
                    }
                }
                hull_2.MonotoneChain = MonotoneChain;
                MonotoneChain["__class"] = "org.dyn4j.geometry.hull.MonotoneChain";
                MonotoneChain["__interfaces"] = ["org.dyn4j.geometry.hull.HullGenerator"];
            })(hull = geometry.hull || (geometry.hull = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var hull;
            (function (hull) {
                /**
                 * Represents a comparator that sorts points by their x coordinate
                 * lowest to highest.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 2.2.0
                 * @class
                 */
                class MinXPointComparator {
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} p1
                     * @param {org.dyn4j.geometry.Vector2} p2
                     * @return {number}
                     */
                    compare(p1, p2) {
                        return ((f => { if (f > 0) {
                            return 1;
                        }
                        else if (f < 0) {
                            return -1;
                        }
                        else {
                            return 0;
                        } })(p1.x - p2.x) | 0);
                    }
                    constructor() {
                    }
                }
                hull.MinXPointComparator = MinXPointComparator;
                MinXPointComparator["__class"] = "org.dyn4j.geometry.hull.MinXPointComparator";
                MinXPointComparator["__interfaces"] = ["java.util.Comparator"];
            })(hull = geometry.hull || (geometry.hull = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var hull;
            (function (hull_3) {
                /**
                 * Implementation of the Divide and Conquer convex hull algorithm.
                 * <p>
                 * This algorithm handles coincident and colinear points by ignoring them during processing. This ensures
                 * the produced hull will not have coincident or colinear vertices.
                 * <p>
                 * This algorithm is O(n log n) where n is the number of input points.
                 * @author William Bittle
                 * @version 3.4.0
                 * @since 2.2.0
                 * @class
                 */
                class DivideAndConquer {
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2[]} points
                     * @return {org.dyn4j.geometry.Vector2[]}
                     */
                    generate(...points) {
                        if (points == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.hull.nullArray"));
                        const size = points.length;
                        if (size <= 2)
                            return points;
                        try {
                            java.util.Arrays.sort(points, ((funcInst) => { if (typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(new org.dyn4j.geometry.hull.MinXYPointComparator()));
                        }
                        catch (e) {
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.hull.nullPoints"));
                        }
                        const hull = this.divide(points, 0, size);
                        return hull.toArray();
                    }
                    /**
                     * Recursive method to subdivide and merge the points.
                     * @param {org.dyn4j.geometry.Vector2[]} points the array of points
                     * @param {number} first the first index inclusive
                     * @param {number} last the last index exclusive
                     * @return {org.dyn4j.geometry.hull.LinkedVertexHull} {@link LinkedVertexHull} the convex hull created
                     */
                    divide(points, first, last) {
                        const size = last - first;
                        if (size === 1) {
                            return new org.dyn4j.geometry.hull.LinkedVertexHull(points[first]);
                        }
                        else {
                            const mid = ((first + last) / 2 | 0);
                            const left = this.divide(points, first, mid);
                            const right = this.divide(points, mid, last);
                            return org.dyn4j.geometry.hull.LinkedVertexHull.merge(left, right);
                        }
                    }
                    constructor() {
                    }
                }
                hull_3.DivideAndConquer = DivideAndConquer;
                DivideAndConquer["__class"] = "org.dyn4j.geometry.hull.DivideAndConquer";
                DivideAndConquer["__interfaces"] = ["org.dyn4j.geometry.hull.HullGenerator"];
            })(hull = geometry.hull || (geometry.hull = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var hull;
            (function (hull_4) {
                /**
                 * Implementation of the Graham Scan convex hull algorithm.
                 * <p>
                 * This algorithm handles coincident and colinear points by ignoring them during processing. This ensures
                 * the produced hull will not have coincident or colinear vertices.
                 * <p>
                 * This algorithm is O(n log n) where n is the number of input points.
                 * @author William Bittle
                 * @version 3.4.0
                 * @since 2.2.0
                 * @class
                 */
                class GrahamScan {
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2[]} points
                     * @return {org.dyn4j.geometry.Vector2[]}
                     */
                    generate(...points) {
                        if (points == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.hull.nullArray"));
                        const size = points.length;
                        if (size <= 2)
                            return points;
                        let minY = points[0];
                        for (let i = 1; i < size; i++) {
                            {
                                const p = points[i];
                                if (p == null)
                                    throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.hull.nullPoints"));
                                if (p.y < minY.y) {
                                    minY = p;
                                }
                                else if (p.y === minY.y) {
                                    if (p.x > minY.x) {
                                        minY = p;
                                    }
                                }
                            }
                            ;
                        }
                        const pc = new org.dyn4j.geometry.hull.ReferencePointComparator(minY);
                        java.util.Arrays.sort(points, (((funcInst) => { if (typeof funcInst == 'function') {
                            return funcInst;
                        } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(pc)));
                        const stack = (new java.util.ArrayList());
                        stack.add(points[0]);
                        stack.add(points[1]);
                        let i = 2;
                        while ((i < size)) {
                            {
                                const sSize = stack.size();
                                if (sSize === 1) {
                                    stack.add(points[i]);
                                    i++;
                                    continue;
                                }
                                const p1 = stack.get(sSize - 2);
                                const p2 = stack.get(sSize - 1);
                                const p3 = points[i];
                                const location = org.dyn4j.geometry.RobustGeometry.getLocation(p3, p2, p1);
                                if (location < 0.0) {
                                    stack.add(p3);
                                    i++;
                                }
                                else {
                                    stack.remove(sSize - 1);
                                }
                            }
                        }
                        ;
                        const hull = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(stack.size());
                        stack.toArray(hull);
                        return hull;
                    }
                    constructor() {
                    }
                }
                hull_4.GrahamScan = GrahamScan;
                GrahamScan["__class"] = "org.dyn4j.geometry.hull.GrahamScan";
                GrahamScan["__interfaces"] = ["org.dyn4j.geometry.hull.HullGenerator"];
            })(hull = geometry.hull || (geometry.hull = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var hull;
            (function (hull_5) {
                /**
                 * Create a convex {@link LinkedVertexHull} of one point.
                 * @param {org.dyn4j.geometry.Vector2} point the point
                 * @class
                 * @author William Bittle
                 */
                class LinkedVertexHull {
                    constructor(point) {
                        if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null)) {
                            let __args = arguments;
                            if (this.leftMost === undefined) {
                                this.leftMost = null;
                            }
                            if (this.rightMost === undefined) {
                                this.rightMost = null;
                            }
                            if (this.size === undefined) {
                                this.size = 0;
                            }
                            const root = new org.dyn4j.geometry.hull.LinkedVertex(point);
                            this.leftMost = root;
                            this.rightMost = root;
                            this.size = 1;
                        }
                        else if (point === undefined) {
                            let __args = arguments;
                            if (this.leftMost === undefined) {
                                this.leftMost = null;
                            }
                            if (this.rightMost === undefined) {
                                this.rightMost = null;
                            }
                            if (this.size === undefined) {
                                this.size = 0;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("LinkedVertexHull[Size=").append(this.size).append("|LeftMostPoint=").append(this.leftMost.point).append("|RightMostPoint=").append(this.rightMost.point);
                        return sb.toString();
                    }
                    /**
                     * Returns a new array representing this convex hull.
                     * @return {org.dyn4j.geometry.Vector2[]} {@link Vector2}[]
                     */
                    toArray() {
                        const points = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.size);
                        let vertex = this.leftMost;
                        for (let i = 0; i < this.size; i++) {
                            {
                                points[i] = vertex.point;
                                vertex = vertex.next;
                            }
                            ;
                        }
                        return points;
                    }
                    /**
                     * Merges the two given convex {@link LinkedVertexHull}s into one convex {@link LinkedVertexHull}.
                     * <p>
                     * The left {@link LinkedVertexHull} should contain only points whose x coordinates are
                     * less than all the points in the right {@link LinkedVertexHull}.
                     * @param {org.dyn4j.geometry.hull.LinkedVertexHull} left the left convex {@link LinkedVertexHull}
                     * @param {org.dyn4j.geometry.hull.LinkedVertexHull} right the right convex {@link LinkedVertexHull}
                     * @return {org.dyn4j.geometry.hull.LinkedVertexHull} {@link LinkedVertexHull} the merged convex hull
                     */
                    static merge(left, right) {
                        const hull = new LinkedVertexHull();
                        hull.leftMost = left.leftMost;
                        hull.rightMost = right.rightMost;
                        let lu = left.rightMost;
                        let ru = right.leftMost;
                        let limitRightU = right.size - 1;
                        let limitLeftU = left.size - 1;
                        while ((true)) {
                            {
                                const prevLu = lu;
                                const prevRu = ru;
                                while ((limitRightU > 0 && org.dyn4j.geometry.RobustGeometry.getLocation(ru.next.point, lu.point, ru.point) <= 0)) {
                                    {
                                        ru = ru.next;
                                        limitRightU--;
                                    }
                                }
                                ;
                                while ((limitLeftU > 0 && org.dyn4j.geometry.RobustGeometry.getLocation(lu.prev.point, lu.point, ru.point) <= 0)) {
                                    {
                                        lu = lu.prev;
                                        limitLeftU--;
                                    }
                                }
                                ;
                                if (lu === prevLu && ru === prevRu) {
                                    break;
                                }
                            }
                        }
                        ;
                        let ll = left.rightMost;
                        let rl = right.leftMost;
                        let limitRightL = right.size - 1;
                        let limitLeftL = left.size - 1;
                        while ((true)) {
                            {
                                const prevLl = ll;
                                const prevRl = rl;
                                while ((limitRightL > 0 && org.dyn4j.geometry.RobustGeometry.getLocation(rl.prev.point, ll.point, rl.point) >= 0)) {
                                    {
                                        rl = rl.prev;
                                        limitRightL--;
                                    }
                                }
                                ;
                                while ((limitLeftL > 0 && org.dyn4j.geometry.RobustGeometry.getLocation(ll.next.point, ll.point, rl.point) >= 0)) {
                                    {
                                        ll = ll.next;
                                        limitLeftL--;
                                    }
                                }
                                ;
                                if (ll === prevLl && rl === prevRl) {
                                    break;
                                }
                            }
                        }
                        ;
                        lu.next = ru;
                        ru.prev = lu;
                        ll.prev = rl;
                        rl.next = ll;
                        let size = 0;
                        let v = lu;
                        do {
                            {
                                size++;
                                v = v.next;
                            }
                        } while ((v !== lu));
                        hull.size = size;
                        return hull;
                    }
                }
                hull_5.LinkedVertexHull = LinkedVertexHull;
                LinkedVertexHull["__class"] = "org.dyn4j.geometry.hull.LinkedVertexHull";
            })(hull = geometry.hull || (geometry.hull = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var hull;
            (function (hull) {
                /**
                 * Represents a comparator that sorts points by their x coordinate
                 * lowest to highest then by the y coordinate lowest to highest.
                 * @author William Bittle
                 * @version 3.4.0
                 * @since 2.2.0
                 * @class
                 */
                class MinXYPointComparator {
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} p1
                     * @param {org.dyn4j.geometry.Vector2} p2
                     * @return {number}
                     */
                    compare(p1, p2) {
                        let diff = p1.x - p2.x;
                        if (diff === 0.0) {
                            diff = p1.y - p2.y;
                        }
                        return diff > 0 ? 1 : diff < 0 ? -1 : 0;
                    }
                    constructor() {
                    }
                }
                hull.MinXYPointComparator = MinXYPointComparator;
                MinXYPointComparator["__class"] = "org.dyn4j.geometry.hull.MinXYPointComparator";
                MinXYPointComparator["__interfaces"] = ["java.util.Comparator"];
            })(hull = geometry.hull || (geometry.hull = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Creates a ray from the given start point in the given direction.
             * @param {org.dyn4j.geometry.Vector2} start the start point
             * @param {number} direction the direction in radians
             * @since 3.0.2
             * @class
             * @author William Bittle
             */
            class Ray {
                constructor(start, direction) {
                    if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((direction != null && direction instanceof org.dyn4j.geometry.Vector2) || direction === null)) {
                        let __args = arguments;
                        if (this.start === undefined) {
                            this.start = null;
                        }
                        if (this.direction === undefined) {
                            this.direction = null;
                        }
                        if (start == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.ray.nullStart"));
                        if (direction == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.ray.nullDirection"));
                        if (direction.isZero())
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.ray.zeroDirection"));
                        this.start = start;
                        this.direction = direction.getNormalized();
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((typeof direction === 'number') || direction === null)) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let direction = new org.dyn4j.geometry.Vector2(__args[1]);
                            if (this.start === undefined) {
                                this.start = null;
                            }
                            if (this.direction === undefined) {
                                this.direction = null;
                            }
                            if (start == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.ray.nullStart"));
                            if (direction == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.ray.nullDirection"));
                            if (direction.isZero())
                                throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.ray.zeroDirection"));
                            this.start = start;
                            this.direction = direction.getNormalized();
                        }
                        if (this.start === undefined) {
                            this.start = null;
                        }
                        if (this.direction === undefined) {
                            this.direction = null;
                        }
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && direction === undefined) {
                        let __args = arguments;
                        let direction = __args[0];
                        {
                            let __args = arguments;
                            let start = new org.dyn4j.geometry.Vector2();
                            if (this.start === undefined) {
                                this.start = null;
                            }
                            if (this.direction === undefined) {
                                this.direction = null;
                            }
                            if (start == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.ray.nullStart"));
                            if (direction == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.ray.nullDirection"));
                            if (direction.isZero())
                                throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.ray.zeroDirection"));
                            this.start = start;
                            this.direction = direction.getNormalized();
                        }
                        if (this.start === undefined) {
                            this.start = null;
                        }
                        if (this.direction === undefined) {
                            this.direction = null;
                        }
                    }
                    else if (((typeof start === 'number') || start === null) && direction === undefined) {
                        let __args = arguments;
                        let direction = __args[0];
                        {
                            let __args = arguments;
                            let direction = new org.dyn4j.geometry.Vector2(__args[0]);
                            {
                                let __args = arguments;
                                let start = new org.dyn4j.geometry.Vector2();
                                if (this.start === undefined) {
                                    this.start = null;
                                }
                                if (this.direction === undefined) {
                                    this.direction = null;
                                }
                                if (start == null)
                                    throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.ray.nullStart"));
                                if (direction == null)
                                    throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.ray.nullDirection"));
                                if (direction.isZero())
                                    throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.ray.zeroDirection"));
                                this.start = start;
                                this.direction = direction.getNormalized();
                            }
                            if (this.start === undefined) {
                                this.start = null;
                            }
                            if (this.direction === undefined) {
                                this.direction = null;
                            }
                        }
                        if (this.start === undefined) {
                            this.start = null;
                        }
                        if (this.direction === undefined) {
                            this.direction = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Ray[Start=").append(this.start).append("|Direction=").append(this.getDirection()).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the start point.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getStart() {
                    return this.start;
                }
                /**
                 * Sets the start point.
                 * @param {org.dyn4j.geometry.Vector2} start the start point
                 * @throws NullPointerException if start is null
                 */
                setStart(start) {
                    if (start == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.ray.nullStart"));
                    this.start = start;
                }
                setDirection$double(direction) {
                    this.direction = new org.dyn4j.geometry.Vector2(direction);
                }
                /**
                 * Returns the direction of this ray in radians.
                 * @return {number} double the direction in radians between [-&pi;, &pi;]
                 * @since 3.0.2
                 */
                getDirection() {
                    return this.direction.getDirection();
                }
                setDirection$org_dyn4j_geometry_Vector2(direction) {
                    if (direction == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.ray.nullDirection"));
                    if (direction.isZero())
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.ray.zeroDirection"));
                    this.direction = direction;
                }
                /**
                 * Sets the direction.
                 * @param {org.dyn4j.geometry.Vector2} direction the direction; should be normalized
                 * @throws NullPointerException if direction is null
                 * @throws IllegalArgumentException if direction is the zero vector
                 */
                setDirection(direction) {
                    if (((direction != null && direction instanceof org.dyn4j.geometry.Vector2) || direction === null)) {
                        return this.setDirection$org_dyn4j_geometry_Vector2(direction);
                    }
                    else if (((typeof direction === 'number') || direction === null)) {
                        return this.setDirection$double(direction);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the direction.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @since 3.0.2
                 */
                getDirectionVector() {
                    return this.direction;
                }
            }
            geometry.Ray = Ray;
            Ray["__class"] = "org.dyn4j.geometry.Ray";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Enumeration for special {@link Mass} types.
             * @author William Bittle
             * @version 1.0.3
             * @since 1.0.0
             * @see Mass
             * @enum
             * @property {org.dyn4j.geometry.MassType} NORMAL
             * Indicates a normal mass
             * @property {org.dyn4j.geometry.MassType} INFINITE
             * Indicates that the mass is infinite (rate of rotation and translation should not change)
             * @property {org.dyn4j.geometry.MassType} FIXED_ANGULAR_VELOCITY
             * Indicates that the mass's rate of rotation should not change
             * @property {org.dyn4j.geometry.MassType} FIXED_LINEAR_VELOCITY
             * Indicates that the mass's rate of translation should not change
             * @property {org.dyn4j.geometry.MassType} X_MOTION_ONLY
             * Indicates that the mass's y coordinate should not change
             * @property {org.dyn4j.geometry.MassType} Y_MOTION_ONLY
             * Indicates that the mass's x coordinate should not change
             * @class
             */
            let MassType;
            (function (MassType) {
                /**
                 * Indicates a normal mass
                 */
                MassType[MassType["NORMAL"] = 0] = "NORMAL";
                /**
                 * Indicates that the mass is infinite (rate of rotation and translation should not change)
                 */
                MassType[MassType["INFINITE"] = 1] = "INFINITE";
                /**
                 * Indicates that the mass's rate of rotation should not change
                 */
                MassType[MassType["FIXED_ANGULAR_VELOCITY"] = 2] = "FIXED_ANGULAR_VELOCITY";
                /**
                 * Indicates that the mass's rate of translation should not change
                 */
                MassType[MassType["FIXED_LINEAR_VELOCITY"] = 3] = "FIXED_LINEAR_VELOCITY";
                /**
                 * Indicates that the mass's y coordinate should not change
                 */
                MassType[MassType["X_MOTION_ONLY"] = 4] = "X_MOTION_ONLY";
                /**
                 * Indicates that the mass's x coordinate should not change
                 */
                MassType[MassType["Y_MOTION_ONLY"] = 5] = "Y_MOTION_ONLY";
            })(MassType = geometry.MassType || (geometry.MassType = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full Constructor.
             * <p>
             * The <code>center</code> parameter will be copied.
             * @param {org.dyn4j.geometry.Vector2} center center of {@link Mass} in local coordinates
             * @param {number} mass mass in kg
             * @param {number} inertia inertia tensor in kg &middot; m<sup>2</sup>
             * @throws NullPointerException if center is null
             * @throws IllegalArgumentException if mass or inertia is less than zero
             * @class
             * @author William Bittle
             */
            class Mass {
                constructor(center, mass, inertia) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null) && ((typeof mass === 'number') || mass === null) && ((typeof inertia === 'number') || inertia === null)) {
                        let __args = arguments;
                        if (this.type === undefined) {
                            this.type = null;
                        }
                        if (this.center === undefined) {
                            this.center = null;
                        }
                        if (this.mass === undefined) {
                            this.mass = 0;
                        }
                        if (this.inertia === undefined) {
                            this.inertia = 0;
                        }
                        if (this.invMass === undefined) {
                            this.invMass = 0;
                        }
                        if (this.invInertia === undefined) {
                            this.invInertia = 0;
                        }
                        if (center == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.mass.nullCenter"));
                        if (mass < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.mass.invalidMass"));
                        if (inertia < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.mass.invalidInertia"));
                        this.type = org.dyn4j.geometry.MassType.NORMAL;
                        this.center = center.copy();
                        this.mass = mass;
                        this.inertia = inertia;
                        if (mass > org.dyn4j.Epsilon.E_$LI$()) {
                            this.invMass = 1.0 / mass;
                        }
                        else {
                            this.invMass = 0.0;
                            this.type = org.dyn4j.geometry.MassType.FIXED_LINEAR_VELOCITY;
                        }
                        if (inertia > org.dyn4j.Epsilon.E_$LI$()) {
                            this.invInertia = 1.0 / inertia;
                        }
                        else {
                            this.invInertia = 0.0;
                            this.type = org.dyn4j.geometry.MassType.FIXED_ANGULAR_VELOCITY;
                        }
                        if (mass <= org.dyn4j.Epsilon.E_$LI$() && inertia <= org.dyn4j.Epsilon.E_$LI$()) {
                            this.type = org.dyn4j.geometry.MassType.INFINITE;
                        }
                    }
                    else if (((center != null && center instanceof org.dyn4j.geometry.Mass) || center === null) && mass === undefined && inertia === undefined) {
                        let __args = arguments;
                        let mass = __args[0];
                        if (this.type === undefined) {
                            this.type = null;
                        }
                        if (this.center === undefined) {
                            this.center = null;
                        }
                        if (this.mass === undefined) {
                            this.mass = 0;
                        }
                        if (this.inertia === undefined) {
                            this.inertia = 0;
                        }
                        if (this.invMass === undefined) {
                            this.invMass = 0;
                        }
                        if (this.invInertia === undefined) {
                            this.invInertia = 0;
                        }
                        if (mass == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.mass.nullMass"));
                        this.type = mass.type;
                        this.center = mass.center.copy();
                        this.mass = mass.mass;
                        this.inertia = mass.inertia;
                        this.invMass = mass.invMass;
                        this.invInertia = mass.invInertia;
                    }
                    else if (center === undefined && mass === undefined && inertia === undefined) {
                        let __args = arguments;
                        if (this.type === undefined) {
                            this.type = null;
                        }
                        if (this.center === undefined) {
                            this.center = null;
                        }
                        if (this.mass === undefined) {
                            this.mass = 0;
                        }
                        if (this.inertia === undefined) {
                            this.inertia = 0;
                        }
                        if (this.invMass === undefined) {
                            this.invMass = 0;
                        }
                        if (this.invInertia === undefined) {
                            this.invInertia = 0;
                        }
                        this.type = org.dyn4j.geometry.MassType.INFINITE;
                        this.center = new org.dyn4j.geometry.Vector2();
                        this.mass = 0.0;
                        this.inertia = 0.0;
                        this.invMass = 0.0;
                        this.invInertia = 0.0;
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Copies this {@link Mass}.
                 * @return {org.dyn4j.geometry.Mass} {@link Mass}
                 */
                copy() {
                    return new Mass(this);
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Mass[Type=").append(this.type).append("|Center=").append(this.center).append("|Mass=").append(this.mass).append("|Inertia=").append(this.inertia).append("]");
                    return sb.toString();
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    const prime = 31;
                    let result = 1;
                    result = prime * result + ((this.center == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                    } })(this.center));
                    let temp;
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.inertia);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.invInertia);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.invMass);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.mass);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    result = prime * result + ((this.type == null) ? 0 : org.dyn4j.geometry.MassType["_$wrappers"][this.type].hashCode());
                    return result;
                }
                /**
                 *
                 * @param {*} other
                 * @return {boolean}
                 */
                equals(other) {
                    if (other == null)
                        return false;
                    if (other != null && other instanceof org.dyn4j.geometry.Mass) {
                        const o = other;
                        if (this.type === o.type && this.mass === o.mass && this.inertia === o.inertia && this.center.equals$org_dyn4j_geometry_Vector2(o.center)) {
                            return true;
                        }
                    }
                    return false;
                }
                /**
                 * Creates a {@link Mass} object from the given array of masses.
                 * <p>
                 * Uses the Parallel Axis Theorem to obtain the inertia tensor about
                 * the center of all the given masses:
                 * <p style="white-space: pre;"> I<sub>dis</sub> = I<sub>cm</sub> + mr<sup>2</sup>
                 * I<sub>total</sub> = &sum; I<sub>dis</sub></p>
                 * The center for the resulting mass will be a mass weighted center.
                 * <p>
                 * This method will produce unexpected results if any mass contained in the
                 * list is infinite.
                 * @param {*} masses the list of {@link Mass} objects to combine
                 * @return {org.dyn4j.geometry.Mass} {@link Mass} the combined {@link Mass}
                 * @throws NullPointerException if masses is null or contains null elements
                 * @throws IllegalArgumentException if masses is empty
                 */
                static create(masses) {
                    if (masses == null) {
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.mass.nullMassList"));
                    }
                    if (masses.size() === 0) {
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.mass.invalidMassListSize"));
                    }
                    const size = masses.size();
                    if (size === 1) {
                        const m = masses.get(0);
                        if (m != null) {
                            return new Mass(masses.get(0));
                        }
                        else {
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.mass.nullMassListElement"));
                        }
                    }
                    const c = new org.dyn4j.geometry.Vector2();
                    let m = 0.0;
                    let I = 0.0;
                    for (let i = 0; i < size; i++) {
                        {
                            const mass = masses.get(i);
                            if (mass == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.mass.nullMassListElement"));
                            c.add$org_dyn4j_geometry_Vector2(mass.center.product(mass.mass));
                            m += mass.mass;
                        }
                        ;
                    }
                    if (m > 0.0) {
                        c.divide(m);
                    }
                    for (let i = 0; i < size; i++) {
                        {
                            const mass = masses.get(i);
                            const d2 = mass.center.distanceSquared$org_dyn4j_geometry_Vector2(c);
                            const Idis = mass.inertia + mass.mass * d2;
                            I += Idis;
                        }
                        ;
                    }
                    return new Mass(c, m, I);
                }
                /**
                 * Returns true if this {@link Mass} object is of type {@link MassType#INFINITE}.
                 * <p>
                 * A mass will still be treated as an infinite mass in physical modeling if the
                 * mass and inertia are zero. This method simply checks the mass type.
                 * @return {boolean} boolean
                 */
                isInfinite() {
                    return this.type === org.dyn4j.geometry.MassType.INFINITE;
                }
                /**
                 * Sets the mass type.
                 * @param {org.dyn4j.geometry.MassType} type the mass type
                 * @throws NullPointerException if type is null
                 */
                setType(type) {
                    if (type == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.mass.nullMassType"));
                    this.type = type;
                }
                /**
                 * Returns the mass type.
                 * @return {org.dyn4j.geometry.MassType} {@link MassType}
                 */
                getType() {
                    return this.type;
                }
                /**
                 * Returns the center of mass.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getCenter() {
                    return this.center;
                }
                /**
                 * Returns the mass.
                 * @return {number} double
                 */
                getMass() {
                    if (this.type === org.dyn4j.geometry.MassType.INFINITE || this.type === org.dyn4j.geometry.MassType.FIXED_LINEAR_VELOCITY) {
                        return 0.0;
                    }
                    else {
                        return this.mass;
                    }
                }
                /**
                 * Returns the inertia tensor.
                 * @return {number} double
                 */
                getInertia() {
                    if (this.type === org.dyn4j.geometry.MassType.INFINITE || this.type === org.dyn4j.geometry.MassType.FIXED_ANGULAR_VELOCITY) {
                        return 0.0;
                    }
                    else {
                        return this.inertia;
                    }
                }
                /**
                 * returns mass (in kg) set for the mass
                 * @return {number} mass=area*density irrespective of nature of mass (static or dynamic)
                 */
                getAssignedMass() {
                    return this.mass;
                }
                /**
                 * returns assigned inertia (in kgm2) set for the mass
                 * @return {number} inertia=area*density*k2 irrespective of nature of mass (static or dynamic)
                 */
                getAssignedInertia() {
                    return this.inertia;
                }
                /**
                 * Returns the inverse mass.
                 * @return {number} double
                 */
                getInverseMass() {
                    if (this.type === org.dyn4j.geometry.MassType.INFINITE || this.type === org.dyn4j.geometry.MassType.FIXED_LINEAR_VELOCITY) {
                        return 0.0;
                    }
                    else {
                        return this.invMass;
                    }
                }
                /**
                 * Returns the inverse inertia tensor.
                 * @return {number} double
                 */
                getInverseInertia() {
                    if (this.type === org.dyn4j.geometry.MassType.INFINITE || this.type === org.dyn4j.geometry.MassType.FIXED_ANGULAR_VELOCITY) {
                        return 0.0;
                    }
                    else {
                        return this.invInertia;
                    }
                }
            }
            geometry.Mass = Mass;
            Mass["__class"] = "org.dyn4j.geometry.Mass";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Copy constructor.
             * @param {org.dyn4j.geometry.Rotation} rotation the {@link Rotation} to copy from
             * @class
             * @author Manolis Tsamis
             */
            class Rotation {
                constructor(cost, sint) {
                    if (((typeof cost === 'number') || cost === null) && ((typeof sint === 'number') || sint === null)) {
                        let __args = arguments;
                        if (this.cost === undefined) {
                            this.cost = 0;
                        }
                        if (this.sint === undefined) {
                            this.sint = 0;
                        }
                        this.cost = cost;
                        this.sint = sint;
                    }
                    else if (((cost != null && cost instanceof org.dyn4j.geometry.Rotation) || cost === null) && sint === undefined) {
                        let __args = arguments;
                        let rotation = __args[0];
                        if (this.cost === undefined) {
                            this.cost = 0;
                        }
                        if (this.sint === undefined) {
                            this.sint = 0;
                        }
                        this.cost = rotation.cost;
                        this.sint = rotation.sint;
                    }
                    else if (((typeof cost === 'number') || cost === null) && sint === undefined) {
                        let __args = arguments;
                        let angle = __args[0];
                        if (this.cost === undefined) {
                            this.cost = 0;
                        }
                        if (this.sint === undefined) {
                            this.sint = 0;
                        }
                        this.cost = Math.cos(angle);
                        this.sint = Math.sin(angle);
                    }
                    else if (cost === undefined && sint === undefined) {
                        let __args = arguments;
                        if (this.cost === undefined) {
                            this.cost = 0;
                        }
                        if (this.sint === undefined) {
                            this.sint = 0;
                        }
                        this.cost = 1.0;
                        this.sint = 0.0;
                    }
                    else
                        throw new Error('invalid overload');
                }
                static SQRT_2_INV_$LI$() { if (Rotation.SQRT_2_INV == null) {
                    Rotation.SQRT_2_INV = 1.0 / Math.sqrt(2);
                } return Rotation.SQRT_2_INV; }
                static of$double(angle) {
                    return new Rotation(angle);
                }
                /**
                 * Alternative way to create a new {@link Rotation} from a given angle, in degrees.
                 * @param {number} angle in degrees
                 * @return {org.dyn4j.geometry.Rotation} A {@link Rotation} for that angle
                 */
                static ofDegrees(angle) {
                    return new Rotation(/* toRadians */ (x => x * Math.PI / 180)(angle));
                }
                static of$org_dyn4j_geometry_Vector2(direction) {
                    const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
                    if (magnitude <= org.dyn4j.Epsilon.E_$LI$()) {
                        return new Rotation();
                    }
                    return new Rotation(direction.x / magnitude, direction.y / magnitude);
                }
                static of$double$double(cost, sint) {
                    const magnitude = cost * cost + sint * sint;
                    if (Math.abs(magnitude - 1) > org.dyn4j.Epsilon.E_$LI$()) {
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.rotation.invalidPoint"));
                    }
                    return new Rotation(cost, sint);
                }
                /**
                 * Static method to create a {@link Rotation} from a pair of values that lie on the unit circle;
                 * That is a pair of values (x, y) such that x = cos(&theta;), y = sin(&theta;) for some value &theta;
                 * This method is provided for the case where the cos and sin values are already computed and
                 * the overhead can be avoided.
                 * This method will check whether those values are indeed on the unit circle and otherwise throw an {@link IllegalArgumentException}.
                 * @param {number} cost The x value = cos(&theta;)
                 * @param {number} sint The y value = sin(&theta;)
                 * @throws IllegalArgumentException if (cost, sint) is not on the unit circle
                 * @return {org.dyn4j.geometry.Rotation} A {@link Rotation} defined by (cost, sint)
                 */
                static of(cost, sint) {
                    if (((typeof cost === 'number') || cost === null) && ((typeof sint === 'number') || sint === null)) {
                        return org.dyn4j.geometry.Rotation.of$double$double(cost, sint);
                    }
                    else if (((cost != null && cost instanceof org.dyn4j.geometry.Vector2) || cost === null) && sint === undefined) {
                        return org.dyn4j.geometry.Rotation.of$org_dyn4j_geometry_Vector2(cost);
                    }
                    else if (((cost != null && cost instanceof org.dyn4j.geometry.Transform) || cost === null) && sint === undefined) {
                        return org.dyn4j.geometry.Rotation.of$org_dyn4j_geometry_Transform(cost);
                    }
                    else if (((typeof cost === 'number') || cost === null) && sint === undefined) {
                        return org.dyn4j.geometry.Rotation.of$double(cost);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static of$org_dyn4j_geometry_Transform(transform) {
                    return new Rotation(transform.cost, transform.sint);
                }
                /**
                 * Creates a new {@link Rotation} of 0 degrees.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                static rotation0() {
                    return new Rotation();
                }
                /**
                 * Creates a new {@link Rotation} of 90 degrees.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                static rotation90() {
                    return new Rotation(0.0, 1.0);
                }
                /**
                 * Creates a new {@link Rotation} of 180 degrees.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                static rotation180() {
                    return new Rotation(-1.0, 0.0);
                }
                /**
                 * Creates a new {@link Rotation} of 270 degrees.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                static rotation270() {
                    return new Rotation(0.0, -1.0);
                }
                /**
                 * Creates a new {@link Rotation} of 45 degrees.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                static rotation45() {
                    return new Rotation(Rotation.SQRT_2_INV_$LI$(), Rotation.SQRT_2_INV_$LI$());
                }
                /**
                 * Creates a new {@link Rotation} of 135 degrees.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                static rotation135() {
                    return new Rotation(-Rotation.SQRT_2_INV_$LI$(), Rotation.SQRT_2_INV_$LI$());
                }
                /**
                 * Creates a new {@link Rotation} of 225 degrees.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                static rotation225() {
                    return new Rotation(-Rotation.SQRT_2_INV_$LI$(), -Rotation.SQRT_2_INV_$LI$());
                }
                /**
                 * Creates a new {@link Rotation} of 315 degrees.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                static rotation315() {
                    return new Rotation(Rotation.SQRT_2_INV_$LI$(), -Rotation.SQRT_2_INV_$LI$());
                }
                /**
                 * @return {org.dyn4j.geometry.Rotation} a copy of this {@link Rotation}
                 */
                copy() {
                    return new Rotation(this.cost, this.sint);
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    const prime = 31;
                    let result = 3;
                    let temp;
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.cost);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.sint);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    return result;
                }
                equals$java_lang_Object(obj) {
                    if (obj == null)
                        return false;
                    if (obj === this)
                        return true;
                    if (obj != null && obj instanceof org.dyn4j.geometry.Rotation) {
                        const rotation = obj;
                        return this.cost === rotation.cost && this.sint === rotation.sint;
                    }
                    return false;
                }
                equals$org_dyn4j_geometry_Rotation(rotation) {
                    if (rotation == null)
                        return false;
                    return this.cost === rotation.cost && this.sint === rotation.sint;
                }
                equals$org_dyn4j_geometry_Rotation$double(rotation, error) {
                    if (rotation == null)
                        return false;
                    return Math.abs(this.cost - rotation.cost) < error && Math.abs(this.sint - rotation.sint) < error;
                }
                /**
                 * Returns true if the cos and sin components of this {@link Rotation}
                 * are the same as the given {@link Rotation} given the specified error.
                 * @param {org.dyn4j.geometry.Rotation} rotation the {@link Rotation} to compare to
                 * @param {number} error the error
                 * @return {boolean} boolean
                 */
                equals(rotation, error) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof error === 'number') || error === null)) {
                        return this.equals$org_dyn4j_geometry_Rotation$double(rotation, error);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof error === 'number') || error === null)) {
                        return this.equals$double$double(rotation, error);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && error === undefined) {
                        return this.equals$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && error === undefined) {
                        return this.equals$double(rotation);
                    }
                    else if (((rotation != null) || rotation === null) && error === undefined) {
                        return this.equals$java_lang_Object(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                equals$double(angle) {
                    return this.cost === Math.cos(angle) && this.sint === Math.sin(angle);
                }
                equals$double$double(angle, error) {
                    return Math.abs(this.cost - Math.cos(angle)) < error && Math.abs(this.sint - Math.sin(angle)) < error;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Rotation(").append(this.cost).append(", ").append(this.sint).append(")");
                    return sb.toString();
                }
                set$org_dyn4j_geometry_Rotation(rotation) {
                    this.cost = rotation.cost;
                    this.sint = rotation.sint;
                    return this;
                }
                /**
                 * Sets this {@link Rotation} to the given {@link Rotation}.
                 * @param {org.dyn4j.geometry.Rotation} rotation the {@link Rotation} to set this {@link Rotation} to
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation} this rotation
                 */
                set(rotation) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null)) {
                        return this.set$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null)) {
                        return this.set$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Sets this {@link Rotation} to be the identity.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation} this rotation
                 */
                setIdentity() {
                    this.cost = 1.0;
                    this.sint = 0.0;
                    return this;
                }
                set$double(angle) {
                    this.cost = Math.cos(angle);
                    this.sint = Math.sin(angle);
                    return this;
                }
                /**
                 * Returns the value of cos(&theta;) for this {@link Rotation}.
                 * @return {number} double
                 */
                getCost() {
                    return this.cost;
                }
                /**
                 * Returns the value of sin(&theta;) for this {@link Rotation}.
                 * @return {number} double
                 */
                getSint() {
                    return this.sint;
                }
                /**
                 * Returns the angle in radians for this {@link Rotation}.
                 * @return {number} double
                 */
                toRadians() {
                    const acos = Math.acos(this.cost);
                    const angle = (this.sint >= 0) ? acos : -acos;
                    return angle;
                }
                /**
                 * Returns the angle in degrees for this {@link Rotation}.
                 * @return {number} double
                 */
                toDegrees() {
                    return /* toDegrees */ (x => x * 180 / Math.PI)(this.toRadians());
                }
                toVector$() {
                    return new org.dyn4j.geometry.Vector2(this.cost, this.sint);
                }
                toVector$double(magnitude) {
                    return new org.dyn4j.geometry.Vector2(this.cost * magnitude, this.sint * magnitude);
                }
                /**
                 * Returns this {@link Rotation} as a direction vector with the given magnitude.
                 * @param {number} magnitude the magnitude
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                toVector(magnitude) {
                    if (((typeof magnitude === 'number') || magnitude === null)) {
                        return this.toVector$double(magnitude);
                    }
                    else if (magnitude === undefined) {
                        return this.toVector$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Internal helper method to perform rotations consisting of a 45 degree.
                 * @param {number} cost the cos of the angle
                 * @param {number} sint the sin of the angle
                 * @return {org.dyn4j.geometry.Rotation} This {@link Rotation} after being set to (cost, sint) and rotated 45 degrees
                 */
                rotate45Helper(cost, sint) {
                    this.cost = Rotation.SQRT_2_INV_$LI$() * (cost - sint);
                    this.sint = Rotation.SQRT_2_INV_$LI$() * (cost + sint);
                    return this;
                }
                /**
                 * Internal helper method to perform rotations consisting of a 45 degree.
                 * Returns a new {@link Rotation} object.
                 * @param {number} cost the cos of the angle
                 * @param {number} sint the sin of the angle
                 * @return {org.dyn4j.geometry.Rotation} A new {@link Rotation} with initial values (cost, sint) and then rotated 45 degrees
                 */
                getRotated45Helper(cost, sint) {
                    return new Rotation(Rotation.SQRT_2_INV_$LI$() * (cost - sint), Rotation.SQRT_2_INV_$LI$() * (cost + sint));
                }
                /**
                 * Rotates this rotation 45 degrees and returns this rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                rotate45() {
                    return this.rotate45Helper(this.cost, this.sint);
                }
                /**
                 * Rotates this rotation 45 degrees and returns a new rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                getRotated45() {
                    return this.getRotated45Helper(this.cost, this.sint);
                }
                /**
                 * Rotates this rotation 90 degrees and returns this rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                rotate90() {
                    const temp = this.cost;
                    this.cost = -this.sint;
                    this.sint = temp;
                    return this;
                }
                /**
                 * Rotates this rotation 90 degrees and returns a new rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                getRotated90() {
                    return new Rotation(-this.sint, this.cost);
                }
                /**
                 * Rotates this rotation 135 degrees and returns this rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                rotate135() {
                    return this.rotate45Helper(-this.sint, this.cost);
                }
                /**
                 * Rotates this rotation 135 degrees and returns a new rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                getRotated135() {
                    return this.getRotated45Helper(-this.sint, this.cost);
                }
                /**
                 * Rotates this rotation 180 degrees and returns this rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                rotate180() {
                    this.cost = -this.cost;
                    this.sint = -this.sint;
                    return this;
                }
                /**
                 * Rotates this rotation 180 degrees and returns a new rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                getRotated180() {
                    return new Rotation(-this.cost, -this.sint);
                }
                /**
                 * Rotates this rotation 225 degrees and returns this rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                rotate225() {
                    return this.rotate45Helper(-this.cost, -this.sint);
                }
                /**
                 * Rotates this rotation 225 degrees and returns a new rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                getRotated225() {
                    return this.getRotated45Helper(-this.cost, -this.sint);
                }
                /**
                 * Rotates this rotation 270 degrees and returns this rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                rotate270() {
                    const temp = this.cost;
                    this.cost = this.sint;
                    this.sint = -temp;
                    return this;
                }
                /**
                 * Rotates this rotation 270 degrees and returns a new rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                getRotated270() {
                    return new Rotation(this.sint, -this.cost);
                }
                /**
                 * Rotates this rotation 315 degrees and returns this rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                rotate315() {
                    return this.rotate45Helper(this.sint, -this.cost);
                }
                /**
                 * Rotates this rotation 315 degrees and returns a new rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                getRotated315() {
                    return this.getRotated45Helper(this.sint, -this.cost);
                }
                /**
                 * Negates this rotation and returns this rotation.
                 * <p>
                 * Let &theta; be the rotation, then -&theta; is the inverse rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                inverse() {
                    this.sint = -this.sint;
                    return this;
                }
                /**
                 * Negates this rotation and returns a new rotation.
                 * <p>
                 * Let &theta; be the rotation, then -&theta; is the inverse rotation.
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                getInversed() {
                    return new Rotation(this.cost, -this.sint);
                }
                rotate$double$double(c, s) {
                    const cost = this.cost;
                    const sint = this.sint;
                    this.cost = cost * c - sint * s;
                    this.sint = cost * s + sint * c;
                    return this;
                }
                /**
                 * Internal method that rotates this {@link Rotation} by an angle &theta; and
                 * returns this rotation.
                 * @param {number} c cos(&theta;)
                 * @param {number} s sin(&theta;)
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                rotate(c, s) {
                    if (((typeof c === 'number') || c === null) && ((typeof s === 'number') || s === null)) {
                        return this.rotate$double$double(c, s);
                    }
                    else if (((c != null && c instanceof org.dyn4j.geometry.Rotation) || c === null) && s === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(c);
                    }
                    else if (((typeof c === 'number') || c === null) && s === undefined) {
                        return this.rotate$double(c);
                    }
                    else
                        throw new Error('invalid overload');
                }
                getRotated$double$double(c, s) {
                    return new Rotation(this.cost * c - this.sint * s, this.cost * s + this.sint * c);
                }
                /**
                 * Internal method that return a new {@link Rotation} representing
                 * this {@link Rotation} after being rotated by an angle &theta;.
                 * @param {number} c cos(&theta;)
                 * @param {number} s sin(&theta;)
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                getRotated(c, s) {
                    if (((typeof c === 'number') || c === null) && ((typeof s === 'number') || s === null)) {
                        return this.getRotated$double$double(c, s);
                    }
                    else if (((c != null && c instanceof org.dyn4j.geometry.Rotation) || c === null) && s === undefined) {
                        return this.getRotated$org_dyn4j_geometry_Rotation(c);
                    }
                    else if (((typeof c === 'number') || c === null) && s === undefined) {
                        return this.getRotated$double(c);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$org_dyn4j_geometry_Rotation(rotation) {
                    return this.rotate$double$double(rotation.cost, rotation.sint);
                }
                getRotated$org_dyn4j_geometry_Rotation(rotation) {
                    return this.getRotated$double$double(rotation.cost, rotation.sint);
                }
                rotate$double(angle) {
                    return this.rotate$double$double(Math.cos(angle), Math.sin(angle));
                }
                getRotated$double(angle) {
                    return this.getRotated$double$double(Math.cos(angle), Math.sin(angle));
                }
                isIdentity$() {
                    return this.cost === 1;
                }
                isIdentity$double(error) {
                    return Math.abs(this.cost - 1) < error;
                }
                /**
                 * Returns true if this rotation is an identity rotation within the given error.
                 * @param {number} error the error
                 * @return {boolean} boolean
                 */
                isIdentity(error) {
                    if (((typeof error === 'number') || error === null)) {
                        return this.isIdentity$double(error);
                    }
                    else if (error === undefined) {
                        return this.isIdentity$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                dot$org_dyn4j_geometry_Rotation(rotation) {
                    return this.cost * rotation.cost + this.sint * rotation.sint;
                }
                /**
                 * Returns the dot product of the this {@link Rotation} and the given {@link Rotation}
                 * which is essentially the sine of the angle between those rotations.
                 * @param {org.dyn4j.geometry.Rotation} rotation the {@link Rotation}
                 * @return {number} double
                 */
                dot(rotation) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null)) {
                        return this.dot$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Vector2) || rotation === null)) {
                        return this.dot$org_dyn4j_geometry_Vector2(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                cross$org_dyn4j_geometry_Rotation(rotation) {
                    return this.cost * rotation.sint - this.sint * rotation.cost;
                }
                /**
                 * Returns the cross product of the this {@link Rotation} and the given {@link Rotation}
                 * which is essentially the sine of the angle between those rotations.
                 * @param {org.dyn4j.geometry.Rotation} rotation the {@link Rotation}
                 * @return {number} double
                 */
                cross(rotation) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null)) {
                        return this.cross$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Vector2) || rotation === null)) {
                        return this.cross$org_dyn4j_geometry_Vector2(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                dot$org_dyn4j_geometry_Vector2(vector) {
                    return this.cost * vector.x + this.sint * vector.y;
                }
                cross$org_dyn4j_geometry_Vector2(vector) {
                    return this.cost * vector.y - this.sint * vector.x;
                }
                compare$org_dyn4j_geometry_Rotation(other) {
                    const cmp = this.cross$org_dyn4j_geometry_Rotation(other);
                    if (cmp > 0.0) {
                        return 1;
                    }
                    else if (cmp < 0.0) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                /**
                 * Compares this {@link Rotation} with another one, based on the angle between them (The one with -&pi; &le; &theta; &le; &pi;)
                 * Returns 1 if &theta; &gt; 0, -1 if &theta; &lt; 0 and 0 otherwise
                 * @param {org.dyn4j.geometry.Rotation} other the {@link Rotation} to compare to
                 * @return {number} int
                 */
                compare(other) {
                    if (((other != null && other instanceof org.dyn4j.geometry.Rotation) || other === null)) {
                        return this.compare$org_dyn4j_geometry_Rotation(other);
                    }
                    else if (((other != null && other instanceof org.dyn4j.geometry.Vector2) || other === null)) {
                        return this.compare$org_dyn4j_geometry_Vector2(other);
                    }
                    else
                        throw new Error('invalid overload');
                }
                compare$org_dyn4j_geometry_Vector2(other) {
                    const cmp = this.cross$org_dyn4j_geometry_Vector2(other);
                    if (cmp > 0.0) {
                        return 1;
                    }
                    else if (cmp < 0.0) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                getRotationBetween$org_dyn4j_geometry_Rotation(rotation) {
                    return new Rotation(this.dot$org_dyn4j_geometry_Rotation(rotation), this.cross$org_dyn4j_geometry_Rotation(rotation));
                }
                /**
                 * Returns the angle between this and the given {@link Rotation}
                 * represented as a new {@link Rotation}.
                 * @param {org.dyn4j.geometry.Rotation} rotation the {@link Rotation}
                 * @return {org.dyn4j.geometry.Rotation} {@link Rotation}
                 */
                getRotationBetween(rotation) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null)) {
                        return this.getRotationBetween$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Vector2) || rotation === null)) {
                        return this.getRotationBetween$org_dyn4j_geometry_Vector2(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                getRotationBetween$org_dyn4j_geometry_Vector2(vector) {
                    return this.getRotationBetween$org_dyn4j_geometry_Rotation(Rotation.of$org_dyn4j_geometry_Vector2(vector));
                }
                /**
                 * Rotates vector by this rotation
                 * @param {org.dyn4j.geometry.Vector2} v
                 * @return {org.dyn4j.geometry.Vector2} this vector after transform
                 */
                transform(v) {
                    const v_x = v.x;
                    const v_y = v.y;
                    v.x = this.cost * v_x - this.sint * v_y;
                    v.y = this.cost * v_x + this.cost * v_y;
                    return v;
                }
            }
            geometry.Rotation = Rotation;
            Rotation["__class"] = "org.dyn4j.geometry.Rotation";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * @param {number} m00 the element at 0,0
             * @param {number} m01 the element at 0,1
             * @param {number} m10 the element at 1,0
             * @param {number} m11 the element at 1,1
             * @class
             * @author William Bittle
             */
            class Matrix22 {
                constructor(m00, m01, m10, m11) {
                    if (((typeof m00 === 'number') || m00 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m11 === 'number') || m11 === null)) {
                        let __args = arguments;
                        if (this.m00 === undefined) {
                            this.m00 = 0;
                        }
                        if (this.m01 === undefined) {
                            this.m01 = 0;
                        }
                        if (this.m10 === undefined) {
                            this.m10 = 0;
                        }
                        if (this.m11 === undefined) {
                            this.m11 = 0;
                        }
                        this.m00 = m00;
                        this.m01 = m01;
                        this.m10 = m10;
                        this.m11 = m11;
                    }
                    else if (((m00 != null && m00 instanceof Array && (m00.length == 0 || m00[0] == null || (typeof m00[0] === 'number'))) || m00 === null) && m01 === undefined && m10 === undefined && m11 === undefined) {
                        let __args = arguments;
                        let values = __args[0];
                        if (this.m00 === undefined) {
                            this.m00 = 0;
                        }
                        if (this.m01 === undefined) {
                            this.m01 = 0;
                        }
                        if (this.m10 === undefined) {
                            this.m10 = 0;
                        }
                        if (this.m11 === undefined) {
                            this.m11 = 0;
                        }
                        if (values == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.matrix.nullArray"));
                        if (values.length !== 4)
                            throw new java.lang.IndexOutOfBoundsException(org.dyn4j.resources.Messages.getString("geometry.matrix.invalidLength4"));
                        this.m00 = values[0];
                        this.m01 = values[1];
                        this.m10 = values[2];
                        this.m11 = values[3];
                    }
                    else if (((m00 != null && m00 instanceof org.dyn4j.geometry.Matrix22) || m00 === null) && m01 === undefined && m10 === undefined && m11 === undefined) {
                        let __args = arguments;
                        let matrix = __args[0];
                        if (this.m00 === undefined) {
                            this.m00 = 0;
                        }
                        if (this.m01 === undefined) {
                            this.m01 = 0;
                        }
                        if (this.m10 === undefined) {
                            this.m10 = 0;
                        }
                        if (this.m11 === undefined) {
                            this.m11 = 0;
                        }
                        this.m00 = matrix.m00;
                        this.m01 = matrix.m01;
                        this.m10 = matrix.m10;
                        this.m11 = matrix.m11;
                    }
                    else if (m00 === undefined && m01 === undefined && m10 === undefined && m11 === undefined) {
                        let __args = arguments;
                        if (this.m00 === undefined) {
                            this.m00 = 0;
                        }
                        if (this.m01 === undefined) {
                            this.m01 = 0;
                        }
                        if (this.m10 === undefined) {
                            this.m10 = 0;
                        }
                        if (this.m11 === undefined) {
                            this.m11 = 0;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns a copy of this {@link Matrix22}.
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22}
                 * @since 3.4.0
                 */
                copy() {
                    return new Matrix22(this);
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    const prime = 31;
                    let result = 1;
                    let temp;
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m00);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m01);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m10);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m11);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    return result;
                }
                /**
                 *
                 * @param {*} obj
                 * @return {boolean}
                 */
                equals(obj) {
                    if (obj == null)
                        return false;
                    if (obj === this)
                        return true;
                    if (obj != null && obj instanceof org.dyn4j.geometry.Matrix22) {
                        const other = obj;
                        if (other.m00 === this.m00 && other.m01 === this.m01 && other.m10 === this.m10 && other.m11 === this.m11) {
                            return true;
                        }
                    }
                    return false;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("[").append(this.m00).append(" ").append(this.m01).append("][").append(this.m10).append(" ").append(this.m11).append("]");
                    return sb.toString();
                }
                /**
                 * Adds the given {@link Matrix22} to this {@link Matrix22}
                 * returning this {@link Matrix22}.
                 * <pre>
                 * this = this + m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix22} matrix the {@link Matrix22} to add
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} this matrix
                 */
                add(matrix) {
                    this.m00 += matrix.m00;
                    this.m01 += matrix.m01;
                    this.m10 += matrix.m10;
                    this.m11 += matrix.m11;
                    return this;
                }
                /**
                 * Returns a new {@link Matrix22} that is the sum of this {@link Matrix22}
                 * and the given {@link Matrix22}.
                 * <pre>
                 * r = this + m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix22} matrix the {@link Matrix22} to add
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} a new matrix containing the result
                 */
                sum(matrix) {
                    return this.copy().add(matrix);
                }
                /**
                 * Subtracts the given {@link Matrix22} from this {@link Matrix22}
                 * returning this {@link Matrix22}.
                 * <pre>
                 * this = this - m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix22} matrix the {@link Matrix22} to subtract
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} this matrix
                 */
                subtract(matrix) {
                    this.m00 -= matrix.m00;
                    this.m01 -= matrix.m01;
                    this.m10 -= matrix.m10;
                    this.m11 -= matrix.m11;
                    return this;
                }
                /**
                 * Returns a new {@link Matrix22} that is the difference of this {@link Matrix22}
                 * and the given {@link Matrix22}.
                 * <pre>
                 * r = this - m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix22} matrix the {@link Matrix22} to subtract
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} a new matrix containing the result
                 */
                difference(matrix) {
                    return this.copy().subtract(matrix);
                }
                multiply$org_dyn4j_geometry_Matrix22(matrix) {
                    const m00 = this.m00;
                    const m01 = this.m01;
                    const m10 = this.m10;
                    const m11 = this.m11;
                    this.m00 = m00 * matrix.m00 + m01 * matrix.m10;
                    this.m01 = m00 * matrix.m01 + m01 * matrix.m11;
                    this.m10 = m10 * matrix.m00 + m11 * matrix.m10;
                    this.m11 = m10 * matrix.m01 + m11 * matrix.m11;
                    return this;
                }
                /**
                 * Multiplies this {@link Matrix22} by the given matrix {@link Matrix22}
                 * returning this {@link Matrix22}.
                 * <pre>
                 * this = this * m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix22} matrix the {@link Matrix22} to subtract
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} this matrix
                 */
                multiply(matrix) {
                    if (((matrix != null && matrix instanceof org.dyn4j.geometry.Matrix22) || matrix === null)) {
                        return this.multiply$org_dyn4j_geometry_Matrix22(matrix);
                    }
                    else if (((matrix != null && matrix instanceof org.dyn4j.geometry.Vector2) || matrix === null)) {
                        return this.multiply$org_dyn4j_geometry_Vector2(matrix);
                    }
                    else if (((typeof matrix === 'number') || matrix === null)) {
                        return this.multiply$double(matrix);
                    }
                    else
                        throw new Error('invalid overload');
                }
                product$org_dyn4j_geometry_Matrix22(matrix) {
                    return this.copy().multiply$org_dyn4j_geometry_Matrix22(matrix);
                }
                /**
                 * Returns a new {@link Matrix22} that is the product of this {@link Matrix22}
                 * and the given {@link Matrix22}.
                 * <pre>
                 * r = this * m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix22} matrix the {@link Matrix22} to multiply
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} a new matrix containing the result
                 */
                product(matrix) {
                    if (((matrix != null && matrix instanceof org.dyn4j.geometry.Matrix22) || matrix === null)) {
                        return this.product$org_dyn4j_geometry_Matrix22(matrix);
                    }
                    else if (((matrix != null && matrix instanceof org.dyn4j.geometry.Vector2) || matrix === null)) {
                        return this.product$org_dyn4j_geometry_Vector2(matrix);
                    }
                    else if (((typeof matrix === 'number') || matrix === null)) {
                        return this.product$double(matrix);
                    }
                    else
                        throw new Error('invalid overload');
                }
                multiply$org_dyn4j_geometry_Vector2(vector) {
                    const x = vector.x;
                    const y = vector.y;
                    vector.x = this.m00 * x + this.m01 * y;
                    vector.y = this.m10 * x + this.m11 * y;
                    return vector;
                }
                product$org_dyn4j_geometry_Vector2(vector) {
                    return this.multiply$org_dyn4j_geometry_Vector2(vector.copy());
                }
                /**
                 * Multiplies the given {@link Vector2} by this {@link Matrix22} and
                 * places the result in the given {@link Vector2}.
                 * <p style="white-space: pre;"> v = v<sup>T</sup> * this</p>
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to multiply
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the vector result
                 */
                multiplyT(vector) {
                    const x = vector.x;
                    const y = vector.y;
                    vector.x = this.m00 * x + this.m10 * y;
                    vector.y = this.m01 * x + this.m11 * y;
                    return vector;
                }
                /**
                 * Multiplies the given {@link Vector2} by this {@link Matrix22} returning
                 * the result in a new {@link Vector2}.
                 * <p style="white-space: pre;"> r = v<sup>T</sup> * this</p>
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2} to multiply
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the vector result
                 */
                productT(vector) {
                    return this.multiplyT(vector.copy());
                }
                multiply$double(scalar) {
                    this.m00 *= scalar;
                    this.m01 *= scalar;
                    this.m10 *= scalar;
                    this.m11 *= scalar;
                    return this;
                }
                product$double(scalar) {
                    return this.copy().multiply$double(scalar);
                }
                /**
                 * Sets this {@link Matrix22} to an identity {@link Matrix22}.
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} this matrix
                 */
                identity() {
                    this.m00 = 1;
                    this.m01 = 0;
                    this.m10 = 0;
                    this.m11 = 1;
                    return this;
                }
                /**
                 * Sets this {@link Matrix22} to the transpose of this {@link Matrix22}.
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} this matrix
                 */
                transpose() {
                    const m = this.m01;
                    this.m01 = this.m10;
                    this.m10 = m;
                    return this;
                }
                /**
                 * Returns the the transpose of this {@link Matrix22} in a new {@link Matrix22}.
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} a new matrix contianing the transpose
                 */
                getTranspose() {
                    return this.copy().transpose();
                }
                /**
                 * Returns the determinant of this {@link Matrix22}.
                 * @return {number} double
                 */
                determinant() {
                    return this.m00 * this.m11 - this.m01 * this.m10;
                }
                /**
                 * Performs the inverse of this {@link Matrix22} and places the
                 * result in this {@link Matrix22}.
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} this matrix
                 */
                invert() {
                    let det = this.determinant();
                    if (Math.abs(det) > org.dyn4j.Epsilon.E_$LI$()) {
                        det = 1.0 / det;
                    }
                    const a = this.m00;
                    const b = this.m01;
                    const c = this.m10;
                    const d = this.m11;
                    this.m00 = det * d;
                    this.m01 = -det * b;
                    this.m10 = -det * c;
                    this.m11 = det * a;
                    return this;
                }
                /**
                 * Returns a new {@link Matrix22} containing the inverse of this {@link Matrix22}.
                 * @return {org.dyn4j.geometry.Matrix22} {@link Matrix22} a new matrix containing the result
                 */
                getInverse() {
                    return this.copy().invert();
                }
                /**
                 * Solves the system of linear equations:
                 * <p style="white-space: pre;"> Ax = b
                 * Multiply by A<sup>-1</sup> on both sides
                 * x = A<sup>-1</sup>b</p>
                 * @param {org.dyn4j.geometry.Vector2} b the b {@link Vector2}
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the x vector
                 */
                solve(b) {
                    let det = this.determinant();
                    if (Math.abs(det) > org.dyn4j.Epsilon.E_$LI$()) {
                        det = 1.0 / det;
                    }
                    const r = new org.dyn4j.geometry.Vector2();
                    r.x = det * (this.m11 * b.x - this.m01 * b.y);
                    r.y = det * (this.m00 * b.y - this.m10 * b.x);
                    return r;
                }
            }
            geometry.Matrix22 = Matrix22;
            Matrix22["__class"] = "org.dyn4j.geometry.Matrix22";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Creates a {@link Vector2} from the first point to the second point.
             * @param {number} x1 the x coordinate of the first point
             * @param {number} y1 the y coordinate of the first point
             * @param {number} x2 the x coordinate of the second point
             * @param {number} y2 the y coordinate of the second point
             * @class
             * @author William Bittle
             */
            class Vector2 {
                constructor(x1, y1, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        let __args = arguments;
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                        this.x = x2 - x1;
                        this.y = y2 - y1;
                    }
                    else if (((x1 != null && x1 instanceof org.dyn4j.geometry.Vector2) || x1 === null) && ((y1 != null && y1 instanceof org.dyn4j.geometry.Vector2) || y1 === null) && x2 === undefined && y2 === undefined) {
                        let __args = arguments;
                        let p1 = __args[0];
                        let p2 = __args[1];
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                        this.x = p2.x - p1.x;
                        this.y = p2.y - p1.y;
                    }
                    else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && x2 === undefined && y2 === undefined) {
                        let __args = arguments;
                        let x = __args[0];
                        let y = __args[1];
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                        this.x = x;
                        this.y = y;
                    }
                    else if (((x1 != null && x1 instanceof org.dyn4j.geometry.Vector2) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        let __args = arguments;
                        let vector = __args[0];
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                        this.x = vector.x;
                        this.y = vector.y;
                    }
                    else if (((typeof x1 === 'number') || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        let __args = arguments;
                        let direction = __args[0];
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                        this.x = Math.cos(direction);
                        this.y = Math.sin(direction);
                    }
                    else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                        let __args = arguments;
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                static X_AXIS_$LI$() { if (Vector2.X_AXIS == null) {
                    Vector2.X_AXIS = new Vector2(1.0, 0.0);
                } return Vector2.X_AXIS; }
                static Y_AXIS_$LI$() { if (Vector2.Y_AXIS == null) {
                    Vector2.Y_AXIS = new Vector2(0.0, 1.0);
                } return Vector2.Y_AXIS; }
                static INV_X_AXIS_$LI$() { if (Vector2.INV_X_AXIS == null) {
                    Vector2.INV_X_AXIS = new Vector2(-1.0, 0.0);
                } return Vector2.INV_X_AXIS; }
                static INV_Y_AXIS_$LI$() { if (Vector2.INV_Y_AXIS == null) {
                    Vector2.INV_Y_AXIS = new Vector2(0.0, -1.0);
                } return Vector2.INV_Y_AXIS; }
                /**
                 * Returns true if Vectors are very Close to each other
                 * @param Vetor2 v
                 * @return
                 * @param {org.dyn4j.geometry.Vector2} v
                 * @return {boolean}
                 */
                approxEqual(v) {
                    return Math.abs(this.x - v.x) < org.dyn4j.Epsilon.E_$LI$() && Math.abs(this.y - v.y) < org.dyn4j.Epsilon.E_$LI$();
                }
                /**
                 * Returns true if Vector is very Close to specified coordinates
                 * @param {number} x
                 * @param {number} y
                 * @return
                 * @return {boolean}
                 */
                approxEquals(x, y) {
                    return Math.abs(this.x - x) < org.dyn4j.Epsilon.E_$LI$() && Math.abs(this.y - y) < org.dyn4j.Epsilon.E_$LI$();
                }
                /**
                 * Returns a new {@link Vector2} given the magnitude and direction.
                 * @param {number} magnitude the magnitude of the {@link Vector2}
                 * @param {number} direction the direction of the {@link Vector2} in radians
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                static create(magnitude, direction) {
                    const x = magnitude * Math.cos(direction);
                    const y = magnitude * Math.sin(direction);
                    return new Vector2(x, y);
                }
                /**
                 * Returns a copy of this {@link Vector2}.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                copy() {
                    return new Vector2(this.x, this.y);
                }
                distance$double$double(x, y) {
                    const dx = this.x - x;
                    const dy = this.y - y;
                    return Math.sqrt(dx * dx + dy * dy);
                }
                /**
                 * Returns the distance from this point to the given point.
                 * @param {number} x the x coordinate of the point
                 * @param {number} y the y coordinate of the point
                 * @return {number} double
                 */
                distance(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.distance$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.distance$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                distance$org_dyn4j_geometry_Vector2(point) {
                    const dx = this.x - point.x;
                    const dy = this.y - point.y;
                    return Math.sqrt(dx * dx + dy * dy);
                }
                distanceSquared$double$double(x, y) {
                    const dx = this.x - x;
                    const dy = this.y - y;
                    return dx * dx + dy * dy;
                }
                /**
                 * Returns the distance from this point to the given point squared.
                 * @param {number} x the x coordinate of the point
                 * @param {number} y the y coordinate of the point
                 * @return {number} double
                 */
                distanceSquared(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.distanceSquared$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.distanceSquared$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                distanceSquared$org_dyn4j_geometry_Vector2(point) {
                    const dx = this.x - point.x;
                    const dy = this.y - point.y;
                    return dx * dx + dy * dy;
                }
                /**
                 * The triple product of {@link Vector2}s is defined as:
                 * <pre>
                 * a x (b x c)
                 * </pre>
                 * However, this method performs the following triple product:
                 * <pre>
                 * (a x b) x c
                 * </pre>
                 * this can be simplified to:
                 * <pre>
                 * -a * (b &middot; c) + b * (a &middot; c)
                 * </pre>
                 * or:
                 * <pre>
                 * b * (a &middot; c) - a * (b &middot; c)
                 * </pre>
                 * @param {org.dyn4j.geometry.Vector2} a the a {@link Vector2} in the above equation
                 * @param {org.dyn4j.geometry.Vector2} b the b {@link Vector2} in the above equation
                 * @param {org.dyn4j.geometry.Vector2} c the c {@link Vector2} in the above equation
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                static tripleProduct(a, b, c) {
                    const r = new Vector2();
                    const ac = a.x * c.x + a.y * c.y;
                    const bc = b.x * c.x + b.y * c.y;
                    r.x = b.x * ac - a.x * bc;
                    r.y = b.y * ac - a.y * bc;
                    return r;
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    const prime = 31;
                    let result = 1;
                    let temp;
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.x);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.y);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    return result;
                }
                equals$java_lang_Object(obj) {
                    if (obj == null)
                        return false;
                    if (obj === this)
                        return true;
                    if (obj != null && obj instanceof org.dyn4j.geometry.Vector2) {
                        const vector = obj;
                        return this.x === vector.x && this.y === vector.y;
                    }
                    return false;
                }
                equals$org_dyn4j_geometry_Vector2(vector) {
                    if (vector == null)
                        return false;
                    if (this === vector) {
                        return true;
                    }
                    else {
                        return this.x === vector.x && this.y === vector.y;
                    }
                }
                equals$double$double(x, y) {
                    return this.x === x && this.y === y;
                }
                /**
                 * Returns true if the x and y components of this {@link Vector2}
                 * are the same as the given x and y components.
                 * @param {number} x the x coordinate of the {@link Vector2} to compare to
                 * @param {number} y the y coordinate of the {@link Vector2} to compare to
                 * @return {boolean} boolean
                 */
                equals(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.equals$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.equals$org_dyn4j_geometry_Vector2(x);
                    }
                    else if (((x != null) || x === null) && y === undefined) {
                        return this.equals$java_lang_Object(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("(").append(this.x).append(", ").append(this.y).append(")");
                    return sb.toString();
                }
                set$org_dyn4j_geometry_Vector2(vector) {
                    this.x = vector.x;
                    this.y = vector.y;
                    return this;
                }
                set$double$double(x, y) {
                    this.x = x;
                    this.y = y;
                    return this;
                }
                /**
                 * Sets this {@link Vector2} to the given {@link Vector2}.
                 * @param {number} x the x component of the {@link Vector2} to set this {@link Vector2} to
                 * @param {number} y the y component of the {@link Vector2} to set this {@link Vector2} to
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 */
                set(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.set$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.set$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the x component of this {@link Vector2}.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getXComponent() {
                    return new Vector2(this.x, 0.0);
                }
                /**
                 * Returns the y component of this {@link Vector2}.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getYComponent() {
                    return new Vector2(0.0, this.y);
                }
                /**
                 * Returns the magnitude of this {@link Vector2}.
                 * @return {number} double
                 */
                getMagnitude() {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                }
                /**
                 * Returns the magnitude of this {@link Vector2} squared.
                 * @return {number} double
                 */
                getMagnitudeSquared() {
                    return this.x * this.x + this.y * this.y;
                }
                /**
                 * Sets the magnitude of the {@link Vector2}.
                 * @param {number} magnitude the magnitude
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 */
                setMagnitude(magnitude) {
                    if (Math.abs(magnitude) <= org.dyn4j.Epsilon.E_$LI$()) {
                        this.x = 0.0;
                        this.y = 0.0;
                        return this;
                    }
                    if (this.isZero()) {
                        return this;
                    }
                    let mag = Math.sqrt(this.x * this.x + this.y * this.y);
                    mag = magnitude / mag;
                    this.x *= mag;
                    this.y *= mag;
                    return this;
                }
                /**
                 * Returns the angle of this {@link Vector2} with +ve x axis
                 * as an angle in radians.
                 * @return {number} double angle in radians [0, 2*&pi;]
                 */
                getAngleWithPositiveXAxis() {
                    let theta = Math.atan2(this.y, this.x);
                    if (theta < 0)
                        theta += Math.PI * 2;
                    return theta;
                }
                /**
                 * Returns the direction of this {@link Vector2}
                 * as an angle in radians.
                 * @return {number} double angle in radians [-&pi;, &pi;]
                 */
                getDirection() {
                    return Math.atan2(this.y, this.x);
                }
                /**
                 * Sets the direction of this {@link Vector2}.
                 * @param {number} angle angle in radians
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 */
                setDirection(angle) {
                    const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
                    this.x = magnitude * Math.cos(angle);
                    this.y = magnitude * Math.sin(angle);
                    return this;
                }
                add$org_dyn4j_geometry_Vector2(vector) {
                    this.x += vector.x;
                    this.y += vector.y;
                    return this;
                }
                add$double$double(x, y) {
                    this.x += x;
                    this.y += y;
                    return this;
                }
                /**
                 * Adds the given {@link Vector2} to this {@link Vector2}.
                 * @param {number} x the x component of the {@link Vector2}
                 * @param {number} y the y component of the {@link Vector2}
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 */
                add(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.add$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.add$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                sum$org_dyn4j_geometry_Vector2(vector) {
                    return new Vector2(this.x + vector.x, this.y + vector.y);
                }
                sum$double$double(x, y) {
                    return new Vector2(this.x + x, this.y + y);
                }
                /**
                 * Adds this {@link Vector2} and the given {@link Vector2} returning
                 * a new {@link Vector2} containing the result.
                 * @param {number} x the x component of the {@link Vector2}
                 * @param {number} y the y component of the {@link Vector2}
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                sum(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.sum$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.sum$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                subtract$org_dyn4j_geometry_Vector2(vector) {
                    this.x -= vector.x;
                    this.y -= vector.y;
                    return this;
                }
                subtract$double$double(x, y) {
                    this.x -= x;
                    this.y -= y;
                    return this;
                }
                /**
                 * Subtracts the given {@link Vector2} from this {@link Vector2}.
                 * @param {number} x the x component of the {@link Vector2}
                 * @param {number} y the y component of the {@link Vector2}
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 */
                subtract(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.subtract$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.subtract$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                difference$org_dyn4j_geometry_Vector2(vector) {
                    return new Vector2(this.x - vector.x, this.y - vector.y);
                }
                difference$double$double(x, y) {
                    return new Vector2(this.x - x, this.y - y);
                }
                /**
                 * Subtracts the given {@link Vector2} from this {@link Vector2} returning
                 * a new {@link Vector2} containing the result.
                 * @param {number} x the x component of the {@link Vector2}
                 * @param {number} y the y component of the {@link Vector2}
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                difference(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.difference$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.difference$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                to$org_dyn4j_geometry_Vector2(vector) {
                    return new Vector2(vector.x - this.x, vector.y - this.y);
                }
                to$double$double(x, y) {
                    return new Vector2(x - this.x, y - this.y);
                }
                /**
                 * Creates a {@link Vector2} from this {@link Vector2} to the given {@link Vector2}.
                 * @param {number} x the x component of the {@link Vector2}
                 * @param {number} y the y component of the {@link Vector2}
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                to(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.to$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.to$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Multiplies this {@link Vector2} by the given scalar.
                 * @param {number} scalar the scalar
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 */
                multiply(scalar) {
                    this.x *= scalar;
                    this.y *= scalar;
                    return this;
                }
                /**
                 * Divides this {@link Vector2} by the given scalar.
                 * @param {number} scalar the scalar
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 * @since 3.4.0
                 */
                divide(scalar) {
                    this.x /= scalar;
                    this.y /= scalar;
                    return this;
                }
                /**
                 * Multiplies this {@link Vector2} by the given scalar returning
                 * a new {@link Vector2} containing the result.
                 * @param {number} scalar the scalar
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                product(scalar) {
                    return new Vector2(this.x * scalar, this.y * scalar);
                }
                /**
                 * Divides this {@link Vector2} by the given scalar returning
                 * a new {@link Vector2} containing the result.
                 * @param {number} scalar the scalar
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @since 3.4.0
                 */
                quotient(scalar) {
                    return new Vector2(this.x / scalar, this.y / scalar);
                }
                /**
                 * Adds scale times specified vector to this vector
                 * @param {number} scale
                 * @param {org.dyn4j.geometry.Vector2} vec Vector to add after scaling
                 * @return {org.dyn4j.geometry.Vector2} this Vector
                 */
                addScaled(scale, vec) {
                    this.x += scale * vec.x;
                    this.y += scale * vec.y;
                    return this;
                }
                dot$org_dyn4j_geometry_Vector2(vector) {
                    return this.x * vector.x + this.y * vector.y;
                }
                dot$double$double(x, y) {
                    return this.x * x + this.y * y;
                }
                /**
                 * Returns the dot product of the given {@link Vector2}
                 * and this {@link Vector2}.
                 * @param {number} x the x component of the {@link Vector2}
                 * @param {number} y the y component of the {@link Vector2}
                 * @return {number} double
                 */
                dot(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.dot$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.dot$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                cross$org_dyn4j_geometry_Vector2(vector) {
                    return this.x * vector.y - this.y * vector.x;
                }
                cross$double$double(x, y) {
                    return this.x * y - this.y * x;
                }
                /**
                 * Returns the cross product of the this {@link Vector2} and the given {@link Vector2}.
                 * @param {number} x the x component of the {@link Vector2}
                 * @param {number} y the y component of the {@link Vector2}
                 * @return {number} double
                 */
                cross(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.cross$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.cross$org_dyn4j_geometry_Vector2(x);
                    }
                    else if (((typeof x === 'number') || x === null) && y === undefined) {
                        return this.cross$double(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                cross$double(z) {
                    return new Vector2(-this.y * z, this.x * z);
                }
                isOrthogonal$org_dyn4j_geometry_Vector2(vector) {
                    return Math.abs(this.x * vector.x + this.y * vector.y) <= org.dyn4j.Epsilon.E_$LI$() ? true : false;
                }
                isOrthogonal$double$double(x, y) {
                    return Math.abs(this.x * x + this.y * y) <= org.dyn4j.Epsilon.E_$LI$() ? true : false;
                }
                /**
                 * Returns true if the given {@link Vector2} is orthogonal (perpendicular)
                 * to this {@link Vector2}.
                 * <p>
                 * If the dot product of this vector and the given vector is
                 * zero then we know that they are perpendicular
                 * @param {number} x the x component of the {@link Vector2}
                 * @param {number} y the y component of the {@link Vector2}
                 * @return {boolean} boolean
                 */
                isOrthogonal(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.isOrthogonal$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.isOrthogonal$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns true if this {@link Vector2} is the zero {@link Vector2}.
                 * @return {boolean} boolean
                 */
                isZero() {
                    return Math.abs(this.x) <= org.dyn4j.Epsilon.E_$LI$() && Math.abs(this.y) <= org.dyn4j.Epsilon.E_$LI$();
                }
                /**
                 *
                 * Negates this {@link Vector2}.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 */
                negate() {
                    this.x *= -1.0;
                    this.y *= -1.0;
                    return this;
                }
                /**
                 * Returns a {@link Vector2} which is the negative of this {@link Vector2}.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getNegative() {
                    return new Vector2(-this.x, -this.y);
                }
                /**
                 *
                 * Sets the {@link Vector2} to the zero {@link Vector2}
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 */
                zero() {
                    this.x = 0.0;
                    this.y = 0.0;
                    return this;
                }
                /**
                 * returns new vector by Rotating this veector about the origin
                 * @param {number} theta the rotation angle in radians
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} new vector
                 */
                getRotated(theta) {
                    const cos = Math.cos(theta);
                    const sin = Math.sin(theta);
                    const x = this.x;
                    const y = this.y;
                    return new Vector2(x * cos - y * sin, x * sin + y * cos);
                }
                rotate$double(theta) {
                    const cos = Math.cos(theta);
                    const sin = Math.sin(theta);
                    const x = this.x;
                    const y = this.y;
                    this.x = x * cos - y * sin;
                    this.y = x * sin + y * cos;
                    return this;
                }
                rotate$double$double$double(theta, x, y) {
                    this.x -= x;
                    this.y -= y;
                    this.rotate$double(theta);
                    this.x += x;
                    this.y += y;
                    return this;
                }
                rotate$double$double(cos, sin) {
                    const x = this.x;
                    const y = this.y;
                    this.x = x * cos - y * sin;
                    this.y = x * sin + y * cos;
                    return this;
                }
                rotate$org_dyn4j_geometry_Rotation(rotation) {
                    return this.rotate$double$double(rotation.cost, rotation.sint);
                }
                inverseRotate$double(theta) {
                    return this.rotate$double$double(Math.cos(theta), -Math.sin(theta));
                }
                inverseRotate$org_dyn4j_geometry_Rotation(rotation) {
                    return this.rotate$double$double(rotation.cost, -rotation.sint);
                }
                rotate$double$double$double$double(cos, sin, x, y) {
                    const tx = (this.x - x);
                    const ty = (this.y - y);
                    this.x = tx * cos - ty * sin + x;
                    this.y = tx * sin + ty * cos + y;
                    return this;
                }
                /**
                 * Internal helper method that rotates about the given coordinates by an angle &theta;.
                 * @param {number} cos cos(&theta;)
                 * @param {number} sin sin(&theta;)
                 * @param {number} x the x coordinate to rotate about
                 * @param {number} y the y coordinate to rotate about
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 * @since 3.4.0
                 */
                rotate(cos, sin, x, y) {
                    if (((typeof cos === 'number') || cos === null) && ((typeof sin === 'number') || sin === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double$double(cos, sin, x, y);
                    }
                    else if (((cos != null && cos instanceof org.dyn4j.geometry.Rotation) || cos === null) && ((typeof sin === 'number') || sin === null) && ((typeof x === 'number') || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$double$double(cos, sin, x);
                    }
                    else if (((typeof cos === 'number') || cos === null) && ((typeof sin === 'number') || sin === null) && ((typeof x === 'number') || x === null) && y === undefined) {
                        return this.rotate$double$double$double(cos, sin, x);
                    }
                    else if (((cos != null && cos instanceof org.dyn4j.geometry.Rotation) || cos === null) && ((sin != null && sin instanceof org.dyn4j.geometry.Vector2) || sin === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(cos, sin);
                    }
                    else if (((typeof cos === 'number') || cos === null) && ((sin != null && sin instanceof org.dyn4j.geometry.Vector2) || sin === null) && x === undefined && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(cos, sin);
                    }
                    else if (((typeof cos === 'number') || cos === null) && ((typeof sin === 'number') || sin === null) && x === undefined && y === undefined) {
                        return this.rotate$double$double(cos, sin);
                    }
                    else if (((cos != null && cos instanceof org.dyn4j.geometry.Rotation) || cos === null) && sin === undefined && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(cos);
                    }
                    else if (((typeof cos === 'number') || cos === null) && sin === undefined && x === undefined && y === undefined) {
                        return this.rotate$double(cos);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    return this.rotate$double$double$double$double(rotation.cost, rotation.sint, x, y);
                }
                inverseRotate$double$double$double(theta, x, y) {
                    return this.rotate$double$double$double$double(Math.cos(theta), -Math.sin(theta), x, y);
                }
                inverseRotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    return this.rotate$double$double$double$double(rotation.cost, -rotation.sint, x, y);
                }
                /**
                 * Rotates about the given coordinates by the inverse angle -&thetasym;.
                 * @param {org.dyn4j.geometry.Rotation} rotation the {@link Rotation}
                 * @param {number} x the x coordinate to rotate about
                 * @param {number} y the y coordinate to rotate about
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 * @since 3.4.0
                 */
                inverseRotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.inverseRotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.inverseRotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.inverseRotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.inverseRotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.inverseRotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.inverseRotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$double$org_dyn4j_geometry_Vector2(theta, point) {
                    return this.rotate$double$double$double(theta, point.x, point.y);
                }
                rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, point) {
                    return this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, point.x, point.y);
                }
                inverseRotate$double$org_dyn4j_geometry_Vector2(theta, point) {
                    return this.inverseRotate$double$double$double(theta, point.x, point.y);
                }
                inverseRotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, point) {
                    return this.inverseRotate$org_dyn4j_geometry_Rotation$double$double(rotation, point.x, point.y);
                }
                /**
                 * Projects this {@link Vector2} onto the given {@link Vector2}.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2}
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the projected {@link Vector2}
                 */
                project(vector) {
                    const dotProd = this.dot$org_dyn4j_geometry_Vector2(vector);
                    let denominator = vector.dot$org_dyn4j_geometry_Vector2(vector);
                    if (denominator <= org.dyn4j.Epsilon.E_$LI$())
                        return new Vector2();
                    denominator = dotProd / denominator;
                    return new Vector2(denominator * vector.x, denominator * vector.y);
                }
                /**
                 * Returns the right-handed normal of this vector.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the right hand orthogonal {@link Vector2}
                 */
                getRightHandOrthogonalVector() {
                    return new Vector2(-this.y, this.x);
                }
                /**
                 * Sets this vector to the right-handed normal of this vector.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 * @see #getRightHandOrthogonalVector()
                 */
                right() {
                    const temp = this.x;
                    this.x = -this.y;
                    this.y = temp;
                    return this;
                }
                /**
                 * Returns the left-handed normal of this vector.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the left hand orthogonal {@link Vector2}
                 */
                getLeftHandOrthogonalVector() {
                    return new Vector2(this.y, -this.x);
                }
                /**
                 * Sets this vector to the left-handed normal of this vector.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} this vector
                 * @see #getLeftHandOrthogonalVector()
                 */
                left() {
                    const temp = this.x;
                    this.x = this.y;
                    this.y = -temp;
                    return this;
                }
                /**
                 * Returns a unit {@link Vector2} of this {@link Vector2}.
                 * <p>
                 * This method requires the length of this {@link Vector2} is not zero.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getNormalized() {
                    let magnitude = this.getMagnitude();
                    if (magnitude <= org.dyn4j.Epsilon.E_$LI$())
                        return new Vector2();
                    magnitude = 1.0 / magnitude;
                    return new Vector2(this.x * magnitude, this.y * magnitude);
                }
                /**
                 * Converts this {@link Vector2} into a unit {@link Vector2} and returns
                 * the magnitude before normalization.
                 * <p>
                 * This method requires the length of this {@link Vector2} is not zero.
                 * @return {number} double
                 */
                normalize() {
                    const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
                    if (magnitude <= org.dyn4j.Epsilon.E_$LI$())
                        return 0;
                    const m = 1.0 / magnitude;
                    this.x *= m;
                    this.y *= m;
                    return magnitude;
                }
                getAngleBetween$org_dyn4j_geometry_Vector2(vector) {
                    const a = Math.atan2(vector.y, vector.x) - Math.atan2(this.y, this.x);
                    if (a > Math.PI)
                        return a - org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                    if (a < -Math.PI)
                        return a + org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                    return a;
                }
                /**
                 * Returns the smallest angle between the given {@link Vector2}s.
                 * <p>
                 * Returns the angle in radians in the range -&pi; to &pi;.
                 * @param {org.dyn4j.geometry.Vector2} vector the {@link Vector2}
                 * @return {number} angle in radians [-&pi;, &pi;]
                 */
                getAngleBetween(vector) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null)) {
                        return this.getAngleBetween$org_dyn4j_geometry_Vector2(vector);
                    }
                    else if (((typeof vector === 'number') || vector === null)) {
                        return this.getAngleBetween$double(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                getAngleBetween$double(otherAngle) {
                    const a = otherAngle - Math.atan2(this.y, this.x);
                    if (a > Math.PI)
                        return a - org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                    if (a < -Math.PI)
                        return a + org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                    return a;
                }
                /**
                 * returns Vector2 with minimum coordinates (bottom left of surrounding rect)
                 * @param {org.dyn4j.geometry.Vector2} a
                 * @param {org.dyn4j.geometry.Vector2} b
                 * @param {org.dyn4j.geometry.Vector2} out
                 */
                static minToOut(a, b, out) {
                    out.x = a.x < b.x ? a.x : b.x;
                    out.y = a.y < b.y ? a.y : b.y;
                }
                /**
                 * returns Vector2 with maximum coordinates(top right of surrounding rect)
                 * @param {org.dyn4j.geometry.Vector2} a
                 * @param {org.dyn4j.geometry.Vector2} b
                 * @param {org.dyn4j.geometry.Vector2} out
                 */
                static maxToOut(a, b, out) {
                    out.x = a.x > b.x ? a.x : b.x;
                    out.y = a.y > b.y ? a.y : b.y;
                }
                /**
                 * Returns mid point of 2 points
                 * @param {org.dyn4j.geometry.Vector2} v1
                 * @param {org.dyn4j.geometry.Vector2} v2
                 * @return
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                static midPoint(v1, v2) {
                    return new Vector2(0.5 * (v1.x + v2.x), 0.5 * (v1.y + v2.y));
                }
                /**
                 * Tests if the three points are colinear.
                 *
                 * @return {boolean} true if three points lie on the same line.
                 * @param {org.dyn4j.geometry.Vector2} p1
                 * @param {org.dyn4j.geometry.Vector2} p2
                 * @param {org.dyn4j.geometry.Vector2} p3
                 */
                static isCollinear(p1, p2, p3) {
                    let dx1;
                    let dx2;
                    let dy1;
                    let dy2;
                    dx1 = p2.x - p1.x;
                    dy1 = p2.y - p1.y;
                    dx2 = p3.x - p1.x;
                    dy2 = p3.y - p1.y;
                    return Math.abs(dx1 * dy2 - dy1 * dx2) < org.dyn4j.Epsilon.E_$LI$();
                }
                /**
                 * Computes the orientation of the 3 points: returns +1 is the path
                 * P0->P1->P2 turns Counter-Clockwise, -1 if the path turns Clockwise, and 0
                 * if the point P2 is located on the line segment [P0 P1]. Algorithm taken
                 * from Sedgewick.
                 *
                 * @param {org.dyn4j.geometry.Vector2} p0 the initial point
                 * @param {org.dyn4j.geometry.Vector2} p1 the middle point
                 * @param {org.dyn4j.geometry.Vector2} p2 the last point
                 * @return {number} +1, 0 or -1, depending on the relative position of the points
                 */
                static ccw(p0, p1, p2) {
                    const x0 = p0.x;
                    const y0 = p0.y;
                    const dx1 = p1.x - x0;
                    const dy1 = p1.y - y0;
                    const dx2 = p2.x - x0;
                    const dy2 = p2.y - y0;
                    if (dx1 * dy2 > dy1 * dx2)
                        return +1;
                    if (dx1 * dy2 < dy1 * dx2)
                        return -1;
                    if ((dx1 * dx2 < 0) || (dy1 * dy2 < 0))
                        return -1;
                    if ((dx1 * dx1 + dy1 * dy1) < (dx2 * dx2 + dy2 * dy2))
                        return +1;
                    return 0;
                }
                static centroid$org_dyn4j_geometry_Vector2_A(points) {
                    const n = points.length;
                    let sx = 0;
                    let sy = 0;
                    for (let i = 0; i < n; i++) {
                        {
                            sx += points[i].x;
                            sy += points[i].y;
                        }
                        ;
                    }
                    return new Vector2(sx / n, sy / n);
                }
                static centroid$org_dyn4j_geometry_Vector2_A$double_A(points, weights) {
                    const n = points.length;
                    if (n !== weights.length) {
                        throw new java.lang.RuntimeException("Arrays must have the same size");
                    }
                    let sx = 0;
                    let sy = 0;
                    let sw = 0;
                    let w;
                    for (let i = 0; i < n; i++) {
                        {
                            w = weights[i];
                            sx += points[i].x * w;
                            sy += points[i].y * w;
                            sw += w;
                        }
                        ;
                    }
                    return new Vector2(sx / sw, sy / sw);
                }
                /**
                 * Computes the weighted centroid, or center of mass, of an array of points.
                 *
                 * @param {org.dyn4j.geometry.Vector2[]} points an array of points
                 * @param {double[]} weights an array of weights the same size as points
                 * @return {org.dyn4j.geometry.Vector2} the centroid of the points
                 */
                static centroid(points, weights) {
                    if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof org.dyn4j.geometry.Vector2))) || points === null) && ((weights != null && weights instanceof Array && (weights.length == 0 || weights[0] == null || (typeof weights[0] === 'number'))) || weights === null)) {
                        return org.dyn4j.geometry.Vector2.centroid$org_dyn4j_geometry_Vector2_A$double_A(points, weights);
                    }
                    else if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof org.dyn4j.geometry.Vector2))) || points === null) && weights === undefined) {
                        return org.dyn4j.geometry.Vector2.centroid$org_dyn4j_geometry_Vector2_A(points);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * returns closest point among parameters
                 * @param {org.dyn4j.geometry.Vector2[]} pts Points to be checked for
                 * @return {org.dyn4j.geometry.Vector2} closest point
                 */
                closestPoint(...pts) {
                    let result = pts[0];
                    let dist = (this.x - result.x) * (this.x - result.x) + (this.y - result.y) * (this.y - result.y);
                    for (let index = 0; index < pts.length; index++) {
                        let p = pts[index];
                        {
                            if (p === result)
                                continue;
                            const d = this.x * p.x + this.y * p.y;
                            if (d < dist) {
                                dist = d;
                                result = p;
                            }
                        }
                    }
                    return result;
                }
                /**
                 * Returns interpolated point
                 * @param {org.dyn4j.geometry.Vector2} p1 first point
                 * @param {org.dyn4j.geometry.Vector2} p2 second point
                 * @param {number} k
                 * @return {org.dyn4j.geometry.Vector2} new point divided p1 and p2 in ratio k:1
                 */
                static interpolate(p1, p2, k) {
                    if (k === javaemul.internal.DoubleHelper.POSITIVE_INFINITY)
                        return p2;
                    return new Vector2((p2.x * k + p1.x) / (k + 1), (p2.y * k + p1.y) / (k + 1));
                }
            }
            geometry.Vector2 = Vector2;
            Vector2["__class"] = "org.dyn4j.geometry.Vector2";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Minimal constructor.
             * @param {org.dyn4j.geometry.Vector2[]} vectors the array to iterate over
             * @class
             * @author William Bittle
             */
            class WoundIterator {
                constructor(vectors) {
                    if (this.vectors === undefined) {
                        this.vectors = null;
                    }
                    if (this.index === undefined) {
                        this.index = 0;
                    }
                    this.vectors = vectors;
                    this.index = 0;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.index < this.vectors.length;
                }
                /**
                 *
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                next() {
                    if (this.index >= this.vectors.length) {
                        throw new java.lang.IndexOutOfBoundsException();
                    }
                    try {
                        const v = this.vectors[this.index++];
                        return v.copy();
                    }
                    catch (ex) {
                        throw new java.util.ConcurrentModificationException();
                    }
                }
                /**
                 *
                 */
                remove() {
                    throw new java.lang.UnsupportedOperationException();
                }
                forEachRemaining(action) {
                    java.util.Objects.requireNonNull((((funcInst) => { if (typeof funcInst == 'function') {
                        return funcInst;
                    } return (arg0) => (funcInst['accept'] ? funcInst['accept'] : funcInst).call(funcInst, arg0); })(action)));
                    while ((this.hasNext())) {
                        (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(action);
                    }
                    ;
                }
            }
            geometry.WoundIterator = WoundIterator;
            WoundIterator["__class"] = "org.dyn4j.geometry.WoundIterator";
            WoundIterator["__interfaces"] = ["java.util.Iterator"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Creates a {@link Vector3} from the first point to the second point.
             * @param {number} x1 the x coordinate of the first point
             * @param {number} y1 the y coordinate of the first point
             * @param {number} z1 the z coordinate of the first point
             * @param {number} x2 the x coordinate of the second point
             * @param {number} y2 the y coordinate of the second point
             * @param {number} z2 the z coordinate of the second point
             * @class
             * @author William Bittle
             */
            class Vector3 {
                constructor(x1, y1, z1, x2, y2, z2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof z1 === 'number') || z1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof z2 === 'number') || z2 === null)) {
                        let __args = arguments;
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                        if (this.z === undefined) {
                            this.z = 0;
                        }
                        this.x = x2 - x1;
                        this.y = y2 - y1;
                        this.z = z2 - z1;
                    }
                    else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof z1 === 'number') || z1 === null) && x2 === undefined && y2 === undefined && z2 === undefined) {
                        let __args = arguments;
                        let x = __args[0];
                        let y = __args[1];
                        let z = __args[2];
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                        if (this.z === undefined) {
                            this.z = 0;
                        }
                        this.x = x;
                        this.y = y;
                        this.z = z;
                    }
                    else if (((x1 != null && x1 instanceof org.dyn4j.geometry.Vector3) || x1 === null) && ((y1 != null && y1 instanceof org.dyn4j.geometry.Vector3) || y1 === null) && z1 === undefined && x2 === undefined && y2 === undefined && z2 === undefined) {
                        let __args = arguments;
                        let p1 = __args[0];
                        let p2 = __args[1];
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                        if (this.z === undefined) {
                            this.z = 0;
                        }
                        this.x = p2.x - p1.x;
                        this.y = p2.y - p1.y;
                        this.z = p2.z - p1.z;
                    }
                    else if (((x1 != null && x1 instanceof org.dyn4j.geometry.Vector3) || x1 === null) && y1 === undefined && z1 === undefined && x2 === undefined && y2 === undefined && z2 === undefined) {
                        let __args = arguments;
                        let vector = __args[0];
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                        if (this.z === undefined) {
                            this.z = 0;
                        }
                        this.x = vector.x;
                        this.y = vector.y;
                        this.z = vector.z;
                    }
                    else if (x1 === undefined && y1 === undefined && z1 === undefined && x2 === undefined && y2 === undefined && z2 === undefined) {
                        let __args = arguments;
                        if (this.x === undefined) {
                            this.x = 0;
                        }
                        if (this.y === undefined) {
                            this.y = 0;
                        }
                        if (this.z === undefined) {
                            this.z = 0;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns a copy of this {@link Vector3}.
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                copy() {
                    return new Vector3(this.x, this.y, this.z);
                }
                distance$double$double$double(x, y, z) {
                    const xd = this.x - x;
                    const yd = this.y - y;
                    const zd = this.z - z;
                    return Math.sqrt(xd * xd + yd * yd + zd * zd);
                }
                /**
                 * Returns the distance from this point to the given point.
                 * @param {number} x the x coordinate of the point
                 * @param {number} y the y coordinate of the point
                 * @param {number} z the z coordinate of the point
                 * @return {number} double
                 */
                distance(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.distance$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.distance$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                distance$org_dyn4j_geometry_Vector3(point) {
                    const xd = this.x - point.x;
                    const yd = this.y - point.y;
                    const zd = this.z - point.z;
                    return Math.sqrt(xd * xd + yd * yd + zd * zd);
                }
                distanceSquared$double$double$double(x, y, z) {
                    const xd = this.x - x;
                    const yd = this.y - y;
                    const zd = this.z - z;
                    return xd * xd + yd * yd + zd * zd;
                }
                /**
                 * Returns the distance from this point to the given point squared.
                 * @param {number} x the x coordinate of the point
                 * @param {number} y the y coordinate of the point
                 * @param {number} z the z coordinate of the point
                 * @return {number} double
                 */
                distanceSquared(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.distanceSquared$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.distanceSquared$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                distanceSquared$org_dyn4j_geometry_Vector3(point) {
                    const xd = this.x - point.x;
                    const yd = this.y - point.y;
                    const zd = this.z - point.z;
                    return xd * xd + yd * yd + zd * zd;
                }
                /**
                 * The triple product of {@link Vector3}s is defined as:
                 * <pre>
                 * a x (b x c)
                 * </pre>
                 * However, this method performs the following triple product:
                 * <pre>
                 * (a x b) x c
                 * </pre>
                 * this can be simplified to:
                 * <pre>
                 * -a * (b &middot; c) + b * (a &middot; c)
                 * </pre>
                 * or:
                 * <pre>
                 * b * (a &middot; c) - a * (b &middot; c)
                 * </pre>
                 * @param {org.dyn4j.geometry.Vector3} a the a {@link Vector3} in the above equation
                 * @param {org.dyn4j.geometry.Vector3} b the b {@link Vector3} in the above equation
                 * @param {org.dyn4j.geometry.Vector3} c the c {@link Vector3} in the above equation
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                static tripleProduct(a, b, c) {
                    const r = new Vector3();
                    const ac = a.x * c.x + a.y * c.y + a.z * c.z;
                    const bc = b.x * c.x + b.y * c.y + b.z * c.z;
                    r.x = b.x * ac - a.x * bc;
                    r.y = b.y * ac - a.y * bc;
                    r.z = b.z * ac - a.z * bc;
                    return r;
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    const prime = 31;
                    let result = 1;
                    let temp;
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.x);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.y);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.z);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    return result;
                }
                equals$java_lang_Object(obj) {
                    if (obj == null)
                        return false;
                    if (obj === this)
                        return true;
                    if (obj != null && obj instanceof org.dyn4j.geometry.Vector3) {
                        const other = obj;
                        if (this.x === other.x && this.y === other.y && this.z === other.z) {
                            return true;
                        }
                    }
                    return false;
                }
                equals$org_dyn4j_geometry_Vector3(vector) {
                    if (vector == null)
                        return false;
                    if (this === vector) {
                        return true;
                    }
                    else {
                        return this.x === vector.x && this.y === vector.y && this.z === vector.z;
                    }
                }
                equals$double$double$double(x, y, z) {
                    return this.x === x && this.y === y && this.z === z;
                }
                /**
                 * Returns true if the x, y and z components of this {@link Vector3}
                 * are the same as the given x, y and z components.
                 * @param {number} x the x coordinate of the {@link Vector3} to compare to
                 * @param {number} y the y coordinate of the {@link Vector3} to compare to
                 * @param {number} z the z coordinate of the {@link Vector3} to compare to
                 * @return {boolean} boolean
                 */
                equals(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.equals$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.equals$org_dyn4j_geometry_Vector3(x);
                    }
                    else if (((x != null) || x === null) && y === undefined && z === undefined) {
                        return this.equals$java_lang_Object(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("(").append(this.x).append(", ").append(this.y).append(", ").append(this.z).append(")");
                    return sb.toString();
                }
                set$org_dyn4j_geometry_Vector3(vector) {
                    this.x = vector.x;
                    this.y = vector.y;
                    this.z = vector.z;
                    return this;
                }
                set$double$double$double(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                }
                /**
                 * Sets this {@link Vector3} to the given {@link Vector3}.
                 * @param {number} x the x component of the {@link Vector3} to set this {@link Vector3} to
                 * @param {number} y the y component of the {@link Vector3} to set this {@link Vector3} to
                 * @param {number} z the z component of the {@link Vector3} to set this {@link Vector3} to
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} this vector
                 */
                set(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.set$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.set$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the x component of this {@link Vector3}.
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                getXComponent() {
                    return new Vector3(this.x, 0.0, 0.0);
                }
                /**
                 * Returns the y component of this {@link Vector3}.
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                getYComponent() {
                    return new Vector3(0.0, this.y, 0.0);
                }
                /**
                 * Returns the z component of this {@link Vector3}.
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                getZComponent() {
                    return new Vector3(0.0, 0.0, this.z);
                }
                /**
                 * Returns the magnitude of this {@link Vector3}.
                 * @return {number} double
                 */
                getMagnitude() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                }
                /**
                 * Returns the magnitude of this {@link Vector3} squared.
                 * @return {number} double
                 */
                getMagnitudeSquared() {
                    return this.x * this.x + this.y * this.y + this.z * this.z;
                }
                /**
                 * Sets the magnitude of the {@link Vector3}.
                 * @param {number} magnitude  the magnitude
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} this vector
                 */
                setMagnitude(magnitude) {
                    if (Math.abs(magnitude) <= org.dyn4j.Epsilon.E_$LI$()) {
                        this.x = 0.0;
                        this.y = 0.0;
                        this.z = 0.0;
                        return this;
                    }
                    if (this.isZero()) {
                        return this;
                    }
                    let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                    mag = magnitude / mag;
                    this.x *= mag;
                    this.y *= mag;
                    this.z *= mag;
                    return this;
                }
                add$org_dyn4j_geometry_Vector3(vector) {
                    this.x += vector.x;
                    this.y += vector.y;
                    this.z += vector.z;
                    return this;
                }
                add$double$double$double(x, y, z) {
                    this.x += x;
                    this.y += y;
                    this.z += z;
                    return this;
                }
                /**
                 * Adds the given {@link Vector3} to this {@link Vector3}.
                 * @param {number} x the x component of the {@link Vector3}
                 * @param {number} y the y component of the {@link Vector3}
                 * @param {number} z the z component of the {@link Vector3}
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} this vector
                 */
                add(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.add$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.add$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                sum$org_dyn4j_geometry_Vector3(vector) {
                    return new Vector3(this.x + vector.x, this.y + vector.y, this.z + vector.z);
                }
                sum$double$double$double(x, y, z) {
                    return new Vector3(this.x + x, this.y + y, this.z + z);
                }
                /**
                 * Adds this {@link Vector3} and the given {@link Vector3} returning
                 * a new {@link Vector3} containing the result.
                 * @param {number} x the x component of the {@link Vector3}
                 * @param {number} y the y component of the {@link Vector3}
                 * @param {number} z the z component of the {@link Vector3}
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                sum(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.sum$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.sum$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                subtract$org_dyn4j_geometry_Vector3(vector) {
                    this.x -= vector.x;
                    this.y -= vector.y;
                    this.z -= vector.z;
                    return this;
                }
                subtract$double$double$double(x, y, z) {
                    this.x -= x;
                    this.y -= y;
                    this.z -= z;
                    return this;
                }
                /**
                 * Subtracts the given {@link Vector3} from this {@link Vector3}.
                 * @param {number} x the x component of the {@link Vector3}
                 * @param {number} y the y component of the {@link Vector3}
                 * @param {number} z the z component of the {@link Vector3}
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} this vector
                 */
                subtract(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.subtract$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.subtract$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                difference$org_dyn4j_geometry_Vector3(vector) {
                    return new Vector3(this.x - vector.x, this.y - vector.y, this.z - vector.z);
                }
                difference$double$double$double(x, y, z) {
                    return new Vector3(this.x - x, this.y - y, this.z - z);
                }
                /**
                 * Subtracts the given {@link Vector3} from this {@link Vector3} returning
                 * a new {@link Vector3} containing the result.
                 * @param {number} x the x component of the {@link Vector3}
                 * @param {number} y the y component of the {@link Vector3}
                 * @param {number} z the z component of the {@link Vector3}
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                difference(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.difference$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.difference$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                to$org_dyn4j_geometry_Vector3(vector) {
                    return new Vector3(vector.x - this.x, vector.y - this.y, vector.z - this.z);
                }
                to$double$double$double(x, y, z) {
                    return new Vector3(x - this.x, y - this.y, z - this.z);
                }
                /**
                 * Creates a {@link Vector3} from this {@link Vector3} to the given {@link Vector3}.
                 * @param {number} x the x component of the {@link Vector3}
                 * @param {number} y the y component of the {@link Vector3}
                 * @param {number} z the z component of the {@link Vector3}
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                to(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.to$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.to$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Multiplies this {@link Vector3} by the given scalar.
                 * @param {number} scalar the scalar
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} this vector
                 */
                multiply(scalar) {
                    this.x *= scalar;
                    this.y *= scalar;
                    this.z *= scalar;
                    return this;
                }
                /**
                 * Multiplies this {@link Vector3} by the given scalar returning
                 * a new {@link Vector3} containing the result.
                 * @param {number} scalar the scalar
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                product(scalar) {
                    return new Vector3(this.x * scalar, this.y * scalar, this.z * scalar);
                }
                dot$org_dyn4j_geometry_Vector3(vector) {
                    return this.x * vector.x + this.y * vector.y + this.z * vector.z;
                }
                dot$double$double$double(x, y, z) {
                    return this.x * x + this.y * y + this.z * z;
                }
                /**
                 * Returns the dot product of the given {@link Vector3}
                 * and this {@link Vector3}.
                 * @param {number} x the x component of the {@link Vector3}
                 * @param {number} y the y component of the {@link Vector3}
                 * @param {number} z the z component of the {@link Vector3}
                 * @return {number} double
                 */
                dot(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.dot$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.dot$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                cross$org_dyn4j_geometry_Vector3(vector) {
                    return new Vector3(this.y * vector.z - this.z * vector.y, this.z * vector.x - this.x * vector.z, this.x * vector.y - this.y * vector.x);
                }
                cross$double$double$double(x, y, z) {
                    return new Vector3(this.y * z - this.z * y, this.z * x - this.x * z, this.x * y - this.y * x);
                }
                /**
                 * Returns the cross product of the this {@link Vector3} and the given {@link Vector3}.
                 * @param {number} x the x component of the {@link Vector3}
                 * @param {number} y the y component of the {@link Vector3}
                 * @param {number} z the z component of the {@link Vector3}
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                cross(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.cross$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.cross$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                isOrthogonal$org_dyn4j_geometry_Vector3(vector) {
                    return Math.abs(this.x * vector.x + this.y * vector.y + this.z * vector.z) <= org.dyn4j.Epsilon.E_$LI$() ? true : false;
                }
                isOrthogonal$double$double$double(x, y, z) {
                    return Math.abs(this.x * x + this.y * y + this.z * z) <= org.dyn4j.Epsilon.E_$LI$();
                }
                /**
                 * Returns true if the given {@link Vector3} is orthogonal (perpendicular)
                 * to this {@link Vector3}.
                 * <p>
                 * If the dot product of this vector and the given vector is
                 * zero then we know that they are perpendicular
                 * @param {number} x the x component of the {@link Vector3}
                 * @param {number} y the y component of the {@link Vector3}
                 * @param {number} z the z component of the {@link Vector3}
                 * @return {boolean} boolean
                 */
                isOrthogonal(x, y, z) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                        return this.isOrthogonal$double$double$double(x, y, z);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector3) || x === null) && y === undefined && z === undefined) {
                        return this.isOrthogonal$org_dyn4j_geometry_Vector3(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns true if this {@link Vector3} is the zero {@link Vector3}.
                 * @return {boolean} boolean
                 */
                isZero() {
                    return Math.abs(this.x) <= org.dyn4j.Epsilon.E_$LI$() && Math.abs(this.y) <= org.dyn4j.Epsilon.E_$LI$() && Math.abs(this.z) <= org.dyn4j.Epsilon.E_$LI$();
                }
                /**
                 *
                 * Negates this {@link Vector3}.
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} this vector
                 */
                negate() {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                    return this;
                }
                /**
                 * Returns a {@link Vector3} which is the negative of this {@link Vector3}.
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                getNegative() {
                    return new Vector3(-this.x, -this.y, -this.z);
                }
                /**
                 *
                 * Sets the {@link Vector3} to the zero {@link Vector3}
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} this vector
                 */
                zero() {
                    this.x = 0.0;
                    this.y = 0.0;
                    this.z = 0.0;
                    return this;
                }
                /**
                 * Projects this {@link Vector3} onto the given {@link Vector3}.
                 * <p>
                 * This method requires the length of the given {@link Vector3} is not zero.
                 * @param {org.dyn4j.geometry.Vector3} vector the {@link Vector3}
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} the projected {@link Vector3}
                 */
                project(vector) {
                    const dotProd = this.dot$org_dyn4j_geometry_Vector3(vector);
                    let denominator = vector.dot$org_dyn4j_geometry_Vector3(vector);
                    if (denominator <= org.dyn4j.Epsilon.E_$LI$())
                        return new Vector3();
                    denominator = dotProd / denominator;
                    return new Vector3(denominator * vector.x, denominator * vector.y, denominator * vector.z);
                }
                /**
                 * Returns a unit {@link Vector3} of this {@link Vector3}.
                 * <p>
                 * This method requires the length of this {@link Vector3} is not zero.
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3}
                 */
                getNormalized() {
                    let magnitude = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                    if (magnitude <= org.dyn4j.Epsilon.E_$LI$())
                        return new Vector3();
                    magnitude = 1.0 / magnitude;
                    return new Vector3(this.x * magnitude, this.y * magnitude, this.z * magnitude);
                }
                /**
                 * Converts this {@link Vector3} into a unit {@link Vector3} and returns
                 * the magnitude before normalization.
                 * <p>
                 * This method requires the length of this {@link Vector3} is not zero.
                 * @return {number} double
                 */
                normalize() {
                    const magnitude = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                    if (magnitude <= org.dyn4j.Epsilon.E_$LI$())
                        return 0;
                    const m = 1.0 / magnitude;
                    this.x *= m;
                    this.y *= m;
                    this.z *= m;
                    return magnitude;
                }
            }
            geometry.Vector3 = Vector3;
            Vector3["__class"] = "org.dyn4j.geometry.Vector3";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Creates a new Spline2D.
             * @param {double[]} x
             * @param {double[]} y
             * @class
             */
            class Spline2D {
                constructor(x, y) {
                    if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && ((y != null && y instanceof Array && (y.length == 0 || y[0] == null || (typeof y[0] === 'number'))) || y === null)) {
                        let __args = arguments;
                        if (this.t === undefined) {
                            this.t = null;
                        }
                        if (this.splineX === undefined) {
                            this.splineX = null;
                        }
                        if (this.splineY === undefined) {
                            this.splineY = null;
                        }
                        if (this.length === undefined) {
                            this.length = 0;
                        }
                        this.init(x, y);
                    }
                    else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (x[0] != null && x[0] instanceof org.dyn4j.geometry.Vector2))) || x === null) && y === undefined) {
                        let __args = arguments;
                        let points = __args[0];
                        if (this.t === undefined) {
                            this.t = null;
                        }
                        if (this.splineX === undefined) {
                            this.splineX = null;
                        }
                        if (this.splineY === undefined) {
                            this.splineY = null;
                        }
                        if (this.length === undefined) {
                            this.length = 0;
                        }
                        const x = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(points.length);
                        const y = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(points.length);
                        for (let i = 0; i < points.length; i++) {
                            {
                                x[i] = points[i].x;
                                y[i] = points[i].y;
                            }
                            ;
                        }
                        this.init(x, y);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ init(x, y) {
                    if (x.length !== y.length) {
                        throw new java.lang.IllegalArgumentException("Arrays must have the same length.");
                    }
                    if (x.length < 2) {
                        throw new java.lang.IllegalArgumentException("Spline edges must have at least two points.");
                    }
                    this.t = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(x.length);
                    this.t[0] = 0.0;
                    for (let i = 1; i < this.t.length; i++) {
                        {
                            const lx = x[i] - x[i - 1];
                            const ly = y[i] - y[i - 1];
                            if (0.0 === lx) {
                                this.t[i] = Math.abs(ly);
                            }
                            else if (0.0 === ly) {
                                this.t[i] = Math.abs(lx);
                            }
                            else {
                                this.t[i] = Math.sqrt(lx * lx + ly * ly);
                            }
                            this.length += this.t[i];
                            this.t[i] += this.t[i - 1];
                        }
                        ;
                    }
                    for (let i = 1; i < (this.t.length) - 1; i++) {
                        {
                            this.t[i] = this.t[i] / this.length;
                        }
                        ;
                    }
                    this.t[(this.t.length) - 1] = 1.0;
                    this.splineX = new org.dyn4j.geometry.Spline(this.t, x);
                    this.splineY = new org.dyn4j.geometry.Spline(this.t, y);
                }
                /**
                 * @param {number} t 0 <= t <= 1
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getPoint(t) {
                    let x;
                    let y;
                    x = this.splineX.getValue(t);
                    y = this.splineY.getValue(t);
                    return new org.dyn4j.geometry.Vector2(x, y);
                }
                /**
                 * Used to check the correctness of this spline
                 * @return {boolean}
                 */
                checkValues() {
                    return (this.splineX.checkValues() && this.splineY.checkValues());
                }
                getDx(t) {
                    return this.splineX.getDx(t);
                }
                getDy(t) {
                    return this.splineY.getDx(t);
                }
                getSplineX() {
                    return this.splineX;
                }
                getSplineY() {
                    return this.splineY;
                }
                getLength() {
                    return this.length;
                }
            }
            geometry.Spline2D = Spline2D;
            Spline2D["__class"] = "org.dyn4j.geometry.Spline2D";
            /**
             * Creates a new Spline.
             * @param {double[]} xx
             * @param {double[]} yy
             * @class
             */
            class Spline {
                constructor(xx, yy) {
                    if (this.xx === undefined) {
                        this.xx = null;
                    }
                    if (this.yy === undefined) {
                        this.yy = null;
                    }
                    if (this.a === undefined) {
                        this.a = null;
                    }
                    if (this.b === undefined) {
                        this.b = null;
                    }
                    if (this.c === undefined) {
                        this.c = null;
                    }
                    if (this.d === undefined) {
                        this.d = null;
                    }
                    this.storageIndex = 0;
                    this.setValues(xx, yy);
                }
                /**
                 * Set values for this Spline.
                 * @param {double[]} xx
                 * @param {double[]} yy
                 */
                setValues(xx, yy) {
                    this.xx = xx;
                    this.yy = yy;
                    if (xx.length > 1) {
                        this.calculateCoefficients();
                    }
                }
                /**
                 * Returns an interpolated value.
                 * @param {number} x
                 * @return {number} the interpolated value
                 */
                getValue(x) {
                    if (this.xx.length === 0) {
                        return javaemul.internal.DoubleHelper.NaN;
                    }
                    if (this.xx.length === 1) {
                        if (this.xx[0] === x) {
                            return this.yy[0];
                        }
                        else {
                            return javaemul.internal.DoubleHelper.NaN;
                        }
                    }
                    let index = java.util.Arrays.binarySearch(this.xx, x);
                    if (index > 0) {
                        return this.yy[index];
                    }
                    index = -(index + 1) - 1;
                    if (index < 0) {
                        return this.yy[0];
                    }
                    return this.a[index] + this.b[index] * (x - this.xx[index]) + this.c[index] * Math.pow(x - this.xx[index], 2) + this.d[index] * Math.pow(x - this.xx[index], 3);
                }
                /**
                 * Returns an interpolated value. To be used when a long sequence of values
                 * are required in order, but ensure checkValues() is called beforehand to
                 * ensure the boundary checks from getValue() are made
                 * @param {number} x
                 * @return {number} the interpolated value
                 */
                getFastValue(x) {
                    if (this.storageIndex > -1 && this.storageIndex < this.xx.length - 1 && x > this.xx[this.storageIndex] && x < this.xx[this.storageIndex + 1]) {
                    }
                    else {
                        let index = java.util.Arrays.binarySearch(this.xx, x);
                        if (index > 0) {
                            return this.yy[index];
                        }
                        index = -(index + 1) - 1;
                        this.storageIndex = index;
                    }
                    if (this.storageIndex < 0) {
                        return this.yy[0];
                    }
                    const value = x - this.xx[this.storageIndex];
                    return this.a[this.storageIndex] + this.b[this.storageIndex] * value + this.c[this.storageIndex] * (value * value) + this.d[this.storageIndex] * (value * value * value);
                }
                /**
                 * Used to check the correctness of this spline
                 * @return {boolean}
                 */
                checkValues() {
                    if (this.xx.length < 2) {
                        return false;
                    }
                    else {
                        return true;
                    }
                }
                /**
                 * Returns the first derivation at x.
                 * @param {number} x
                 * @return {number} the first derivation at x
                 */
                getDx(x) {
                    if (this.xx.length === 0 || this.xx.length === 1) {
                        return 0;
                    }
                    let index = java.util.Arrays.binarySearch(this.xx, x);
                    if (index < 0) {
                        index = -(index + 1) - 1;
                    }
                    return this.b[index] + 2 * this.c[index] * (x - this.xx[index]) + 3 * this.d[index] * Math.pow(x - this.xx[index], 2);
                }
                /**
                 * Calculates the Spline coefficients.
                 * @private
                 */
                /*private*/ calculateCoefficients() {
                    const N = this.yy.length;
                    this.a = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(N);
                    this.b = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(N);
                    this.c = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(N);
                    this.d = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(N);
                    if (N === 2) {
                        this.a[0] = this.yy[0];
                        this.b[0] = this.yy[1] - this.yy[0];
                        return;
                    }
                    const h = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(N - 1);
                    for (let i = 0; i < N - 1; i++) {
                        {
                            this.a[i] = this.yy[i];
                            h[i] = this.xx[i + 1] - this.xx[i];
                            if (h[i] === 0.0) {
                                h[i] = 0.01;
                            }
                        }
                        ;
                    }
                    this.a[N - 1] = this.yy[N - 1];
                    const A = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                        return 0;
                    }
                    else {
                        let array = [];
                        for (let i = 0; i < dims[0]; i++) {
                            array.push(allocate(dims.slice(1)));
                        }
                        return array;
                    } }; return allocate(dims); })([N - 2, N - 2]);
                    const y = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(N - 2);
                    for (let i = 0; i < N - 2; i++) {
                        {
                            y[i] = 3 * ((this.yy[i + 2] - this.yy[i + 1]) / h[i + 1] - (this.yy[i + 1] - this.yy[i]) / h[i]);
                            A[i][i] = 2 * (h[i] + h[i + 1]);
                            if (i > 0) {
                                A[i][i - 1] = h[i];
                            }
                            if (i < N - 3) {
                                A[i][i + 1] = h[i + 1];
                            }
                        }
                        ;
                    }
                    this.solve(A, y);
                    for (let i = 0; i < N - 2; i++) {
                        {
                            this.c[i + 1] = y[i];
                            this.b[i] = (this.a[i + 1] - this.a[i]) / h[i] - (2 * this.c[i] + this.c[i + 1]) / 3 * h[i];
                            this.d[i] = (this.c[i + 1] - this.c[i]) / (3 * h[i]);
                        }
                        ;
                    }
                    this.b[N - 2] = (this.a[N - 1] - this.a[N - 2]) / h[N - 2] - (2 * this.c[N - 2] + this.c[N - 1]) / 3 * h[N - 2];
                    this.d[N - 2] = (this.c[N - 1] - this.c[N - 2]) / (3 * h[N - 2]);
                }
                /**
                 * Solves Ax=b and stores the solution in b.
                 * @param {double[][]} A
                 * @param {double[]} b
                 */
                solve(A, b) {
                    const n = b.length;
                    for (let i = 1; i < n; i++) {
                        {
                            A[i][i - 1] = A[i][i - 1] / A[i - 1][i - 1];
                            A[i][i] = A[i][i] - A[i - 1][i] * A[i][i - 1];
                            b[i] = b[i] - A[i][i - 1] * b[i - 1];
                        }
                        ;
                    }
                    b[n - 1] = b[n - 1] / A[n - 1][n - 1];
                    for (let i = b.length - 2; i >= 0; i--) {
                        {
                            b[i] = (b[i] - A[i][i + 1] * b[i + 1]) / A[i][i];
                        }
                        ;
                    }
                }
            }
            geometry.Spline = Spline;
            Spline["__class"] = "org.dyn4j.geometry.Spline";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * @param {number} minX the minimum x extent
             * @param {number} minY the minimum y extent
             * @param {number} maxX the maximum x extent
             * @param {number} maxY the maximum y extent
             * @class
             * @author William Bittle
             */
            class AABB {
                constructor(minX, minY, maxX, maxY) {
                    if (((typeof minX === 'number') || minX === null) && ((typeof minY === 'number') || minY === null) && ((typeof maxX === 'number') || maxX === null) && ((typeof maxY === 'number') || maxY === null)) {
                        let __args = arguments;
                        if (this.minX === undefined) {
                            this.minX = 0;
                        }
                        if (this.minY === undefined) {
                            this.minY = 0;
                        }
                        if (this.maxX === undefined) {
                            this.maxX = 0;
                        }
                        if (this.maxY === undefined) {
                            this.maxY = 0;
                        }
                        if (minX > maxX || minY > maxY)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.aabb.invalidMinMax"));
                        this.minX = minX;
                        this.minY = minY;
                        this.maxX = maxX;
                        this.maxY = maxY;
                    }
                    else if (((minX != null && minX instanceof org.dyn4j.geometry.Vector2) || minX === null) && ((minY != null && minY instanceof org.dyn4j.geometry.Vector2) || minY === null) && maxX === undefined && maxY === undefined) {
                        let __args = arguments;
                        let min = __args[0];
                        let max = __args[1];
                        {
                            let __args = arguments;
                            let minX = min.x;
                            let minY = min.y;
                            let maxX = max.x;
                            let maxY = max.y;
                            if (this.minX === undefined) {
                                this.minX = 0;
                            }
                            if (this.minY === undefined) {
                                this.minY = 0;
                            }
                            if (this.maxX === undefined) {
                                this.maxX = 0;
                            }
                            if (this.maxY === undefined) {
                                this.maxY = 0;
                            }
                            if (minX > maxX || minY > maxY)
                                throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.aabb.invalidMinMax"));
                            this.minX = minX;
                            this.minY = minY;
                            this.maxX = maxX;
                            this.maxY = maxY;
                        }
                        if (this.minX === undefined) {
                            this.minX = 0;
                        }
                        if (this.minY === undefined) {
                            this.minY = 0;
                        }
                        if (this.maxX === undefined) {
                            this.maxX = 0;
                        }
                        if (this.maxY === undefined) {
                            this.maxY = 0;
                        }
                    }
                    else if (((minX != null && minX instanceof org.dyn4j.geometry.Vector2) || minX === null) && ((typeof minY === 'number') || minY === null) && maxX === undefined && maxY === undefined) {
                        let __args = arguments;
                        let center = __args[0];
                        let radius = __args[1];
                        if (this.minX === undefined) {
                            this.minX = 0;
                        }
                        if (this.minY === undefined) {
                            this.minY = 0;
                        }
                        if (this.maxX === undefined) {
                            this.maxX = 0;
                        }
                        if (this.maxY === undefined) {
                            this.maxY = 0;
                        }
                        if (radius < 0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.aabb.invalidRadius"));
                        if (center == null) {
                            this.minX = -radius;
                            this.minY = -radius;
                            this.maxX = radius;
                            this.maxY = radius;
                        }
                        else {
                            this.minX = center.x - radius;
                            this.minY = center.y - radius;
                            this.maxX = center.x + radius;
                            this.maxY = center.y + radius;
                        }
                    }
                    else if (((minX != null && minX instanceof org.dyn4j.geometry.AABB) || minX === null) && minY === undefined && maxX === undefined && maxY === undefined) {
                        let __args = arguments;
                        let aabb = __args[0];
                        if (this.minX === undefined) {
                            this.minX = 0;
                        }
                        if (this.minY === undefined) {
                            this.minY = 0;
                        }
                        if (this.maxX === undefined) {
                            this.maxX = 0;
                        }
                        if (this.maxY === undefined) {
                            this.maxY = 0;
                        }
                        this.minX = aabb.minX;
                        this.minY = aabb.minY;
                        this.maxX = aabb.maxX;
                        this.maxY = aabb.maxY;
                    }
                    else if (((typeof minX === 'number') || minX === null) && minY === undefined && maxX === undefined && maxY === undefined) {
                        let __args = arguments;
                        let radius = __args[0];
                        {
                            let __args = arguments;
                            let center = null;
                            if (this.minX === undefined) {
                                this.minX = 0;
                            }
                            if (this.minY === undefined) {
                                this.minY = 0;
                            }
                            if (this.maxX === undefined) {
                                this.maxX = 0;
                            }
                            if (this.maxY === undefined) {
                                this.maxY = 0;
                            }
                            if (radius < 0)
                                throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.aabb.invalidRadius"));
                            if (center == null) {
                                this.minX = -radius;
                                this.minY = -radius;
                                this.maxX = radius;
                                this.maxY = radius;
                            }
                            else {
                                this.minX = center.x - radius;
                                this.minY = center.y - radius;
                                this.maxX = center.x + radius;
                                this.maxY = center.y + radius;
                            }
                        }
                        if (this.minX === undefined) {
                            this.minX = 0;
                        }
                        if (this.minY === undefined) {
                            this.minY = 0;
                        }
                        if (this.maxX === undefined) {
                            this.maxX = 0;
                        }
                        if (this.maxY === undefined) {
                            this.maxY = 0;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                static createAABBFromPoints$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(point1, point2) {
                    return AABB.createAABBFromPoints$double$double$double$double(point1.x, point1.y, point2.x, point2.y);
                }
                static createAABBFromPoints$double$double$double$double(point1x, point1y, point2x, point2y) {
                    if (point2x < point1x) {
                        const temp = point1x;
                        point1x = point2x;
                        point2x = temp;
                    }
                    if (point2y < point1y) {
                        const temp = point1y;
                        point1y = point2y;
                        point2y = temp;
                    }
                    return new AABB(point1x, point1y, point2x, point2y);
                }
                /**
                 * Method to create the valid AABB defined by the two points A(point1x, point1y) and B(point2x, point2y).
                 *
                 * @param {number} point1x The x coordinate of point A
                 * @param {number} point1y The y coordinate of point A
                 * @param {number} point2x The x coordinate of point B
                 * @param {number} point2y The y coordinate of point B
                 * @return {org.dyn4j.geometry.AABB} The one and only one valid AABB formed by A and B
                 */
                static createAABBFromPoints(point1x, point1y, point2x, point2y) {
                    if (((typeof point1x === 'number') || point1x === null) && ((typeof point1y === 'number') || point1y === null) && ((typeof point2x === 'number') || point2x === null) && ((typeof point2y === 'number') || point2y === null)) {
                        return org.dyn4j.geometry.AABB.createAABBFromPoints$double$double$double$double(point1x, point1y, point2x, point2y);
                    }
                    else if (((point1x != null && point1x instanceof org.dyn4j.geometry.Vector2) || point1x === null) && ((point1y != null && point1y instanceof org.dyn4j.geometry.Vector2) || point1y === null) && point2x === undefined && point2y === undefined) {
                        return org.dyn4j.geometry.AABB.createAABBFromPoints$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(point1x, point1y);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns a copy of this {@link AABB}.
                 * @return {org.dyn4j.geometry.AABB} {@link AABB}
                 * @since 3.4.0
                 */
                copy() {
                    return new AABB(this);
                }
                set$org_dyn4j_geometry_AABB(aabb) {
                    this.minX = aabb.minX;
                    this.minY = aabb.minY;
                    this.maxX = aabb.maxX;
                    this.maxY = aabb.maxY;
                    return this;
                }
                set$double$double$double$double(minx, miny, maxx, maxy) {
                    this.minX = minx;
                    this.minY = miny;
                    this.maxX = maxx;
                    this.maxY = maxy;
                    return this;
                }
                /**
                 * Sets this aabb to the given aabb's value and returns
                 * this AABB.
                 * @param {number} minx
                 * @param {number} miny
                 * @param {number} maxx
                 * @param {number} maxy
                 *
                 * @return {org.dyn4j.geometry.AABB} {@link AABB}
                 * @since 4.0
                 */
                set(minx, miny, maxx, maxy) {
                    if (((typeof minx === 'number') || minx === null) && ((typeof miny === 'number') || miny === null) && ((typeof maxx === 'number') || maxx === null) && ((typeof maxy === 'number') || maxy === null)) {
                        return this.set$double$double$double$double(minx, miny, maxx, maxy);
                    }
                    else if (((minx != null && minx instanceof org.dyn4j.geometry.AABB) || minx === null) && miny === undefined && maxx === undefined && maxy === undefined) {
                        return this.set$org_dyn4j_geometry_AABB(minx);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * resets this AABB to degenerate one, which has negative volume
                 * @return {org.dyn4j.geometry.AABB} this AABB
                 */
                reset() {
                    this.minX = javaemul.internal.DoubleHelper.MAX_VALUE;
                    this.minY = javaemul.internal.DoubleHelper.MAX_VALUE;
                    this.maxX = -javaemul.internal.DoubleHelper.MAX_VALUE;
                    this.maxY = -javaemul.internal.DoubleHelper.MAX_VALUE;
                    return this;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("AABB[Min=").append("(").append(this.minX).append(", ").append(this.minY).append(")").append("|Max=").append("(").append(this.maxX).append(", ").append(this.maxY).append(")").append("]");
                    return sb.toString();
                }
                translate$double$double(x, y) {
                    this.minX += x;
                    this.minY += y;
                    this.maxX += x;
                    this.maxY += y;
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$org_dyn4j_geometry_Vector2(translation) {
                    this.translate$double$double(translation.x, translation.y);
                }
                /**
                 * Returns a new AABB of this AABB translated by the
                 * given translation amount.
                 * @param {org.dyn4j.geometry.Vector2} translation the translation
                 * @return {org.dyn4j.geometry.AABB} AABB
                 * @since 3.1.1
                 */
                getTranslated(translation) {
                    return new AABB(this.minX + translation.x, this.minY + translation.y, this.maxX + translation.x, this.maxY + translation.y);
                }
                /**
                 * Returns the width of this {@link AABB}.
                 * @return {number} double
                 * @since 3.0.1
                 */
                getWidth() {
                    return this.maxX - this.minX;
                }
                /**
                 * Returns the height of this {@link AABB}.
                 * @return {number} double
                 * @since 3.0.1
                 */
                getHeight() {
                    return this.maxY - this.minY;
                }
                /**
                 * Returns the perimeter of this {@link AABB}.
                 * @return {number} double
                 */
                getPerimeter() {
                    return 2 * (this.maxX - this.minX + this.maxY - this.minY);
                }
                /**
                 * Returns the area of this {@link AABB};.
                 * @return {number} double
                 */
                getArea() {
                    return (this.maxX - this.minX) * (this.maxY - this.minY);
                }
                /**
                 * Automatically expands this AABB so that specified point lies inside it.
                 * Does nothing if point already lies inside this.
                 * @param {number} x x coordinate of the Point to contain
                 * @param {number} y y coordinate of the Point to contain
                 * @return
                 * @return {org.dyn4j.geometry.AABB}
                 */
                expandToFit(x, y) {
                    if (!this.contains$double$double(x, y)) {
                        this.minX = Math.min(this.minX, x);
                        this.minY = Math.min(this.minY, y);
                        this.maxX = Math.max(this.maxX, x);
                        this.maxY = Math.max(this.maxY, y);
                    }
                    return this;
                }
                /**
                 * Performs a union of this {@link AABB} and the given {@link AABB} placing
                 * the result of the union into this {@link AABB} and then returns
                 * this {@link AABB}
                 * @param {org.dyn4j.geometry.AABB} aabb the {@link AABB} to union
                 * @return {org.dyn4j.geometry.AABB} {@link AABB}
                 */
                union(aabb) {
                    this.minX = Math.min(this.minX, aabb.minX);
                    this.minY = Math.min(this.minY, aabb.minY);
                    this.maxX = Math.max(this.maxX, aabb.maxX);
                    this.maxY = Math.max(this.maxY, aabb.maxY);
                    return this;
                }
                /**
                 * Performs a union of this {@link AABB} and the given {@link AABB} returning
                 * a new {@link AABB} containing the result.
                 * @param {org.dyn4j.geometry.AABB} aabb the {@link AABB} to union
                 * @return {org.dyn4j.geometry.AABB} {@link AABB} the resulting union
                 */
                getUnion(aabb) {
                    return this.copy().union(aabb);
                }
                /**
                 * Performs the intersection of this {@link AABB} and the given {@link AABB} placing
                 * the result into this {@link AABB} and then returns this {@link AABB}.
                 * <p>
                 * If the given {@link AABB} does not overlap this {@link AABB}, this {@link AABB} is
                 * set to a zero {@link AABB}.
                 * @param {org.dyn4j.geometry.AABB} aabb the {@link AABB} to intersect
                 * @return {org.dyn4j.geometry.AABB} {@link AABB}
                 * @since 3.1.1
                 */
                intersection(aabb) {
                    this.minX = Math.max(this.minX, aabb.minX);
                    this.minY = Math.max(this.minY, aabb.minY);
                    this.maxX = Math.min(this.maxX, aabb.maxX);
                    this.maxY = Math.min(this.maxY, aabb.maxY);
                    if (this.minX > this.maxX || this.minY > this.maxY) {
                        this.minX = 0.0;
                        this.minY = 0.0;
                        this.maxX = 0.0;
                        this.maxY = 0.0;
                    }
                    return this;
                }
                /**
                 * Performs the intersection of this {@link AABB} and the given {@link AABB} returning
                 * the result in a new {@link AABB}.
                 * <p>
                 * If the given {@link AABB} does not overlap this {@link AABB}, a zero {@link AABB} is
                 * returned.
                 * @param {org.dyn4j.geometry.AABB} aabb the {@link AABB} to intersect
                 * @return {org.dyn4j.geometry.AABB} {@link AABB}
                 * @since 3.1.1
                 */
                getIntersection(aabb) {
                    return this.copy().intersection(aabb);
                }
                /**
                 * Expands this {@link AABB} by half the given expansion in each direction and
                 * then returns this {@link AABB}.
                 * <p>
                 * The expansion can be negative to shrink the {@link AABB}.  However, if the expansion is
                 * greater than the current width/height, the {@link AABB} can become invalid.  In this
                 * case, the AABB will become a degenerate AABB at the mid point of the min and max for
                 * the respective coordinates.
                 * @param {number} expansion the expansion amount
                 * @return {org.dyn4j.geometry.AABB} {@link AABB}
                 */
                expand(expansion) {
                    const e = expansion * 0.5;
                    this.minX -= e;
                    this.minY -= e;
                    this.maxX += e;
                    this.maxY += e;
                    if (expansion < 0.0) {
                        if (this.minX > this.maxX) {
                            const mid = (this.minX + this.maxX) * 0.5;
                            this.minX = mid;
                            this.maxX = mid;
                        }
                        if (this.minY > this.maxY) {
                            const mid = (this.minY + this.maxY) * 0.5;
                            this.minY = mid;
                            this.maxY = mid;
                        }
                    }
                    return this;
                }
                /**
                 * Returns a new {@link AABB} of this AABB expanded by half the given expansion
                 * in both the x and y directions.
                 * <p>
                 * The expansion can be negative to shrink the {@link AABB}.  However, if the expansion is
                 * greater than the current width/height, the {@link AABB} can become invalid.  In this
                 * case, the AABB will become a degenerate AABB at the mid point of the min and max for
                 * the respective coordinates.
                 * @param {number} expansion the expansion amount
                 * @return {org.dyn4j.geometry.AABB} {@link AABB}
                 * @since 3.1.1
                 */
                getExpanded(expansion) {
                    return this.copy().expand(expansion);
                }
                /**
                 * Returns true if the given {@link AABB} and this {@link AABB} overlap.
                 * @param {org.dyn4j.geometry.AABB} aabb the {@link AABB} to test
                 * @return {boolean} boolean true if the {@link AABB}s overlap
                 */
                overlaps(aabb) {
                    return this.minX <= aabb.maxX && this.maxX >= aabb.minX && this.minY <= aabb.maxY && this.maxY >= aabb.minY;
                }
                contains$org_dyn4j_geometry_AABB(aabb) {
                    return this.minX <= aabb.minX && this.maxX >= aabb.maxX && this.minY <= aabb.minY && this.maxY >= aabb.maxY;
                }
                contains$org_dyn4j_geometry_Vector2(point) {
                    return this.contains$double$double(point.x, point.y);
                }
                contains$double$double(x, y) {
                    return this.minX <= x && this.maxX >= x && this.minY <= y && this.maxY >= y;
                }
                /**
                 * Returns true if the given point's coordinates are contained within this {@link AABB}.
                 * @param {number} x the x coordinate of the point
                 * @param {number} y the y coordinate of the point
                 * @return {boolean} boolean
                 * @since 3.1.1
                 */
                contains(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.AABB) || x === null) && y === undefined) {
                        return this.contains$org_dyn4j_geometry_AABB(x);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                isDegenerate$() {
                    return this.minX === this.maxX || this.minY === this.maxY;
                }
                isDegenerate$double(error) {
                    return Math.abs(this.maxX - this.minX) <= error || Math.abs(this.maxY - this.minY) <= error;
                }
                /**
                 * Returns true if this {@link AABB} is degenerate given
                 * the specified error.
                 * <p>
                 * An {@link AABB} is degenerate given some error if
                 * max - min &lt;= error for either the x or y coordinate.
                 * @param {number} error the allowed error
                 * @return {boolean} boolean
                 * @since 3.1.1
                 * @see #isDegenerate()
                 */
                isDegenerate(error) {
                    if (((typeof error === 'number') || error === null)) {
                        return this.isDegenerate$double(error);
                    }
                    else if (error === undefined) {
                        return this.isDegenerate$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the minimum x extent.
                 * @return {number} double
                 */
                getMinX() {
                    return this.minX;
                }
                /**
                 * Returns the maximum x extent.
                 * @return {number} double
                 */
                getMaxX() {
                    return this.maxX;
                }
                /**
                 * Returns the maximum y extent.
                 * @return {number} double
                 */
                getMaxY() {
                    return this.maxY;
                }
                /**
                 * Returns the minimum y extent.
                 * @return {number} double
                 */
                getMinY() {
                    return this.minY;
                }
            }
            geometry.AABB = AABB;
            AABB["__class"] = "org.dyn4j.geometry.AABB";
            AABB["__interfaces"] = ["org.dyn4j.geometry.Translatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.geometry.decompose.SweepLineVertex} vertex the vertex to test with
                 * @class
                 * @author William Bittle
                 */
                class ClosestEdgeToVertexSearchCriteria {
                    constructor(vertex) {
                        if (this.vertex === undefined) {
                            this.vertex = null;
                        }
                        if (this.closest === undefined) {
                            this.closest = null;
                        }
                        this.vertex = vertex;
                        this.closest = null;
                    }
                    evaluate$org_dyn4j_geometry_decompose_SweepLineEdge(edge) {
                        if (this.vertex.isLeft(edge)) {
                            return -1;
                        }
                        else {
                            this.closest = edge;
                            return 1;
                        }
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.decompose.SweepLineEdge} edge
                     * @return {number}
                     */
                    evaluate(edge) {
                        if (((edge != null && edge instanceof org.dyn4j.geometry.decompose.SweepLineEdge) || edge === null)) {
                            return this.evaluate$org_dyn4j_geometry_decompose_SweepLineEdge(edge);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                decompose.ClosestEdgeToVertexSearchCriteria = ClosestEdgeToVertexSearchCriteria;
                ClosestEdgeToVertexSearchCriteria["__class"] = "org.dyn4j.geometry.decompose.ClosestEdgeToVertexSearchCriteria";
                ClosestEdgeToVertexSearchCriteria["__interfaces"] = ["org.dyn4j.BinarySearchTreeSearchCriteria"];
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.geometry.Vector2} point the vertex point
                 * @param {number} index the index in the original simple polygon
                 * @class
                 * @author William Bittle
                 */
                class SweepLineVertex {
                    constructor(point, index) {
                        if (this.point === undefined) {
                            this.point = null;
                        }
                        if (this.index === undefined) {
                            this.index = 0;
                        }
                        if (this.type === undefined) {
                            this.type = null;
                        }
                        if (this.next === undefined) {
                            this.next = null;
                        }
                        if (this.prev === undefined) {
                            this.prev = null;
                        }
                        if (this.left === undefined) {
                            this.left = null;
                        }
                        if (this.right === undefined) {
                            this.right = null;
                        }
                        this.point = point;
                        this.index = index;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.decompose.SweepLineVertex} other
                     * @return {number}
                     */
                    compareTo(other) {
                        const p = this.point;
                        const q = other.point;
                        const diff = q.y - p.y;
                        if (diff === 0.0) {
                            return ((f => { if (f > 0) {
                                return 1;
                            }
                            else if (f < 0) {
                                return -1;
                            }
                            else {
                                return 0;
                            } })(p.x - q.x) | 0);
                        }
                        else {
                            return ((f => { if (f > 0) {
                                return 1;
                            }
                            else if (f < 0) {
                                return -1;
                            }
                            else {
                                return 0;
                            } })(diff) | 0);
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return this.point.toString();
                    }
                    /**
                     * Returns true if this {@link SweepLineVertex} is left of the given {@link SweepLineEdge}.
                     * @param {org.dyn4j.geometry.decompose.SweepLineEdge} edge the {@link SweepLineEdge}
                     * @return {boolean} boolean true if this {@link SweepLineVertex} is to the left of the given {@link SweepLineEdge}
                     */
                    isLeft(edge) {
                        const location = org.dyn4j.geometry.Segment.getLocation(this.point, edge.v0.point, edge.v1.point);
                        if (location < 0.0) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    /**
                     * Returns true if the interior is to the right of this vertex.
                     * <p>
                     * The left edge of this vertex is used to determine where the
                     * interior of the polygon is.
                     * @return {boolean} boolean
                     */
                    isInteriorRight() {
                        return this.left.isInteriorRight();
                    }
                }
                decompose.SweepLineVertex = SweepLineVertex;
                SweepLineVertex["__class"] = "org.dyn4j.geometry.decompose.SweepLineVertex";
                SweepLineVertex["__interfaces"] = ["java.lang.Comparable"];
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Represents a half edge of the {@link DoubleEdgeList}.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 2.2.0
                 * @class
                 */
                class DoubleEdgeListHalfEdge {
                    constructor() {
                        if (this.origin === undefined) {
                            this.origin = null;
                        }
                        if (this.twin === undefined) {
                            this.twin = null;
                        }
                        if (this.next === undefined) {
                            this.next = null;
                        }
                        if (this.face === undefined) {
                            this.face = null;
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append(this.origin).append(" to ").append(this.next.origin);
                        return sb.toString();
                    }
                    /**
                     * Returns this half edge's destination.
                     * @return {org.dyn4j.geometry.decompose.DoubleEdgeListVertex} {@link DoubleEdgeListVertex}
                     */
                    getDestination() {
                        return this.next.origin;
                    }
                    /**
                     * Returns the previous half edge having the same
                     * face as this half edge.
                     * @return {org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge} {@link DoubleEdgeListHalfEdge}
                     */
                    getPrevious() {
                        let edge = this.twin.next.twin;
                        while ((edge.next !== this)) {
                            {
                                edge = edge.next.twin;
                            }
                        }
                        ;
                        return edge;
                    }
                    /**
                     * Returns this half edge's face.
                     * @return {org.dyn4j.geometry.decompose.DoubleEdgeListFace} {@link DoubleEdgeListFace}
                     */
                    getFace() {
                        return this.face;
                    }
                }
                decompose.DoubleEdgeListHalfEdge = DoubleEdgeListHalfEdge;
                DoubleEdgeListHalfEdge["__class"] = "org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge";
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Minimal constructor.
                 * @param {*} data the vertex data
                 * @class
                 * @author William Bittle
                 */
                class MonotoneVertex {
                    constructor(data) {
                        if (this.data === undefined) {
                            this.data = null;
                        }
                        if (this.next === undefined) {
                            this.next = null;
                        }
                        if (this.previous === undefined) {
                            this.previous = null;
                        }
                        if (this.chainType === undefined) {
                            this.chainType = null;
                        }
                        this.data = data;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return this.data.toString();
                    }
                    /**
                     * Returns true if the given vertex is adjacent to this vertex.
                     * @param {org.dyn4j.geometry.decompose.MonotoneVertex} vertex the vertex to test
                     * @return {boolean} boolean
                     */
                    isAdjacent(vertex) {
                        return vertex === this.previous || vertex === this.next;
                    }
                }
                decompose.MonotoneVertex = MonotoneVertex;
                MonotoneVertex["__class"] = "org.dyn4j.geometry.decompose.MonotoneVertex";
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Enumeration of the {@link SweepLineVertex} types.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 2.2.0
                 * @enum
                 * @property {org.dyn4j.geometry.decompose.SweepLineVertexType} START
                 * Vertex above both its neighbors and the internal angle is less than &pi;
                 * @property {org.dyn4j.geometry.decompose.SweepLineVertexType} SPLIT
                 * Vertex above both its neighbors and the internal angle is greater than &pi;
                 * @property {org.dyn4j.geometry.decompose.SweepLineVertexType} END
                 * Vertex below both its neighbors and the internal angle is less than &pi;
                 * @property {org.dyn4j.geometry.decompose.SweepLineVertexType} MERGE
                 * Vertex below both its neighbors and the internal angle is greater than &pi;
                 * @property {org.dyn4j.geometry.decompose.SweepLineVertexType} REGULAR
                 * Vertex between both of its neighbors
                 * @class
                 */
                let SweepLineVertexType;
                (function (SweepLineVertexType) {
                    /**
                     * Vertex above both its neighbors and the internal angle is less than &pi;
                     */
                    SweepLineVertexType[SweepLineVertexType["START"] = 0] = "START";
                    /**
                     * Vertex above both its neighbors and the internal angle is greater than &pi;
                     */
                    SweepLineVertexType[SweepLineVertexType["SPLIT"] = 1] = "SPLIT";
                    /**
                     * Vertex below both its neighbors and the internal angle is less than &pi;
                     */
                    SweepLineVertexType[SweepLineVertexType["END"] = 2] = "END";
                    /**
                     * Vertex below both its neighbors and the internal angle is greater than &pi;
                     */
                    SweepLineVertexType[SweepLineVertexType["MERGE"] = 3] = "MERGE";
                    /**
                     * Vertex between both of its neighbors
                     */
                    SweepLineVertexType[SweepLineVertexType["REGULAR"] = 4] = "REGULAR";
                })(SweepLineVertexType = decompose.SweepLineVertexType || (decompose.SweepLineVertexType = {}));
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.geometry.decompose.MonotonePolygonType} type the monotone polygon type
                 * @param {*} vertices the sorted array of vertices; descending order
                 * @class
                 * @author William Bittle
                 */
                class MonotonePolygon {
                    constructor(type, vertices) {
                        if (this.type === undefined) {
                            this.type = null;
                        }
                        if (this.vertices === undefined) {
                            this.vertices = null;
                        }
                        this.type = type;
                        this.vertices = vertices;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("MonotonePolygon[Type=").append(this.type);
                        sb.append("|Vertices={");
                        const size = this.vertices.size();
                        for (let i = 0; i < size; i++) {
                            {
                                if (i !== 0)
                                    sb.append(",");
                                sb.append(this.vertices.get(i));
                            }
                            ;
                        }
                        sb.append("}]");
                        return sb.toString();
                    }
                    /**
                     * Returns the maximum vertex in the sorted array.
                     * @return {org.dyn4j.geometry.decompose.MonotoneVertex} {@link MonotoneVertex}
                     */
                    getMaximum() {
                        return this.vertices.get(0);
                    }
                    /**
                     * Returns the minimum vertex in the sorted array.
                     * @return {org.dyn4j.geometry.decompose.MonotoneVertex} {@link MonotoneVertex}
                     */
                    getMinimum() {
                        return this.vertices.get(this.vertices.size() - 1);
                    }
                }
                decompose.MonotonePolygon = MonotonePolygon;
                MonotonePolygon["__class"] = "org.dyn4j.geometry.decompose.MonotonePolygon";
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Default constructor.
                 * @class
                 * @author William Bittle
                 */
                class SweepLineState {
                    constructor() {
                        if (this.referenceY === undefined) {
                            this.referenceY = null;
                        }
                        if (this.tree === undefined) {
                            this.tree = null;
                        }
                        if (this.dcel === undefined) {
                            this.dcel = null;
                        }
                        this.referenceY = (new org.dyn4j.Reference(0.0));
                        this.tree = (new org.dyn4j.BinarySearchTree(true));
                    }
                    /**
                     * Returns a priority queue of the points in the given array and initializes
                     * the Binary Tree and DCEL for the SweepLine algorithm.
                     * @param {org.dyn4j.geometry.Vector2[]} points the array of polygon points
                     * @return {java.util.PriorityQueue} PriorityQueue&lt;{@link SweepLineVertex}&gt;
                     */
                    initialize(points) {
                        this.dcel = new org.dyn4j.geometry.decompose.DoubleEdgeList(points);
                        const size = points.length;
                        const queue = (new java.util.PriorityQueue(size));
                        let rootVertex = null;
                        let prevVertex = null;
                        let rootEdge = null;
                        let prevEdge = null;
                        for (let i = 0; i < size; i++) {
                            {
                                const point = points[i];
                                const vertex = new org.dyn4j.geometry.decompose.SweepLineVertex(point, i);
                                vertex.type = org.dyn4j.geometry.decompose.SweepLineVertexType.REGULAR;
                                vertex.prev = prevVertex;
                                if (prevVertex != null) {
                                    prevVertex.next = vertex;
                                }
                                if (rootVertex == null) {
                                    rootVertex = vertex;
                                }
                                const point1 = points[i + 1 === size ? 0 : i + 1];
                                const point0 = points[i === 0 ? size - 1 : i - 1];
                                vertex.type = this.getType(point0, point, point1);
                                prevVertex = vertex;
                                queue.offer(vertex);
                                const e = new org.dyn4j.geometry.decompose.SweepLineEdge(this.referenceY);
                                e.v0 = vertex;
                                const my = point.y - point1.y;
                                if (my === 0.0) {
                                    e.slope = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                                }
                                else {
                                    const mx = point.x - point1.x;
                                    e.slope = (mx / my);
                                }
                                if (prevEdge != null) {
                                    prevEdge.v1 = vertex;
                                }
                                if (rootEdge == null) {
                                    rootEdge = e;
                                }
                                vertex.left = e;
                                vertex.right = prevEdge;
                                prevEdge = e;
                            }
                            ;
                        }
                        prevEdge.v1 = rootEdge.v0;
                        rootVertex.right = prevEdge;
                        rootVertex.prev = prevVertex;
                        prevVertex.next = rootVertex;
                        return queue;
                    }
                    /**
                     * Returns the vertex type given the previous and next points.
                     * @param {org.dyn4j.geometry.Vector2} point0 the previous point
                     * @param {org.dyn4j.geometry.Vector2} point the vertex point
                     * @param {org.dyn4j.geometry.Vector2} point1 the next point
                     * @return {org.dyn4j.geometry.decompose.SweepLineVertexType} {@link SweepLineVertexType}
                     */
                    getType(point0, point, point1) {
                        const v1 = point0.to$org_dyn4j_geometry_Vector2(point);
                        const v2 = point.to$org_dyn4j_geometry_Vector2(point1);
                        if (v1.isZero() || v2.isZero())
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.decompose.coincident"));
                        const cross = v1.cross$org_dyn4j_geometry_Vector2(v2);
                        const pBelowP0 = this.isBelow(point, point0);
                        const pBelowP1 = this.isBelow(point, point1);
                        if (pBelowP0 && pBelowP1) {
                            if (cross > 0.0) {
                                return org.dyn4j.geometry.decompose.SweepLineVertexType.END;
                            }
                            else {
                                return org.dyn4j.geometry.decompose.SweepLineVertexType.MERGE;
                            }
                        }
                        else if (!pBelowP0 && !pBelowP1) {
                            if (cross > 0.0) {
                                return org.dyn4j.geometry.decompose.SweepLineVertexType.START;
                            }
                            else {
                                return org.dyn4j.geometry.decompose.SweepLineVertexType.SPLIT;
                            }
                        }
                        return org.dyn4j.geometry.decompose.SweepLineVertexType.REGULAR;
                    }
                    /**
                     * Returns true if the given point p is below the given point q.
                     * <p>
                     * If the point p and q form a horizontal line then p is considered
                     * below if its x coordinate is greater than q's x coordinate.
                     * @param {org.dyn4j.geometry.Vector2} p the point
                     * @param {org.dyn4j.geometry.Vector2} q another point
                     * @return {boolean} boolean true if p is below q; false if p is above q
                     */
                    isBelow(p, q) {
                        const diff = p.y - q.y;
                        if (diff === 0.0) {
                            if (p.x > q.x) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                        else {
                            if (diff < 0.0) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                    }
                }
                decompose.SweepLineState = SweepLineState;
                SweepLineState["__class"] = "org.dyn4j.geometry.decompose.SweepLineState";
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.geometry.Vector2[]} points the points of the simple polygon
                 * @class
                 * @author William Bittle
                 */
                class DoubleEdgeList {
                    constructor(points) {
                        if (this.vertices === undefined) {
                            this.vertices = null;
                        }
                        if (this.edges === undefined) {
                            this.edges = null;
                        }
                        if (this.faces === undefined) {
                            this.faces = null;
                        }
                        this.vertices = (new java.util.ArrayList());
                        this.edges = (new java.util.ArrayList());
                        this.faces = (new java.util.ArrayList());
                        this.initialize(points);
                    }
                    /**
                     * Initializes the DCEL class given the points of the polygon.
                     * @param {org.dyn4j.geometry.Vector2[]} points the points of the polygon
                     */
                    initialize(points) {
                        const size = points.length;
                        const face = new org.dyn4j.geometry.decompose.DoubleEdgeListFace();
                        this.faces.add(face);
                        let prevLeftEdge = null;
                        let prevRightEdge = null;
                        for (let i = 0; i < size; i++) {
                            {
                                const point = points[i];
                                const vertex = new org.dyn4j.geometry.decompose.DoubleEdgeListVertex(point);
                                const left = new org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge();
                                const right = new org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge();
                                left.face = face;
                                left.next = null;
                                left.origin = vertex;
                                left.twin = right;
                                right.face = null;
                                right.next = prevRightEdge;
                                right.origin = null;
                                right.twin = left;
                                this.edges.add(left);
                                this.edges.add(right);
                                vertex.leaving = left;
                                this.vertices.add(vertex);
                                if (prevLeftEdge != null) {
                                    prevLeftEdge.next = left;
                                }
                                if (prevRightEdge != null) {
                                    prevRightEdge.origin = vertex;
                                }
                                prevLeftEdge = left;
                                prevRightEdge = right;
                            }
                            ;
                        }
                        const firstLeftEdge = this.edges.get(0);
                        prevLeftEdge.next = firstLeftEdge;
                        const firstRightEdge = this.edges.get(1);
                        firstRightEdge.next = prevRightEdge;
                        prevRightEdge.origin = this.vertices.get(0);
                        face.edge = firstLeftEdge;
                    }
                    addHalfEdges$int$int(i, j) {
                        const vertex1 = this.vertices.get(i);
                        const vertex2 = this.vertices.get(j);
                        this.addHalfEdges$org_dyn4j_geometry_decompose_DoubleEdgeListVertex$org_dyn4j_geometry_decompose_DoubleEdgeListVertex(vertex1, vertex2);
                    }
                    addHalfEdges$org_dyn4j_geometry_decompose_DoubleEdgeListVertex$org_dyn4j_geometry_decompose_DoubleEdgeListVertex(v1, v2) {
                        const face = new org.dyn4j.geometry.decompose.DoubleEdgeListFace();
                        const left = new org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge();
                        const right = new org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge();
                        const referenceDoubleEdgeListFace = this.getReferenceFace(v1, v2);
                        const prev1 = this.getPreviousEdge(v1, referenceDoubleEdgeListFace);
                        const prev2 = this.getPreviousEdge(v2, referenceDoubleEdgeListFace);
                        if (org.dyn4j.geometry.Segment.getSegmentIntersection(prev1.origin.point, prev1.next.origin.point, prev2.origin.point, prev2.next.origin.point) != null) {
                            throw new java.lang.IllegalArgumentException("The input must be a simple polygon. Edges " + prev1.origin.point + " -> " + prev1.next.origin.point + " and " + prev2.origin.point + " -> " + prev2.next.origin.point + " cross each other.");
                        }
                        face.edge = left;
                        referenceDoubleEdgeListFace.edge = right;
                        left.face = face;
                        left.next = prev2.next;
                        left.origin = v1;
                        left.twin = right;
                        right.face = referenceDoubleEdgeListFace;
                        right.next = prev1.next;
                        right.origin = v2;
                        right.twin = left;
                        prev1.next = left;
                        prev2.next = right;
                        let curr = left.next;
                        while ((curr !== left)) {
                            {
                                curr.face = face;
                                curr = curr.next;
                            }
                        }
                        ;
                        this.edges.add(left);
                        this.edges.add(right);
                        this.faces.add(face);
                    }
                    /**
                     * Adds two half edges to this DCEL object given the vertices to connect.
                     * <p>
                     * This method assumes that no crossing edges will be added.
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListVertex} v1 the first vertex
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListVertex} v2 the second vertex
                     */
                    addHalfEdges(v1, v2) {
                        if (((v1 != null && v1 instanceof org.dyn4j.geometry.decompose.DoubleEdgeListVertex) || v1 === null) && ((v2 != null && v2 instanceof org.dyn4j.geometry.decompose.DoubleEdgeListVertex) || v2 === null)) {
                            return this.addHalfEdges$org_dyn4j_geometry_decompose_DoubleEdgeListVertex$org_dyn4j_geometry_decompose_DoubleEdgeListVertex(v1, v2);
                        }
                        else if (((typeof v1 === 'number') || v1 === null) && ((typeof v2 === 'number') || v2 === null)) {
                            return this.addHalfEdges$int$int(v1, v2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Walks around the given face and finds the previous edge
                     * for the given vertex.
                     * <p>
                     * This method assumes that the given vertex will be on the given face.
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListVertex} vertex the vertex to find the previous edge for
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListFace} face the face the edge should lie on
                     * @return {org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge} {@link DoubleEdgeListHalfEdge} the previous edge
                     */
                    getPreviousEdge(vertex, face) {
                        const twin = vertex.leaving.twin;
                        let edge = vertex.leaving.twin.next.twin;
                        while ((edge !== twin)) {
                            {
                                if (edge.face === face) {
                                    return edge;
                                }
                                edge = edge.next.twin;
                            }
                        }
                        ;
                        return edge;
                    }
                    /**
                     * Finds the face that both vertices are on.
                     * <p>
                     * If the given vertices are connected then the first common face is returned.
                     * <p>
                     * If the given vertices do not have a common face the first vertex's leaving
                     * edge's face is returned.
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListVertex} v1 the first vertex
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListVertex} v2 the second vertex
                     * @return {org.dyn4j.geometry.decompose.DoubleEdgeListFace} {@link DoubleEdgeListFace} the face on which both vertices lie
                     */
                    getReferenceFace(v1, v2) {
                        if (v1.leaving.face === v2.leaving.face)
                            return v1.leaving.face;
                        let e1 = v1.leaving.twin.next.twin;
                        while ((e1 !== v1.leaving.twin)) {
                            {
                                let e2 = v2.leaving.twin.next.twin;
                                while ((e2 !== v2.leaving.twin)) {
                                    {
                                        if (e1.face === e2.face)
                                            return e1.face;
                                        e2 = e2.next.twin;
                                    }
                                }
                                ;
                                e1 = e1.next.twin;
                            }
                        }
                        ;
                        return v1.leaving.face;
                    }
                    removeHalfEdges$int(index) {
                        const e = this.edges.get(index);
                        this.removeHalfEdges$int$org_dyn4j_geometry_decompose_DoubleEdgeListHalfEdge(index, e);
                    }
                    removeHalfEdges$org_dyn4j_geometry_decompose_DoubleEdgeListHalfEdge(edge) {
                        const index = this.edges.indexOf(edge);
                        this.removeHalfEdges$int$org_dyn4j_geometry_decompose_DoubleEdgeListHalfEdge(index, edge);
                    }
                    removeHalfEdges$int$org_dyn4j_geometry_decompose_DoubleEdgeListHalfEdge(index, edge) {
                        const face = edge.twin.face;
                        const ePrev = edge.getPrevious();
                        const tPrev = edge.twin.getPrevious();
                        const eNext = edge.next;
                        const tNext = edge.twin.next;
                        ePrev.next = tNext;
                        tPrev.next = eNext;
                        face.edge = eNext;
                        let te = eNext;
                        while ((te !== tNext)) {
                            {
                                te.face = face;
                                te = te.next;
                            }
                        }
                        ;
                        this.faces.remove(edge.face);
                        this.edges.remove(index);
                        this.edges.remove(index);
                    }
                    /**
                     * Removes the given half edge and its twin.
                     * @param {number} index the index of the given edge
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge} edge the half edge to remove
                     */
                    removeHalfEdges(index, edge) {
                        if (((typeof index === 'number') || index === null) && ((edge != null && edge instanceof org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge) || edge === null)) {
                            return this.removeHalfEdges$int$org_dyn4j_geometry_decompose_DoubleEdgeListHalfEdge(index, edge);
                        }
                        else if (((index != null && index instanceof org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge) || index === null) && edge === undefined) {
                            return this.removeHalfEdges$org_dyn4j_geometry_decompose_DoubleEdgeListHalfEdge(index);
                        }
                        else if (((typeof index === 'number') || index === null) && edge === undefined) {
                            return this.removeHalfEdges$int(index);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Returns the convex decomposition of this DCEL assuming that the remaining
                     * faces are all convex polygons.
                     * @return {*} List&lt;{@link Convex}&gt;
                     */
                    getConvexDecomposition() {
                        const convexes = (new java.util.ArrayList());
                        const fSize = this.faces.size();
                        for (let i = 0; i < fSize; i++) {
                            {
                                const face = this.faces.get(i);
                                const size = face.getEdgeCount();
                                let left = face.edge;
                                const vertices = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(size);
                                vertices[0] = left.origin.point;
                                left = left.next;
                                let j = 1;
                                while ((left !== face.edge)) {
                                    {
                                        vertices[j++] = left.origin.point;
                                        left = left.next;
                                    }
                                }
                                ;
                                if (vertices.length < 3) {
                                    throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.decompose.crossingEdges"));
                                }
                                const p = org.dyn4j.geometry.Geometry.createPolygon.apply(null, vertices);
                                convexes.add(p);
                            }
                            ;
                        }
                        return convexes;
                    }
                    /**
                     * Returns the triangulation of this DCEL assuming that the remaining
                     * faces are all triangles.
                     * @return {*} List&lt;{@link Triangle}&gt;
                     * @since 3.1.9
                     */
                    getTriangulation() {
                        const triangles = (new java.util.ArrayList());
                        const fSize = this.faces.size();
                        for (let i = 0; i < fSize; i++) {
                            {
                                const face = this.faces.get(i);
                                const size = face.getEdgeCount();
                                let left = face.edge;
                                const vertices = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(size);
                                vertices[0] = left.origin.point;
                                left = left.next;
                                let j = 1;
                                while ((left !== face.edge)) {
                                    {
                                        vertices[j++] = left.origin.point;
                                        left = left.next;
                                    }
                                }
                                ;
                                if (vertices.length !== 3) {
                                    throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.decompose.crossingEdges"));
                                }
                                const t = org.dyn4j.geometry.Geometry.createTriangle(vertices[0], vertices[1], vertices[2]);
                                triangles.add(t);
                            }
                            ;
                        }
                        return triangles;
                    }
                    /**
                     * Performs a triangulation of the DCEL assuming all faces are Monotone Y polygons.
                     */
                    triangulateYMonotonePolygons() {
                        const monotonePolygons = this.getYMonotonePolygons();
                        const size = monotonePolygons.size();
                        for (let i = 0; i < size; i++) {
                            {
                                this.triangulateYMonotonePolygon(monotonePolygons.get(i));
                            }
                            ;
                        }
                    }
                    /**
                     * Triangulates the given y-monotone polygon adding the new diagonals to this DCEL.
                     * @param {org.dyn4j.geometry.decompose.MonotonePolygon} monotonePolygon the monotone polygon (x or y) to triangulate
                     */
                    triangulateYMonotonePolygon(monotonePolygon) {
                        const stack = (new java.util.ArrayList());
                        const vertices = monotonePolygon.vertices;
                        stack.add(vertices.get(0));
                        stack.add(vertices.get(1));
                        let i = 2;
                        while ((!stack.isEmpty())) {
                            {
                                const v = vertices.get(i);
                                const vBot = stack.get(0);
                                const vTop = stack.get(stack.size() - 1);
                                if (v.isAdjacent(vBot) && !v.isAdjacent(vTop)) {
                                    while ((stack.size() > 1)) {
                                        {
                                            const vt = stack.remove(stack.size() - 1);
                                            this.addHalfEdges$org_dyn4j_geometry_decompose_DoubleEdgeListVertex$org_dyn4j_geometry_decompose_DoubleEdgeListVertex(v.data, vt.data);
                                        }
                                    }
                                    ;
                                    stack.clear();
                                    stack.add(vTop);
                                    stack.add(v);
                                }
                                else if (v.isAdjacent(vTop) && !v.isAdjacent(vBot)) {
                                    let cross = 0;
                                    let sSize = stack.size();
                                    while ((sSize > 1)) {
                                        {
                                            const vt = stack.get(sSize - 1);
                                            const vt1 = stack.get(sSize - 2);
                                            const p1 = v.data.point;
                                            const p2 = vt.data.point;
                                            const p3 = vt1.data.point;
                                            if (v.chainType === org.dyn4j.geometry.decompose.MonotoneChainType.LEFT || v.chainType === org.dyn4j.geometry.decompose.MonotoneChainType.BOTTOM) {
                                                const v1 = p2.to$org_dyn4j_geometry_Vector2(p3);
                                                const v2 = p2.to$org_dyn4j_geometry_Vector2(p1);
                                                cross = v1.cross$org_dyn4j_geometry_Vector2(v2);
                                            }
                                            else {
                                                const v1 = p1.to$org_dyn4j_geometry_Vector2(p2);
                                                const v2 = p3.to$org_dyn4j_geometry_Vector2(p2);
                                                cross = v1.cross$org_dyn4j_geometry_Vector2(v2);
                                            }
                                            if (cross < -org.dyn4j.Epsilon.E_$LI$()) {
                                                this.addHalfEdges$org_dyn4j_geometry_decompose_DoubleEdgeListVertex$org_dyn4j_geometry_decompose_DoubleEdgeListVertex(v.data, vt1.data);
                                                stack.remove(sSize - 1);
                                                sSize--;
                                            }
                                            else {
                                                break;
                                            }
                                        }
                                    }
                                    ;
                                    stack.add(v);
                                }
                                else if (v.isAdjacent(vTop) && v.isAdjacent(vBot)) {
                                    stack.remove(stack.size() - 1);
                                    while ((stack.size() > 1)) {
                                        {
                                            const vt = stack.remove(stack.size() - 1);
                                            this.addHalfEdges$org_dyn4j_geometry_decompose_DoubleEdgeListVertex$org_dyn4j_geometry_decompose_DoubleEdgeListVertex(v.data, vt.data);
                                        }
                                    }
                                    ;
                                    break;
                                }
                                i++;
                            }
                        }
                        ;
                    }
                    /**
                     * Returns a list of y-monotone polygons from the faces of this DCEL.
                     * <p>
                     * This method assumes that all faces within this DCEL are y-monotone and does not
                     * perform any verification of this assumption.
                     * @return {*} List&lt;{@link MonotonePolygon}&gt;
                     */
                    getYMonotonePolygons() {
                        const fSize = this.faces.size();
                        const yMonotonePolygons = (new java.util.ArrayList(fSize));
                        for (let i = 0; i < fSize; i++) {
                            {
                                const face = this.faces.get(i);
                                const size = face.getEdgeCount();
                                let left = face.edge;
                                const root = (new org.dyn4j.geometry.decompose.MonotoneVertex(left.origin));
                                left = left.next;
                                let prev = root;
                                let curr = null;
                                let max = root;
                                while ((left !== face.edge)) {
                                    {
                                        curr = (new org.dyn4j.geometry.decompose.MonotoneVertex(left.origin));
                                        curr.previous = prev;
                                        prev.next = curr;
                                        const p = curr.data.point;
                                        const q = max.data.point;
                                        let diff = p.y - q.y;
                                        if (diff === 0.0) {
                                            diff = p.x - q.x;
                                            if (diff < 0) {
                                                max = curr;
                                            }
                                        }
                                        else if (diff > 0.0) {
                                            max = curr;
                                        }
                                        left = left.next;
                                        prev = curr;
                                    }
                                }
                                ;
                                root.previous = curr;
                                curr.next = root;
                                const sorted = (new java.util.ArrayList(size));
                                sorted.add(max);
                                max.chainType = org.dyn4j.geometry.decompose.MonotoneChainType.LEFT;
                                let currLeft = max.next;
                                let currRight = max.previous;
                                let j = 1;
                                while ((j < size)) {
                                    {
                                        const l = currLeft.data.point;
                                        const r = currRight.data.point;
                                        let diff = l.y - r.y;
                                        if (diff === 0) {
                                            diff = r.x - l.x;
                                        }
                                        if (diff > 0) {
                                            sorted.add(currLeft);
                                            currLeft.chainType = org.dyn4j.geometry.decompose.MonotoneChainType.LEFT;
                                            currLeft = currLeft.next;
                                        }
                                        else {
                                            sorted.add(currRight);
                                            currRight.chainType = org.dyn4j.geometry.decompose.MonotoneChainType.RIGHT;
                                            currRight = currRight.previous;
                                        }
                                        j++;
                                    }
                                }
                                ;
                                sorted.get(size - 1).chainType = org.dyn4j.geometry.decompose.MonotoneChainType.RIGHT;
                                yMonotonePolygons.add((new org.dyn4j.geometry.decompose.MonotonePolygon(org.dyn4j.geometry.decompose.MonotonePolygonType.Y, sorted)));
                            }
                            ;
                        }
                        return yMonotonePolygons;
                    }
                    /**
                     * Performs the Hertel-Mehlhorn algorithm on the given DCEL assuming that
                     * it is a valid triangulation.
                     * <p>
                     * This method will remove unnecessary diagonals and remove faces that get merged
                     * leaving a convex decomposition.
                     * <p>
                     * This method is guaranteed to produce a convex decomposition with no more than
                     * 4 times the minimum number of convex pieces.
                     */
                    hertelMehlhorn() {
                        const vSize = this.vertices.size();
                        let i = vSize * 2;
                        while ((i < this.edges.size())) {
                            {
                                const e = this.edges.get(i);
                                let v1 = e.origin;
                                let v0 = e.getPrevious().origin;
                                let v2 = e.twin.next.next.origin;
                                if (this.isReflex(v0, v1, v2)) {
                                    i += 2;
                                    continue;
                                }
                                v1 = e.twin.origin;
                                v0 = e.twin.getPrevious().origin;
                                v2 = e.next.next.origin;
                                if (this.isReflex(v0, v1, v2)) {
                                    i += 2;
                                    continue;
                                }
                                this.removeHalfEdges$int$org_dyn4j_geometry_decompose_DoubleEdgeListHalfEdge(i, e);
                            }
                        }
                        ;
                    }
                    /**
                     * Returns true if the given vertices create a reflex vertex.
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListVertex} v0 the previous vertex
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListVertex} v1 the vertex
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListVertex} v2 the next vertex
                     * @return {boolean} boolean
                     */
                    isReflex(v0, v1, v2) {
                        const p0 = v0.point;
                        const p1 = v1.point;
                        const p2 = v2.point;
                        const e1 = p0.to$org_dyn4j_geometry_Vector2(p1);
                        const e2 = p1.to$org_dyn4j_geometry_Vector2(p2);
                        const cross = e1.cross$org_dyn4j_geometry_Vector2(e2);
                        if (cross < 0)
                            return true;
                        return false;
                    }
                }
                decompose.DoubleEdgeList = DoubleEdgeList;
                DoubleEdgeList["__class"] = "org.dyn4j.geometry.decompose.DoubleEdgeList";
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Enumeration of the types of monotone polygons supported.
                 * <p>
                 * The type of monotone polygon is the axis in which the polygon
                 * is monotone with respect to.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 2.2.0
                 * @enum
                 * @property {org.dyn4j.geometry.decompose.MonotonePolygonType} Y
                 * Represents a y-monotone polygon
                 * @property {org.dyn4j.geometry.decompose.MonotonePolygonType} X
                 * Represents a x-monotone polygon
                 * @class
                 */
                let MonotonePolygonType;
                (function (MonotonePolygonType) {
                    /**
                     * Represents a y-monotone polygon
                     */
                    MonotonePolygonType[MonotonePolygonType["Y"] = 0] = "Y";
                    /**
                     * Represents a x-monotone polygon
                     */
                    MonotonePolygonType[MonotonePolygonType["X"] = 1] = "X";
                })(MonotonePolygonType = decompose.MonotonePolygonType || (decompose.MonotonePolygonType = {}));
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Enumeration of monotone chain types.
                 * <p>
                 * A monotone chain is a group of vertices that are monotone with respect to
                 * some axis.  Typically x or y monotone chains are created.
                 * <p>
                 * A monotone polygon will always contain two monotone chains.  For a y-monotone
                 * polygon, a {@link MonotoneChainType#LEFT} and {@link MonotoneChainType#RIGHT}.  For
                 * a x-monotone polygon, a {@link MonotoneChainType#TOP} and {@link MonotoneChainType#BOTTOM}.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 3.2.0
                 * @enum
                 * @property {org.dyn4j.geometry.decompose.MonotoneChainType} LEFT
                 * Indicates that the vertex is on the left chain of a y-monotone polygon
                 * @property {org.dyn4j.geometry.decompose.MonotoneChainType} RIGHT
                 * Indicates that the vertex is on the right chain of a y-monotone polygon
                 * @property {org.dyn4j.geometry.decompose.MonotoneChainType} TOP
                 * Indicates that the vertex is on the top chain of a x-monotone polygon
                 * @property {org.dyn4j.geometry.decompose.MonotoneChainType} BOTTOM
                 * Indicates that the vertex is on the bottom chain of a x-monotone polygon
                 * @class
                 */
                let MonotoneChainType;
                (function (MonotoneChainType) {
                    /**
                     * Indicates that the vertex is on the left chain of a y-monotone polygon
                     */
                    MonotoneChainType[MonotoneChainType["LEFT"] = 0] = "LEFT";
                    /**
                     * Indicates that the vertex is on the right chain of a y-monotone polygon
                     */
                    MonotoneChainType[MonotoneChainType["RIGHT"] = 1] = "RIGHT";
                    /**
                     * Indicates that the vertex is on the top chain of a x-monotone polygon
                     */
                    MonotoneChainType[MonotoneChainType["TOP"] = 2] = "TOP";
                    /**
                     * Indicates that the vertex is on the bottom chain of a x-monotone polygon
                     */
                    MonotoneChainType[MonotoneChainType["BOTTOM"] = 3] = "BOTTOM";
                })(MonotoneChainType = decompose.MonotoneChainType || (decompose.MonotoneChainType = {}));
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Represents a face in the {@link DoubleEdgeList}.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 2.2.0
                 * @class
                 */
                class DoubleEdgeListFace {
                    constructor() {
                        if (this.edge === undefined) {
                            this.edge = null;
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("Face[Edge=").append(this.edge).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the number of edges on this face.
                     * @return {number} int
                     */
                    getEdgeCount() {
                        let edge = this.edge;
                        let count = 0;
                        if (edge != null) {
                            count++;
                            while ((edge.next !== this.edge)) {
                                {
                                    count++;
                                    edge = edge.next;
                                }
                            }
                            ;
                        }
                        return count;
                    }
                }
                decompose.DoubleEdgeListFace = DoubleEdgeListFace;
                DoubleEdgeListFace["__class"] = "org.dyn4j.geometry.decompose.DoubleEdgeListFace";
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Implementation of the Bayazit convex decomposition algorithm for simple polygons.
                 * <p>
                 * This algorithm is a O(nr) complexity algorithm where n is the number of input vertices and r is the number of
                 * output convex polygons.  This algorithm can achieve optimal decompositions, however this is not guaranteed.
                 * @author William Bittle
                 * @version 3.1.10
                 * @since 2.2.0
                 * @see <a href="http://mnbayazit.com/406/bayazit" target="_blank">Bayazit</a>
                 * @class
                 */
                class Bayazit {
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2[]} points
                     * @return {*}
                     */
                    decompose(...points) {
                        if (points == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.decompose.nullArray"));
                        const size = points.length;
                        if (size < 4)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.decompose.invalidSize"));
                        const winding = org.dyn4j.geometry.Geometry.getWinding$org_dyn4j_geometry_Vector2_A.apply(null, points);
                        if (winding < 0.0) {
                            org.dyn4j.geometry.Geometry.reverseWinding$org_dyn4j_geometry_Vector2_A.apply(null, points);
                        }
                        const polygon = (new java.util.ArrayList());
                        java.util.Collections.addAll(polygon, ...points);
                        const polygons = (new java.util.ArrayList());
                        this.decomposePolygon(polygon, polygons);
                        return polygons;
                    }
                    /**
                     * Internal recursive method to decompose the given polygon into convex sub-polygons.
                     * @param {*} polygon the polygon to decompose
                     * @param {*} polygons the list to store the convex polygons resulting from the decomposition
                     */
                    decomposePolygon(polygon, polygons) {
                        const size = polygon.size();
                        const upperIntersection = new org.dyn4j.geometry.Vector2();
                        const lowerIntersection = new org.dyn4j.geometry.Vector2();
                        let upperDistance = javaemul.internal.DoubleHelper.MAX_VALUE;
                        let lowerDistance = javaemul.internal.DoubleHelper.MAX_VALUE;
                        let closestDistance = javaemul.internal.DoubleHelper.MAX_VALUE;
                        let upperIndex = 0;
                        let lowerIndex = 0;
                        let closestIndex = 0;
                        const lower = (new java.util.ArrayList());
                        const upper = (new java.util.ArrayList());
                        for (let i = 0; i < size; i++) {
                            {
                                const p = polygon.get(i);
                                const p0 = polygon.get(i - 1 < 0 ? size - 1 : i - 1);
                                const p1 = polygon.get(i + 1 === size ? 0 : i + 1);
                                if (this.isReflex(p0, p, p1)) {
                                    for (let j = 0; j < size; j++) {
                                        {
                                            const q = polygon.get(j);
                                            const q0 = polygon.get(j - 1 < 0 ? size - 1 : j - 1);
                                            const q1 = polygon.get(j + 1 === size ? 0 : j + 1);
                                            const s = new org.dyn4j.geometry.Vector2();
                                            if (this.left(p0, p, q) && this.rightOn(p0, p, q0)) {
                                                if (this.getIntersection(p0, p, q, q0, s)) {
                                                    if (this.right(p1, p, s)) {
                                                        const dist = p.distanceSquared$org_dyn4j_geometry_Vector2(s);
                                                        if (dist < lowerDistance) {
                                                            lowerDistance = dist;
                                                            lowerIntersection.set$org_dyn4j_geometry_Vector2(s);
                                                            lowerIndex = j;
                                                        }
                                                    }
                                                }
                                            }
                                            if (this.left(p1, p, q1) && this.rightOn(p1, p, q)) {
                                                if (this.getIntersection(p1, p, q, q1, s)) {
                                                    if (this.left(p0, p, s)) {
                                                        const dist = p.distanceSquared$org_dyn4j_geometry_Vector2(s);
                                                        if (dist < upperDistance) {
                                                            upperDistance = dist;
                                                            upperIntersection.set$org_dyn4j_geometry_Vector2(s);
                                                            upperIndex = j;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        ;
                                    }
                                    if (lowerIndex === (upperIndex + 1) % size) {
                                        const s = upperIntersection.sum$org_dyn4j_geometry_Vector2(lowerIntersection).multiply(0.5);
                                        if (i < upperIndex) {
                                            lower.addAll(polygon.subList(i, upperIndex + 1));
                                            lower.add(s);
                                            upper.add(s);
                                            if (lowerIndex !== 0)
                                                upper.addAll(polygon.subList(lowerIndex, size));
                                            upper.addAll(polygon.subList(0, i + 1));
                                        }
                                        else {
                                            if (i !== 0)
                                                lower.addAll(polygon.subList(i, size));
                                            lower.addAll(polygon.subList(0, upperIndex + 1));
                                            lower.add(s);
                                            upper.add(s);
                                            upper.addAll(polygon.subList(lowerIndex, i + 1));
                                        }
                                    }
                                    else {
                                        if (lowerIndex > upperIndex) {
                                            upperIndex += size;
                                        }
                                        closestIndex = lowerIndex;
                                        for (let j = lowerIndex; j <= upperIndex; j++) {
                                            {
                                                const jmod = j % size;
                                                const q = polygon.get(jmod);
                                                if (q === p || q === p0 || q === p1)
                                                    continue;
                                                const dist = p.distanceSquared$org_dyn4j_geometry_Vector2(q);
                                                if (dist < closestDistance) {
                                                    if (this.isVisible(polygon, i, jmod)) {
                                                        closestDistance = dist;
                                                        closestIndex = jmod;
                                                    }
                                                }
                                            }
                                            ;
                                        }
                                        if (i < closestIndex) {
                                            lower.addAll(polygon.subList(i, closestIndex + 1));
                                            if (closestIndex !== 0)
                                                upper.addAll(polygon.subList(closestIndex, size));
                                            upper.addAll(polygon.subList(0, i + 1));
                                        }
                                        else {
                                            if (i !== 0)
                                                lower.addAll(polygon.subList(i, size));
                                            lower.addAll(polygon.subList(0, closestIndex + 1));
                                            upper.addAll(polygon.subList(closestIndex, i + 1));
                                        }
                                    }
                                    if (lower.size() < upper.size()) {
                                        this.decomposePolygon(lower, polygons);
                                        this.decomposePolygon(upper, polygons);
                                    }
                                    else {
                                        this.decomposePolygon(upper, polygons);
                                        this.decomposePolygon(lower, polygons);
                                    }
                                    return;
                                }
                            }
                            ;
                        }
                        if (polygon.size() < 3) {
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.decompose.crossingEdges"));
                        }
                        const vertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(polygon.size());
                        polygon.toArray(vertices);
                        polygons.add(org.dyn4j.geometry.Geometry.createPolygon.apply(null, vertices));
                    }
                    /**
                     * Returns true if the given vertex, b, is a reflex vertex.
                     * <p>
                     * A reflex vertex is a vertex who's interior angle is greater
                     * than 180 degrees.
                     * @param {org.dyn4j.geometry.Vector2} p0 the vertex to test
                     * @param {org.dyn4j.geometry.Vector2} p the previous vertex
                     * @param {org.dyn4j.geometry.Vector2} p1 the next vertex
                     * @return {boolean} boolean
                     */
                    isReflex(p0, p, p1) {
                        return this.right(p1, p0, p);
                    }
                    /**
                     * Returns true if the given point p is to the left
                     * of the line created by a-b.
                     * @param {org.dyn4j.geometry.Vector2} a the first point of the line
                     * @param {org.dyn4j.geometry.Vector2} b the second point of the line
                     * @param {org.dyn4j.geometry.Vector2} p the point to test
                     * @return {boolean} boolean
                     */
                    left(a, b, p) {
                        return org.dyn4j.geometry.Segment.getLocation(p, a, b) > 0;
                    }
                    /**
                     * Returns true if the given point p is to the left
                     * or on the line created by a-b.
                     * @param {org.dyn4j.geometry.Vector2} a the first point of the line
                     * @param {org.dyn4j.geometry.Vector2} b the second point of the line
                     * @param {org.dyn4j.geometry.Vector2} p the point to test
                     * @return {boolean} boolean
                     */
                    leftOn(a, b, p) {
                        return org.dyn4j.geometry.Segment.getLocation(p, a, b) >= 0;
                    }
                    /**
                     * Returns true if the given point p is to the right
                     * of the line created by a-b.
                     * @param {org.dyn4j.geometry.Vector2} a the first point of the line
                     * @param {org.dyn4j.geometry.Vector2} b the second point of the line
                     * @param {org.dyn4j.geometry.Vector2} p the point to test
                     * @return {boolean} boolean
                     */
                    right(a, b, p) {
                        return org.dyn4j.geometry.Segment.getLocation(p, a, b) < 0;
                    }
                    /**
                     * Returns true if the given point p is to the right
                     * or on the line created by a-b.
                     * @param {org.dyn4j.geometry.Vector2} a the first point of the line
                     * @param {org.dyn4j.geometry.Vector2} b the second point of the line
                     * @param {org.dyn4j.geometry.Vector2} p the point to test
                     * @return {boolean} boolean
                     */
                    rightOn(a, b, p) {
                        return org.dyn4j.geometry.Segment.getLocation(p, a, b) <= 0;
                    }
                    /**
                     * Returns true if the given lines intersect and returns the intersection point in
                     * the p parameter.
                     * @param {org.dyn4j.geometry.Vector2} a1 the first point of the first line
                     * @param {org.dyn4j.geometry.Vector2} a2 the second point of the first line
                     * @param {org.dyn4j.geometry.Vector2} b1 the first point of the second line
                     * @param {org.dyn4j.geometry.Vector2} b2 the second point of the second line
                     * @param {org.dyn4j.geometry.Vector2} p the destination object for the intersection point
                     * @return {boolean} boolean
                     */
                    getIntersection(a1, a2, b1, b2, p) {
                        const s1 = a1.difference$org_dyn4j_geometry_Vector2(a2);
                        const s2 = b1.difference$org_dyn4j_geometry_Vector2(b2);
                        let det = s1.cross$org_dyn4j_geometry_Vector2(s2);
                        if (Math.abs(det) <= org.dyn4j.Epsilon.E_$LI$()) {
                            return false;
                        }
                        else {
                            det = 1.0 / det;
                            const t2 = det * (a1.cross$org_dyn4j_geometry_Vector2(s1) - b1.cross$org_dyn4j_geometry_Vector2(s1));
                            p.x = b1.x * (1.0 - t2) + b2.x * t2;
                            p.y = b1.y * (1.0 - t2) + b2.y * t2;
                            return true;
                        }
                    }
                    /**
                     * Returns true if the vertex at index i can see the vertex at index j.
                     * @param {*} polygon the current polygon
                     * @param {number} i the ith vertex
                     * @param {number} j the jth vertex
                     * @return {boolean} boolean
                     * @since 3.1.10
                     * @private
                     */
                    /*private*/ isVisible(polygon, i, j) {
                        const s = polygon.size();
                        let iv0;
                        let iv;
                        let iv1;
                        let jv0;
                        let jv;
                        let jv1;
                        iv0 = polygon.get(i === 0 ? s - 1 : i - 1);
                        iv = polygon.get(i);
                        iv1 = polygon.get(i + 1 === s ? 0 : i + 1);
                        jv0 = polygon.get(j === 0 ? s - 1 : j - 1);
                        jv = polygon.get(j);
                        jv1 = polygon.get(j + 1 === s ? 0 : j + 1);
                        if (this.isReflex(iv0, iv, iv1)) {
                            if (this.leftOn(iv, iv0, jv) && this.rightOn(iv, iv1, jv))
                                return false;
                        }
                        else {
                            if (this.rightOn(iv, iv1, jv) || this.leftOn(iv, iv0, jv))
                                return false;
                        }
                        if (this.isReflex(jv0, jv, jv1)) {
                            if (this.leftOn(jv, jv0, iv) && this.rightOn(jv, jv1, iv))
                                return false;
                        }
                        else {
                            if (this.rightOn(jv, jv1, iv) || this.leftOn(jv, jv0, iv))
                                return false;
                        }
                        for (let k = 0; k < s; k++) {
                            {
                                const ki1 = k + 1 === s ? 0 : k + 1;
                                if (k === i || k === j || ki1 === i || ki1 === j)
                                    continue;
                                const k1 = polygon.get(k);
                                const k2 = polygon.get(ki1);
                                const into = org.dyn4j.geometry.Segment.getSegmentIntersection(iv, jv, k1, k2);
                                if (into != null)
                                    return false;
                            }
                            ;
                        }
                        return true;
                    }
                    constructor() {
                    }
                }
                decompose.Bayazit = Bayazit;
                Bayazit["__class"] = "org.dyn4j.geometry.decompose.Bayazit";
                Bayazit["__interfaces"] = ["org.dyn4j.geometry.decompose.Decomposer"];
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.geometry.Vector2} point the vertex point
                 * @class
                 * @author William Bittle
                 */
                class DoubleEdgeListVertex {
                    constructor(point) {
                        if (this.point === undefined) {
                            this.point = null;
                        }
                        if (this.leaving === undefined) {
                            this.leaving = null;
                        }
                        this.point = point;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return this.point.toString();
                    }
                    /**
                     * Returns the edge from this node to the given node.
                     * @param {org.dyn4j.geometry.decompose.DoubleEdgeListVertex} node the node to find an edge to
                     * @return {org.dyn4j.geometry.decompose.DoubleEdgeListHalfEdge} {@link DoubleEdgeListHalfEdge}
                     */
                    getEdgeTo(node) {
                        if (this.leaving != null) {
                            if (this.leaving.twin.origin === node) {
                                return this.leaving;
                            }
                            else {
                                let edge = this.leaving.twin.next;
                                while ((edge !== this.leaving)) {
                                    {
                                        if (edge.twin.origin === node) {
                                            return edge;
                                        }
                                        else {
                                            edge = edge.twin.next;
                                        }
                                    }
                                }
                                ;
                            }
                        }
                        return null;
                    }
                }
                decompose.DoubleEdgeListVertex = DoubleEdgeListVertex;
                DoubleEdgeListVertex["__class"] = "org.dyn4j.geometry.decompose.DoubleEdgeListVertex";
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.geometry.Vector2} point the point for the vertex
                 * @class
                 * @author William Bittle
                 */
                class EarClippingVertex {
                    constructor(point) {
                        if (this.point === undefined) {
                            this.point = null;
                        }
                        if (this.prev === undefined) {
                            this.prev = null;
                        }
                        if (this.next === undefined) {
                            this.next = null;
                        }
                        if (this.ear === undefined) {
                            this.ear = false;
                        }
                        if (this.reflex === undefined) {
                            this.reflex = false;
                        }
                        if (this.index === undefined) {
                            this.index = 0;
                        }
                        this.point = point;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return this.point.toString();
                    }
                }
                decompose.EarClippingVertex = EarClippingVertex;
                EarClippingVertex["__class"] = "org.dyn4j.geometry.decompose.EarClippingVertex";
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.Reference} referenceY the current sweep position
                 * @class
                 * @author William Bittle
                 */
                class SweepLineEdge {
                    constructor(referenceY) {
                        if (this.referenceY === undefined) {
                            this.referenceY = null;
                        }
                        if (this.v0 === undefined) {
                            this.v0 = null;
                        }
                        if (this.v1 === undefined) {
                            this.v1 = null;
                        }
                        if (this.helper === undefined) {
                            this.helper = null;
                        }
                        if (this.slope === undefined) {
                            this.slope = 0;
                        }
                        this.referenceY = referenceY;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append(this.v0).append(" to ").append(this.v1);
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.decompose.SweepLineEdge} o
                     * @return {number}
                     */
                    compareTo(o) {
                        if (this === o)
                            return 0;
                        const y = this.referenceY.value;
                        const x1 = this.getSortValue(y);
                        const x2 = o.getSortValue(y);
                        if (x1 < x2) {
                            return -1;
                        }
                        else {
                            return 1;
                        }
                    }
                    /**
                     * Returns the intersection point of the given y value (horizontal
                     * sweep line) with this edge.
                     * <p>
                     * Returns the x value of the corresponding intersection point.
                     * @param {number} y the horizontal line y value
                     * @return {number} double
                     */
                    getSortValue(y) {
                        let min = this.v0.point;
                        if (this.v1.point.x < this.v0.point.x) {
                            min = this.v1.point;
                        }
                        if (this.slope === javaemul.internal.DoubleHelper.POSITIVE_INFINITY) {
                            return min.x;
                        }
                        else {
                            return min.x + (y - min.y) * this.slope;
                        }
                    }
                    /**
                     * Returns true if the interior of the polygon is
                     * to the right of this edge.
                     * <p>
                     * Given that the polygon's vertex winding is Counter-
                     * Clockwise, if the vertices that make this edge
                     * decrease along the y axis then the interior of the
                     * polygon is to the right, otherwise its to the
                     * left.
                     * @return {boolean} boolean
                     */
                    isInteriorRight() {
                        const diff = this.v0.point.y - this.v1.point.y;
                        if (diff === 0.0) {
                            if (this.v0.point.x < this.v1.point.x) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                        else if (diff > 0.0) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                decompose.SweepLineEdge = SweepLineEdge;
                SweepLineEdge["__class"] = "org.dyn4j.geometry.decompose.SweepLineEdge";
                SweepLineEdge["__interfaces"] = ["java.lang.Comparable"];
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Implementation of the Sweep convex decomposition algorithm for simple polygons.
                 * <p>
                 * This algorithm first decomposes the polygon into y-monotone polygons, then decomposes the y-monotone
                 * polygons into triangles, finally using the Hertel-Mehlhorn algorithm to recombine the triangles
                 * into convex pieces.
                 * <p>
                 * This algorithm is O(n log n) complexity in the y-monotone decomposition phase and O(n) in the
                 * triangulation phase yielding a total complexity of O(n log n).
                 * <p>
                 * After triangulation, the Hertel-Mehlhorn algorithm is used to reduce the number of convex
                 * pieces.  This is performed in O(n) time.
                 * <p>
                 * This algorithm total complexity is O(n log n).
                 * @author William Bittle
                 * @version 3.4.0
                 * @since 2.2.0
                 * @class
                 */
                class SweepLine {
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2[]} points
                     * @return {*}
                     */
                    decompose(...points) {
                        const dcel = this.createTriangulation.apply(this, points);
                        dcel.hertelMehlhorn();
                        return dcel.getConvexDecomposition();
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2[]} points
                     * @return {*}
                     */
                    triangulate(...points) {
                        const dcel = this.createTriangulation.apply(this, points);
                        return dcel.getTriangulation();
                    }
                    /**
                     * Creates a triangulation of the given simple polygon and places it in the
                     * returned doubly-connected edge list (DCEL).
                     * @param {org.dyn4j.geometry.Vector2[]} points the vertices of the simple polygon to triangulate
                     * @return {org.dyn4j.geometry.decompose.DoubleEdgeList} {@link DoubleEdgeList}
                     * @since 3.1.9
                     */
                    createTriangulation(...points) {
                        if (points == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.decompose.nullArray"));
                        const size = points.length;
                        if (size < 4)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.decompose.invalidSize"));
                        const winding = org.dyn4j.geometry.Geometry.getWinding$org_dyn4j_geometry_Vector2_A.apply(null, points);
                        if (winding < 0.0) {
                            org.dyn4j.geometry.Geometry.reverseWinding$org_dyn4j_geometry_Vector2_A.apply(null, points);
                        }
                        const sweepstate = new org.dyn4j.geometry.decompose.SweepLineState();
                        const queue = sweepstate.initialize(points);
                        while ((!queue.isEmpty())) {
                            {
                                const vertex = queue.poll();
                                if (vertex.type === org.dyn4j.geometry.decompose.SweepLineVertexType.START) {
                                    this.start(vertex, sweepstate);
                                }
                                else if (vertex.type === org.dyn4j.geometry.decompose.SweepLineVertexType.END) {
                                    this.end(vertex, sweepstate);
                                }
                                else if (vertex.type === org.dyn4j.geometry.decompose.SweepLineVertexType.SPLIT) {
                                    this.split(vertex, sweepstate);
                                }
                                else if (vertex.type === org.dyn4j.geometry.decompose.SweepLineVertexType.MERGE) {
                                    this.merge(vertex, sweepstate);
                                }
                                else if (vertex.type === org.dyn4j.geometry.decompose.SweepLineVertexType.REGULAR) {
                                    this.regular(vertex, sweepstate);
                                }
                            }
                        }
                        ;
                        sweepstate.dcel.triangulateYMonotonePolygons();
                        return sweepstate.dcel;
                    }
                    /**
                     * Handles a {@link SweepLineVertexType#START} event.
                     * @param {org.dyn4j.geometry.decompose.SweepLineVertex} vertex the vertex
                     * @param {org.dyn4j.geometry.decompose.SweepLineState} sweepstate the current state of the SweepLine algorithm
                     */
                    start(vertex, sweepstate) {
                        const leftEdge = vertex.left;
                        sweepstate.referenceY.value = vertex.point.y;
                        sweepstate.tree.insert(leftEdge);
                        leftEdge.helper = vertex;
                    }
                    /**
                     * Handles a {@link SweepLineVertexType#END} event.
                     * @param {org.dyn4j.geometry.decompose.SweepLineVertex} vertex the vertex
                     * @param {org.dyn4j.geometry.decompose.SweepLineState} sweepstate the current state of the SweepLine algorithm
                     */
                    end(vertex, sweepstate) {
                        const rightEdge = vertex.right;
                        if (rightEdge.helper.type === org.dyn4j.geometry.decompose.SweepLineVertexType.MERGE) {
                            sweepstate.dcel.addHalfEdges$int$int(vertex.index, rightEdge.helper.index);
                        }
                        sweepstate.referenceY.value = vertex.point.y;
                        sweepstate.tree.remove(rightEdge);
                    }
                    /**
                     * Handles a {@link SweepLineVertexType#SPLIT} event.
                     * @param {org.dyn4j.geometry.decompose.SweepLineVertex} vertex the vertex
                     * @param {org.dyn4j.geometry.decompose.SweepLineState} sweepstate the current state of the SweepLine algorithm
                     */
                    split(vertex, sweepstate) {
                        const ej = sweepstate.tree.search(new org.dyn4j.geometry.decompose.ClosestEdgeToVertexSearchCriteria(vertex)).closest;
                        if (ej == null)
                            throw new java.lang.IllegalArgumentException("The input must be a simple polygon");
                        sweepstate.dcel.addHalfEdges$int$int(vertex.index, ej.helper.index);
                        ej.helper = vertex;
                        sweepstate.referenceY.value = vertex.point.y;
                        sweepstate.tree.insert(vertex.left);
                        vertex.left.helper = vertex;
                    }
                    /**
                     * Handles a {@link SweepLineVertexType#MERGE} event.
                     * @param {org.dyn4j.geometry.decompose.SweepLineVertex} vertex the vertex
                     * @param {org.dyn4j.geometry.decompose.SweepLineState} sweepstate the current state of the SweepLine algorithm
                     */
                    merge(vertex, sweepstate) {
                        const eiPrev = vertex.right;
                        if (eiPrev.helper.type === org.dyn4j.geometry.decompose.SweepLineVertexType.MERGE) {
                            sweepstate.dcel.addHalfEdges$int$int(vertex.index, eiPrev.helper.index);
                        }
                        sweepstate.referenceY.value = vertex.point.y;
                        sweepstate.tree.remove(eiPrev);
                        const ej = sweepstate.tree.search(new org.dyn4j.geometry.decompose.ClosestEdgeToVertexSearchCriteria(vertex)).closest;
                        if (ej == null)
                            throw new java.lang.IllegalArgumentException("The input must be a simple polygon");
                        if (ej.helper.type === org.dyn4j.geometry.decompose.SweepLineVertexType.MERGE) {
                            sweepstate.dcel.addHalfEdges$int$int(vertex.index, ej.helper.index);
                        }
                        ej.helper = vertex;
                    }
                    /**
                     * Handles a {@link SweepLineVertexType#MERGE} event.
                     * @param {org.dyn4j.geometry.decompose.SweepLineVertex} vertex the vertex
                     * @param {org.dyn4j.geometry.decompose.SweepLineState} sweepstate the current state of the SweepLine algorithm
                     */
                    regular(vertex, sweepstate) {
                        if (vertex.isInteriorRight()) {
                            if (vertex.right.helper.type === org.dyn4j.geometry.decompose.SweepLineVertexType.MERGE) {
                                sweepstate.dcel.addHalfEdges$int$int(vertex.index, vertex.right.helper.index);
                            }
                            sweepstate.referenceY.value = vertex.point.y;
                            sweepstate.tree.remove(vertex.right);
                            sweepstate.tree.insert(vertex.left);
                            vertex.left.helper = vertex;
                        }
                        else {
                            const ej = sweepstate.tree.search(new org.dyn4j.geometry.decompose.ClosestEdgeToVertexSearchCriteria(vertex)).closest;
                            if (ej == null)
                                throw new java.lang.IllegalArgumentException("The input must be a simple polygon");
                            if (ej.helper.type === org.dyn4j.geometry.decompose.SweepLineVertexType.MERGE) {
                                sweepstate.dcel.addHalfEdges$int$int(vertex.index, ej.helper.index);
                            }
                            ej.helper = vertex;
                        }
                    }
                    constructor() {
                    }
                }
                decompose.SweepLine = SweepLine;
                SweepLine["__class"] = "org.dyn4j.geometry.decompose.SweepLine";
                SweepLine["__interfaces"] = ["org.dyn4j.geometry.decompose.Triangulator", "org.dyn4j.geometry.decompose.Decomposer"];
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Minimal constructor.
             * @param {number} index the index of the feature in the {@link Shape}
             * @class
             * @author William Bittle
             */
            class Feature {
                constructor(index) {
                    if (this.index === undefined) {
                        this.index = 0;
                    }
                    this.index = index;
                }
                /**
                 * Returns the edge index.
                 * <p>
                 * If the index == {@link #NOT_INDEXED} then
                 * this feature represents a curved shape feature.
                 * @return {number} int
                 */
                getIndex() {
                    return this.index;
                }
            }
            /**
             * Index for non-indexed vertices
             */
            Feature.NOT_INDEXED = -1;
            geometry.Feature = Feature;
            Feature["__class"] = "org.dyn4j.geometry.Feature";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Contains static methods to perform standard geometric operations.
             * <p>
             * This class can be used to create {@link Shape}s of varying types via the <code>create</code>* methods.
             * While {@link Shape}s can be created using their constructors as well, the methods here can place their
             * centers on the origin and also make copies of the given input to avoid reuse issues.
             * <p>
             * This class also contains various helper methods for cleaning vector arrays and lists and performing
             * various operations on {@link Shape}s.
             * @author William Bittle
             * @version 3.4.0
             * @since 1.0.0
             * @class
             */
            class Geometry {
                static TWO_PI_$LI$() { if (Geometry.TWO_PI == null) {
                    Geometry.TWO_PI = 2.0 * Math.PI;
                } return Geometry.TWO_PI; }
                static INV_SQRT_3_$LI$() { if (Geometry.INV_SQRT_3 == null) {
                    Geometry.INV_SQRT_3 = 1.0 / Math.sqrt(3.0);
                } return Geometry.INV_SQRT_3; }
                static getWinding$java_util_List(points) {
                    if (points == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointList"));
                    const size = points.size();
                    if (size < 2)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidSizePointList2"));
                    let area = 0.0;
                    for (let i = 0; i < size; i++) {
                        {
                            const p1 = points.get(i);
                            const p2 = points.get(i + 1 === size ? 0 : i + 1);
                            if (p1 == null || p2 == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointListElements"));
                            area += p1.cross$org_dyn4j_geometry_Vector2(p2);
                        }
                        ;
                    }
                    return area;
                }
                /**
                 * Returns the winding, Clockwise or Counter-Clockwise, for the given
                 * list of points of a polygon.
                 * <p>
                 * This method determines the winding by computing a signed "area".
                 * @param {*} points the points of a polygon
                 * @return {number} double negative for Clockwise winding; positive for Counter-Clockwise winding
                 * @throws NullPointerException if points is null or an element of points is null
                 * @throws IllegalArgumentException if points contains less than 2 elements
                 * @since 2.2.0
                 */
                static getWinding(points) {
                    if (((points != null && (points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || points === null)) {
                        return org.dyn4j.geometry.Geometry.getWinding$java_util_List(points);
                    }
                    else if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof org.dyn4j.geometry.Vector2))) || points === null)) {
                        return org.dyn4j.geometry.Geometry.getWinding$org_dyn4j_geometry_Vector2_A(...points);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static getWinding$org_dyn4j_geometry_Vector2_A(...points) {
                    if (points == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointArray"));
                    const size = points.length;
                    if (size < 2)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidSizePointArray2"));
                    let area = 0.0;
                    for (let i = 0; i < size; i++) {
                        {
                            const p1 = points[i];
                            const p2 = points[i + 1 === size ? 0 : i + 1];
                            if (p1 == null || p2 == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointArrayElements"));
                            area += p1.cross$org_dyn4j_geometry_Vector2(p2);
                        }
                        ;
                    }
                    return area;
                }
                static reverseWinding$org_dyn4j_geometry_Vector2_A(...points) {
                    if (points == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointArray"));
                    const size = points.length;
                    if (size === 1 || size === 0)
                        return;
                    let i = 0;
                    let j = size - 1;
                    let temp = null;
                    while ((j > i)) {
                        {
                            temp = points[j];
                            points[j] = points[i];
                            points[i] = temp;
                            j--;
                            i++;
                        }
                    }
                    ;
                }
                /**
                 * Reverses the order of the polygon points within the given array.
                 * <p>
                 * This method performs a simple array reverse.
                 * @param {org.dyn4j.geometry.Vector2[]} points the polygon points
                 * @throws NullPointerException if points is null
                 * @since 2.2.0
                 */
                static reverseWinding(...points) {
                    if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof org.dyn4j.geometry.Vector2))) || points === null)) {
                        return org.dyn4j.geometry.Geometry.reverseWinding$org_dyn4j_geometry_Vector2_A(...points);
                    }
                    else if (((points != null && (points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || points === null)) {
                        return org.dyn4j.geometry.Geometry.reverseWinding$java_util_List(points);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static reverseWinding$java_util_List(points) {
                    if (points == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointList"));
                    if (points.size() <= 1)
                        return;
                    java.util.Collections.reverse(points);
                }
                static getAverageCenter$java_util_List(points) {
                    if (points == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointList"));
                    if (points.isEmpty())
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidSizePointList1"));
                    const size = points.size();
                    if (size === 1) {
                        const p = points.get(0);
                        if (p == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointListElements"));
                        return p.copy();
                    }
                    const ac = new org.dyn4j.geometry.Vector2();
                    for (let i = 0; i < size; i++) {
                        {
                            const point = points.get(i);
                            if (point == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointListElements"));
                            ac.add$org_dyn4j_geometry_Vector2(point);
                        }
                        ;
                    }
                    return ac.divide(size);
                }
                /**
                 * Returns the centroid of the given points by performing an average.
                 * @param {*} points the list of points
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the centroid
                 * @throws NullPointerException if points is null or an element of points is null
                 * @throws IllegalArgumentException if points is an empty list
                 */
                static getAverageCenter(points) {
                    if (((points != null && (points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || points === null)) {
                        return org.dyn4j.geometry.Geometry.getAverageCenter$java_util_List(points);
                    }
                    else if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof org.dyn4j.geometry.Vector2))) || points === null)) {
                        return org.dyn4j.geometry.Geometry.getAverageCenter$org_dyn4j_geometry_Vector2_A(...points);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static getAverageCenter$org_dyn4j_geometry_Vector2_A(...points) {
                    if (points == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointArray"));
                    const size = points.length;
                    if (size === 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidSizePointArray1"));
                    if (size === 1) {
                        const p = points[0];
                        if (p == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointArrayElements"));
                        return p.copy();
                    }
                    const ac = new org.dyn4j.geometry.Vector2();
                    for (let i = 0; i < size; i++) {
                        {
                            const point = points[i];
                            if (point == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointArrayElements"));
                            ac.add$org_dyn4j_geometry_Vector2(point);
                        }
                        ;
                    }
                    return ac.divide(size);
                }
                static getAreaWeightedCenter$java_util_ArrayList$org_dyn4j_geometry_Vector2(points, center) {
                    const ac = Geometry.getAverageCenter$java_util_List(points);
                    const size = points.size();
                    let area = 0.0;
                    for (let i = 0; i < size; i++) {
                        {
                            let p1 = points.get(i);
                            let p2 = i + 1 < size ? points.get(i + 1) : points.get(0);
                            p1 = p1.difference$org_dyn4j_geometry_Vector2(ac);
                            p2 = p2.difference$org_dyn4j_geometry_Vector2(ac);
                            const d = p1.cross$org_dyn4j_geometry_Vector2(p2);
                            const triangleArea = 0.5 * d;
                            area += triangleArea;
                            center.add$org_dyn4j_geometry_Vector2(p1.add$org_dyn4j_geometry_Vector2(p2).multiply(Geometry.INV_3).multiply(triangleArea));
                        }
                        ;
                    }
                    if (Math.abs(area) <= org.dyn4j.Epsilon.E_$LI$()) {
                        center.set$org_dyn4j_geometry_Vector2(points.get(0));
                        return 0;
                    }
                    center.divide(area).add$org_dyn4j_geometry_Vector2(ac);
                    return area;
                }
                /**
                 * Returns the area weighted centroid for the given points.
                 * <p>
                 * A {@link Polygon}'s centroid must be computed by the area weighted method since the
                 * average method can be bias to one side if there are more points on that one
                 * side than another.
                 * <p>
                 * Finding the area of a {@link Polygon} can be done by using the following
                 * summation:
                 * <p style="white-space: pre;"> 0.5 * &sum;(x<sub>i</sub> * y<sub>i + 1</sub> - x<sub>i + 1</sub> * y<sub>i</sub>)</p>
                 * Finding the area weighted centroid can be done by using the following
                 * summation:
                 * <p style="white-space: pre;"> 1 / (6 * A) * &sum;(p<sub>i</sub> + p<sub>i + 1</sub>) * (x<sub>i</sub> * y<sub>i + 1</sub> - x<sub>i + 1</sub> * y<sub>i</sub>)</p>
                 * @param {java.util.ArrayList} points the {@link Polygon} points
                 * @return {number} the area and writes center of points to specified center
                 * @throws NullPointerException if points is null or an element of points is null
                 * @throws IllegalArgumentException if points is empty
                 * @param {org.dyn4j.geometry.Vector2} center
                 */
                static getAreaWeightedCenter(points, center) {
                    if (((points != null && points instanceof java.util.ArrayList) || points === null) && ((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        return org.dyn4j.geometry.Geometry.getAreaWeightedCenter$java_util_ArrayList$org_dyn4j_geometry_Vector2(points, center);
                    }
                    else if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof org.dyn4j.geometry.Vector2))) || points === null) && center === undefined) {
                        return org.dyn4j.geometry.Geometry.getAreaWeightedCenter$org_dyn4j_geometry_Vector2_A(...points);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static getAreaWeightedCenter$org_dyn4j_geometry_Vector2_A(...points) {
                    const ac = Geometry.getAverageCenter$org_dyn4j_geometry_Vector2_A.apply(null, points);
                    const size = points.length;
                    const center = new org.dyn4j.geometry.Vector2();
                    let area = 0.0;
                    for (let i = 0; i < size; i++) {
                        {
                            let p1 = points[i];
                            let p2 = i + 1 < size ? points[i + 1] : points[0];
                            p1 = p1.difference$org_dyn4j_geometry_Vector2(ac);
                            p2 = p2.difference$org_dyn4j_geometry_Vector2(ac);
                            const d = p1.cross$org_dyn4j_geometry_Vector2(p2);
                            const triangleArea = 0.5 * d;
                            area += triangleArea;
                            center.add$org_dyn4j_geometry_Vector2(p1.add$org_dyn4j_geometry_Vector2(p2).multiply(Geometry.INV_3).multiply(triangleArea));
                        }
                        ;
                    }
                    if (Math.abs(area) <= org.dyn4j.Epsilon.E_$LI$()) {
                        return points[0].copy();
                    }
                    center.divide(area).add$org_dyn4j_geometry_Vector2(ac);
                    return center;
                }
                static getRotationRadius$org_dyn4j_geometry_Vector2_A(...vertices) {
                    return Geometry.getRotationRadius$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2_A.apply(null, [new org.dyn4j.geometry.Vector2()].concat(vertices));
                }
                static getRotationRadius$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2_A(center, ...vertices) {
                    if (vertices == null)
                        return 0.0;
                    if (center == null)
                        center = new org.dyn4j.geometry.Vector2();
                    const size = vertices.length;
                    if (size === 0)
                        return 0.0;
                    let r2 = 0.0;
                    for (let i = 0; i < size; i++) {
                        {
                            const v = vertices[i];
                            if (v != null) {
                                const r2t = center.distanceSquared$org_dyn4j_geometry_Vector2(v);
                                r2 = Math.max(r2, r2t);
                            }
                        }
                        ;
                    }
                    return Math.sqrt(r2);
                }
                /**
                 * Returns the maximum radius of the given vertices rotated about the given center.
                 * <p>
                 * If the vertices array is null or empty, zero is returned.  If center is null
                 * the origin will be used instead.
                 * @param {org.dyn4j.geometry.Vector2} center the center point
                 * @param {org.dyn4j.geometry.Vector2[]} vertices the polygon vertices
                 * @return {number} double
                 * @since 3.2.0
                 */
                static getRotationRadius(center, ...vertices) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null) && ((vertices != null && vertices instanceof Array && (vertices.length == 0 || vertices[0] == null || (vertices[0] != null && vertices[0] instanceof org.dyn4j.geometry.Vector2))) || vertices === null)) {
                        return org.dyn4j.geometry.Geometry.getRotationRadius$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2_A(center, ...vertices);
                    }
                    else if (((center != null && center instanceof Array && (center.length == 0 || center[0] == null || (center[0] != null && center[0] instanceof org.dyn4j.geometry.Vector2))) || center === null) && vertices === undefined || vertices.length === 0) {
                        return org.dyn4j.geometry.Geometry.getRotationRadius$org_dyn4j_geometry_Vector2_A(...center);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns an array of normalized vectors representing the normals of all the
                 * edges given the vertices.
                 * <p>
                 * This method assumes counter-clockwise ordering.
                 * <p>
                 * Returns null if the given vertices array is null or empty.
                 * @param {org.dyn4j.geometry.Vector2[]} vertices the vertices
                 * @return {org.dyn4j.geometry.Vector2[]} {@link Vector2}[]
                 * @throws NullPointerException if vertices contains a null element
                 * @since 3.2.0
                 */
                static getCounterClockwiseEdgeNormals(...vertices) {
                    if (vertices == null)
                        return null;
                    const size = vertices.length;
                    if (size === 0)
                        return null;
                    const normals = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size);
                    for (let i = 0; i < size; i++) {
                        {
                            const p1 = vertices[i];
                            const p2 = (i + 1 === size) ? vertices[0] : vertices[i + 1];
                            const n = p1.to$org_dyn4j_geometry_Vector2(p2).left();
                            n.normalize();
                            normals[i] = n;
                        }
                        ;
                    }
                    return normals;
                }
                /**
                 * Returns a new {@link Circle} with the given radius centered on the origin.
                 * @param {number} radius the radius in meters
                 * @return {org.dyn4j.geometry.Circle} {@link Circle}
                 * @throws IllegalArgumentException if radius is less than or equal to zero
                 */
                static createCircle(radius) {
                    return new org.dyn4j.geometry.Circle(radius);
                }
                /**
                 * Returns a new {@link Ring} with the given radius centered on the origin.
                 * @param {number} radius the radius in meters
                 * @return {org.dyn4j.geometry.Ring} {@link Ring}
                 * @throws IllegalArgumentException if radius is less than or equal to zero
                 */
                static createRing(radius) {
                    return new org.dyn4j.geometry.Ring(radius);
                }
                /**
                 * Returns a new {@link Polygon} with the given vertices.
                 * <p>
                 * This method makes a copy of both the array and the vertices within the array to
                 * create the new {@link Polygon}.
                 * <p>
                 * The center of the {@link Polygon} will be computed using the area weighted method.
                 * @param {org.dyn4j.geometry.Vector2[]} vertices the array of vertices
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws NullPointerException if vertices is null or an element of vertices is null
                 * @throws IllegalArgumentException if vertices contains less than 3 non-null vertices
                 * @see #createPolygonAtOrigin(Vector2...) to create a new {@link Polygon} that is centered on the origin
                 */
                static createPolygon(...vertices) {
                    if (vertices == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullVerticesArray"));
                    const size = vertices.length;
                    const verts = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size);
                    for (let i = 0; i < size; i++) {
                        {
                            const vertex = vertices[i];
                            if (vertex != null) {
                                verts[i] = vertex.copy();
                            }
                            else {
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPolygonPoint"));
                            }
                        }
                        ;
                    }
                    return new org.dyn4j.geometry.Polygon(verts);
                }
                /**
                 * Returns a new {@link Polygon}, using the given vertices, centered at the origin.
                 * <p>
                 * This method makes a copy of both the array and the vertices within the array to
                 * create the new {@link Polygon}.
                 * <p>
                 * This method translates the {@link Polygon} vertices so that the center is at the origin.
                 * @param {org.dyn4j.geometry.Vector2[]} vertices the array of vertices
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws NullPointerException if vertices is null or an element of vertices is null
                 * @throws IllegalArgumentException if vertices contains less than 3 non-null vertices
                 */
                static createPolygonAtOrigin(...vertices) {
                    const polygon = Geometry.createPolygon.apply(null, vertices);
                    const center = polygon.getCenter();
                    polygon.translate$double$double(-center.x, -center.y);
                    return polygon;
                }
                static createUnitCirclePolygon$int$double(count, radius) {
                    return Geometry.createUnitCirclePolygon$int$double$double(count, radius, 0.0);
                }
                static createUnitCirclePolygon$int$double$double(count, radius, theta) {
                    if (count < 3)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidVerticesSize"));
                    if (radius <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidRadius"));
                    return Geometry.createPolygonalCircle$int$double$double(count, radius, theta);
                }
                /**
                 * Returns a new {@link Polygon} with count number of points, where the
                 * points are evenly distributed around the unit circle.  The resulting {@link Polygon}
                 * will be centered on the origin.
                 * <p>
                 * The radius parameter is the distance from the center of the polygon to each vertex.
                 * <p>
                 * The theta parameter is a vertex angle offset used to rotate all the vertices
                 * by the given amount.
                 * @param {number} count the number of vertices
                 * @param {number} radius the radius from the center to each vertex in meters
                 * @param {number} theta the vertex angle offset in radians
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws IllegalArgumentException if count is less than 3 or radius is less than or equal to zero
                 * @see #createPolygonalCircle(int, double, double)
                 */
                static createUnitCirclePolygon(count, radius, theta) {
                    if (((typeof count === 'number') || count === null) && ((typeof radius === 'number') || radius === null) && ((typeof theta === 'number') || theta === null)) {
                        return org.dyn4j.geometry.Geometry.createUnitCirclePolygon$int$double$double(count, radius, theta);
                    }
                    else if (((typeof count === 'number') || count === null) && ((typeof radius === 'number') || radius === null) && theta === undefined) {
                        return org.dyn4j.geometry.Geometry.createUnitCirclePolygon$int$double(count, radius);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Creates a square (equal height and width {@link Rectangle}) with the given size
                 * centered at the origin.
                 * @param {number} size the size in meters
                 * @return {org.dyn4j.geometry.Rectangle} {@link Rectangle}
                 * @throws IllegalArgumentException if size is less than or equal to zero
                 */
                static createSquare(size) {
                    if (size <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidSize"));
                    return new org.dyn4j.geometry.Rectangle(size, size);
                }
                /**
                 * Creates a new {@link Rectangle} with the given width and height centered at the origin.
                 * @param {number} width the width in meters
                 * @param {number} height the height in meters
                 * @return {org.dyn4j.geometry.Rectangle} {@link Rectangle}
                 * @throws IllegalArgumentException if width or height is less than or equal to zero
                 */
                static createRectangle(width, height) {
                    return new org.dyn4j.geometry.Rectangle(width, height);
                }
                /**
                 * Creates a new {@link Triangle}, using the given points.
                 * <p>
                 * This method makes a copy of the given points to create the {@link Triangle}.
                 * <p>
                 * The center of the {@link Triangle} will be computed using the area weighted method.
                 * @param {org.dyn4j.geometry.Vector2} p1 the first point
                 * @param {org.dyn4j.geometry.Vector2} p2 the second point
                 * @param {org.dyn4j.geometry.Vector2} p3 the third point
                 * @return {org.dyn4j.geometry.Triangle} {@link Triangle}
                 * @throws NullPointerException if p1, p2, or p3 is null
                 * @see #createTriangleAtOrigin(Vector2, Vector2, Vector2) to create a new {@link Triangle} that is centered on the origin
                 */
                static createTriangle(p1, p2, p3) {
                    if (p1 == null || p2 == null || p3 == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullTrianglePoint"));
                    return new org.dyn4j.geometry.Triangle(p1.copy(), p2.copy(), p3.copy());
                }
                /**
                 * Creates a new {@link Triangle} with the given points centered at the origin.
                 * <p>
                 * This method makes a copy of the given points to create the {@link Triangle}.
                 * @param {org.dyn4j.geometry.Vector2} p1 the first point
                 * @param {org.dyn4j.geometry.Vector2} p2 the second point
                 * @param {org.dyn4j.geometry.Vector2} p3 the third point
                 * @return {org.dyn4j.geometry.Triangle} {@link Triangle}
                 * @throws NullPointerException if p1, p2, or p3 is null
                 */
                static createTriangleAtOrigin(p1, p2, p3) {
                    const triangle = Geometry.createTriangle(p1, p2, p3);
                    const center = triangle.getCenter();
                    triangle.translate$double$double(-center.x, -center.y);
                    return triangle;
                }
                static createRightTriangle$double$double(width, height) {
                    return Geometry.createRightTriangle$double$double$boolean(width, height, false);
                }
                static createRightTriangle$double$double$boolean(width, height, mirror) {
                    if (width <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidWidth"));
                    if (height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidHeight"));
                    const top = new org.dyn4j.geometry.Vector2(0.0, height);
                    const left = new org.dyn4j.geometry.Vector2(0.0, 0.0);
                    const right = new org.dyn4j.geometry.Vector2(mirror ? -width : width, 0.0);
                    let triangle;
                    if (mirror) {
                        triangle = new org.dyn4j.geometry.Triangle(top, right, left);
                    }
                    else {
                        triangle = new org.dyn4j.geometry.Triangle(top, left, right);
                    }
                    const center = triangle.getCenter();
                    triangle.translate$double$double(-center.x, -center.y);
                    return triangle;
                }
                /**
                 * Creates a right angle {@link Triangle} with the center at the origin.
                 * @param {number} width the width of the base in meters
                 * @param {number} height the height in meters
                 * @param {boolean} mirror true if the triangle should be mirrored along the y-axis
                 * @return {org.dyn4j.geometry.Triangle} {@link Triangle}
                 * @throws IllegalArgumentException if width or height is less than or equal to zero
                 */
                static createRightTriangle(width, height, mirror) {
                    if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null) && ((typeof mirror === 'boolean') || mirror === null)) {
                        return org.dyn4j.geometry.Geometry.createRightTriangle$double$double$boolean(width, height, mirror);
                    }
                    else if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null) && mirror === undefined) {
                        return org.dyn4j.geometry.Geometry.createRightTriangle$double$double(width, height);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Creates an equilateral {@link Triangle} with the center at the origin.
                 * @param {number} height the height of the triangle in meters
                 * @return {org.dyn4j.geometry.Triangle} {@link Triangle}
                 * @throws IllegalArgumentException if height is less than or equal to zero
                 */
                static createEquilateralTriangle(height) {
                    if (height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidSize"));
                    const a = 2.0 * height * Geometry.INV_SQRT_3_$LI$();
                    return Geometry.createIsoscelesTriangle(a, height);
                }
                /**
                 * Creates an isosceles {@link Triangle} with the center at the origin.
                 * @param {number} width the width of the base in meters
                 * @param {number} height the height in meters
                 * @return {org.dyn4j.geometry.Triangle} {@link Triangle}
                 * @throws IllegalArgumentException if width or height is less than or equal to zero
                 */
                static createIsoscelesTriangle(width, height) {
                    if (width <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidWidth"));
                    if (height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidHeight"));
                    const top = new org.dyn4j.geometry.Vector2(0.0, height);
                    const left = new org.dyn4j.geometry.Vector2(-width * 0.5, 0.0);
                    const right = new org.dyn4j.geometry.Vector2(width * 0.5, 0.0);
                    const triangle = new org.dyn4j.geometry.Triangle(top, left, right);
                    const center = triangle.getCenter();
                    triangle.translate$double$double(-center.x, -center.y);
                    return triangle;
                }
                static createSegment$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(p1, p2) {
                    if (p1 == null || p2 == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullSegmentPoint"));
                    return new org.dyn4j.geometry.Segment(p1.copy(), p2.copy());
                }
                /**
                 * Creates a new {@link Segment} with the given points.
                 * <p>
                 * This method makes a copy of the given points to create the {@link Segment}.
                 * <p>
                 * The center of the {@link Segment} will be the average of the two points.
                 * @param {org.dyn4j.geometry.Vector2} p1 the first point
                 * @param {org.dyn4j.geometry.Vector2} p2 the second point
                 * @return {org.dyn4j.geometry.Segment} {@link Segment}
                 * @throws NullPointerException if p1 or p2 is null
                 * @see #createSegmentAtOrigin(Vector2, Vector2) to create a {@link Segment} centered on the origin
                 */
                static createSegment(p1, p2) {
                    if (((p1 != null && p1 instanceof org.dyn4j.geometry.Vector2) || p1 === null) && ((p2 != null && p2 instanceof org.dyn4j.geometry.Vector2) || p2 === null)) {
                        return org.dyn4j.geometry.Geometry.createSegment$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(p1, p2);
                    }
                    else if (((p1 != null && p1 instanceof org.dyn4j.geometry.Vector2) || p1 === null) && p2 === undefined) {
                        return org.dyn4j.geometry.Geometry.createSegment$org_dyn4j_geometry_Vector2(p1);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Creates a new {@link Segment} with the given points.
                 * <p>
                 * This method makes a copy of the given points to create the {@link Segment}.
                 * <p>
                 * This method translates the {@link Segment} vertices so that the center is at the origin.
                 * @param {org.dyn4j.geometry.Vector2} p1 the first point
                 * @param {org.dyn4j.geometry.Vector2} p2 the second point
                 * @return {org.dyn4j.geometry.Segment} {@link Segment}
                 * @throws NullPointerException if p1 or p2 is null
                 */
                static createSegmentAtOrigin(p1, p2) {
                    const segment = Geometry.createSegment$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(p1, p2);
                    const center = segment.getCenter();
                    segment.translate$double$double(-center.x, -center.y);
                    return segment;
                }
                static createSegment$org_dyn4j_geometry_Vector2(end) {
                    return Geometry.createSegment$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(), end);
                }
                /**
                 * Creates a new {@link Segment} with the given length with the center
                 * at the origin.
                 * <p>
                 * Renamed from createSegment(double).
                 * @param {number} length the length of the segment in meters
                 * @return {org.dyn4j.geometry.Segment} {@link Segment}
                 * @throws IllegalArgumentException if length is less than or equal to zero
                 * @since 2.2.3
                 */
                static createHorizontalSegment(length) {
                    if (length <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidLength"));
                    const start = new org.dyn4j.geometry.Vector2(-length * 0.5, 0.0);
                    const end = new org.dyn4j.geometry.Vector2(length * 0.5, 0.0);
                    return new org.dyn4j.geometry.Segment(start, end);
                }
                /**
                 * Creates a new {@link Segment} with the given length with the center
                 * at the origin.
                 * @param {number} length the length of the segment in meters
                 * @return {org.dyn4j.geometry.Segment} {@link Segment}
                 * @throws IllegalArgumentException if length is less than or equal to zero
                 * @since 2.2.3
                 */
                static createVerticalSegment(length) {
                    if (length <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidLength"));
                    const start = new org.dyn4j.geometry.Vector2(0.0, -length * 0.5);
                    const end = new org.dyn4j.geometry.Vector2(0.0, length * 0.5);
                    return new org.dyn4j.geometry.Segment(start, end);
                }
                /**
                 * Creates a new {@link Capsule} bounded by the given rectangle width and height.
                 * <p>
                 * The capsule will be axis-aligned and centered on the origin with the caps on the
                 * ends of the largest dimension.
                 * <p>
                 * If width and height are equal use a {@link Circle} shape instead.
                 * @param {number} width the bounding rectangle width
                 * @param {number} height the bounding rectangle height
                 * @return {org.dyn4j.geometry.Capsule} {@link Capsule}
                 * @throws IllegalArgumentException if width or height are less than or equal to zero
                 * @since 3.1.5
                 */
                static createCapsule(width, height) {
                    return new org.dyn4j.geometry.Capsule(width, height);
                }
                /**
                 * Creates a new {@link Parabola} bounded by the given rectangle width and height.
                 * <p>
                 * A {@link Parabola} is axis aligned with its axis along x axis .
                 * <p>
                 * <p> The Parabola will be positioned with the <i>vertex</i> at the origin.
                 * <p>
                 * @param {number} width the bounding rectangle width
                 * @param {number} height the bounding rectangle height
                 * @return {org.dyn4j.geometry.Parabola} {@link Parabola}
                 * @throws IllegalArgumentException if width or height is less than or equal to zero;
                 * @since 3.1.10
                 */
                static createParabola(width, height) {
                    return new org.dyn4j.geometry.Parabola(width, height);
                }
                /**
                 * Creates a new {@link Parabola} bounded by the given rectangle width and height.
                 * <p>
                 * A {@link Parabola} is axis aligned with its axis along x axis .
                 * <p> The Parabola will be positioned with the <i>centroid</i> at the origin.
                 *
                 * @param {number} width the bounding rectangle width
                 * @param {number} height the bounding rectangle height
                 * @return {org.dyn4j.geometry.Parabola} {@link Parabola}
                 * @throws IllegalArgumentException if width or height is less than or equal to zero;
                 * @since 3.1.10
                 */
                static createParabolaAtOrigin(width, height) {
                    const p = new org.dyn4j.geometry.Parabola(width, height);
                    p.translate$double$double(-p.center.x, -p.center.y);
                    return p;
                }
                /**
                 * Creates a new {@link Slice} with the given circle radius and arc length theta.
                 * <p>
                 * A {@link Slice} is an arbitrary slice of a circle. The specified radius is the radius
                 * of the circle. The slice will be positioned with the <i>circle center</i> on the origin.
                 * <p>
                 * Theta is the total arc length of the slice specified in radians. Theta is halved, putting
                 * half the arc length below the x-axis and half above.
                 * <p>
                 * Theta cannot be greater than &pi;.
                 * @param {number} radius the circle radius
                 * @param {number} theta the total arc length in radians
                 * @return {org.dyn4j.geometry.Slice} {@link Slice}
                 * @throws IllegalArgumentException if radius is less than or equal to zero; if theta is less than or equal to zero or is greater than &pi;
                 * @since 3.1.5
                 */
                static createSlice(radius, theta) {
                    return new org.dyn4j.geometry.Slice(radius, theta);
                }
                /**
                 * Creates a new {@link Slice} with the given circle radius and arc length theta.
                 * <p>
                 * A {@link Slice} is an arbitrary slice of a circle. The specified radius is the radius
                 * of the circle. The slice will be positioned with the <i>centroid</i> at the origin.
                 * <p>
                 * Theta is the total arc length of the slice specified in radians. Theta is halved, putting
                 * half the arc length below the x-axis and half above.
                 * <p>
                 * Theta cannot be greater than &pi;.
                 * @param {number} radius the circle radius
                 * @param {number} theta the total arc length in radians
                 * @return {org.dyn4j.geometry.Slice} {@link Slice}
                 * @throws IllegalArgumentException if radius is less than or equal to zero; if theta is less than or equal to zero or is greater than &pi;
                 * @since 3.1.5
                 */
                static createSliceAtOrigin(radius, theta) {
                    const slice = new org.dyn4j.geometry.Slice(radius, theta);
                    slice.translate$double$double(-slice.center.x, -slice.center.y);
                    return slice;
                }
                /**
                 * Creates a new {@link Ellipse} bounded by the given rectangle width and height.
                 * <p>
                 * The ellipse will be axis-aligned and centered on the origin.
                 * <p>
                 * If width and height are equal use a {@link Circle} shape instead.
                 * @param {number} width the bounding rectangle width
                 * @param {number} height the bounding rectangle height
                 * @return {org.dyn4j.geometry.Ellipse} {@link Ellipse}
                 * @throws IllegalArgumentException if width or height are less than or equal to zero
                 * @since 3.1.5
                 */
                static createEllipse(width, height) {
                    return new org.dyn4j.geometry.Ellipse(width, height);
                }
                /**
                 * Creates a new {@link HalfEllipse} bounded by the given rectangle width and height.
                 * <p>
                 * The ellipse will be axis-aligned with the base of the half ellipse on the x-axis. The given height
                 * is the height of the half, not the height of the full ellipse.
                 * <p>
                 * If width and height are equal use a {@link Slice} shape with <code>theta = Math.PI</code> instead.
                 * @param {number} width the bounding rectangle width
                 * @param {number} height the bounding rectangle height
                 * @return {org.dyn4j.geometry.HalfEllipse} {@link HalfEllipse}
                 * @throws IllegalArgumentException if width or height are less than or equal to zero
                 * @since 3.1.5
                 */
                static createHalfEllipse(width, height) {
                    return new org.dyn4j.geometry.HalfEllipse(width, height);
                }
                /**
                 * Creates a new {@link HalfEllipse} bounded by the given rectangle width and height.
                 * <p>
                 * The ellipse will be axis-aligned with the base of the half ellipse on the x-axis. The given height
                 * is the height of the half, not the height of the full ellipse.
                 * <p>
                 * If width and height are equal use a {@link Slice} shape with <code>theta = Math.PI</code> instead.
                 * @param {number} width the bounding rectangle width
                 * @param {number} height the bounding rectangle height
                 * @return {org.dyn4j.geometry.HalfEllipse} {@link HalfEllipse}
                 * @throws IllegalArgumentException if width or height are less than or equal to zero
                 * @since 3.1.5
                 */
                static createHalfEllipseAtOrigin(width, height) {
                    const half = new org.dyn4j.geometry.HalfEllipse(width, height);
                    const c = half.getCenter();
                    half.translate$double$double(-c.x, -c.y);
                    return half;
                }
                static createPolygonalCircle$int$double(count, radius) {
                    return Geometry.createPolygonalCircle$int$double$double(count, radius, 0);
                }
                /**
                 * Creates a list of Spline{@link Link}s for the given vertices.
                 * @param {org.dyn4j.geometry.Vector2[]} vertices the poly-line vertices
                 * @param closed true if the last vertex and first vertex are identical and shape should be enclosed
                 * @return {*} List&lt;{@link Link}&gt;
                 * @throws NullPointerException if the array of vertices is null or an element of the vertex array is null
                 * @throws IllegalArgumentException if the array of vertices doesn't contain 2 or more elements
                 * @since 3.2.2
                 */
                static createSplineLinks(vertices) {
                    if (vertices == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointArray"));
                    let closed = false;
                    let numDiv = 8;
                    const size = vertices.length;
                    if (size < 3)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidSizePointList3"));
                    if (size > 50) {
                        numDiv = 1;
                    }
                    else if (size > 25) {
                        numDiv = 2;
                    }
                    else if (size > 15) {
                        numDiv = 5;
                    }
                    else if (size >= 10) {
                        numDiv = 8;
                    }
                    else if (size >= 5) {
                        numDiv = 10;
                    }
                    else {
                        numDiv = 15;
                    }
                    let n = numDiv * vertices.length;
                    let step = Math.fround(1 / n);
                    let t = 0;
                    let t0 = 0;
                    if (vertices.length > 3 && vertices[vertices.length - 1].approxEqual(vertices[0])) {
                        closed = true;
                        n = numDiv * (vertices.length - 1);
                        let m = vertices.length - 1;
                        const pts = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(3 * m);
                        for (let i = 0; i < m; i++) {
                            pts[i] = vertices[i];
                        }
                        for (let i = 0; i < m; i++) {
                            pts[m + i] = vertices[i];
                        }
                        for (let i = 0; i < m; i++) {
                            pts[2 * m + i] = vertices[i];
                        }
                        vertices = pts;
                        m = numDiv * (vertices.length - 1);
                        step = Math.fround(1 / m);
                        t0 = Math.fround(n * step);
                        n--;
                    }
                    const spline = new org.dyn4j.geometry.Spline2D(vertices);
                    const p = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(n + 1);
                    t = t0;
                    for (let i = 0; i <= n; i++) {
                        {
                            p[i] = spline.getPoint(t);
                            t += step;
                        }
                        ;
                    }
                    return Geometry.createLinks$org_dyn4j_geometry_Vector2_A$boolean(p, closed);
                }
                static createPolygonalCircle$int$double$double(count, radius, theta) {
                    if (count < 3)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.circleInvalidCount"));
                    if (radius <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.circleInvalidRadius"));
                    const pin = Geometry.TWO_PI_$LI$() / count;
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(count);
                    const c = Math.cos(pin);
                    const s = Math.sin(pin);
                    let t = 0;
                    let x = radius;
                    let y = 0;
                    if (theta !== 0) {
                        x = radius * Math.cos(theta);
                        y = radius * Math.sin(theta);
                    }
                    for (let i = 0; i < count; i++) {
                        {
                            vertices[i] = new org.dyn4j.geometry.Vector2(x, y);
                            t = x;
                            x = c * x - s * y;
                            y = s * t + c * y;
                        }
                        ;
                    }
                    return new org.dyn4j.geometry.Polygon(vertices);
                }
                /**
                 * Creates a new {@link Polygon} in the shape of a circle with count number of vertices centered
                 * on the origin.
                 * @param {number} count the number of vertices to use; must be greater than or equal to 3
                 * @param {number} radius the radius of the circle; must be greater than zero
                 * @param {number} theta the radial offset for the points in radians
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws IllegalArgumentException thrown if count is less than 3 or the radius is less than or equal to zero
                 * @since 3.1.5
                 */
                static createPolygonalCircle(count, radius, theta) {
                    if (((typeof count === 'number') || count === null) && ((typeof radius === 'number') || radius === null) && ((typeof theta === 'number') || theta === null)) {
                        return org.dyn4j.geometry.Geometry.createPolygonalCircle$int$double$double(count, radius, theta);
                    }
                    else if (((typeof count === 'number') || count === null) && ((typeof radius === 'number') || radius === null) && theta === undefined) {
                        return org.dyn4j.geometry.Geometry.createPolygonalCircle$int$double(count, radius);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Creates a new {@link Polygon} in the shape of a {@link Slice} with count number of vertices with the
                 * circle center centered on the origin.
                 * <p>
                 * This method returns a polygon with count + 3 vertices.
                 * @param {number} count the number of vertices to use; must be greater than or equal to 1
                 * @param {number} radius the radius of the circle; must be greater than zero
                 * @param {number} theta the arc length of the slice in radians; must be greater than zero
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws IllegalArgumentException thrown if count is less than 1 or the radius is less than or equal to zero or theta is less than or equal to zero
                 * @since 3.1.5
                 */
                static createPolygonalSlice(count, radius, theta) {
                    if (count < 1)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.sliceInvalidCount"));
                    if (radius <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.sliceInvalidRadius"));
                    if (theta <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.sliceInvalidTheta"));
                    const pin = theta / (count + 1);
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(count + 3);
                    const c = Math.cos(pin);
                    const s = Math.sin(pin);
                    let t = 0;
                    let x = radius * Math.cos(-theta * 0.5);
                    let y = radius * Math.sin(-theta * 0.5);
                    vertices[0] = new org.dyn4j.geometry.Vector2(x, y);
                    vertices[count + 1] = new org.dyn4j.geometry.Vector2(x, -y);
                    for (let i = 1; i < count + 1; i++) {
                        {
                            t = x;
                            x = c * x - s * y;
                            y = s * t + c * y;
                            vertices[i] = new org.dyn4j.geometry.Vector2(x, y);
                        }
                        ;
                    }
                    vertices[count + 2] = new org.dyn4j.geometry.Vector2();
                    return new org.dyn4j.geometry.Polygon(vertices);
                }
                /**
                 * Creates a new {@link Polygon} in the shape of a {@link Slice} with count number of vertices centered on the origin.
                 * <p>
                 * This method returns a polygon with count + 3 vertices.
                 * @param {number} count the number of vertices to use; must be greater than or equal to 1
                 * @param {number} radius the radius of the circle; must be greater than zero
                 * @param {number} theta the arc length of the slice in radians; must be greater than zero
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws IllegalArgumentException thrown if count is less than 1 or the radius is less than or equal to zero or theta is less than or equal to zero
                 * @since 3.1.5
                 */
                static createPolygonalSliceAtOrigin(count, radius, theta) {
                    const polygon = Geometry.createPolygonalSlice(count, radius, theta);
                    const center = polygon.getCenter();
                    polygon.translate$double$double(-center.x, -center.y);
                    return polygon;
                }
                /**
                 * Creates a new {@link Polygon} in the shape of an ellipse with count number of vertices centered
                 * on the origin.
                 * <p>
                 * The count should be greater than or equal to 4 and a multiple of 2.  If not, the returned polygon will have count - 1
                 * vertices.
                 * @param {number} count the number of vertices to use; must be greater than or equal to 4; should be even, if not, count - 1 vertices will be generated
                 * @param {number} width the width of the ellipse
                 * @param {number} height the height of the ellipse
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws IllegalArgumentException thrown if count is less than 4 or the width or height are less than or equal to zero
                 * @since 3.1.5
                 */
                static createPolygonalEllipse(count, width, height) {
                    if (count < 4)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.ellipseInvalidCount"));
                    if (width <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.ellipseInvalidWidth"));
                    if (height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.ellipseInvalidHeight"));
                    const a = width * 0.5;
                    const b = height * 0.5;
                    const n2 = (count / 2 | 0);
                    const pin2 = Math.PI / n2;
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(n2 * 2);
                    let j = 0;
                    for (let i = 0; i < n2 + 1; i++) {
                        {
                            const t = pin2 * i;
                            const x = a * Math.cos(t);
                            const y = b * Math.sin(t);
                            if (i > 0) {
                                vertices[vertices.length - j] = new org.dyn4j.geometry.Vector2(x, -y);
                            }
                            vertices[j++] = new org.dyn4j.geometry.Vector2(x, y);
                        }
                        ;
                    }
                    return new org.dyn4j.geometry.Polygon(vertices);
                }
                /**
                 * Creates a new {@link Polygon} in the shape of a half ellipse with count number of vertices with the
                 * base at the origin.
                 * <p>
                 * Returns a polygon with count + 2 vertices.
                 * <p>
                 * The height is the total height of the half not the half height.
                 * @param {number} count the number of vertices to use; must be greater than or equal to 1
                 * @param {number} width the width of the half ellipse
                 * @param {number} height the height of the half ellipse; should be the total height
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws IllegalArgumentException thrown if count is less than 1 or the width or height are less than or equal to zero
                 * @since 3.1.5
                 */
                static createPolygonalHalfEllipse(count, width, height) {
                    if (count < 1)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.halfEllipseInvalidCount"));
                    if (width <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.halfEllipseInvalidWidth"));
                    if (height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.halfEllipseInvalidHeight"));
                    const a = width * 0.5;
                    const b = height * 0.5;
                    const inc = Math.PI / (count + 1);
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(count + 2);
                    vertices[0] = new org.dyn4j.geometry.Vector2(a, 0);
                    vertices[count + 1] = new org.dyn4j.geometry.Vector2(-a, 0);
                    for (let i = 1; i < count + 1; i++) {
                        {
                            const t = inc * i;
                            const x = a * Math.cos(t);
                            const y = b * Math.sin(t);
                            vertices[i] = new org.dyn4j.geometry.Vector2(x, y);
                        }
                        ;
                    }
                    return new org.dyn4j.geometry.Polygon(vertices);
                }
                /**
                 * Creates a new {@link Polygon} in the shape of a half ellipse with count number of vertices centered
                 * on the origin.
                 * <p>
                 * Returns a polygon with count + 2 vertices.
                 * <p>
                 * The height is the total height of the half not the half height.
                 * @param {number} count the number of vertices to use; should be even, if not, count - 1 vertices will be generated
                 * @param {number} width the width of the half ellipse
                 * @param {number} height the height of the half ellipse; should be the total height
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws IllegalArgumentException thrown if count is less than 1 or the width or height are less than or equal to zero
                 * @since 3.1.5
                 */
                static createPolygonalHalfEllipseAtOrigin(count, width, height) {
                    const polygon = Geometry.createPolygonalHalfEllipse(count, width, height);
                    const center = polygon.getCenter();
                    polygon.translate$double$double(-center.x, -center.y);
                    return polygon;
                }
                /**
                 * Creates a new {@link Polygon} in the shape of a capsule using count number of vertices on each
                 * cap, centered on the origin.  The caps will be on the ends of the largest dimension.
                 * <p>
                 * The returned polygon will have 4 + 2 * count number of vertices.
                 * @param {number} count the number of vertices to use for one cap; must be greater than or equal to 1
                 * @param {number} width the bounding rectangle width
                 * @param {number} height the bounding rectangle height
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @since 3.1.5
                 */
                static createPolygonalCapsule(count, width, height) {
                    if (count < 1)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.capsuleInvalidCount"));
                    if (width <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.capsuleInvalidWidth"));
                    if (height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.capsuleInvalidHeight"));
                    if (Math.abs(width - height) < org.dyn4j.Epsilon.E_$LI$()) {
                        return Geometry.createPolygonalCircle$int$double(count, width);
                    }
                    const pin = Math.PI / (count + 1);
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(4 + 2 * count);
                    const c = Math.cos(pin);
                    const s = Math.sin(pin);
                    let t = 0;
                    let major = width;
                    let minor = height;
                    let vertical = false;
                    if (width < height) {
                        major = height;
                        minor = width;
                        vertical = true;
                    }
                    const radius = minor * 0.5;
                    const offset = major * 0.5 - radius;
                    let ox = 0;
                    let oy = 0;
                    if (vertical) {
                        oy = offset;
                    }
                    else {
                        ox = offset;
                    }
                    let n = 0;
                    let ao = vertical ? 0 : Math.PI * 0.5;
                    let x = radius * Math.cos(pin - ao);
                    let y = radius * Math.sin(pin - ao);
                    for (let i = 0; i < count; i++) {
                        {
                            vertices[n++] = new org.dyn4j.geometry.Vector2(x + ox, y + oy);
                            t = x;
                            x = c * x - s * y;
                            y = s * t + c * y;
                        }
                        ;
                    }
                    if (vertical) {
                        vertices[n++] = new org.dyn4j.geometry.Vector2(-radius, oy);
                        vertices[n++] = new org.dyn4j.geometry.Vector2(-radius, -oy);
                    }
                    else {
                        vertices[n++] = new org.dyn4j.geometry.Vector2(ox, radius);
                        vertices[n++] = new org.dyn4j.geometry.Vector2(-ox, radius);
                    }
                    ao = vertical ? Math.PI : Math.PI * 0.5;
                    x = radius * Math.cos(pin + ao);
                    y = radius * Math.sin(pin + ao);
                    for (let i = 0; i < count; i++) {
                        {
                            vertices[n++] = new org.dyn4j.geometry.Vector2(x - ox, y - oy);
                            t = x;
                            x = c * x - s * y;
                            y = s * t + c * y;
                        }
                        ;
                    }
                    if (vertical) {
                        vertices[n++] = new org.dyn4j.geometry.Vector2(radius, -oy);
                        vertices[n++] = new org.dyn4j.geometry.Vector2(radius, oy);
                    }
                    else {
                        vertices[n++] = new org.dyn4j.geometry.Vector2(-ox, -radius);
                        vertices[n++] = new org.dyn4j.geometry.Vector2(ox, -radius);
                    }
                    return new org.dyn4j.geometry.Polygon(vertices);
                }
                /**
                 * Creates a new {@link Polygon} in the shape of a Parabola with vertex at origin and  with count number of vertices .
                 * <p>
                 * The count should be greater than or equal to 4 .  If so, the returned polygon will have count - 1
                 * vertices.
                 * @param {number} count the number of vertices to use; must be greater than or equal to 4
                 * @param {number} width the width of the ellipse
                 * @param {number} height the height of the ellipse
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws IllegalArgumentException thrown if count is less than 4 or the width or height are less than or equal to zero
                 * @since 3.1.5
                 */
                static createPolygonalParabola(count, width, height) {
                    if (count < 4)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.parabolaInvalidCount"));
                    if (width <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.parabolaInvalidWidth"));
                    if (height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.parabolaInvalidHeight"));
                    const p = new org.dyn4j.geometry.Parabola(width, height);
                    const a = p.getFocalDistance();
                    const b = p.getWidth();
                    const h = p.getHalfHeight();
                    const cx = p.getVertex().x;
                    const cy = p.getVertex().y;
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(count);
                    const n = count - 1;
                    let y = h;
                    let x = b;
                    const dy = 2 * h / n;
                    for (let i = 0; i <= n; i++) {
                        {
                            vertices[i] = new org.dyn4j.geometry.Vector2(cx + x, cy + y);
                            y = y - dy;
                            x = y * y / (4 * a);
                        }
                        ;
                    }
                    return new org.dyn4j.geometry.Polygon(vertices);
                }
                /**
                 * Creates a new {@link Polygon} in the shape of a Parabola with centroid at origin and  with count number of vertices .
                 * <p>
                 * The count should be greater than or equal to 4 .  If so, the returned polygon will have count - 1
                 * vertices.
                 * @param {number} count the number of vertices to use; must be greater than or equal to 4
                 * @param {number} width the width of the ellipse
                 * @param {number} height the height of the ellipse
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws IllegalArgumentException thrown if count is less than 4 or the width or height are less than or equal to zero
                 * @since 3.1.5
                 */
                static createPolygonalParabolaAtOrigin(count, width, height) {
                    const p = Geometry.createPolygonalParabola(count, width, height);
                    p.translate$double$double(-p.center.x, -p.center.y);
                    return p;
                }
                static cleanse$java_util_List(points) {
                    if (points == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointList"));
                    const size = points.size();
                    if (size === 0)
                        return points;
                    const result = (new java.util.ArrayList(size));
                    let winding = 0.0;
                    for (let i = 0; i < size; i++) {
                        {
                            const point = points.get(i);
                            const prev = points.get(i - 1 < 0 ? size - 1 : i - 1);
                            const next = points.get(i + 1 === size ? 0 : i + 1);
                            if (point == null || prev == null || next == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointListElements"));
                            const diff = point.difference$org_dyn4j_geometry_Vector2(next);
                            if (diff.isZero()) {
                                continue;
                            }
                            const prevToPoint = prev.to$org_dyn4j_geometry_Vector2(point);
                            const pointToNext = point.to$org_dyn4j_geometry_Vector2(next);
                            if (!prevToPoint.isZero()) {
                                const cross = prevToPoint.cross$org_dyn4j_geometry_Vector2(pointToNext);
                                if (Math.abs(cross) <= org.dyn4j.Epsilon.E_$LI$()) {
                                    continue;
                                }
                            }
                            winding += point.cross$org_dyn4j_geometry_Vector2(next);
                            result.add(point);
                        }
                        ;
                    }
                    if (winding < 0.0) {
                        Geometry.reverseWinding$java_util_List(result);
                    }
                    return result;
                }
                /**
                 * Returns a new list containing the 'cleansed' version of the given listing of polygon points.
                 * <p>
                 * This method ensures the polygon has CCW winding, removes colinear vertices, and removes coincident vertices.
                 * <p>
                 * If the given list is empty, the list is returned.
                 * @param {*} points the list polygon points
                 * @return {*} List&lt;{@link Vector2}&gt;
                 * @throws NullPointerException if points is null or if points contains null elements
                 */
                static cleanse(points) {
                    if (((points != null && (points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || points === null)) {
                        return org.dyn4j.geometry.Geometry.cleanse$java_util_List(points);
                    }
                    else if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof org.dyn4j.geometry.Vector2))) || points === null)) {
                        return org.dyn4j.geometry.Geometry.cleanse$org_dyn4j_geometry_Vector2_A(...points);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static cleanse$org_dyn4j_geometry_Vector2_A(...points) {
                    if (points == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointArray"));
                    const pointList = java.util.Arrays.asList(...points);
                    const resultList = Geometry.cleanse$java_util_List(pointList);
                    const result = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(resultList.size());
                    resultList.toArray(result);
                    return result;
                }
                static flipAlongTheXAxis$org_dyn4j_geometry_Polygon(polygon) {
                    return Geometry.flip$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(polygon, org.dyn4j.geometry.Vector2.X_AXIS_$LI$(), null);
                }
                static flipAlongTheYAxis$org_dyn4j_geometry_Polygon(polygon) {
                    return Geometry.flip$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(polygon, org.dyn4j.geometry.Vector2.Y_AXIS_$LI$(), null);
                }
                static flipAlongTheXAxis$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2(polygon, point) {
                    return Geometry.flip$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(polygon, org.dyn4j.geometry.Vector2.X_AXIS_$LI$(), point);
                }
                /**
                 * Flips the given polygon about the given point along the x-axis and
                 * returns the result as a new polygon.
                 * @param {org.dyn4j.geometry.Polygon} polygon the polygon to flip
                 * @param {org.dyn4j.geometry.Vector2} point the point to flip about
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws NullPointerException if the given polygon is null
                 * @see #flip(Polygon, Vector2)
                 * @see #flip(Polygon, Vector2, Vector2)
                 * @since 3.1.4
                 */
                static flipAlongTheXAxis(polygon, point) {
                    if (((polygon != null && polygon instanceof org.dyn4j.geometry.Polygon) || polygon === null) && ((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null)) {
                        return org.dyn4j.geometry.Geometry.flipAlongTheXAxis$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2(polygon, point);
                    }
                    else if (((polygon != null && polygon instanceof org.dyn4j.geometry.Polygon) || polygon === null) && point === undefined) {
                        return org.dyn4j.geometry.Geometry.flipAlongTheXAxis$org_dyn4j_geometry_Polygon(polygon);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static flipAlongTheYAxis$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2(polygon, point) {
                    return Geometry.flip$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(polygon, org.dyn4j.geometry.Vector2.Y_AXIS_$LI$(), point);
                }
                /**
                 * Flips the given polygon about the given point along the y-axis and
                 * returns the result as a new polygon.
                 * @param {org.dyn4j.geometry.Polygon} polygon the polygon to flip
                 * @param {org.dyn4j.geometry.Vector2} point the point to flip about
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws NullPointerException if the given polygon is null
                 * @see #flip(Polygon, Vector2)
                 * @see #flip(Polygon, Vector2, Vector2)
                 * @since 3.1.4
                 */
                static flipAlongTheYAxis(polygon, point) {
                    if (((polygon != null && polygon instanceof org.dyn4j.geometry.Polygon) || polygon === null) && ((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null)) {
                        return org.dyn4j.geometry.Geometry.flipAlongTheYAxis$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2(polygon, point);
                    }
                    else if (((polygon != null && polygon instanceof org.dyn4j.geometry.Polygon) || polygon === null) && point === undefined) {
                        return org.dyn4j.geometry.Geometry.flipAlongTheYAxis$org_dyn4j_geometry_Polygon(polygon);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static flip$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2(polygon, axis) {
                    return Geometry.flip$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(polygon, axis, null);
                }
                static flip$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(polygon, axis, point) {
                    if (polygon == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullFlipPolygon"));
                    if (axis == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullFlipAxis"));
                    if (axis.isZero())
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.zeroFlipAxis"));
                    if (point == null)
                        point = polygon.getCenter();
                    axis.normalize();
                    const pv = polygon.getVertices();
                    const nv = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(pv.length);
                    for (let i = 0; i < pv.length; i++) {
                        {
                            const v0 = pv[i];
                            const v1 = v0.difference$org_dyn4j_geometry_Vector2(point);
                            const proj = v1.dot$org_dyn4j_geometry_Vector2(axis);
                            const vp = axis.product(proj);
                            const rv = vp.add$double$double(vp.x - v1.x, vp.y - v1.y);
                            nv[i] = rv.add$org_dyn4j_geometry_Vector2(point);
                        }
                        ;
                    }
                    if (Geometry.getWinding$org_dyn4j_geometry_Vector2_A.apply(null, nv) < 0.0) {
                        Geometry.reverseWinding$org_dyn4j_geometry_Vector2_A.apply(null, nv);
                    }
                    return new org.dyn4j.geometry.Polygon(nv);
                }
                /**
                 * Flips the given polygon about the given line and returns the result
                 * as a new polygon.
                 * @param {org.dyn4j.geometry.Polygon} polygon the polygon to flip
                 * @param {org.dyn4j.geometry.Vector2} axis the axis to flip about
                 * @param {org.dyn4j.geometry.Vector2} point the point to flip about; if null, the polygon center is used
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws NullPointerException if the given polygon or axis is null
                 * @throws IllegalArgumentException if the given axis is the zero vector
                 * @since 3.1.4
                 */
                static flip(polygon, axis, point) {
                    if (((polygon != null && polygon instanceof org.dyn4j.geometry.Polygon) || polygon === null) && ((axis != null && axis instanceof org.dyn4j.geometry.Vector2) || axis === null) && ((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null)) {
                        return org.dyn4j.geometry.Geometry.flip$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(polygon, axis, point);
                    }
                    else if (((polygon != null && polygon instanceof org.dyn4j.geometry.Polygon) || polygon === null) && ((typeof axis === 'boolean') || axis === null) && ((typeof point === 'boolean') || point === null)) {
                        return org.dyn4j.geometry.Geometry.flip$org_dyn4j_geometry_Polygon$boolean$boolean(polygon, axis, point);
                    }
                    else if (((polygon != null && (polygon.constructor != null && polygon.constructor["__interfaces"] != null && polygon.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || polygon === null) && ((typeof axis === 'boolean') || axis === null) && ((typeof point === 'boolean') || point === null)) {
                        return org.dyn4j.geometry.Geometry.flip$org_dyn4j_geometry_Convex$boolean$boolean(polygon, axis, point);
                    }
                    else if (((polygon != null && polygon instanceof org.dyn4j.geometry.Polygon) || polygon === null) && ((axis != null && axis instanceof org.dyn4j.geometry.Vector2) || axis === null) && point === undefined) {
                        return org.dyn4j.geometry.Geometry.flip$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Vector2(polygon, axis);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static minkowskiSum$org_dyn4j_geometry_Wound$org_dyn4j_geometry_Wound(convex1, convex2) {
                    if (convex1 == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullMinkowskiSumConvex"));
                    if (convex2 == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullMinkowskiSumConvex"));
                    const p1v = convex1.getVertices();
                    const p2v = convex2.getVertices();
                    if ((convex1 != null && convex1 instanceof org.dyn4j.geometry.Segment) && (convex2 != null && convex2 instanceof org.dyn4j.geometry.Segment)) {
                        const s1 = p1v[0].to$org_dyn4j_geometry_Vector2(p1v[1]);
                        const s2 = p2v[0].to$org_dyn4j_geometry_Vector2(p2v[1]);
                        if (s1.cross$org_dyn4j_geometry_Vector2(s2) <= org.dyn4j.Epsilon.E_$LI$()) {
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidMinkowskiSumSegments"));
                        }
                    }
                    const c1 = p1v.length;
                    const c2 = p2v.length;
                    let i = 0;
                    let j = 0;
                    const min = new org.dyn4j.geometry.Vector2(javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    for (let k = 0; k < c1; k++) {
                        {
                            const v = p1v[k];
                            if (v.y < min.y) {
                                min.set$org_dyn4j_geometry_Vector2(v);
                                i = k;
                            }
                            else if (v.y === min.y) {
                                if (v.x < min.x) {
                                    min.set$org_dyn4j_geometry_Vector2(v);
                                    i = k;
                                }
                            }
                        }
                        ;
                    }
                    min.set$double$double(javaemul.internal.DoubleHelper.MAX_VALUE, javaemul.internal.DoubleHelper.MAX_VALUE);
                    for (let k = 0; k < c2; k++) {
                        {
                            const v = p2v[k];
                            if (v.y < min.y) {
                                min.set$org_dyn4j_geometry_Vector2(v);
                                j = k;
                            }
                            else if (v.y === min.y) {
                                if (v.x < min.x) {
                                    min.set$org_dyn4j_geometry_Vector2(v);
                                    j = k;
                                }
                            }
                        }
                        ;
                    }
                    const n1 = c1 + i;
                    const n2 = c2 + j;
                    const sum = (new java.util.ArrayList(c1 + c2));
                    for (; i <= n1 && j <= n2;) {
                        {
                            const v1s = p1v[i % c1];
                            const v1e = p1v[(i + 1) % c1];
                            const v2s = p2v[j % c2];
                            const v2e = p2v[(j + 1) % c2];
                            sum.add(v1s.sum$org_dyn4j_geometry_Vector2(v2s));
                            const e1 = v1s.to$org_dyn4j_geometry_Vector2(v1e);
                            const e2 = v2s.to$org_dyn4j_geometry_Vector2(v2e);
                            let a1 = org.dyn4j.geometry.Vector2.X_AXIS_$LI$().getAngleBetween$org_dyn4j_geometry_Vector2(e1);
                            let a2 = org.dyn4j.geometry.Vector2.X_AXIS_$LI$().getAngleBetween$org_dyn4j_geometry_Vector2(e2);
                            if (a1 < 0)
                                a1 += Geometry.TWO_PI_$LI$();
                            if (a2 < 0)
                                a2 += Geometry.TWO_PI_$LI$();
                            if (a1 < a2) {
                                i++;
                            }
                            else if (a1 > a2) {
                                j++;
                            }
                            else {
                                i++;
                                j++;
                            }
                        }
                        ;
                    }
                    return new org.dyn4j.geometry.Polygon(sum.toArray([]));
                }
                static minkowskiSum$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Polygon$int(circle, polygon, count) {
                    return Geometry.minkowskiSum$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Circle$int(polygon, circle, count);
                }
                /**
                 * Performs the Minkowski Sum of the given {@link Polygon} and {@link Circle}.
                 * <p>
                 * Use the count parameter to specify the number of vertices to use per round corner.
                 * <p>
                 * If the given polygon has <i>n</i> number of vertices, the returned polygon will have
                 * <i>n * 2 + n * count</i> number of vertices.
                 * <p>
                 * This method is O(n) where n is the number of vertices in the given polygon.
                 * @param {org.dyn4j.geometry.Polygon} polygon the polygon
                 * @param {org.dyn4j.geometry.Circle} circle the circle to add to the polygon
                 * @param {number} count the number of vertices to add for each rounded corner; must be greater than zero
                 * @return {org.dyn4j.geometry.Polygon} {@link Polygon}
                 * @throws NullPointerException if the given polygon or circle is null
                 * @throws IllegalArgumentException if the given radius or count is less than or equal to zero
                 * @since 3.1.5
                 * @see #minkowskiSum(Polygon, double, int)
                 */
                static minkowskiSum(circle, polygon, count) {
                    if (((circle != null && circle instanceof org.dyn4j.geometry.Circle) || circle === null) && ((polygon != null && polygon instanceof org.dyn4j.geometry.Polygon) || polygon === null) && ((typeof count === 'number') || count === null)) {
                        return org.dyn4j.geometry.Geometry.minkowskiSum$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Polygon$int(circle, polygon, count);
                    }
                    else if (((circle != null && circle instanceof org.dyn4j.geometry.Polygon) || circle === null) && ((polygon != null && polygon instanceof org.dyn4j.geometry.Circle) || polygon === null) && ((typeof count === 'number') || count === null)) {
                        return org.dyn4j.geometry.Geometry.minkowskiSum$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Circle$int(circle, polygon, count);
                    }
                    else if (((circle != null && circle instanceof org.dyn4j.geometry.Polygon) || circle === null) && ((typeof polygon === 'number') || polygon === null) && ((typeof count === 'number') || count === null)) {
                        return org.dyn4j.geometry.Geometry.minkowskiSum$org_dyn4j_geometry_Polygon$double$int(circle, polygon, count);
                    }
                    else if (((circle != null) || circle === null) && ((polygon != null) || polygon === null) && count === undefined) {
                        return org.dyn4j.geometry.Geometry.minkowskiSum$org_dyn4j_geometry_Wound$org_dyn4j_geometry_Wound(circle, polygon);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static minkowskiSum$org_dyn4j_geometry_Polygon$org_dyn4j_geometry_Circle$int(polygon, circle, count) {
                    if (circle == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullMinkowskiSumCircle"));
                    return Geometry.minkowskiSum$org_dyn4j_geometry_Polygon$double$int(polygon, circle.radius, count);
                }
                static minkowskiSum$org_dyn4j_geometry_Polygon$double$int(polygon, radius, count) {
                    if (polygon == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullMinkowskiSumPolygon"));
                    if (radius <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidMinkowskiSumRadius"));
                    if (count <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidMinkowskiSumCount"));
                    const vertices = polygon.vertices;
                    const normals = polygon.normals;
                    const size = vertices.length;
                    const nVerts = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size * 2 + size * count);
                    let j = 0;
                    for (let i = 0; i < size; i++) {
                        {
                            const v1 = vertices[i];
                            const v2 = vertices[i + 1 === size ? 0 : i + 1];
                            const normal = normals[i];
                            const nv1 = normal.product(radius).add$org_dyn4j_geometry_Vector2(v1);
                            const nv2 = normal.product(radius).add$org_dyn4j_geometry_Vector2(v2);
                            let cv1 = null;
                            if (i === 0) {
                                const tn = normals[size - 1];
                                cv1 = v1.to$org_dyn4j_geometry_Vector2(tn.product(radius).add$org_dyn4j_geometry_Vector2(v1));
                            }
                            else {
                                cv1 = v1.to$org_dyn4j_geometry_Vector2(nVerts[j - 1]);
                            }
                            const cv2 = v1.to$org_dyn4j_geometry_Vector2(nv1);
                            const theta = cv1.getAngleBetween$org_dyn4j_geometry_Vector2(cv2);
                            const pin = theta / (count + 1);
                            const c = Math.cos(pin);
                            const s = Math.sin(pin);
                            let t = 0;
                            let sTheta = org.dyn4j.geometry.Vector2.X_AXIS_$LI$().getAngleBetween$org_dyn4j_geometry_Vector2(normals[i - 1 < 0 ? size - 1 : i - 1]);
                            if (sTheta < 0) {
                                sTheta += Geometry.TWO_PI_$LI$();
                            }
                            let x = radius * Math.cos(sTheta);
                            let y = radius * Math.sin(sTheta);
                            for (let k = 0; k < count; k++) {
                                {
                                    t = x;
                                    x = c * x - s * y;
                                    y = s * t + c * y;
                                    nVerts[j++] = new org.dyn4j.geometry.Vector2(x, y).add$org_dyn4j_geometry_Vector2(v1);
                                }
                                ;
                            }
                            nVerts[j++] = nv1;
                            nVerts[j++] = nv2;
                        }
                        ;
                    }
                    return new org.dyn4j.geometry.Polygon(nVerts);
                }
                static scale$org_dyn4j_geometry_Circle$double(circle, scale) {
                    if (circle == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (scale <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    return new org.dyn4j.geometry.Circle(circle.radius * scale);
                }
                static scale$org_dyn4j_geometry_Capsule$double(capsule, scale) {
                    if (capsule == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (scale <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    return new org.dyn4j.geometry.Capsule(capsule.getLength() * scale, capsule.getCapRadius() * 2.0 * scale);
                }
                static scale$org_dyn4j_geometry_Ellipse$double(ellipse, scale) {
                    if (ellipse == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (scale <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    return new org.dyn4j.geometry.Ellipse(ellipse.getWidth() * scale, ellipse.getHeight() * scale);
                }
                static scale$org_dyn4j_geometry_HalfEllipse$double(halfEllipse, scale) {
                    if (halfEllipse == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (scale <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    return new org.dyn4j.geometry.HalfEllipse(halfEllipse.getWidth() * scale, halfEllipse.getHeight() * scale);
                }
                static scale$org_dyn4j_geometry_Slice$double(slice, scale) {
                    if (slice == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (scale <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    return new org.dyn4j.geometry.Slice(slice.getSliceRadius() * scale, slice.getTheta());
                }
                static scale$org_dyn4j_geometry_Polygon$double(polygon, scale) {
                    if (polygon == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (scale <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    const oVertices = polygon.vertices;
                    const size = oVertices.length;
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size);
                    const center = polygon.center;
                    for (let i = 0; i < size; i++) {
                        {
                            vertices[i] = center.to$org_dyn4j_geometry_Vector2(oVertices[i]).multiply(scale).add$org_dyn4j_geometry_Vector2(center);
                        }
                        ;
                    }
                    return new org.dyn4j.geometry.Polygon(vertices);
                }
                static scale$org_dyn4j_geometry_Segment$double(segment, scale) {
                    if (segment == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (scale <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    const length = segment.getLength() * scale * 0.5;
                    const n = segment.vertices[0].to$org_dyn4j_geometry_Vector2(segment.vertices[1]);
                    n.normalize();
                    n.multiply(length);
                    return new org.dyn4j.geometry.Segment(segment.center.sum$double$double(n.x, n.y), segment.center.difference$double$double(n.x, n.y));
                }
                static createLinks$java_util_List$boolean(vertices, closed) {
                    return Geometry.createLinks$org_dyn4j_geometry_Vector2_A$boolean(vertices.toArray([]), closed);
                }
                /**
                 * Creates a list of {@link Link}s for the given vertices.
                 * <p>
                 * If the closed parameter is true, an extra link is created joining the last and first
                 * vertices in the list.
                 * @param {*} vertices the poly-line vertices
                 * @param {boolean} closed true if the shape should be enclosed
                 * @return {*} List&lt;{@link Link}&gt;
                 * @throws NullPointerException if the list of vertices is null or an element of the vertex list is null
                 * @throws IllegalArgumentException if the list of vertices doesn't contain 2 or more elements
                 * @since 3.2.2
                 */
                static createLinks(vertices, closed) {
                    if (((vertices != null && (vertices.constructor != null && vertices.constructor["__interfaces"] != null && vertices.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || vertices === null) && ((typeof closed === 'boolean') || closed === null)) {
                        return org.dyn4j.geometry.Geometry.createLinks$java_util_List$boolean(vertices, closed);
                    }
                    else if (((vertices != null && vertices instanceof Array && (vertices.length == 0 || vertices[0] == null || (vertices[0] != null && vertices[0] instanceof org.dyn4j.geometry.Vector2))) || vertices === null) && ((typeof closed === 'boolean') || closed === null)) {
                        return org.dyn4j.geometry.Geometry.createLinks$org_dyn4j_geometry_Vector2_A$boolean(vertices, closed);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static createLinks$org_dyn4j_geometry_Vector2_A$boolean(vertices, closed) {
                    if (vertices == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointArray"));
                    const size = vertices.length;
                    if (size < 2)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidSizePointList2"));
                    const links = (new java.util.ArrayList());
                    for (let i = 0; i < size - 1; i++) {
                        {
                            const p1 = vertices[i].copy();
                            const p2 = vertices[i + 1].copy();
                            if (p1 == null || p2 == null) {
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullPointListElements"));
                            }
                            const link = new org.dyn4j.geometry.Link(p1, p2);
                            if (i > 0) {
                                const prev = links.get(i - 1);
                                link.setPrevious(prev);
                            }
                            links.add(link);
                        }
                        ;
                    }
                    if (closed) {
                        const p1 = vertices[0].copy();
                        const p2 = vertices[size - 1].copy();
                        const link = new org.dyn4j.geometry.Link(p1, p2);
                        const prev = links.get(links.size() - 1);
                        const next = links.get(0);
                        link.setPrevious(prev);
                        link.setNext(next);
                        links.add(link);
                    }
                    return links;
                }
                /**
                 * Creates a new polygon that surrounds a line connecting multiple points.
                 *
                 * @param {number} width the line
                 * @param height the bounding rectangle height
                 * @return {org.dyn4j.geometry.Convex[]} {@link Parabola}
                 * @throws IllegalArgumentException if width or height is less than or equal to zero;
                 * @since 3.1.10
                 * @param {org.dyn4j.geometry.Vector2[]} vertices
                 */
                static createPolygonalLine(vertices, width) {
                    if (vertices == null || vertices.length < 2)
                        return null;
                    const polygons = (new java.util.ArrayList());
                    const indent = width / 2;
                    let v1 = vertices[0].copy();
                    let v2 = vertices[1].copy();
                    let l = v1.to$org_dyn4j_geometry_Vector2(v2);
                    let length = l.getMagnitude();
                    let dx = indent * l.x / length;
                    let dy = indent * l.y / length;
                    let p1 = new org.dyn4j.geometry.Vector2(v1.x - dy, v1.y + dx);
                    let p2 = new org.dyn4j.geometry.Vector2(v1.x + dy, v1.y - dx);
                    let p3 = new org.dyn4j.geometry.Vector2(v2.x + dy, v2.y - dx);
                    let p4 = new org.dyn4j.geometry.Vector2(v2.x - dy, v2.y + dx);
                    if (vertices.length === 2) {
                        polygons.add(new org.dyn4j.geometry.Polygon([p1, p2, p3, p4]));
                        return polygons.toArray([]);
                    }
                    for (let i = 2; i < vertices.length; i++) {
                        {
                            v1.copy();
                            v1 = v2.copy();
                            v2 = vertices[i].copy();
                            if (v1.approxEqual(v2)) {
                                if (i === vertices.length - 1) {
                                    polygons.add(new org.dyn4j.geometry.Polygon([p1, p2, p3, p4]));
                                    break;
                                }
                                continue;
                            }
                            l = v1.to$org_dyn4j_geometry_Vector2(v2);
                            length = l.getMagnitude();
                            dx = indent * l.x / length;
                            dy = indent * l.y / length;
                            const pt1 = new org.dyn4j.geometry.Vector2(v1.x - dy, v1.y + dx);
                            const pt2 = new org.dyn4j.geometry.Vector2(v1.x + dy, v1.y - dx);
                            const pt3 = new org.dyn4j.geometry.Vector2(v2.x + dy, v2.y - dx);
                            const pt4 = new org.dyn4j.geometry.Vector2(v2.x - dy, v2.y + dx);
                            const i1 = org.dyn4j.geometry.Segment.getLineIntersection(p2, p3, pt2, pt3);
                            const i2 = org.dyn4j.geometry.Segment.getLineIntersection(p1, p4, pt1, pt4);
                            if (i1 == null || i2 == null) {
                                continue;
                            }
                            polygons.add(new org.dyn4j.geometry.Polygon([p1, p2, i1, i2]));
                            p1 = i1;
                            p2 = i2;
                            p3 = pt3;
                            p4 = pt4;
                        }
                        ;
                    }
                    return polygons.toArray([]);
                }
                /**
                 * Returns the intersection point of the two lines  or null if they are parallel, coincident
                 * or don't intersect.
                 * <p>
                 * If the segments are parallel, or are coincident, null is returned.
                 * @param {org.dyn4j.geometry.Vector2} ap1 the first point of the first line segment
                 * @param {org.dyn4j.geometry.Vector2} ap2 the second point of the first line segment
                 * @param {org.dyn4j.geometry.Vector2} bp1 the first point of the second line segment
                 * @param {org.dyn4j.geometry.Vector2} bp2 the second point of the second line segment
                 * @return {org.dyn4j.geometry.Vector2} Vector2 the intersection point; null if the lines are parallel, or are coincident
                 * @see #getLineIntersection(Vector2, Vector2, Vector2, Vector2)
                 * @throws NullPointerException if ap1, ap2, bp1, or bp2 is null
                 * @since 3.1.1
                 */
                static getLineIntersection(ap1, ap2, bp1, bp2) {
                    const A = ap1.to$org_dyn4j_geometry_Vector2(ap2);
                    const B = bp1.to$org_dyn4j_geometry_Vector2(bp2);
                    const BxA = B.cross$org_dyn4j_geometry_Vector2(A);
                    if (Math.abs(BxA) <= org.dyn4j.Epsilon.E_$LI$()) {
                        return null;
                    }
                    const ambxA = ap1.difference$org_dyn4j_geometry_Vector2(bp1).cross$org_dyn4j_geometry_Vector2(A);
                    if (Math.abs(ambxA) <= org.dyn4j.Epsilon.E_$LI$()) {
                        return null;
                    }
                    const tb = ambxA / BxA;
                    if (tb < 0.0 || tb > 1.0) {
                        return null;
                    }
                    const ip = B.product(tb).add$org_dyn4j_geometry_Vector2(bp1);
                    return ip;
                }
                /**
                 * Returns polygonal equivalent of the shape
                 * @param s Shape to be converted to equivalent polygon
                 * @param {number} count the number of vertices to use; must be greater than 4
                 * @return {org.dyn4j.geometry.Polygon} Equivalent polygon for the shape transformed with current shape's transform
                 * @param {*} shape
                 */
                static shapeToPolygon(shape, count) {
                    if (count < 4)
                        count = 4;
                    let poly = null;
                    if (shape != null && shape instanceof org.dyn4j.geometry.Circle) {
                        const c = shape;
                        poly = Geometry.createPolygonalCircle$int$double(count, c.getRadius$());
                        poly.translate$org_dyn4j_geometry_Vector2(c.getCenter());
                    }
                    else if (shape != null && shape instanceof org.dyn4j.geometry.Slice) {
                        const s = shape;
                        count = (Math.max(s.getTheta() * count / Math.PI / 2, 3) | 0);
                        poly = Geometry.createPolygonalSliceAtOrigin(count, s.getSliceRadius(), s.getTheta());
                        poly.rotate$org_dyn4j_geometry_Rotation(s.getRotation());
                        poly.translate$org_dyn4j_geometry_Vector2(s.getCenter());
                    }
                    else if (shape != null && shape instanceof org.dyn4j.geometry.Ellipse) {
                        const p = shape;
                        poly = Geometry.createPolygonalEllipse(count, p.getWidth(), p.getHeight());
                        poly.rotate$org_dyn4j_geometry_Rotation(p.getRotation());
                        poly.translate$org_dyn4j_geometry_Vector2(p.getCenter());
                    }
                    else if (shape != null && shape instanceof org.dyn4j.geometry.Capsule) {
                        const cap = shape;
                        poly = Geometry.createPolygonalCapsule(count, cap.getLength(), 2 * cap.getCapRadius());
                        poly.rotate$org_dyn4j_geometry_Rotation(cap.getRotation());
                        poly.translate$org_dyn4j_geometry_Vector2(cap.getCenter());
                    }
                    else if (shape != null && shape instanceof org.dyn4j.geometry.Parabola) {
                        const p = shape;
                        count = (count / 2 | 0) + 2;
                        poly = Geometry.createPolygonalParabolaAtOrigin(count, p.getWidth(), p.getHeight());
                        poly.rotate$double(p.getRotation());
                        poly.translate$org_dyn4j_geometry_Vector2(p.getCenter());
                    }
                    else if (shape != null && shape instanceof org.dyn4j.geometry.Polygon) {
                        poly = shape;
                    }
                    return poly;
                }
                static scale$org_dyn4j_geometry_Ring$double(ring, scale) {
                    if (ring == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (scale <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    return new org.dyn4j.geometry.Ring(ring.radius * scale);
                }
                static scale$org_dyn4j_geometry_Rectangle$double$double(rect, xScale, yScale) {
                    if (rect == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (xScale <= 0 || yScale < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    return new org.dyn4j.geometry.Rectangle(rect.getWidth() * xScale, rect.getHeight() * yScale);
                }
                /**
                 * Returns a scaled version of the given rectangle.
                 * @param {org.dyn4j.geometry.Rectangle} rect the Rectangle
                 * @param {number} xScale the scale; must be greater than zero
                 * @param {number} yScale the scale; must be greater than zero
                 * @return {org.dyn4j.geometry.Rectangle} {@link Rectangle}
                 * @throws NullPointerException if the given circle is null
                 * @throws IllegalArgumentException if the given scale is less than or equal to zero
                 * @since 3.1.5
                 */
                static scale(rect, xScale, yScale) {
                    if (((rect != null && rect instanceof org.dyn4j.geometry.Rectangle) || rect === null) && ((typeof xScale === 'number') || xScale === null) && ((typeof yScale === 'number') || yScale === null)) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Rectangle$double$double(rect, xScale, yScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Capsule) || rect === null) && ((typeof xScale === 'number') || xScale === null) && ((typeof yScale === 'number') || yScale === null)) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Capsule$double$double(rect, xScale, yScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Parabola) || rect === null) && ((typeof xScale === 'number') || xScale === null) && ((typeof yScale === 'number') || yScale === null)) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Parabola$double$double(rect, xScale, yScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Ellipse) || rect === null) && ((typeof xScale === 'number') || xScale === null) && ((typeof yScale === 'number') || yScale === null)) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Ellipse$double$double(rect, xScale, yScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.HalfEllipse) || rect === null) && ((typeof xScale === 'number') || xScale === null) && ((typeof yScale === 'number') || yScale === null)) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_HalfEllipse$double$double(rect, xScale, yScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Slice) || rect === null) && ((typeof xScale === 'number') || xScale === null) && ((typeof yScale === 'number') || yScale === null)) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Slice$double$double(rect, xScale, yScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Polygon) || rect === null) && ((typeof xScale === 'number') || xScale === null) && ((typeof yScale === 'number') || yScale === null)) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Polygon$double$double(rect, xScale, yScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Link) || rect === null) && ((typeof xScale === 'number') || xScale === null) && ((typeof yScale === 'number') || yScale === null)) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Link$double$double(rect, xScale, yScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Segment) || rect === null) && ((typeof xScale === 'number') || xScale === null) && ((typeof yScale === 'number') || yScale === null)) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Segment$double$double(rect, xScale, yScale);
                    }
                    else if (((rect != null && (rect.constructor != null && rect.constructor["__interfaces"] != null && rect.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || rect === null) && ((typeof xScale === 'number') || xScale === null) && ((typeof yScale === 'number') || yScale === null)) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Convex$double$double(rect, xScale, yScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Circle) || rect === null) && ((typeof xScale === 'number') || xScale === null) && yScale === undefined) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Circle$double(rect, xScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Capsule) || rect === null) && ((typeof xScale === 'number') || xScale === null) && yScale === undefined) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Capsule$double(rect, xScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Ellipse) || rect === null) && ((typeof xScale === 'number') || xScale === null) && yScale === undefined) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Ellipse$double(rect, xScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.HalfEllipse) || rect === null) && ((typeof xScale === 'number') || xScale === null) && yScale === undefined) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_HalfEllipse$double(rect, xScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Slice) || rect === null) && ((typeof xScale === 'number') || xScale === null) && yScale === undefined) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Slice$double(rect, xScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Polygon) || rect === null) && ((typeof xScale === 'number') || xScale === null) && yScale === undefined) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Polygon$double(rect, xScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Segment) || rect === null) && ((typeof xScale === 'number') || xScale === null) && yScale === undefined) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Segment$double(rect, xScale);
                    }
                    else if (((rect != null && rect instanceof org.dyn4j.geometry.Ring) || rect === null) && ((typeof xScale === 'number') || xScale === null) && yScale === undefined) {
                        return org.dyn4j.geometry.Geometry.scale$org_dyn4j_geometry_Ring$double(rect, xScale);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static scale$org_dyn4j_geometry_Capsule$double$double(capsule, xScale, yScale) {
                    if (capsule == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (xScale <= 0 || yScale < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    return new org.dyn4j.geometry.Capsule(capsule.length * xScale, capsule.capRadius * 2.0 * yScale);
                }
                static scale$org_dyn4j_geometry_Parabola$double$double(parabola, xScale, yScale) {
                    if (parabola == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (xScale <= 0 || yScale < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    const p = new org.dyn4j.geometry.Parabola(parabola.getWidth() * xScale, parabola.getHeight() * yScale);
                    p.translate$org_dyn4j_geometry_Vector2(p.getCenter().getNegative());
                    return p;
                }
                static scale$org_dyn4j_geometry_Ellipse$double$double(ellipse, xScale, yScale) {
                    if (ellipse == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (xScale <= 0 || yScale < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    return new org.dyn4j.geometry.Ellipse(ellipse.getWidth() * xScale, ellipse.getHeight() * yScale);
                }
                static scale$org_dyn4j_geometry_HalfEllipse$double$double(halfEllipse, xScale, yScale) {
                    if (halfEllipse == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (xScale <= 0 || yScale < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    const he = new org.dyn4j.geometry.HalfEllipse(halfEllipse.getWidth() * xScale, halfEllipse.height * xScale);
                    he.translate$org_dyn4j_geometry_Vector2(he.getCenter().getNegative());
                    return he;
                }
                static scale$org_dyn4j_geometry_Slice$double$double(slice, xScale, yScale) {
                    if (slice == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (xScale <= 0 || yScale < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    const s = new org.dyn4j.geometry.Slice(slice.sliceRadius * xScale, slice.getTheta());
                    s.translate$org_dyn4j_geometry_Vector2(s.getCenter().getNegative());
                    return s;
                }
                static scale$org_dyn4j_geometry_Polygon$double$double(polygon, xScale, yScale) {
                    if (polygon == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (xScale <= 0 || yScale < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    const oVertices = polygon.vertices;
                    const size = oVertices.length;
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size);
                    const center = polygon.center;
                    for (let i = 0; i < size; i++) {
                        {
                            vertices[i] = center.to$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(oVertices[i].x * xScale, oVertices[i].y * yScale)).add$org_dyn4j_geometry_Vector2(center);
                        }
                        ;
                    }
                    const p = new org.dyn4j.geometry.Polygon(vertices);
                    p.translate$org_dyn4j_geometry_Vector2(p.getCenter().getNegative());
                    return p;
                }
                static scale$org_dyn4j_geometry_Segment$double$double(segment, xScale, yScale) {
                    if (segment == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (xScale <= 0 || yScale < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    const oVertices = segment.vertices;
                    const size = oVertices.length;
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size);
                    const center = segment.center;
                    for (let i = 0; i < size; i++) {
                        {
                            vertices[i] = center.to$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(oVertices[i].x * xScale, oVertices[i].y * yScale)).add$org_dyn4j_geometry_Vector2(center);
                        }
                        ;
                    }
                    const s = new org.dyn4j.geometry.Segment(vertices[0], vertices[1]);
                    s.translate$org_dyn4j_geometry_Vector2(segment.center.getNegative());
                    return s;
                }
                static scale$org_dyn4j_geometry_Link$double$double(link, xScale, yScale) {
                    if (link == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (xScale <= 0 || yScale < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    const oVertices = [null, null];
                    oVertices[0] = link.vertices[0];
                    oVertices[1] = link.vertices[1];
                    const vertices = [null, null];
                    const center = link.center;
                    for (let i = 0; i < 2; i++) {
                        {
                            if (oVertices[i] != null) {
                                vertices[i] = center.to$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(oVertices[i].x * xScale, oVertices[i].y * yScale)).add$org_dyn4j_geometry_Vector2(center);
                            }
                            else {
                                vertices[i] = null;
                            }
                        }
                        ;
                    }
                    const s = new org.dyn4j.geometry.Link(vertices[0], vertices[1]);
                    s.translate$org_dyn4j_geometry_Vector2(s.getCenter().getNegative());
                    s.setPrevious(link.getPrevious());
                    s.setNext(link.getNext());
                    return s;
                }
                static scale$org_dyn4j_geometry_Convex$double$double(s, xScale, yScale) {
                    if (s == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (xScale <= 0 || yScale <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.invalidScale"));
                    let newShape;
                    const center = s.getCenter();
                    if (s != null && s instanceof org.dyn4j.geometry.Circle) {
                        const c = s;
                        if (xScale !== yScale) {
                            newShape = new org.dyn4j.geometry.Ellipse(2 * c.getRadius$() * xScale, 2 * c.getRadius$() * yScale);
                        }
                        else {
                            newShape = Geometry.scale$org_dyn4j_geometry_Circle$double(c, xScale);
                            newShape.isRuler = c.isRuler;
                        }
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Ellipse) {
                        const e = s;
                        if (Math.abs(xScale * e.halfWidth - yScale * e.halfHeight) < 0.002) {
                            newShape = new org.dyn4j.geometry.Circle(xScale * e.halfWidth);
                        }
                        else {
                            newShape = Geometry.scale$org_dyn4j_geometry_Ellipse$double$double(e, xScale, yScale);
                        }
                        newShape['rotate$org_dyn4j_geometry_Rotation'](e.getRotation());
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Capsule) {
                        const c = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Capsule$double$double(c, xScale, yScale);
                        newShape['rotate$org_dyn4j_geometry_Rotation'](c.getRotation());
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Slice) {
                        const sl = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Slice$double$double(sl, xScale, yScale);
                        newShape['rotate$org_dyn4j_geometry_Rotation'](sl.getRotation());
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Rectangle) {
                        const r = s;
                        s.getCenter();
                        newShape = Geometry.scale$org_dyn4j_geometry_Rectangle$double$double(r, xScale, yScale);
                        newShape.isRuler = r.isRuler;
                        newShape['rotate$org_dyn4j_geometry_Rotation'](r.getRotation());
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Polygon) {
                        const p = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Polygon$double$double(p, xScale, yScale);
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Parabola) {
                        const p = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Parabola$double$double(p, xScale, yScale);
                        newShape['rotate$double'](p.getRotation());
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Link) {
                        const p = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Link$double$double(p, xScale, yScale);
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Segment) {
                        const p = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Segment$double$double(p, xScale, yScale);
                    }
                    else {
                        return s;
                    }
                    newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(center.x * xScale, center.y * yScale));
                    return newShape;
                }
                static flip$org_dyn4j_geometry_Convex$boolean$boolean(s, aboutX, aboutY) {
                    if (s == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    let newShape;
                    if (s != null && s instanceof org.dyn4j.geometry.Ring) {
                        const c = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Ring$double(c, 1);
                        newShape = Geometry.scale$org_dyn4j_geometry_Ring$double(c, 1);
                        if (aboutY)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(-c.getCenter().x, c.getCenter().y));
                        if (aboutX)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(c.getCenter().x, -c.getCenter().y));
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Circle) {
                        const c = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Circle$double(c, 1);
                        newShape = Geometry.scale$org_dyn4j_geometry_Circle$double(c, 1);
                        newShape.isRuler = c.isRuler;
                        if (aboutY)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(-c.getCenter().x, c.getCenter().y));
                        if (aboutX)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(c.getCenter().x, -c.getCenter().y));
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Ellipse) {
                        const e = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Ellipse$double$double(e, 1, 1);
                        newShape['rotate$double'](-e.getRotationAngle());
                        if (aboutY)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(-e.getCenter().x, e.getCenter().y));
                        if (aboutX)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(e.getCenter().x, -e.getCenter().y));
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Capsule) {
                        const c = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Capsule$double$double(c, 1, 1);
                        newShape['rotate$double'](-c.getRotationAngle());
                        if (aboutY)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(-c.getCenter().x, c.getCenter().y));
                        if (aboutX)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(c.getCenter().x, -c.getCenter().y));
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Rectangle) {
                        const r = s;
                        newShape = Geometry.createRectangle(r.getWidth(), r.getHeight());
                        newShape.isRuler = r.isRuler;
                        newShape['rotate$double'](-r.getRotationAngle());
                        if (aboutY)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(-r.getCenter().x, r.getCenter().y));
                        if (aboutX)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(r.getCenter().x, -r.getCenter().y));
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Slice) {
                        const sl = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Slice$double$double(sl, 1, 1);
                        newShape['rotate$double'](-sl.getRotationAngle());
                        if (aboutY)
                            newShape.rotateAboutCenter(Math.PI);
                        if (aboutY)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(-sl.getCenter().x, sl.getCenter().y));
                        if (aboutX)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(sl.getCenter().x, -sl.getCenter().y));
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Parabola) {
                        const p = s;
                        newShape = Geometry.scale$org_dyn4j_geometry_Parabola$double$double(p, 1, 1);
                        newShape['rotate$double'](-p.getRotation());
                        if (aboutY)
                            newShape.rotateAboutCenter(Math.PI);
                        if (aboutY)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(-p.getCenter().x, p.getCenter().y));
                        if (aboutX)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(p.getCenter().x, -p.getCenter().y));
                    }
                    else if (s != null && s instanceof org.dyn4j.geometry.Polygon) {
                        const p = s;
                        newShape = Geometry.flip$org_dyn4j_geometry_Polygon$boolean$boolean(p, aboutX, aboutY);
                        if (aboutY)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(-p.getCenter().x, p.getCenter().y));
                        if (aboutX)
                            newShape['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(p.getCenter().x, -p.getCenter().y));
                    }
                    else {
                        return s;
                    }
                    return newShape;
                }
                /*private*/ static flipHorizontally(polygon) {
                    if (polygon == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    const oVertices = polygon.vertices;
                    const size = oVertices.length;
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size);
                    for (let i = 0; i < size; i++) {
                        {
                            vertices[size - i - 1] = oVertices[i].sum$double$double(-2 * oVertices[i].x, 0);
                        }
                        ;
                    }
                    const p = new org.dyn4j.geometry.Polygon(vertices);
                    p.translate$org_dyn4j_geometry_Vector2(p.getCenter().getNegative());
                    return p;
                }
                /*private*/ static flipVertically(polygon) {
                    if (polygon == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    const oVertices = polygon.vertices;
                    const size = oVertices.length;
                    const vertices = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size);
                    for (let i = 0; i < size; i++) {
                        {
                            vertices[size - i - 1] = oVertices[i].sum$double$double(0, -2 * oVertices[i].y);
                        }
                        ;
                    }
                    const p = new org.dyn4j.geometry.Polygon(vertices);
                    p.translate$org_dyn4j_geometry_Vector2(p.getCenter().getNegative());
                    return p;
                }
                /*private*/ static flip$org_dyn4j_geometry_Polygon$boolean$boolean(polygon, aboutX, aboutY) {
                    if (polygon == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.nullShape"));
                    if (aboutX === true && aboutY === false) {
                        return Geometry.flipVertically(polygon);
                    }
                    else if (aboutX === false && aboutY === true) {
                        return Geometry.flipHorizontally(polygon);
                    }
                    else if (aboutX === true && aboutY === true) {
                        return Geometry.flipHorizontally(Geometry.flipVertically(polygon));
                    }
                    else {
                        return polygon;
                    }
                }
                static BoundingRectangle(points) {
                    const hullGenerator = new org.dyn4j.geometry.hull.GiftWrap();
                    const p = new org.dyn4j.geometry.Polygon((o => o.generate.apply(o, points))(hullGenerator));
                    let v1 = points[0];
                    let v2;
                    const T = new org.dyn4j.geometry.Transform();
                    let angle = 0;
                    let area = 0;
                    let minArea = javaemul.internal.DoubleHelper.MAX_VALUE;
                    let aabb = p.createAABB$org_dyn4j_geometry_Transform(T);
                    let rect = new org.dyn4j.geometry.Rectangle(aabb.getWidth(), aabb.getHeight());
                    for (let i = 0; i < points.length - 1; i++) {
                        {
                            v2 = points[i + 1];
                            const v = v1.to$org_dyn4j_geometry_Vector2(v2);
                            angle = v.getAngleWithPositiveXAxis();
                            T.setRotation$double(angle);
                            aabb = p.createAABB$org_dyn4j_geometry_Transform(T);
                            area = aabb.getArea();
                            if (area < minArea) {
                                minArea = area;
                                rect = new org.dyn4j.geometry.Rectangle(aabb.getWidth(), aabb.getHeight());
                                rect.rotate$double(-angle);
                            }
                            v1 = v2;
                        }
                        ;
                    }
                    return rect;
                }
                static BoundingEllipse(points) {
                    const rect = Geometry.BoundingRectangle(points);
                    const e = new org.dyn4j.geometry.Ellipse(rect.getWidth(), rect.getHeight());
                    e.rotate$org_dyn4j_geometry_Rotation(rect.getRotation());
                    return e;
                }
                static BoundingBox(points) {
                    if (points.length === 0) {
                        return new org.dyn4j.geometry.AABB(0, 0, 0, 0);
                    }
                    let minX = javaemul.internal.DoubleHelper.MAX_VALUE;
                    let maxX = -javaemul.internal.DoubleHelper.MAX_VALUE;
                    let minY = javaemul.internal.DoubleHelper.MAX_VALUE;
                    let maxY = -javaemul.internal.DoubleHelper.MAX_VALUE;
                    for (let index = 0; index < points.length; index++) {
                        let p = points[index];
                        {
                            if (p.x < minX)
                                minX = p.x;
                            if (p.x > maxX)
                                maxX = p.x;
                            if (p.y < minY)
                                minY = p.y;
                            if (p.y > maxY)
                                maxY = p.y;
                        }
                    }
                    return new org.dyn4j.geometry.AABB(minX, minY, maxX, maxY);
                }
            }
            /**
             * The value of 1/3
             */
            Geometry.INV_3 = 1.0 / 3.0;
            geometry.Geometry = Geometry;
            Geometry["__class"] = "org.dyn4j.geometry.Geometry";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * @param {number} m00 the element at 0,0
             * @param {number} m01 the element at 0,1
             * @param {number} m02 the element at 0,2
             * @param {number} m10 the element at 1,0
             * @param {number} m11 the element at 1,1
             * @param {number} m12 the element at 1,2
             * @param {number} m20 the element at 2,0
             * @param {number} m21 the element at 2,1
             * @param {number} m22 the element at 2,2
             * @class
             * @author William Bittle
             */
            class Matrix33 {
                constructor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
                    if (((typeof m00 === 'number') || m00 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m12 === 'number') || m12 === null) && ((typeof m20 === 'number') || m20 === null) && ((typeof m21 === 'number') || m21 === null) && ((typeof m22 === 'number') || m22 === null)) {
                        let __args = arguments;
                        if (this.m00 === undefined) {
                            this.m00 = 0;
                        }
                        if (this.m01 === undefined) {
                            this.m01 = 0;
                        }
                        if (this.m02 === undefined) {
                            this.m02 = 0;
                        }
                        if (this.m10 === undefined) {
                            this.m10 = 0;
                        }
                        if (this.m11 === undefined) {
                            this.m11 = 0;
                        }
                        if (this.m12 === undefined) {
                            this.m12 = 0;
                        }
                        if (this.m20 === undefined) {
                            this.m20 = 0;
                        }
                        if (this.m21 === undefined) {
                            this.m21 = 0;
                        }
                        if (this.m22 === undefined) {
                            this.m22 = 0;
                        }
                        this.m00 = m00;
                        this.m01 = m01;
                        this.m02 = m02;
                        this.m10 = m10;
                        this.m11 = m11;
                        this.m12 = m12;
                        this.m20 = m20;
                        this.m21 = m21;
                        this.m22 = m22;
                    }
                    else if (((m00 != null && m00 instanceof Array && (m00.length == 0 || m00[0] == null || (typeof m00[0] === 'number'))) || m00 === null) && m01 === undefined && m02 === undefined && m10 === undefined && m11 === undefined && m12 === undefined && m20 === undefined && m21 === undefined && m22 === undefined) {
                        let __args = arguments;
                        let values = __args[0];
                        if (this.m00 === undefined) {
                            this.m00 = 0;
                        }
                        if (this.m01 === undefined) {
                            this.m01 = 0;
                        }
                        if (this.m02 === undefined) {
                            this.m02 = 0;
                        }
                        if (this.m10 === undefined) {
                            this.m10 = 0;
                        }
                        if (this.m11 === undefined) {
                            this.m11 = 0;
                        }
                        if (this.m12 === undefined) {
                            this.m12 = 0;
                        }
                        if (this.m20 === undefined) {
                            this.m20 = 0;
                        }
                        if (this.m21 === undefined) {
                            this.m21 = 0;
                        }
                        if (this.m22 === undefined) {
                            this.m22 = 0;
                        }
                        if (values == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.matrix.nullArray"));
                        if (values.length !== 9)
                            throw new java.lang.IndexOutOfBoundsException(org.dyn4j.resources.Messages.getString("geometry.matrix.invalidLength9"));
                        this.m00 = values[0];
                        this.m01 = values[1];
                        this.m02 = values[2];
                        this.m10 = values[3];
                        this.m11 = values[4];
                        this.m12 = values[5];
                        this.m20 = values[6];
                        this.m21 = values[7];
                        this.m22 = values[8];
                    }
                    else if (((m00 != null && m00 instanceof org.dyn4j.geometry.Matrix33) || m00 === null) && m01 === undefined && m02 === undefined && m10 === undefined && m11 === undefined && m12 === undefined && m20 === undefined && m21 === undefined && m22 === undefined) {
                        let __args = arguments;
                        let matrix = __args[0];
                        if (this.m00 === undefined) {
                            this.m00 = 0;
                        }
                        if (this.m01 === undefined) {
                            this.m01 = 0;
                        }
                        if (this.m02 === undefined) {
                            this.m02 = 0;
                        }
                        if (this.m10 === undefined) {
                            this.m10 = 0;
                        }
                        if (this.m11 === undefined) {
                            this.m11 = 0;
                        }
                        if (this.m12 === undefined) {
                            this.m12 = 0;
                        }
                        if (this.m20 === undefined) {
                            this.m20 = 0;
                        }
                        if (this.m21 === undefined) {
                            this.m21 = 0;
                        }
                        if (this.m22 === undefined) {
                            this.m22 = 0;
                        }
                        this.m00 = matrix.m00;
                        this.m01 = matrix.m01;
                        this.m02 = matrix.m02;
                        this.m10 = matrix.m10;
                        this.m11 = matrix.m11;
                        this.m12 = matrix.m12;
                        this.m20 = matrix.m20;
                        this.m21 = matrix.m21;
                        this.m22 = matrix.m22;
                    }
                    else if (m00 === undefined && m01 === undefined && m02 === undefined && m10 === undefined && m11 === undefined && m12 === undefined && m20 === undefined && m21 === undefined && m22 === undefined) {
                        let __args = arguments;
                        if (this.m00 === undefined) {
                            this.m00 = 0;
                        }
                        if (this.m01 === undefined) {
                            this.m01 = 0;
                        }
                        if (this.m02 === undefined) {
                            this.m02 = 0;
                        }
                        if (this.m10 === undefined) {
                            this.m10 = 0;
                        }
                        if (this.m11 === undefined) {
                            this.m11 = 0;
                        }
                        if (this.m12 === undefined) {
                            this.m12 = 0;
                        }
                        if (this.m20 === undefined) {
                            this.m20 = 0;
                        }
                        if (this.m21 === undefined) {
                            this.m21 = 0;
                        }
                        if (this.m22 === undefined) {
                            this.m22 = 0;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns a copy of this {@link Matrix33}.
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33}
                 * @since 3.4.0
                 */
                copy() {
                    return new Matrix33(this);
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    const prime = 31;
                    let result = 1;
                    let temp;
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m00);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m01);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m02);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m10);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m11);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m12);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m20);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m21);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    temp = javaemul.internal.DoubleHelper.doubleToLongBits(this.m22);
                    result = prime * result + ((temp ^ (temp >>> 32)) | 0);
                    return result;
                }
                /**
                 *
                 * @param {*} obj
                 * @return {boolean}
                 */
                equals(obj) {
                    if (obj == null)
                        return false;
                    if (obj === this)
                        return true;
                    if (obj != null && obj instanceof org.dyn4j.geometry.Matrix33) {
                        const other = obj;
                        if (other.m00 === this.m00 && other.m01 === this.m01 && other.m02 === this.m02 && other.m10 === this.m10 && other.m11 === this.m11 && other.m12 === this.m12 && other.m20 === this.m20 && other.m21 === this.m21 && other.m22 === this.m22) {
                            return true;
                        }
                    }
                    return false;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("[").append(this.m00).append(" ").append(this.m01).append(" ").append(this.m02).append("][").append(this.m10).append(" ").append(this.m11).append(" ").append(this.m12).append("][").append(this.m20).append(" ").append(this.m21).append(" ").append(this.m22).append("]");
                    return sb.toString();
                }
                /**
                 * Adds the given {@link Matrix33} to this {@link Matrix33}
                 * returning this {@link Matrix33}.
                 * <pre>
                 * this = this + m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix33} matrix the {@link Matrix33} to add
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} this matrix
                 */
                add(matrix) {
                    this.m00 += matrix.m00;
                    this.m01 += matrix.m01;
                    this.m02 += matrix.m02;
                    this.m10 += matrix.m10;
                    this.m11 += matrix.m11;
                    this.m12 += matrix.m12;
                    this.m20 += matrix.m20;
                    this.m21 += matrix.m21;
                    this.m22 += matrix.m22;
                    return this;
                }
                /**
                 * Returns a new {@link Matrix33} that is the sum of this {@link Matrix33}
                 * and the given {@link Matrix33}.
                 * <pre>
                 * r = this + m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix33} matrix the {@link Matrix33} to add
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} a new matrix containing the result
                 */
                sum(matrix) {
                    return this.copy().add(matrix);
                }
                /**
                 * Subtracts the given {@link Matrix33} from this {@link Matrix33}
                 * returning this {@link Matrix33}.
                 * <pre>
                 * this = this - m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix33} matrix the {@link Matrix33} to subtract
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} this matrix
                 */
                subtract(matrix) {
                    this.m00 -= matrix.m00;
                    this.m01 -= matrix.m01;
                    this.m02 -= matrix.m02;
                    this.m10 -= matrix.m10;
                    this.m11 -= matrix.m11;
                    this.m12 -= matrix.m12;
                    this.m20 -= matrix.m20;
                    this.m21 -= matrix.m21;
                    this.m22 -= matrix.m22;
                    return this;
                }
                /**
                 * Returns a new {@link Matrix33} that is the difference of this {@link Matrix33}
                 * and the given {@link Matrix33}.
                 * <pre>
                 * r = this - m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix33} matrix the {@link Matrix33} to subtract
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} a new matrix containing the result
                 */
                difference(matrix) {
                    return this.copy().subtract(matrix);
                }
                multiply$org_dyn4j_geometry_Matrix33(matrix) {
                    const m00 = this.m00;
                    const m01 = this.m01;
                    const m02 = this.m02;
                    const m10 = this.m10;
                    const m11 = this.m11;
                    const m12 = this.m12;
                    const m20 = this.m20;
                    const m21 = this.m21;
                    const m22 = this.m22;
                    this.m00 = m00 * matrix.m00 + m01 * matrix.m10 + m02 * matrix.m20;
                    this.m01 = m00 * matrix.m01 + m01 * matrix.m11 + m02 * matrix.m21;
                    this.m02 = m00 * matrix.m02 + m01 * matrix.m12 + m02 * matrix.m22;
                    this.m10 = m10 * matrix.m00 + m11 * matrix.m10 + m12 * matrix.m20;
                    this.m11 = m10 * matrix.m01 + m11 * matrix.m11 + m12 * matrix.m21;
                    this.m12 = m10 * matrix.m02 + m11 * matrix.m12 + m12 * matrix.m22;
                    this.m20 = m20 * matrix.m00 + m21 * matrix.m10 + m22 * matrix.m20;
                    this.m21 = m20 * matrix.m01 + m21 * matrix.m11 + m22 * matrix.m21;
                    this.m22 = m20 * matrix.m02 + m21 * matrix.m12 + m22 * matrix.m22;
                    return this;
                }
                /**
                 * Multiplies this {@link Matrix33} by the given matrix {@link Matrix33}
                 * returning this {@link Matrix33}.
                 * <pre>
                 * this = this * m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix33} matrix the {@link Matrix33} to subtract
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} this matrix
                 */
                multiply(matrix) {
                    if (((matrix != null && matrix instanceof org.dyn4j.geometry.Matrix33) || matrix === null)) {
                        return this.multiply$org_dyn4j_geometry_Matrix33(matrix);
                    }
                    else if (((matrix != null && matrix instanceof org.dyn4j.geometry.Vector3) || matrix === null)) {
                        return this.multiply$org_dyn4j_geometry_Vector3(matrix);
                    }
                    else if (((typeof matrix === 'number') || matrix === null)) {
                        return this.multiply$double(matrix);
                    }
                    else
                        throw new Error('invalid overload');
                }
                product$org_dyn4j_geometry_Matrix33(matrix) {
                    return this.copy().multiply$org_dyn4j_geometry_Matrix33(matrix);
                }
                /**
                 * Returns a new {@link Matrix33} that is the product of this {@link Matrix33}
                 * and the given {@link Matrix33}.
                 * <pre>
                 * r = this * m
                 * </pre>
                 * @param {org.dyn4j.geometry.Matrix33} matrix the {@link Matrix33} to multiply
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} a new matrix containing the result
                 */
                product(matrix) {
                    if (((matrix != null && matrix instanceof org.dyn4j.geometry.Matrix33) || matrix === null)) {
                        return this.product$org_dyn4j_geometry_Matrix33(matrix);
                    }
                    else if (((matrix != null && matrix instanceof org.dyn4j.geometry.Vector3) || matrix === null)) {
                        return this.product$org_dyn4j_geometry_Vector3(matrix);
                    }
                    else if (((typeof matrix === 'number') || matrix === null)) {
                        return this.product$double(matrix);
                    }
                    else
                        throw new Error('invalid overload');
                }
                multiply$org_dyn4j_geometry_Vector3(vector) {
                    const x = vector.x;
                    const y = vector.y;
                    const z = vector.z;
                    vector.x = this.m00 * x + this.m01 * y + this.m02 * z;
                    vector.y = this.m10 * x + this.m11 * y + this.m12 * z;
                    vector.z = this.m20 * x + this.m21 * y + this.m22 * z;
                    return vector;
                }
                product$org_dyn4j_geometry_Vector3(vector) {
                    return this.multiply$org_dyn4j_geometry_Vector3(vector.copy());
                }
                /**
                 * Multiplies the given {@link Vector3} by this {@link Matrix33} and
                 * places the result in the given {@link Vector3}.
                 * <p style="white-space: pre;"> v = v<sup>T</sup> * this</p>
                 * @param {org.dyn4j.geometry.Vector3} vector the {@link Vector3} to multiply
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} the vector result
                 */
                multiplyT(vector) {
                    const x = vector.x;
                    const y = vector.y;
                    const z = vector.z;
                    vector.x = this.m00 * x + this.m10 * y + this.m20 * z;
                    vector.y = this.m01 * x + this.m11 * y + this.m21 * z;
                    vector.z = this.m02 * x + this.m12 * y + this.m22 * z;
                    return vector;
                }
                /**
                 * Multiplies the given {@link Vector3} by this {@link Matrix33} returning
                 * the result in a new {@link Vector3}.
                 * <p style="white-space: pre;"> r = v<sup>T</sup> * this</p>
                 * @param {org.dyn4j.geometry.Vector3} vector the {@link Vector3} to multiply
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} the vector result
                 */
                productT(vector) {
                    return this.multiplyT(vector.copy());
                }
                multiply$double(scalar) {
                    this.m00 *= scalar;
                    this.m01 *= scalar;
                    this.m02 *= scalar;
                    this.m10 *= scalar;
                    this.m11 *= scalar;
                    this.m12 *= scalar;
                    this.m20 *= scalar;
                    this.m21 *= scalar;
                    this.m22 *= scalar;
                    return this;
                }
                product$double(scalar) {
                    return this.copy().multiply$double(scalar);
                }
                /**
                 * Sets this {@link Matrix33} to an identity {@link Matrix33}.
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} this matrix
                 */
                identity() {
                    this.m00 = 1;
                    this.m01 = 0;
                    this.m02 = 0;
                    this.m10 = 0;
                    this.m11 = 1;
                    this.m12 = 0;
                    this.m20 = 0;
                    this.m21 = 0;
                    this.m22 = 1;
                    return this;
                }
                /**
                 * Sets this {@link Matrix33} to the transpose of this {@link Matrix33}.
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} this matrix
                 */
                transpose() {
                    let s;
                    s = this.m01;
                    this.m01 = this.m10;
                    this.m10 = s;
                    s = this.m02;
                    this.m02 = this.m20;
                    this.m20 = s;
                    s = this.m12;
                    this.m12 = this.m21;
                    this.m21 = s;
                    return this;
                }
                /**
                 * Returns the the transpose of this {@link Matrix33} in a new {@link Matrix33}.
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} a new matrix contianing the transpose
                 */
                getTranspose() {
                    const rm = new Matrix33();
                    rm.m00 = this.m00;
                    rm.m01 = this.m10;
                    rm.m02 = this.m20;
                    rm.m10 = this.m01;
                    rm.m11 = this.m11;
                    rm.m12 = this.m21;
                    rm.m20 = this.m02;
                    rm.m21 = this.m12;
                    rm.m22 = this.m22;
                    return rm;
                }
                /**
                 * Returns the determinant of this {@link Matrix33}.
                 * @return {number} double
                 */
                determinant() {
                    return this.m00 * this.m11 * this.m22 + this.m01 * this.m12 * this.m20 + this.m02 * this.m10 * this.m21 - this.m20 * this.m11 * this.m02 - this.m21 * this.m12 * this.m00 - this.m22 * this.m10 * this.m01;
                }
                /**
                 * Performs the inverse of this {@link Matrix33} and places the
                 * result in this {@link Matrix33}.
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} this matrix
                 */
                invert() {
                    let det = this.determinant();
                    if (Math.abs(det) > org.dyn4j.Epsilon.E_$LI$()) {
                        det = 1.0 / det;
                    }
                    const m00 = det * (this.m11 * this.m22 - this.m12 * this.m21);
                    const m01 = -det * (this.m01 * this.m22 - this.m21 * this.m02);
                    const m02 = det * (this.m01 * this.m12 - this.m11 * this.m02);
                    const m10 = -det * (this.m10 * this.m22 - this.m20 * this.m12);
                    const m11 = det * (this.m00 * this.m22 - this.m20 * this.m02);
                    const m12 = -det * (this.m00 * this.m12 - this.m10 * this.m02);
                    const m20 = det * (this.m10 * this.m21 - this.m20 * this.m11);
                    const m21 = -det * (this.m00 * this.m21 - this.m20 * this.m01);
                    const m22 = det * (this.m00 * this.m11 - this.m10 * this.m01);
                    this.m00 = m00;
                    this.m01 = m01;
                    this.m02 = m02;
                    this.m10 = m10;
                    this.m11 = m11;
                    this.m12 = m12;
                    this.m20 = m20;
                    this.m21 = m21;
                    this.m22 = m22;
                    return this;
                }
                /**
                 * Returns a new {@link Matrix33} containing the inverse of this {@link Matrix33}.
                 * @return {org.dyn4j.geometry.Matrix33} {@link Matrix33} a new matrix containing the result
                 */
                getInverse() {
                    return this.copy().invert();
                }
                /**
                 * Solves the system of linear equations:
                 * <p style="white-space: pre;"> Ax = b
                 * Multiply by A<sup>-1</sup> on both sides
                 * x = A<sup>-1</sup>b</p>
                 * @param {org.dyn4j.geometry.Vector3} b the b {@link Vector3}
                 * @return {org.dyn4j.geometry.Vector3} {@link Vector3} the x vector
                 */
                solve33(b) {
                    let det = this.determinant();
                    if (Math.abs(det) > org.dyn4j.Epsilon.E_$LI$()) {
                        det = 1.0 / det;
                    }
                    const r = new org.dyn4j.geometry.Vector3();
                    const m00 = this.m11 * this.m22 - this.m12 * this.m21;
                    const m01 = -this.m01 * this.m22 + this.m21 * this.m02;
                    const m02 = this.m01 * this.m12 - this.m11 * this.m02;
                    const m10 = -this.m10 * this.m22 + this.m20 * this.m12;
                    const m11 = this.m00 * this.m22 - this.m20 * this.m02;
                    const m12 = -this.m00 * this.m12 + this.m10 * this.m02;
                    const m20 = this.m10 * this.m21 - this.m20 * this.m11;
                    const m21 = -this.m00 * this.m21 + this.m20 * this.m01;
                    const m22 = this.m00 * this.m11 - this.m10 * this.m01;
                    r.x = det * (m00 * b.x + m01 * b.y + m02 * b.z);
                    r.y = det * (m10 * b.x + m11 * b.y + m12 * b.z);
                    r.z = det * (m20 * b.x + m21 * b.y + m22 * b.z);
                    return r;
                }
                /**
                 * Solves the system of linear equations:
                 * <p style="white-space: pre;"> Ax = b
                 * Multiply by A<sup>-1</sup> on both sides
                 * x = A<sup>-1</sup>b</p>
                 * @param {org.dyn4j.geometry.Vector2} b the b {@link Vector2}
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the x vector
                 */
                solve22(b) {
                    let det = this.m00 * this.m11 - this.m01 * this.m10;
                    if (Math.abs(det) > org.dyn4j.Epsilon.E_$LI$()) {
                        det = 1.0 / det;
                    }
                    const r = new org.dyn4j.geometry.Vector2();
                    r.x = det * (this.m11 * b.x - this.m01 * b.y);
                    r.y = det * (this.m00 * b.y - this.m10 * b.x);
                    return r;
                }
            }
            geometry.Matrix33 = Matrix33;
            Matrix33["__class"] = "org.dyn4j.geometry.Matrix33";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * This class provides geometric routines that have guarantees about some properties
             * of their floating point results and operations.
             *
             * @author Manolis Tsamis
             * @version 3.4.0
             * @since 3.4.0
             * @class
             */
            class RobustGeometry {
                static __static_initialize() { if (!RobustGeometry.__static_initialized) {
                    RobustGeometry.__static_initialized = true;
                    RobustGeometry.__static_initializer_0();
                } }
                static SPLITTER_$LI$() { RobustGeometry.__static_initialize(); return RobustGeometry.SPLITTER; }
                static RESULT_ERROR_BOUND_$LI$() { RobustGeometry.__static_initialize(); return RobustGeometry.RESULT_ERROR_BOUND; }
                static ERROR_BOUND_A_$LI$() { RobustGeometry.__static_initialize(); return RobustGeometry.ERROR_BOUND_A; }
                static ERROR_BOUND_B_$LI$() { RobustGeometry.__static_initialize(); return RobustGeometry.ERROR_BOUND_B; }
                static ERROR_BOUND_C_$LI$() { RobustGeometry.__static_initialize(); return RobustGeometry.ERROR_BOUND_C; }
                static __static_initializer_0() {
                    let everyOther = true;
                    let epsilon = 1.0;
                    let splitterMut = 1;
                    while ((1.0 + epsilon > 1.0)) {
                        {
                            if (everyOther) {
                                splitterMut *= 2;
                            }
                            epsilon *= 0.5;
                            everyOther = !everyOther;
                        }
                    }
                    ;
                    splitterMut += 1.0;
                    RobustGeometry.SPLITTER = splitterMut;
                    RobustGeometry.RESULT_ERROR_BOUND = (3 + 8 * epsilon) * epsilon;
                    RobustGeometry.ERROR_BOUND_A = (3 + 16 * epsilon) * epsilon;
                    RobustGeometry.ERROR_BOUND_B = (2 + 12 * epsilon) * epsilon;
                    RobustGeometry.ERROR_BOUND_C = (9 + 64 * epsilon) * epsilon * epsilon;
                }
                static cross$double$double$double$double(ax, ay, bx, by) {
                    return RobustGeometry.cross$double$double$double$double$org_dyn4j_geometry_AdaptiveDecimal(ax, ay, bx, by, null);
                }
                static cross$double$double$double$double$org_dyn4j_geometry_AdaptiveDecimal(ax, ay, bx, by, result) {
                    const axby = ax * by;
                    const aybx = bx * ay;
                    const axbyTail = org.dyn4j.geometry.AdaptiveDecimal.getErrorComponentFromProduct(ax, by, axby);
                    const aybxTail = org.dyn4j.geometry.AdaptiveDecimal.getErrorComponentFromProduct(bx, ay, aybx);
                    const newResult = org.dyn4j.geometry.AdaptiveDecimal.fromDiff$double$double$double$double$org_dyn4j_geometry_AdaptiveDecimal(axbyTail, axby, aybxTail, aybx, result);
                    return newResult;
                }
                /**
                 * Performs the cross product of two vectors a, b, that is ax * by - ay * bx but with extended precision
                 * and stores the 4 component result in the given {@link AdaptiveDecimal} {@code result}.
                 * In the same way as with {@link AdaptiveDecimal#sum(AdaptiveDecimal, AdaptiveDecimal)} if {@code result} is null
                 * a new one is allocated, otherwise the existing is cleared and used.
                 *
                 * @param {number} ax The x value of the vector a
                 * @param {number} ay The y value of the vector a
                 * @param {number} bx The x value of the vector b
                 * @param {number} by The y value of the vector b
                 * @param {org.dyn4j.geometry.AdaptiveDecimal} result The {@link AdaptiveDecimal} in which the cross product is stored
                 * @return {org.dyn4j.geometry.AdaptiveDecimal} The result
                 */
                static cross(ax, ay, bx, by, result) {
                    if (((typeof ax === 'number') || ax === null) && ((typeof ay === 'number') || ay === null) && ((typeof bx === 'number') || bx === null) && ((typeof by === 'number') || by === null) && ((result != null && result instanceof org.dyn4j.geometry.AdaptiveDecimal) || result === null)) {
                        return org.dyn4j.geometry.RobustGeometry.cross$double$double$double$double$org_dyn4j_geometry_AdaptiveDecimal(ax, ay, bx, by, result);
                    }
                    else if (((typeof ax === 'number') || ax === null) && ((typeof ay === 'number') || ay === null) && ((typeof bx === 'number') || bx === null) && ((typeof by === 'number') || by === null) && result === undefined) {
                        return org.dyn4j.geometry.RobustGeometry.cross$double$double$double$double(ax, ay, bx, by);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Robust side-of-line test.
                 * Computes the same value with {@link Segment#getLocation(Vector2, Vector2, Vector2)} but with
                 * enough precision so the sign of the result is correct for any {@link Vector2}s pa, pb, pc.
                 * This implementation uses more precision as-needed only for the hardest cases.
                 * For the majority of inputs this will be only slightly slower than the corresponding call
                 * to {@link Segment#getLocation(Vector2, Vector2, Vector2)} but in the hard cases can be 5-25 times slower.
                 *
                 * @param {org.dyn4j.geometry.Vector2} point the point
                 * @param {org.dyn4j.geometry.Vector2} linePoint1 the first point of the line
                 * @param {org.dyn4j.geometry.Vector2} linePoint2 the second point of the line
                 * @return {number} double
                 * @see Segment#getLocation(Vector2, Vector2, Vector2)
                 */
                static getLocation(point, linePoint1, linePoint2) {
                    const detLeft = (point.x - linePoint2.x) * (linePoint1.y - linePoint2.y);
                    const detRight = (point.y - linePoint2.y) * (linePoint1.x - linePoint2.x);
                    const det = detLeft - detRight;
                    if (detLeft === 0 || detRight === 0 || (detLeft > 0) !== (detRight > 0)) {
                        return det;
                    }
                    const detSum = Math.abs(detLeft + detRight);
                    if (Math.abs(det) >= RobustGeometry.ERROR_BOUND_A_$LI$() * detSum) {
                        return det;
                    }
                    return RobustGeometry.getLocationAdaptive(point, linePoint1, linePoint2, detSum);
                }
                /**
                 * The extended precision implementation for the side-of-line test.
                 *
                 * @param {org.dyn4j.geometry.Vector2} point the point
                 * @param {org.dyn4j.geometry.Vector2} linePoint1 the first point of the line
                 * @param {org.dyn4j.geometry.Vector2} linePoint2 the second point of the line
                 * @return {number} double
                 * @see #getLocation(Vector2, Vector2, Vector2)
                 * @param {number} detSum
                 * @private
                 */
                /*private*/ static getLocationAdaptive(point, linePoint1, linePoint2, detSum) {
                    const acx = point.x - linePoint2.x;
                    const acy = point.y - linePoint2.y;
                    const bcx = linePoint1.x - linePoint2.x;
                    const bcy = linePoint1.y - linePoint2.y;
                    const B = RobustGeometry.cross$double$double$double$double(acx, acy, bcx, bcy);
                    let det = B.getEstimation();
                    let errorBound = RobustGeometry.ERROR_BOUND_B_$LI$() * detSum;
                    if (Math.abs(det) >= errorBound) {
                        return det;
                    }
                    const acxTail = org.dyn4j.geometry.AdaptiveDecimal.getErrorComponentFromDifference(point.x, linePoint2.x, acx);
                    const acyTail = org.dyn4j.geometry.AdaptiveDecimal.getErrorComponentFromDifference(point.y, linePoint2.y, acy);
                    const bcxTail = org.dyn4j.geometry.AdaptiveDecimal.getErrorComponentFromDifference(linePoint1.x, linePoint2.x, bcx);
                    const bcyTail = org.dyn4j.geometry.AdaptiveDecimal.getErrorComponentFromDifference(linePoint1.y, linePoint2.y, bcy);
                    if (acxTail === 0 && acyTail === 0 && bcxTail === 0 && bcyTail === 0) {
                        return det;
                    }
                    errorBound = RobustGeometry.ERROR_BOUND_C_$LI$() * detSum + RobustGeometry.RESULT_ERROR_BOUND_$LI$() * Math.abs(det);
                    det += (acx * bcyTail + bcy * acxTail) - (acy * bcxTail + bcx * acyTail);
                    if (Math.abs(det) >= errorBound) {
                        return det;
                    }
                    const buffer = new org.dyn4j.geometry.AdaptiveDecimal(4);
                    RobustGeometry.cross$double$double$double$double$org_dyn4j_geometry_AdaptiveDecimal(acxTail, bcx, acyTail, bcy, buffer);
                    const C1 = B.sum$org_dyn4j_geometry_AdaptiveDecimal(buffer);
                    RobustGeometry.cross$double$double$double$double$org_dyn4j_geometry_AdaptiveDecimal(acx, bcxTail, acy, bcyTail, buffer);
                    const C2 = C1.sum$org_dyn4j_geometry_AdaptiveDecimal(buffer);
                    RobustGeometry.cross$double$double$double$double$org_dyn4j_geometry_AdaptiveDecimal(acxTail, bcxTail, acyTail, bcyTail, buffer);
                    const D = C2.sum$org_dyn4j_geometry_AdaptiveDecimal(buffer);
                    return D.get(D.size() - 1);
                }
            }
            RobustGeometry.__static_initialized = false;
            geometry.RobustGeometry = RobustGeometry;
            RobustGeometry["__class"] = "org.dyn4j.geometry.RobustGeometry";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        /**
         * The version of the engine.
         * @author William Bittle
         * @version 3.4.0
         * @since 1.0.0
         * @class
         */
        class Version {
            constructor() {
            }
            /**
             * Returns the version as a string.
             * @return {string} String
             */
            static getVersion() {
                return Version.MAJOR + "." + Version.MINOR + "." + Version.REVISION;
            }
            /**
             * Returns the version numbers in an array of ints.
             * <p>
             * The array is of length 3 and has the major, minor, and
             * revision numbers in that order.
             * @return {int[]} int[] the major, minor, and revision numbers
             * @since 3.1.0
             */
            static getVersionNumbers() {
                return [Version.MAJOR, Version.MINOR, Version.REVISION];
            }
            /**
             * Returns the major version number.
             * @return {number} int
             * @since 3.1.0
             */
            static getMajorNumber() {
                return Version.MAJOR;
            }
            /**
             * Returns the minor version number.
             * @return {number} int
             * @since 3.1.0
             */
            static getMinorNumber() {
                return Version.MINOR;
            }
            /**
             * Returns the revision number.
             * @return {number} int
             * @since 3.1.0
             */
            static getRevisionNumber() {
                return Version.REVISION;
            }
            /**
             * Main class to print the version to the console.
             * @param {java.lang.String[]} args command line arguments (none accepted)
             */
            static main(args) {
                console.info("dyn4j v" + Version.getVersion());
            }
        }
        /**
         * The major version number; high impact changes; major API changes, major enhancements, etc.
         */
        Version.MAJOR = 3;
        /**
         * The minor version number; medium impact changes; minor API changes, minor enhancements, major bug fixes, etc.
         */
        Version.MINOR = 4;
        /**
         * The revision number; low impact changes; deprecating API changes, minor bug fixes, etc.
         */
        Version.REVISION = 0;
        dyn4j.Version = Version;
        Version["__class"] = "org.dyn4j.Version";
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        /**
         * Full constructor.
         * @param {org.dyn4j.BinarySearchTreeNode} root the root node of the subtree to traverse
         * @param {*} from the value to start iterating from (inclusive)
         * @param {*} to the value to stop iterating after (inclusive)
         * @throws NullPointerException if node is null
         * @since 3.2.3
         * @class
         * @author William Bittle
         */
        class BinarySearchTreeIterator {
            constructor(root, from, to, inOrder) {
                if (((root != null && root instanceof org.dyn4j.BinarySearchTreeNode) || root === null) && ((from != null) || from === null) && ((to != null) || to === null) && ((typeof inOrder === 'boolean') || inOrder === null)) {
                    let __args = arguments;
                    if (this.stack === undefined) {
                        this.stack = null;
                    }
                    if (this.root === undefined) {
                        this.root = null;
                    }
                    if (this.from === undefined) {
                        this.from = null;
                    }
                    if (this.to === undefined) {
                        this.to = null;
                    }
                    if (this.inOrder === undefined) {
                        this.inOrder = false;
                    }
                    if (root == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("binarySearchTree.nullSubTreeForIterator"));
                    this.inOrder = inOrder;
                    this.stack = (new java.util.ArrayDeque());
                    this.root = root;
                    this.from = from;
                    this.to = to;
                    if (inOrder) {
                        if (this.from != null) {
                            this.pushLeftFrom(from);
                        }
                        else {
                            this.pushLeft(root);
                        }
                    }
                    else {
                        this.pushRight(root);
                    }
                }
                else if (((root != null && root instanceof org.dyn4j.BinarySearchTreeNode) || root === null) && ((from != null) || from === null) && ((to != null) || to === null) && inOrder === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let inOrder = true;
                        if (this.stack === undefined) {
                            this.stack = null;
                        }
                        if (this.root === undefined) {
                            this.root = null;
                        }
                        if (this.from === undefined) {
                            this.from = null;
                        }
                        if (this.to === undefined) {
                            this.to = null;
                        }
                        if (this.inOrder === undefined) {
                            this.inOrder = false;
                        }
                        if (root == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("binarySearchTree.nullSubTreeForIterator"));
                        this.inOrder = inOrder;
                        this.stack = (new java.util.ArrayDeque());
                        this.root = root;
                        this.from = from;
                        this.to = to;
                        if (inOrder) {
                            if (this.from != null) {
                                this.pushLeftFrom(from);
                            }
                            else {
                                this.pushLeft(root);
                            }
                        }
                        else {
                            this.pushRight(root);
                        }
                    }
                    if (this.stack === undefined) {
                        this.stack = null;
                    }
                    if (this.root === undefined) {
                        this.root = null;
                    }
                    if (this.from === undefined) {
                        this.from = null;
                    }
                    if (this.to === undefined) {
                        this.to = null;
                    }
                    if (this.inOrder === undefined) {
                        this.inOrder = false;
                    }
                }
                else if (((root != null && root instanceof org.dyn4j.BinarySearchTreeNode) || root === null) && ((typeof from === 'boolean') || from === null) && to === undefined && inOrder === undefined) {
                    let __args = arguments;
                    let inOrder = __args[1];
                    {
                        let __args = arguments;
                        let from = null;
                        let to = null;
                        if (this.stack === undefined) {
                            this.stack = null;
                        }
                        if (this.root === undefined) {
                            this.root = null;
                        }
                        if (this.from === undefined) {
                            this.from = null;
                        }
                        if (this.to === undefined) {
                            this.to = null;
                        }
                        if (this.inOrder === undefined) {
                            this.inOrder = false;
                        }
                        if (root == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("binarySearchTree.nullSubTreeForIterator"));
                        this.inOrder = inOrder;
                        this.stack = (new java.util.ArrayDeque());
                        this.root = root;
                        this.from = from;
                        this.to = to;
                        if (inOrder) {
                            if (this.from != null) {
                                this.pushLeftFrom(from);
                            }
                            else {
                                this.pushLeft(root);
                            }
                        }
                        else {
                            this.pushRight(root);
                        }
                    }
                    if (this.stack === undefined) {
                        this.stack = null;
                    }
                    if (this.root === undefined) {
                        this.root = null;
                    }
                    if (this.from === undefined) {
                        this.from = null;
                    }
                    if (this.to === undefined) {
                        this.to = null;
                    }
                    if (this.inOrder === undefined) {
                        this.inOrder = false;
                    }
                }
                else if (((root != null && root instanceof org.dyn4j.BinarySearchTreeNode) || root === null) && from === undefined && to === undefined && inOrder === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let from = null;
                        let to = null;
                        let inOrder = true;
                        if (this.stack === undefined) {
                            this.stack = null;
                        }
                        if (this.root === undefined) {
                            this.root = null;
                        }
                        if (this.from === undefined) {
                            this.from = null;
                        }
                        if (this.to === undefined) {
                            this.to = null;
                        }
                        if (this.inOrder === undefined) {
                            this.inOrder = false;
                        }
                        if (root == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("binarySearchTree.nullSubTreeForIterator"));
                        this.inOrder = inOrder;
                        this.stack = (new java.util.ArrayDeque());
                        this.root = root;
                        this.from = from;
                        this.to = to;
                        if (inOrder) {
                            if (this.from != null) {
                                this.pushLeftFrom(from);
                            }
                            else {
                                this.pushLeft(root);
                            }
                        }
                        else {
                            this.pushRight(root);
                        }
                    }
                    if (this.stack === undefined) {
                        this.stack = null;
                    }
                    if (this.root === undefined) {
                        this.root = null;
                    }
                    if (this.from === undefined) {
                        this.from = null;
                    }
                    if (this.to === undefined) {
                        this.to = null;
                    }
                    if (this.inOrder === undefined) {
                        this.inOrder = false;
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Pushes the required nodes onto the stack to begin iterating
             * nodes in order starting from the given value.
             * @param {*} from the value to start iterating from
             * @since 3.2.3
             */
            pushLeftFrom(from) {
                let node = this.root;
                while ((node != null)) {
                    {
                        const cmp = from.compareTo(node.comparable);
                        if (cmp < 0) {
                            this.stack.push(node);
                            node = node.left;
                        }
                        else if (cmp > 0) {
                            node = node.right;
                        }
                        else {
                            this.stack.push(node);
                            break;
                        }
                    }
                }
                ;
            }
            /**
             * Pushes the left most nodes of the given subtree onto the stack.
             * @param {org.dyn4j.BinarySearchTreeNode} node the root node of the subtree
             */
            pushLeft(node) {
                while ((node != null)) {
                    {
                        if (this.to == null || this.to.compareTo(node.comparable) >= 0) {
                            this.stack.push(node);
                        }
                        node = node.left;
                    }
                }
                ;
            }
            /**
             * Pushes the right most nodes of the given subtree onto the stack.
             * @param {org.dyn4j.BinarySearchTreeNode} node the root node of the subtree
             */
            pushRight(node) {
                while ((node != null)) {
                    {
                        this.stack.push(node);
                        node = node.right;
                    }
                }
                ;
            }
            /**
             *
             * @return {boolean}
             */
            hasNext() {
                return !this.stack.isEmpty();
            }
            /**
             *
             * @return {*}
             */
            next() {
                if (this.stack.isEmpty())
                    throw new java.util.NoSuchElementException();
                const node = this.stack.pop();
                if (this.inOrder) {
                    this.pushLeft(node.right);
                }
                else {
                    this.pushRight(node.left);
                }
                return node.comparable;
            }
            /**
             * Currently unsupported.
             */
            remove() {
                throw new java.lang.UnsupportedOperationException();
            }
            forEachRemaining(action) {
                java.util.Objects.requireNonNull((((funcInst) => { if (typeof funcInst == 'function') {
                    return funcInst;
                } return (arg0) => (funcInst['accept'] ? funcInst['accept'] : funcInst).call(funcInst, arg0); })(action)));
                while ((this.hasNext())) {
                    (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(action);
                }
                ;
            }
        }
        dyn4j.BinarySearchTreeIterator = BinarySearchTreeIterator;
        BinarySearchTreeIterator["__class"] = "org.dyn4j.BinarySearchTreeIterator";
        BinarySearchTreeIterator["__interfaces"] = ["java.util.Iterator"];
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        class RandomUUID {
            constructor() {
                this.id = -1;
                this.id = ((Math.random() * 1000000.0) | 0);
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                if (o == null)
                    return false;
                if (o === this)
                    return true;
                if (o != null && o instanceof org.dyn4j.RandomUUID) {
                    const uid = o;
                    return uid.id === this.id;
                }
                return false;
            }
        }
        dyn4j.RandomUUID = RandomUUID;
        RandomUUID["__class"] = "org.dyn4j.RandomUUID";
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            /**
             * Convenience class for implementing the {@link BoundsListener} interface.
             * <p>
             * This class can be used to implement only the methods desired instead of all
             * the methods contained in the {@link BoundsListener} interface.
             * @author William Bittle
             * @version 3.2.0
             * @since 1.0.0
             * @class
             */
            class BoundsAdapter {
                outside(collidable) {
                }
                constructor() {
                }
            }
            collision.BoundsAdapter = BoundsAdapter;
            BoundsAdapter["__class"] = "org.dyn4j.collision.BoundsAdapter";
            BoundsAdapter["__interfaces"] = ["org.dyn4j.Listener", "org.dyn4j.collision.BoundsListener"];
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            /**
             * A base implementation of a class hierarchy {@link Fixture} {@link Filter}.
             * <p>
             * This class is not used directly but instead extended by marker classes (see example below).
             * <p>
             * This filter is designed to allow a <strong>hierarchy</strong> of categories where each category
             * can collide with it's parents and it's descendants, but not it's siblings.
             * <p>
             * For example, imagine we have the following hierarchy of categories:
             * <pre>
             * Root Category
             * /           \
             * Category1     Category2
             * /      \
             * Category 3  Category 4
             * </pre>
             * This hierarchy allows the following:
             * <ul>
             * <li>A fixture with the Root category can collide with anything.</li>
             * <li>A fixture with the Category1 category can collide with the Category1, Category3, Category4, and Root categories. (i.e. not Category2)</li>
             * <li>A fixture with the Category2 category can collide with the Category2 and Root categories only.</li>
             * <li>A fixture with the Category3 category can collide with the Category3, Category1, and Root categories.</li>
             * <li>A fixture with the Category4 category can collide with the Category4, Category1, and Root categories.</li>
             * </ul>
             * <p>
             * To implement this you create a class for each category (you could put these in
             * their own class file, its done this way for brevity):
             * <pre>
             * public final class Categories {
             * private static class Root extends TypeFilter {}
             * private static class Category1 extends Root {}
             * private static class Category2 extends Root {}
             * private static class Category3 extends Category1 {}
             * private static class Category4 extends Category1 {}
             *
             * public static final TypeFilter ROOT = new Root();
             * public static final TypeFilter CATEGORY1 = new Category1();
             * public static final TypeFilter CATEGORY2 = new Category2();
             * public static final TypeFilter CATEGORY3 = new Category3();
             * public static final TypeFilter CATEGORY4 = new Category4();
             * }
             * // then set the filter on the fixtures
             * fixture.setFilter(Categories.ROOT);
             * // or
             * fixture.setFilter(Categories.CATEGORY1);
             * </pre>
             * @author William Bittle
             * @version 3.0.2
             * @since 3.0.2
             * @class
             */
            class TypeFilter {
                /**
                 * Returns true under the following conditions:
                 * <ol>
                 * <li>If this filter is the same type as the given filter.</li>
                 * <li>If this filter type is a descendant of the given filter's type.</li>
                 * <li>If the given filter's type is a descendant of this filter's type.</li>
                 * </ol>
                 * If the given filter is not of type {@link TypeFilter} then false is returned.
                 * <p>
                 * If the given filter is null then false is returned.
                 * @param {*} filter the other filter
                 * @return {boolean}
                 */
                isAllowed(filter) {
                    if (filter == null)
                        return false;
                    if (this === filter)
                        return true;
                    if (filter != null && filter instanceof org.dyn4j.collision.TypeFilter) {
                        if (this.constructor.isInstance(filter) || filter.constructor.isInstance(this)) {
                            return true;
                        }
                    }
                    return false;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("TypeFilter[ClassName=").append(/* getName */ (c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])(this.constructor)).append("]");
                    return sb.toString();
                }
                constructor() {
                }
            }
            collision.TypeFilter = TypeFilter;
            TypeFilter["__class"] = "org.dyn4j.collision.TypeFilter";
            TypeFilter["__interfaces"] = ["org.dyn4j.collision.Filter"];
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            /**
             * Class used to estimate collision counts and other one-off collision methods and values.
             * <p>
             * This class is transient and may get deprecated at any time.
             * @author William Bittle
             * @version 3.2.0
             * @since 3.1.1
             * @class
             */
            class Collisions {
                constructor() {
                }
                /**
                 * Returns an estimate on the number of collision pairs based on the number objects being simulated.
                 * @param {number} n the number of objects
                 * @return {number} int
                 */
                static getEstimatedCollisionPairs(n) {
                    return n * Collisions.ESTIMATED_COLLISIONS_PER_OBJECT;
                }
                /**
                 * Returns an estimate on the number of collisions per object.
                 * @return {number} int
                 */
                static getEstimatedCollisionsPerObject() {
                    return Collisions.ESTIMATED_COLLISIONS_PER_OBJECT;
                }
                /**
                 * Returns an estimate on the number of raycast collisions given the total number
                 * of objects to collide with.
                 * @param {number} n the number of objects
                 * @return {number} int
                 * @since 3.2.0
                 */
                static getEstimatedRaycastCollisions(n) {
                    return (Math.max(1.0, n * Collisions.ESTIMATED_RAYCAST_DENSITY) | 0);
                }
            }
            /**
             * The estimated collisions per object.
             * <p>
             * Worst Case:
             * <pre>size * size(every object colliding with every object) - size(remove self collisions)</pre>
             * Which is just way too large.  Dividing by a factor is still grossly over estimated so
             * I opted to do an estimate on the test results found in the Sandbox application.
             * <p>
             * Test Results:
             * <pre>
             * +----------+--------------+-----------------+-------------------+
             * | Test     | Object Count | Collision Pairs | Collisions/Object |
             * +----------+--------------+-----------------+-------------------+
             * | Bucket   |          200 |            ~500 |               2.5 |
             * | Funnel   |          200 |            ~400 |               2.0 |
             * | Parallel |          300 |             600 |               2.0 |
             * +----------+--------------+-----------------+-------------------+</pre>
             * Therefore a good estimate could be 4 collisions per object.
             */
            Collisions.ESTIMATED_COLLISIONS_PER_OBJECT = 4;
            /**
             * An estimate of the number of objects that will be hit when raycasting assuming uniform
             * distribution of objects.
             * <p>
             * This was computed from the Sandbox's Raycast Performance test.
             */
            Collisions.ESTIMATED_RAYCAST_DENSITY = 0.02;
            collision.Collisions = Collisions;
            Collisions["__class"] = "org.dyn4j.collision.Collisions";
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            /**
             * Optional constructor.
             * <p>
             * Creates a new {@link AbstractCollidable} using the given estimated fixture count.
             * Assignment of the initial fixture count allows sizing of internal structures
             * for optimal memory/performance.  This estimated fixture count is <b>not</b> a
             * limit on the number of fixtures.
             * @param {number} fixtureCount the estimated number of fixtures
             * @class
             * @author William Bittle
             */
            class AbstractCollidable {
                constructor(fixtureCount) {
                    if (((typeof fixtureCount === 'number') || fixtureCount === null)) {
                        let __args = arguments;
                        if (this.id === undefined) {
                            this.id = null;
                        }
                        if (this.transform === undefined) {
                            this.transform = null;
                        }
                        if (this.fixtures === undefined) {
                            this.fixtures = null;
                        }
                        if (this.radius === undefined) {
                            this.radius = 0;
                        }
                        if (this.userData === undefined) {
                            this.userData = null;
                        }
                        const size = fixtureCount <= 0 ? org.dyn4j.collision.Collidable.TYPICAL_FIXTURE_COUNT : fixtureCount;
                        this.id = new org.dyn4j.RandomUUID();
                        this.fixtures = (new java.util.ArrayList(size));
                        this.radius = 0.0;
                        this.transform = new org.dyn4j.geometry.Transform();
                    }
                    else if (fixtureCount === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let fixtureCount = org.dyn4j.collision.Collidable.TYPICAL_FIXTURE_COUNT;
                            if (this.id === undefined) {
                                this.id = null;
                            }
                            if (this.transform === undefined) {
                                this.transform = null;
                            }
                            if (this.fixtures === undefined) {
                                this.fixtures = null;
                            }
                            if (this.radius === undefined) {
                                this.radius = 0;
                            }
                            if (this.userData === undefined) {
                                this.userData = null;
                            }
                            const size = fixtureCount <= 0 ? org.dyn4j.collision.Collidable.TYPICAL_FIXTURE_COUNT : fixtureCount;
                            this.id = new org.dyn4j.RandomUUID();
                            this.fixtures = (new java.util.ArrayList(size));
                            this.radius = 0.0;
                            this.transform = new org.dyn4j.geometry.Transform();
                        }
                        if (this.id === undefined) {
                            this.id = null;
                        }
                        if (this.transform === undefined) {
                            this.transform = null;
                        }
                        if (this.fixtures === undefined) {
                            this.fixtures = null;
                        }
                        if (this.radius === undefined) {
                            this.radius = 0;
                        }
                        if (this.userData === undefined) {
                            this.userData = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                removeFixture$org_dyn4j_collision_Fixture(fixture) {
                    return this.fixtures.remove(fixture);
                }
                removeFixture(fixture) {
                    if (((fixture != null) || fixture === null)) {
                        return this.removeFixture$org_dyn4j_collision_Fixture(fixture);
                    }
                    else if (((fixture != null && fixture instanceof org.dyn4j.geometry.Vector2) || fixture === null)) {
                        return this.removeFixture$org_dyn4j_geometry_Vector2(fixture);
                    }
                    else if (((typeof fixture === 'number') || fixture === null)) {
                        return this.removeFixture$int(fixture);
                    }
                    else
                        throw new Error('invalid overload');
                }
                removeFixture$int(index) {
                    return this.fixtures.remove(index);
                }
                removeAllFixtures() {
                    const fixtures = this.fixtures;
                    this.fixtures = (new java.util.ArrayList(fixtures.size()));
                    return fixtures;
                }
                containsFixture(fixture) {
                    return this.fixtures.contains(fixture);
                }
                rotate$double$double$double(theta, x, y) {
                    this.transform.rotate$double$double$double(theta, x, y);
                }
                rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    this.transform.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$double$org_dyn4j_geometry_Vector2(theta, point) {
                    this.transform.rotate$double$org_dyn4j_geometry_Vector2(theta, point);
                }
                rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, point) {
                    this.transform.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, point);
                }
                rotate$double(theta) {
                    this.transform.rotate$double(theta);
                }
                rotate$org_dyn4j_geometry_Rotation(rotation) {
                    this.transform.rotate$org_dyn4j_geometry_Rotation(rotation);
                }
                /**
                 * Rotates the {@link Collidable} about its center of mass.
                 * @param {number} theta the angle of rotation in radians
                 */
                rotateAboutCenter(theta) {
                    const center = this.getWorldCenter();
                    this.rotate$double$org_dyn4j_geometry_Vector2(theta, center);
                }
                translate$double$double(x, y) {
                    this.transform.translate$double$double(x, y);
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$org_dyn4j_geometry_Vector2(vector) {
                    this.transform.translate$org_dyn4j_geometry_Vector2(vector);
                }
                translateToOrigin() {
                    const wc = this.getWorldCenter();
                    this.transform.translate$double$double(-wc.x, -wc.y);
                }
                shift(shift) {
                    this.transform.translate$org_dyn4j_geometry_Vector2(shift);
                }
                getFixture$int(index) {
                    return this.fixtures.get(index);
                }
                getFixture$org_dyn4j_geometry_Vector2(point) {
                    const size = this.fixtures.size();
                    for (let i = 0; i < size; i++) {
                        {
                            const fixture = this.fixtures.get(i);
                            const convex = fixture.getShape();
                            if (convex['contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](point, this.transform)) {
                                return fixture;
                            }
                        }
                        ;
                    }
                    return null;
                }
                getFixture(point) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null)) {
                        return this.getFixture$org_dyn4j_geometry_Vector2(point);
                    }
                    else if (((typeof point === 'number') || point === null)) {
                        return this.getFixture$int(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                getFixtures$org_dyn4j_geometry_Vector2(point) {
                    const fixtures = (new java.util.ArrayList());
                    const size = this.fixtures.size();
                    for (let i = 0; i < size; i++) {
                        {
                            const fixture = this.fixtures.get(i);
                            const convex = fixture.getShape();
                            if (convex['contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](point, this.transform)) {
                                fixtures.add(fixture);
                            }
                        }
                        ;
                    }
                    return fixtures;
                }
                getFixtures(point) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null)) {
                        return this.getFixtures$org_dyn4j_geometry_Vector2(point);
                    }
                    else if (point === undefined) {
                        return this.getFixtures$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                removeFixture$org_dyn4j_geometry_Vector2(point) {
                    const size = this.fixtures.size();
                    for (let i = 0; i < size; i++) {
                        {
                            const fixture = this.fixtures.get(i);
                            const convex = fixture.getShape();
                            if (convex['contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](point, this.transform)) {
                                this.fixtures.remove(i);
                                return fixture;
                            }
                        }
                        ;
                    }
                    return null;
                }
                removeFixtures(point) {
                    const fixtures = (new java.util.ArrayList());
                    const it = this.fixtures.iterator();
                    while ((it.hasNext())) {
                        {
                            const fixture = it.next();
                            const convex = fixture.getShape();
                            if (convex['contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](point, this.transform)) {
                                it.remove();
                                fixtures.add(fixture);
                            }
                        }
                    }
                    ;
                    return fixtures;
                }
                getFixtureCount() {
                    return this.fixtures.size();
                }
                getFixtures$() {
                    return java.util.Collections.unmodifiableList(this.fixtures);
                }
                /**
                 *
                 * @return {*}
                 */
                getFixtureIterator() {
                    return (new org.dyn4j.collision.FixtureIterator(this));
                }
                getTransform() {
                    return this.transform;
                }
                getRotationDiscRadius() {
                    return this.radius;
                }
                setTransform(transform) {
                    if (transform == null)
                        return;
                    this.transform.set(transform);
                }
                getUserData() {
                    return this.userData;
                }
                setUserData(userData) {
                    this.userData = userData;
                }
                getId() {
                    return this.id;
                }
                createAABB$() {
                    return this.createAABB$org_dyn4j_geometry_Transform(this.transform);
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    const size = this.fixtures.size();
                    if (size > 0) {
                        const aabb = this.fixtures.get(0).getShape()['createAABB$org_dyn4j_geometry_Transform'](transform);
                        for (let i = 1; i < size; i++) {
                            {
                                const faabb = this.fixtures.get(i).getShape()['createAABB$org_dyn4j_geometry_Transform'](transform);
                                aabb.union(faabb);
                            }
                            ;
                        }
                        return aabb;
                    }
                    return new org.dyn4j.geometry.AABB(0.0, 0.0, 0.0, 0.0);
                }
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                getLocalPoint(worldPoint) {
                    return this.transform.getInverseTransformed$org_dyn4j_geometry_Vector2(worldPoint);
                }
                getWorldPoint(localPoint) {
                    return this.transform.getTransformed$org_dyn4j_geometry_Vector2(localPoint);
                }
                getLocalVector(worldVector) {
                    return this.transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(worldVector);
                }
                getWorldVector(localVector) {
                    return this.transform.getTransformedR$org_dyn4j_geometry_Vector2(localVector);
                }
                contains(point) {
                    const size = this.fixtures.size();
                    for (let i = 0; i < size; i++) {
                        {
                            const fixture = this.fixtures.get(i);
                            const convex = fixture.getShape();
                            if (convex['contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](point, this.transform)) {
                                return true;
                            }
                        }
                        ;
                    }
                    return false;
                }
            }
            collision.AbstractCollidable = AbstractCollidable;
            AbstractCollidable["__class"] = "org.dyn4j.collision.AbstractCollidable";
            AbstractCollidable["__interfaces"] = ["org.dyn4j.collision.Collidable", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            /**
             * Minimal constructor.
             * @param {*} collidable the collidable to iterate over
             * @class
             * @author William Bittle
             */
            class FixtureIterator {
                constructor(collidable) {
                    if (this.collidable === undefined) {
                        this.collidable = null;
                    }
                    if (this.index === undefined) {
                        this.index = 0;
                    }
                    this.collidable = collidable;
                    this.index = -1;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.index + 1 < this.collidable.getFixtureCount();
                }
                /**
                 *
                 * @return {org.dyn4j.collision.Fixture}
                 */
                next() {
                    if (this.index >= this.collidable.getFixtureCount()) {
                        throw new java.lang.IndexOutOfBoundsException();
                    }
                    try {
                        this.index++;
                        const fixture = this.collidable['getFixture$int'](this.index);
                        return fixture;
                    }
                    catch (ex) {
                        throw new java.util.ConcurrentModificationException();
                    }
                }
                /**
                 *
                 */
                remove() {
                    if (this.index < 0) {
                        throw new java.lang.IllegalStateException();
                    }
                    if (this.index >= this.collidable.getFixtureCount()) {
                        throw new java.lang.IndexOutOfBoundsException();
                    }
                    try {
                        this.collidable['removeFixture$int'](this.index);
                        this.index--;
                    }
                    catch (ex) {
                        throw new java.util.ConcurrentModificationException();
                    }
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((((funcInst) => { if (typeof funcInst == 'function') {
                        return funcInst;
                    } return (arg0) => (funcInst['accept'] ? funcInst['accept'] : funcInst).call(funcInst, arg0); })(consumer)));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
            }
            collision.FixtureIterator = FixtureIterator;
            FixtureIterator["__class"] = "org.dyn4j.collision.FixtureIterator";
            FixtureIterator["__interfaces"] = ["java.util.Iterator"];
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Represents a basic node in a {@link LazyAABBTree}.
                 * <p>
                 * The AABB of the node should be the union of all the AABBs below this node.
                 * @author Manolis Tsamis
                 * @version 3.4.0
                 * @since 3.4.0
                 * @class
                 */
                class LazyAABBTreeNode {
                    constructor() {
                        if (this.left === undefined) {
                            this.left = null;
                        }
                        if (this.right === undefined) {
                            this.right = null;
                        }
                        if (this.parent === undefined) {
                            this.parent = null;
                        }
                        if (this.height === undefined) {
                            this.height = 0;
                        }
                        if (this.aabb === undefined) {
                            this.aabb = null;
                        }
                    }
                    /**
                     * Replace oldChild with newChild. oldChild must be a child of this node before the replacement.
                     * Children are compared with the equality operator.
                     *
                     * @param {org.dyn4j.collision.broadphase.LazyAABBTreeNode} oldChild The child to replace in this node
                     * @param {org.dyn4j.collision.broadphase.LazyAABBTreeNode} newChild The replacement
                     * @throws IllegalArgumentException if oldChild is not a child of this node
                     */
                    replaceChild(oldChild, newChild) {
                        if (this.left === oldChild) {
                            this.left = newChild;
                        }
                        else if (this.right === oldChild) {
                            this.right = newChild;
                        }
                        else {
                            throw new java.lang.IllegalArgumentException(oldChild.toString() + " is not a child of node " + this.toString());
                        }
                    }
                    /**
                     * Returns the sibling of this node, that is the other child of this node's parent.
                     *
                     * @return {org.dyn4j.collision.broadphase.LazyAABBTreeNode} The sibling node
                     * @throws NullPointerException if this node has no parent
                     * @throws IllegalStateException if this node is not a child of it's parent
                     */
                    getSibling() {
                        if (this.parent.left === this) {
                            return this.parent.right;
                        }
                        else if (this.parent.right === this) {
                            return this.parent.left;
                        }
                        else {
                            throw new java.lang.IllegalStateException("Invalid parent pointer for node " + this.toString());
                        }
                    }
                    /**
                     * Returns true if this node is a leaf node.
                     * @return {boolean} boolean true if this node is a leaf node
                     */
                    isLeaf() {
                        return this.left == null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("LazyAABBTreeNode[AABB=").append(this.aabb.toString()).append("|Height=").append(this.height).append("]");
                        return sb.toString();
                    }
                }
                broadphase.LazyAABBTreeNode = LazyAABBTreeNode;
                LazyAABBTreeNode["__class"] = "org.dyn4j.collision.broadphase.LazyAABBTreeNode";
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Minimal constructor.
                 * @param {*} collidable the collidable
                 * @param {org.dyn4j.collision.Fixture} fixture the fixture
                 * @class
                 * @author William Bittle
                 */
                class BroadphaseItem {
                    constructor(collidable, fixture) {
                        if (this.collidable === undefined) {
                            this.collidable = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        this.collidable = collidable;
                        this.fixture = fixture;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (obj == null)
                            return false;
                        if (obj === this)
                            return true;
                        if (obj != null && obj instanceof org.dyn4j.collision.broadphase.BroadphaseItem) {
                            const pair = obj;
                            if (pair.collidable === this.collidable && pair.fixture === this.fixture) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let hash = 17;
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable);
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture);
                        return hash;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("BroadphaseItem[Collidable=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable)).append("|Fixture=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture)).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the {@link Collidable}.
                     * @return {*} E
                     */
                    getCollidable() {
                        return this.collidable;
                    }
                    /**
                     * Returns the {@link Fixture}.
                     * @return {org.dyn4j.collision.Fixture} T
                     */
                    getFixture() {
                        return this.fixture;
                    }
                }
                broadphase.BroadphaseItem = BroadphaseItem;
                BroadphaseItem["__class"] = "org.dyn4j.collision.broadphase.BroadphaseItem";
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                let BroadphaseDetector;
                (function (BroadphaseDetector) {
                    /**
                     * The default {@link AABB} expansion value
                     */
                    BroadphaseDetector.DEFAULT_AABB_EXPANSION = 0.2;
                    /**
                     * The default initial capacity of fixtures
                     */
                    BroadphaseDetector.DEFAULT_INITIAL_CAPACITY = 64;
                })(BroadphaseDetector = broadphase.BroadphaseDetector || (broadphase.BroadphaseDetector = {}));
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Full constructor.
                 * @param {*} collidable the collidable
                 * @param {org.dyn4j.collision.Fixture} fixture the fixture
                 * @param {org.dyn4j.geometry.AABB} aabb the aabb
                 * @class
                 * @author William Bittle
                 */
                class SapProxy {
                    constructor(collidable, fixture, aabb) {
                        if (this.collidable === undefined) {
                            this.collidable = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        if (this.aabb === undefined) {
                            this.aabb = null;
                        }
                        if (this.tested === undefined) {
                            this.tested = false;
                        }
                        this.collidable = collidable;
                        this.fixture = fixture;
                        this.aabb = aabb;
                    }
                    compareTo(o) {
                        if (this === o)
                            return 0;
                        let diff = this.aabb.getMinX() - o.aabb.getMinX();
                        if (diff !== 0) {
                            return ((f => { if (f > 0) {
                                return 1;
                            }
                            else if (f < 0) {
                                return -1;
                            }
                            else {
                                return 0;
                            } })(diff) | 0);
                        }
                        else {
                            diff = this.aabb.getMinY() - o.aabb.getMinY();
                            return ((f => { if (f > 0) {
                                return 1;
                            }
                            else if (f < 0) {
                                return -1;
                            }
                            else {
                                return 0;
                            } })(diff) | 0);
                        }
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (obj == null)
                            return false;
                        if (obj === this)
                            return true;
                        if (obj != null && obj instanceof org.dyn4j.collision.broadphase.SapProxy) {
                            const pair = obj;
                            if (pair.collidable === this.collidable && pair.fixture === this.fixture) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let hash = 17;
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable);
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture);
                        return hash;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("SapProxy[Collidable=").append(this.collidable != null ? /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable) : "null").append("|Fixture=").append(this.fixture != null ? /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture) : "null").append("|AABB=").append(this.aabb.toString()).append("|Tested=").append(this.tested).append("]");
                        return sb.toString();
                    }
                }
                broadphase.SapProxy = SapProxy;
                SapProxy["__class"] = "org.dyn4j.collision.broadphase.SapProxy";
                SapProxy["__interfaces"] = ["java.lang.Comparable"];
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Helper class to avoid having to override all the methods of the {@link BroadphaseFilter} interface.
                 * <p>
                 * By default all the methods return true to allow all results to be returned.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 3.2.0
                 * @param <E> the {@link Collidable} type
                 * @param <T> the {@link Fixture} type
                 * @class
                 */
                class BroadphaseFilterAdapter {
                    isAllowed$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable1, fixture1, collidable2, fixture2) {
                        return true;
                    }
                    /**
                     *
                     * @param {*} collidable1
                     * @param {org.dyn4j.collision.Fixture} fixture1
                     * @param {*} collidable2
                     * @param {org.dyn4j.collision.Fixture} fixture2
                     * @return {boolean}
                     */
                    isAllowed(collidable1, fixture1, collidable2, fixture2) {
                        if (((collidable1 != null) || collidable1 === null) && ((fixture1 != null) || fixture1 === null) && ((collidable2 != null) || collidable2 === null) && ((fixture2 != null) || fixture2 === null)) {
                            return this.isAllowed$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable1, fixture1, collidable2, fixture2);
                        }
                        else if (((collidable1 != null && collidable1 instanceof org.dyn4j.geometry.Ray) || collidable1 === null) && ((typeof fixture1 === 'number') || fixture1 === null) && ((collidable2 != null) || collidable2 === null) && ((fixture2 != null) || fixture2 === null)) {
                            return this.isAllowed$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable1, fixture1, collidable2, fixture2);
                        }
                        else if (((collidable1 != null && collidable1 instanceof org.dyn4j.geometry.AABB) || collidable1 === null) && ((fixture1 != null) || fixture1 === null) && ((collidable2 != null) || collidable2 === null) && fixture2 === undefined) {
                            return this.isAllowed$org_dyn4j_geometry_AABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable1, fixture1, collidable2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    isAllowed$org_dyn4j_geometry_AABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(aabb, collidable, fixture) {
                        return true;
                    }
                    isAllowed$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(ray, length, collidable, fixture) {
                        return true;
                    }
                    constructor() {
                    }
                }
                broadphase.BroadphaseFilterAdapter = BroadphaseFilterAdapter;
                BroadphaseFilterAdapter["__class"] = "org.dyn4j.collision.broadphase.BroadphaseFilterAdapter";
                BroadphaseFilterAdapter["__interfaces"] = ["org.dyn4j.collision.broadphase.BroadphaseFilter"];
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.geometry.AABB} query the query AABB
                 * @class
                 * @author William Bittle
                 */
                class SapQuerySearchCriteria {
                    constructor(query) {
                        if (this.query === undefined) {
                            this.query = null;
                        }
                        if (this.min === undefined) {
                            this.min = 0;
                        }
                        if (this.lowest === undefined) {
                            this.lowest = null;
                        }
                        this.query = query;
                        this.min = javaemul.internal.DoubleHelper.MAX_VALUE;
                    }
                    evaluate$org_dyn4j_collision_broadphase_SapProxy(comparable) {
                        if (comparable.aabb.getMaxX() < this.query.getMinX()) {
                            return 1;
                        }
                        if (this.min >= comparable.aabb.getMinX()) {
                            this.min = comparable.aabb.getMinX();
                            this.lowest = comparable;
                            return -1;
                        }
                        return 0;
                    }
                    /**
                     *
                     * @param {org.dyn4j.collision.broadphase.SapProxy} comparable
                     * @return {number}
                     */
                    evaluate(comparable) {
                        if (((comparable != null && comparable instanceof org.dyn4j.collision.broadphase.SapProxy) || comparable === null)) {
                            return this.evaluate$org_dyn4j_collision_broadphase_SapProxy(comparable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                broadphase.SapQuerySearchCriteria = SapQuerySearchCriteria;
                SapQuerySearchCriteria["__class"] = "org.dyn4j.collision.broadphase.SapQuerySearchCriteria";
                SapQuerySearchCriteria["__interfaces"] = ["org.dyn4j.BinarySearchTreeSearchCriteria"];
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Minimal constructor.
                 * @param {*} collidable the {@link Collidable}
                 * @param {org.dyn4j.collision.Fixture} fixture the {@link Fixture}
                 * @class
                 * @author William Bittle
                 */
                class BroadphaseKey {
                    constructor(collidable, fixture) {
                        if (this.collidable === undefined) {
                            this.collidable = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        if (this.__hashCode === undefined) {
                            this.__hashCode = 0;
                        }
                        this.collidable = collidable;
                        this.fixture = fixture;
                        this.__hashCode = this.computeHashCode();
                    }
                    /**
                     * Creates and returns a new key for the given {@link Collidable} and {@link Fixture}.
                     * @param {*} collidable the {@link Collidable}
                     * @param {org.dyn4j.collision.Fixture} fixture the {@link Fixture}
                     * @return {org.dyn4j.collision.broadphase.BroadphaseKey} {@link BroadphaseKey}
                     */
                    static get(collidable, fixture) {
                        return new BroadphaseKey(collidable, fixture);
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (obj == null)
                            return false;
                        if (obj === this)
                            return true;
                        if (obj != null && obj instanceof org.dyn4j.collision.broadphase.BroadphaseKey) {
                            const key = obj;
                            return key.collidable === this.collidable && key.fixture === this.fixture;
                        }
                        return false;
                    }
                    /**
                     * Computes the hashcode from the collidable and fixture ids.
                     * @return {number} int
                     */
                    computeHashCode() {
                        let hash = 17;
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable);
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture);
                        return hash;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        return this.__hashCode;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("BroadphaseKey[Collidable=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable)).append("|Fixture=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture)).append("]");
                        return sb.toString();
                    }
                }
                broadphase.BroadphaseKey = BroadphaseKey;
                BroadphaseKey["__class"] = "org.dyn4j.collision.broadphase.BroadphaseKey";
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Simple helper class that holds information for each item in the {@link BruteForceBroadphase}.
                 *
                 * @author Manolis Tsamis
                 * @version 3.4.0
                 * @since 3.4.0
                 * @param <E> the {@link Collidable} type
                 * @param <T> the {@link Fixture} type
                 * @class
                 */
                class BruteForceBroadphaseNode {
                    constructor(collidable, fixture) {
                        if (this.collidable === undefined) {
                            this.collidable = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        if (this.aabb === undefined) {
                            this.aabb = null;
                        }
                        if (this.tested === undefined) {
                            this.tested = false;
                        }
                        this.collidable = collidable;
                        this.fixture = fixture;
                        this.updateAABB();
                    }
                    /**
                     * Updates the AABB of this node
                     */
                    updateAABB() {
                        const tx = this.collidable.getTransform();
                        this.aabb = this.fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](tx);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("PlainBroadphaseNode[AABB=").append(this.aabb.toString()).append("|Fixture=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture)).append("]");
                        return sb.toString();
                    }
                }
                broadphase.BruteForceBroadphaseNode = BruteForceBroadphaseNode;
                BruteForceBroadphaseNode["__class"] = "org.dyn4j.collision.broadphase.BruteForceBroadphaseNode";
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Minimal constructor.
                 * @param {*} collidable1 the first collidable
                 * @param {org.dyn4j.collision.Fixture} fixture1 the first collidable's fixture
                 * @param {*} collidable2 the second collidable
                 * @param {org.dyn4j.collision.Fixture} fixture2 the second collidable's fixture
                 * @class
                 * @author William Bittle
                 */
                class BroadphasePair {
                    constructor(collidable1, fixture1, collidable2, fixture2) {
                        if (this.collidable1 === undefined) {
                            this.collidable1 = null;
                        }
                        if (this.fixture1 === undefined) {
                            this.fixture1 = null;
                        }
                        if (this.collidable2 === undefined) {
                            this.collidable2 = null;
                        }
                        if (this.fixture2 === undefined) {
                            this.fixture2 = null;
                        }
                        this.collidable1 = collidable1;
                        this.fixture1 = fixture1;
                        this.collidable2 = collidable2;
                        this.fixture2 = fixture2;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (obj == null)
                            return false;
                        if (obj === this)
                            return true;
                        if (obj != null && obj instanceof org.dyn4j.collision.broadphase.BroadphasePair) {
                            const pair = obj;
                            if (pair.collidable1 === this.collidable1 && pair.fixture1 === this.fixture1 && pair.collidable2 === this.collidable2 && pair.fixture2 === this.fixture2) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let hash = 17;
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable1);
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture1);
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable2);
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture2);
                        return hash;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("BroadphasePair[Collidable1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable1)).append("|Fixture1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture1)).append("|Collidable2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable2)).append("|Fixture2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture2)).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the first {@link Collidable}.
                     * @return {*} E
                     */
                    getCollidable1() {
                        return this.collidable1;
                    }
                    /**
                     * Returns the first {@link Fixture}.
                     * @return {org.dyn4j.collision.Fixture} T
                     */
                    getFixture1() {
                        return this.fixture1;
                    }
                    /**
                     * Returns the second {@link Collidable}.
                     * @return {*} E
                     */
                    getCollidable2() {
                        return this.collidable2;
                    }
                    /**
                     * Returns the second {@link Fixture}.
                     * @return {org.dyn4j.collision.Fixture} T
                     */
                    getFixture2() {
                        return this.fixture2;
                    }
                }
                broadphase.BroadphasePair = BroadphasePair;
                BroadphasePair["__class"] = "org.dyn4j.collision.broadphase.BroadphasePair";
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Abstract implementation of a {@link BroadphaseDetector}.
                 * @author William Bittle
                 * @version 3.4.0
                 * @since 1.0.0
                 * @param <E> the {@link Collidable} type
                 * @param <T> the {@link Fixture} type
                 * @class
                 */
                class AbstractBroadphaseDetector {
                    constructor() {
                        this.defaultFilter = (new org.dyn4j.collision.broadphase.DefaultBroadphaseFilter());
                        this.expansion = org.dyn4j.collision.broadphase.BroadphaseDetector.DEFAULT_AABB_EXPANSION;
                    }
                    /**
                     * Adds a new {@link Fixture} for the given {@link Collidable} to
                     * the broad-phase.
                     * @param {*} collidable the collidable
                     * @param {org.dyn4j.collision.Fixture} fixture the fixture to add
                     * @since 3.2.0
                     */
                    add(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.add$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    add$org_dyn4j_collision_Collidable(collidable) {
                        const size = collidable.getFixtureCount();
                        for (let i = 0; i < size; i++) {
                            {
                                const fixture = collidable['getFixture$int'](i);
                                this.add(collidable, fixture);
                            }
                            ;
                        }
                    }
                    /**
                     * Removes the given {@link Fixture} for the given {@link Collidable} from
                     * the broad-phase and returns true if it was found.
                     * @param {*} collidable the collidable
                     * @param {org.dyn4j.collision.Fixture} fixture the fixture to remove
                     * @return {boolean} boolean true if the fixture was found and removed
                     * @since 3.2.0
                     */
                    remove(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.remove$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    remove$org_dyn4j_collision_Collidable(collidable) {
                        const size = collidable.getFixtureCount();
                        if (size === 0)
                            return;
                        for (let i = 0; i < size; i++) {
                            {
                                const fixture = collidable['getFixture$int'](i);
                                this.remove(collidable, fixture);
                            }
                            ;
                        }
                    }
                    /**
                     * Updates the given {@link Collidable}'s {@link Fixture}.
                     * <p>
                     * Used when a fixture on a {@link Collidable} has moved or rotated.
                     * <p>
                     * This method will add the {@link Fixture} if it doesn't currently exist in
                     * this broad-phase.
                     * @param {*} collidable the {@link Collidable}
                     * @param {org.dyn4j.collision.Fixture} fixture the {@link Fixture} that has moved
                     * @since 3.2.0
                     */
                    update(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.update$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    update$org_dyn4j_collision_Collidable(collidable) {
                        const size = collidable.getFixtureCount();
                        for (let i = 0; i < size; i++) {
                            {
                                const fixture = collidable['getFixture$int'](i);
                                this.update(collidable, fixture);
                            }
                            ;
                        }
                    }
                    detect$org_dyn4j_collision_Collidable$org_dyn4j_collision_Collidable(a, b) {
                        const aAABB = this.getAABB(a);
                        const bAABB = this.getAABB(b);
                        if (aAABB == null || bAABB == null)
                            return false;
                        if (aAABB.overlaps(bAABB)) {
                            return true;
                        }
                        return false;
                    }
                    /**
                     * Returns the AABB for the given {@link Collidable} {@link Fixture}.
                     * <p>
                     * If the collidable and its fixture have not been added to this
                     * broad-phase, a new AABB is created and returned (but not added to
                     * broad-phase).
                     * @param {*} collidable the {@link Collidable}
                     * @param {org.dyn4j.collision.Fixture} fixture the {@link Fixture}
                     * @return {org.dyn4j.geometry.AABB} {@link AABB}
                     * @since 3.2.0
                     */
                    getAABB(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.getAABB$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getAABB$org_dyn4j_collision_Collidable(collidable) {
                        const size = collidable.getFixtureCount();
                        if (size === 0)
                            return new org.dyn4j.geometry.AABB(0, 0, 0, 0);
                        const union = this.getAABB(collidable, collidable['getFixture$int'](0));
                        for (let i = 1; i < size; i++) {
                            {
                                const aabb = this.getAABB(collidable, collidable['getFixture$int'](i));
                                union.union(aabb);
                            }
                            ;
                        }
                        return union;
                    }
                    detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform(convex1, transform1, convex2, transform2) {
                        const a = convex1['createAABB$org_dyn4j_geometry_Transform'](transform1);
                        const b = convex2['createAABB$org_dyn4j_geometry_Transform'](transform2);
                        if (a.overlaps(b)) {
                            return true;
                        }
                        return false;
                    }
                    /**
                     *
                     * @param {*} convex1
                     * @param {org.dyn4j.geometry.Transform} transform1
                     * @param {*} convex2
                     * @param {org.dyn4j.geometry.Transform} transform2
                     * @return {boolean}
                     */
                    detect(convex1, transform1, convex2, transform2) {
                        if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null)) {
                            return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform(convex1, transform1, convex2, transform2);
                        }
                        else if (((convex1 != null) || convex1 === null) && ((transform1 != null) || transform1 === null) && convex2 === undefined && transform2 === undefined) {
                            return this.detect$org_dyn4j_collision_Collidable$org_dyn4j_collision_Collidable(convex1, transform1);
                        }
                        else if (((convex1 != null && convex1 instanceof org.dyn4j.geometry.AABB) || convex1 === null) && transform1 === undefined && convex2 === undefined && transform2 === undefined) {
                            return this.detect$org_dyn4j_geometry_AABB(convex1);
                        }
                        else if (convex1 === undefined && transform1 === undefined && convex2 === undefined && transform2 === undefined) {
                            return this.detect$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Returns true if the given {@link Fixture} on the given {@link Collidable}
                     * has been added to this broadphase.
                     * @param {*} collidable the {@link Collidable}
                     * @param {org.dyn4j.collision.Fixture} fixture the {@link Fixture}
                     * @return {boolean} boolean
                     * @since 3.2.0
                     */
                    contains(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.contains$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    contains$org_dyn4j_collision_Collidable(collidable) {
                        const size = collidable.getFixtureCount();
                        for (let i = 0; i < size; i++) {
                            {
                                const fixture = collidable['getFixture$int'](i);
                                if (!this.contains(collidable, fixture)) {
                                    return false;
                                }
                            }
                            ;
                        }
                        return true;
                    }
                    raycast$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_geometry_AABB(start, length, invDx, invDy, aabb) {
                        const tx1 = (aabb.getMinX() - start.x) * invDx;
                        const tx2 = (aabb.getMaxX() - start.x) * invDx;
                        let tmin = Math.min(tx1, tx2);
                        let tmax = Math.max(tx1, tx2);
                        const ty1 = (aabb.getMinY() - start.y) * invDy;
                        const ty2 = (aabb.getMaxY() - start.y) * invDy;
                        tmin = Math.max(tmin, Math.min(ty1, ty2));
                        tmax = Math.min(tmax, Math.max(ty1, ty2));
                        if (tmax < 0)
                            return false;
                        if (tmin > length)
                            return false;
                        return tmax >= tmin;
                    }
                    /**
                     * Returns true if the ray and AABB intersect.
                     * <p>
                     * This method is ideally called for a number of AABBs where the invDx and invDy can
                     * be computed once.
                     * @param {org.dyn4j.geometry.Vector2} start the start position of the ray
                     * @param {number} length the length of the ray
                     * @param {number} invDx the inverse of the x component of the ray direction
                     * @param {number} invDy the inverse of the y component of the ray direction
                     * @param {org.dyn4j.geometry.AABB} aabb the AABB to test
                     * @return {boolean} true if the AABB and ray intersect
                     */
                    raycast(start, length, invDx, invDy, aabb) {
                        if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((typeof length === 'number') || length === null) && ((typeof invDx === 'number') || invDx === null) && ((typeof invDy === 'number') || invDy === null) && ((aabb != null && aabb instanceof org.dyn4j.geometry.AABB) || aabb === null)) {
                            return this.raycast$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_geometry_AABB(start, length, invDx, invDy, aabb);
                        }
                        else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof length === 'number') || length === null) && invDx === undefined && invDy === undefined && aabb === undefined) {
                            return this.raycast$org_dyn4j_geometry_Ray$double(start, length);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    detect$() {
                        return this['detect$org_dyn4j_collision_broadphase_BroadphaseFilter'](this.defaultFilter);
                    }
                    detect$org_dyn4j_geometry_AABB(aabb) {
                        return this['detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter'](aabb, this.defaultFilter);
                    }
                    raycast$org_dyn4j_geometry_Ray$double(ray, length) {
                        return this['raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_broadphase_BroadphaseFilter'](ray, length, this.defaultFilter);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    supportsAABBExpansion() {
                        return true;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getAABBExpansion() {
                        return this.expansion;
                    }
                    /**
                     *
                     * @param {number} expansion
                     */
                    setAABBExpansion(expansion) {
                        this.expansion = expansion;
                    }
                }
                broadphase.AbstractBroadphaseDetector = AbstractBroadphaseDetector;
                AbstractBroadphaseDetector["__class"] = "org.dyn4j.collision.broadphase.AbstractBroadphaseDetector";
                AbstractBroadphaseDetector["__interfaces"] = ["org.dyn4j.collision.broadphase.BroadphaseDetector", "org.dyn4j.geometry.Shiftable"];
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Represents a basic node in a {@link DynamicAABBTree}.
                 * <p>
                 * The AABB of the node should be the union of all the AABBs below this node.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 3.2.0
                 * @class
                 */
                class DynamicAABBTreeNode {
                    constructor() {
                        if (this.left === undefined) {
                            this.left = null;
                        }
                        if (this.right === undefined) {
                            this.right = null;
                        }
                        if (this.parent === undefined) {
                            this.parent = null;
                        }
                        if (this.height === undefined) {
                            this.height = 0;
                        }
                        if (this.aabb === undefined) {
                            this.aabb = null;
                        }
                    }
                    /**
                     * Returns true if this node is a leaf node.
                     * @return {boolean} boolean true if this node is a leaf node
                     */
                    isLeaf() {
                        return this.left == null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("DynamicAABBTreeNode[AABB=").append(this.aabb.toString()).append("|Height=").append(this.height).append("]");
                        return sb.toString();
                    }
                }
                broadphase.DynamicAABBTreeNode = DynamicAABBTreeNode;
                DynamicAABBTreeNode["__class"] = "org.dyn4j.collision.broadphase.DynamicAABBTreeNode";
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var manifold;
            (function (manifold) {
                /**
                 * Full constructor.
                 * @param {number} referenceEdge the reference edge index
                 * @param {number} incidentEdge the incident edge index
                 * @param {number} incidentVertex the incident vertex index
                 * @param {boolean} flipped whether the reference and incident features flipped
                 * @class
                 * @author William Bittle
                 */
                class IndexedManifoldPointId {
                    constructor(referenceEdge, incidentEdge, incidentVertex, flipped) {
                        if (((typeof referenceEdge === 'number') || referenceEdge === null) && ((typeof incidentEdge === 'number') || incidentEdge === null) && ((typeof incidentVertex === 'number') || incidentVertex === null) && ((typeof flipped === 'boolean') || flipped === null)) {
                            let __args = arguments;
                            if (this.referenceEdge === undefined) {
                                this.referenceEdge = 0;
                            }
                            if (this.incidentEdge === undefined) {
                                this.incidentEdge = 0;
                            }
                            if (this.incidentVertex === undefined) {
                                this.incidentVertex = 0;
                            }
                            if (this.flipped === undefined) {
                                this.flipped = false;
                            }
                            this.referenceEdge = referenceEdge;
                            this.incidentEdge = incidentEdge;
                            this.incidentVertex = incidentVertex;
                            this.flipped = flipped;
                        }
                        else if (((typeof referenceEdge === 'number') || referenceEdge === null) && ((typeof incidentEdge === 'number') || incidentEdge === null) && ((typeof incidentVertex === 'number') || incidentVertex === null) && flipped === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let flipped = false;
                                if (this.referenceEdge === undefined) {
                                    this.referenceEdge = 0;
                                }
                                if (this.incidentEdge === undefined) {
                                    this.incidentEdge = 0;
                                }
                                if (this.incidentVertex === undefined) {
                                    this.incidentVertex = 0;
                                }
                                if (this.flipped === undefined) {
                                    this.flipped = false;
                                }
                                this.referenceEdge = referenceEdge;
                                this.incidentEdge = incidentEdge;
                                this.incidentVertex = incidentVertex;
                                this.flipped = flipped;
                            }
                            if (this.referenceEdge === undefined) {
                                this.referenceEdge = 0;
                            }
                            if (this.incidentEdge === undefined) {
                                this.incidentEdge = 0;
                            }
                            if (this.incidentVertex === undefined) {
                                this.incidentVertex = 0;
                            }
                            if (this.flipped === undefined) {
                                this.flipped = false;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {boolean}
                     */
                    equals(other) {
                        if (other == null)
                            return false;
                        if (other === this)
                            return true;
                        if (other != null && other instanceof org.dyn4j.collision.manifold.IndexedManifoldPointId) {
                            const o = other;
                            if (this.referenceEdge === o.referenceEdge && this.incidentEdge === o.incidentEdge && this.incidentVertex === o.incidentVertex && this.flipped === o.flipped) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let hash = this.referenceEdge;
                        hash = 37 * hash + this.incidentEdge;
                        hash = 37 * hash + this.incidentVertex;
                        hash = 37 * hash + (this.flipped ? 1231 : 1237);
                        return hash;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("IndexedManifoldPointId[ReferenceEdge=").append(this.referenceEdge).append("|IncidentEdge=").append(this.incidentEdge).append("|IncidentVertex=").append(this.incidentVertex).append("|IsFlipped=").append(this.flipped).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the reference edge index of this manifold
                     * on the {@link Shape}.
                     * <p>
                     * The reference edge is the edge that is most perpendicular to the collision normal.
                     * @return {number} int
                     */
                    getReferenceEdge() {
                        return this.referenceEdge;
                    }
                    /**
                     * Returns the incident edge index of this manifold
                     * on the other {@link Shape}.
                     * @return {number} int
                     */
                    getIncidentEdge() {
                        return this.incidentEdge;
                    }
                    /**
                     * Returns the index of the deepest collision point of the incident edge of this manifold on
                     * the other {@link Shape}.
                     * @return {number} int
                     */
                    getIncidentVertex() {
                        return this.incidentVertex;
                    }
                    /**
                     * Returns true if the reference edge and incident edges were swapped.
                     * @return {boolean} boolean
                     */
                    isFlipped() {
                        return this.flipped;
                    }
                }
                manifold.IndexedManifoldPointId = IndexedManifoldPointId;
                IndexedManifoldPointId["__class"] = "org.dyn4j.collision.manifold.IndexedManifoldPointId";
                IndexedManifoldPointId["__interfaces"] = ["org.dyn4j.collision.manifold.ManifoldPointId"];
            })(manifold = collision.manifold || (collision.manifold = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var manifold;
            (function (manifold) {
                let ManifoldPointId;
                (function (ManifoldPointId) {
                    function DISTANCE_$LI$() { if (ManifoldPointId.DISTANCE == null) {
                        ManifoldPointId.DISTANCE = new ManifoldPointId.ManifoldPointId$0(this);
                    } return ManifoldPointId.DISTANCE; }
                    ManifoldPointId.DISTANCE_$LI$ = DISTANCE_$LI$;
                    ;
                })(ManifoldPointId = manifold.ManifoldPointId || (manifold.ManifoldPointId = {}));
                (function (ManifoldPointId) {
                    class ManifoldPointId$0 {
                        constructor(__parent) {
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        toString() {
                            return "DistanceManifoldPointId[]";
                        }
                    }
                    ManifoldPointId.ManifoldPointId$0 = ManifoldPointId$0;
                    ManifoldPointId$0["__interfaces"] = ["org.dyn4j.collision.manifold.ManifoldPointId"];
                })(ManifoldPointId = manifold.ManifoldPointId || (manifold.ManifoldPointId = {}));
            })(manifold = collision.manifold || (collision.manifold = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var manifold;
            (function (manifold_1) {
                /**
                 * Implementation of a Sutherland-Hodgman clipping {@link ManifoldSolver} algorithm.
                 * <p>
                 * A {@link NarrowphaseDetector} should return a penetration normal and depth when two {@link Convex} {@link Shape}s are
                 * intersecting.  The penetration normal should always point from the first {@link Shape} to the second.  Using the
                 * {@link Penetration}, this class will find the closest features and perform a series of clipping operations to build
                 * a contact {@link Manifold}.
                 * <p>
                 * In the case that a {@link Convex} {@link Shape} returns a {@link PointFeature} {@link Feature}, that feature will always
                 * take precedence.
                 * <p>
                 * It's possible that no contact points are returned, in which case the {@link #getManifold(Penetration, Convex, Transform, Convex, Transform, Manifold)}
                 * method will return false.
                 * @author William Bittle
                 * @version 3.0.2
                 * @since 1.0.0
                 * @see <a href="http://www.dyn4j.org/2011/11/contact-points-using-clipping/" target="_blank">Contact Points Using Clipping</a>
                 * @class
                 */
                class ClippingManifoldSolver {
                    /**
                     *
                     * @param {org.dyn4j.collision.narrowphase.Penetration} penetration
                     * @param {*} convex1
                     * @param {org.dyn4j.geometry.Transform} transform1
                     * @param {*} convex2
                     * @param {org.dyn4j.geometry.Transform} transform2
                     * @param {org.dyn4j.collision.manifold.Manifold} manifold
                     * @return {boolean}
                     */
                    getManifold(penetration, convex1, transform1, convex2, transform2, manifold) {
                        manifold.clear();
                        const n = penetration.getNormal();
                        const feature1 = convex1.getFarthestFeature(n, transform1);
                        if (feature1 != null && feature1 instanceof org.dyn4j.geometry.PointFeature) {
                            const vertex = feature1;
                            const mp = new org.dyn4j.collision.manifold.ManifoldPoint(org.dyn4j.collision.manifold.ManifoldPointId.DISTANCE_$LI$(), vertex.getPoint(), penetration.getDepth());
                            manifold.points.add(mp);
                            manifold.normal = n.getNegative();
                            return true;
                        }
                        const ne = n.getNegative();
                        const feature2 = convex2.getFarthestFeature(ne, transform2);
                        if (feature2 != null && feature2 instanceof org.dyn4j.geometry.PointFeature) {
                            const vertex = feature2;
                            const mp = new org.dyn4j.collision.manifold.ManifoldPoint(org.dyn4j.collision.manifold.ManifoldPointId.DISTANCE_$LI$(), vertex.getPoint(), penetration.getDepth());
                            manifold.points.add(mp);
                            manifold.normal = ne;
                            return true;
                        }
                        let reference = feature1;
                        let incident = feature2;
                        let flipped = false;
                        const e1 = reference.getEdge();
                        const e2 = incident.getEdge();
                        if (Math.abs(e1.dot$org_dyn4j_geometry_Vector2(n)) > Math.abs(e2.dot$org_dyn4j_geometry_Vector2(n))) {
                            const e = reference;
                            reference = incident;
                            incident = e;
                            flipped = true;
                        }
                        const refev = reference.getEdge();
                        refev.normalize();
                        const offset1 = -refev.dot$org_dyn4j_geometry_Vector2(reference.getVertex1().getPoint());
                        const clip1 = this.clip(incident.getVertex1(), incident.getVertex2(), refev.getNegative(), offset1);
                        if (clip1.size() < 2) {
                            return false;
                        }
                        const offset2 = refev.dot$org_dyn4j_geometry_Vector2(reference.getVertex2().getPoint());
                        const clip2 = this.clip(clip1.get(0), clip1.get(1), refev, offset2);
                        if (clip2.size() < 2) {
                            return false;
                        }
                        const frontNormal = refev.getRightHandOrthogonalVector();
                        const frontOffset = frontNormal.dot$org_dyn4j_geometry_Vector2(reference.getMaximum().getPoint());
                        manifold.normal = flipped ? frontNormal.getNegative() : frontNormal;
                        for (let i = 0; i < clip2.size(); i++) {
                            {
                                const vertex = clip2.get(i);
                                const point = vertex.getPoint();
                                const depth = frontNormal.dot$org_dyn4j_geometry_Vector2(point) - frontOffset;
                                if (depth >= 0.0) {
                                    const id = new org.dyn4j.collision.manifold.IndexedManifoldPointId(reference.getIndex(), incident.getIndex(), vertex.getIndex(), flipped);
                                    const mp = new org.dyn4j.collision.manifold.ManifoldPoint(id, point, depth);
                                    manifold.points.add(mp);
                                }
                            }
                            ;
                        }
                        if (manifold.points.size() === 0)
                            return false;
                        return true;
                    }
                    /**
                     * Clips the segment given by s1 and s2 by n.
                     * @param {org.dyn4j.geometry.PointFeature} v1 the first vertex of the segment to be clipped
                     * @param {org.dyn4j.geometry.PointFeature} v2 the second vertex of the segment to be clipped
                     * @param {org.dyn4j.geometry.Vector2} n the clipping plane/line
                     * @param {number} offset the offset of the end point of the segment to be clipped
                     * @return {*} List&lt;{@link Vector2}&gt; the clipped segment
                     */
                    clip(v1, v2, n, offset) {
                        const points = (new java.util.ArrayList(2));
                        const p1 = v1.getPoint();
                        const p2 = v2.getPoint();
                        const d1 = n.dot$org_dyn4j_geometry_Vector2(p1) - offset;
                        const d2 = n.dot$org_dyn4j_geometry_Vector2(p2) - offset;
                        if (d1 <= 0.0)
                            points.add(v1);
                        if (d2 <= 0.0)
                            points.add(v2);
                        if (d1 * d2 < 0.0) {
                            const e = p1.to$org_dyn4j_geometry_Vector2(p2);
                            const u = d1 / (d1 - d2);
                            e.multiply(u);
                            e.add$org_dyn4j_geometry_Vector2(p1);
                            if (d1 > 0.0) {
                                points.add(new org.dyn4j.geometry.PointFeature(e, v1.getIndex()));
                            }
                            else {
                                points.add(new org.dyn4j.geometry.PointFeature(e, v2.getIndex()));
                            }
                        }
                        return points;
                    }
                    constructor() {
                    }
                }
                manifold_1.ClippingManifoldSolver = ClippingManifoldSolver;
                ClippingManifoldSolver["__class"] = "org.dyn4j.collision.manifold.ClippingManifoldSolver";
                ClippingManifoldSolver["__interfaces"] = ["org.dyn4j.collision.manifold.ManifoldSolver"];
            })(manifold = collision.manifold || (collision.manifold = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var manifold;
            (function (manifold) {
                /**
                 * Full constructor.
                 * @param {*} points the manifold points
                 * @param {org.dyn4j.geometry.Vector2} normal the manifold normal
                 * @class
                 * @author William Bittle
                 */
                class Manifold {
                    constructor(points, normal) {
                        if (((points != null && (points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || points === null) && ((normal != null && normal instanceof org.dyn4j.geometry.Vector2) || normal === null)) {
                            let __args = arguments;
                            if (this.points === undefined) {
                                this.points = null;
                            }
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            this.points = points;
                            this.normal = normal;
                        }
                        else if (points === undefined && normal === undefined) {
                            let __args = arguments;
                            if (this.points === undefined) {
                                this.points = null;
                            }
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            this.points = (new java.util.ArrayList(2));
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("Manifold[Normal=").append(this.normal);
                        sb.append("|Points={");
                        const size = this.points.size();
                        for (let i = 0; i < size; i++) {
                            {
                                if (i !== 0)
                                    sb.append(",");
                                sb.append(this.points.get(i));
                            }
                            ;
                        }
                        sb.append("}]");
                        return sb.toString();
                    }
                    /**
                     * Clears the {@link Manifold} information.
                     */
                    clear() {
                        this.points.clear();
                        this.normal = null;
                    }
                    /**
                     * Returns the list of manifold points.
                     * @return {*} List&lt;{@link ManifoldPoint}&gt;
                     */
                    getPoints() {
                        return this.points;
                    }
                    /**
                     * Returns the normal.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getNormal() {
                        return this.normal;
                    }
                    /**
                     * Sets the point list of this {@link Manifold}.
                     * @param {*} points the point list
                     */
                    setPoints(points) {
                        this.points = points;
                    }
                    /**
                     * Sets the manifold normal.
                     * <p>
                     * Must be normalized.
                     * @param {org.dyn4j.geometry.Vector2} normal the manifold normal
                     */
                    setNormal(normal) {
                        this.normal = normal;
                    }
                }
                manifold.Manifold = Manifold;
                Manifold["__class"] = "org.dyn4j.collision.manifold.Manifold";
            })(manifold = collision.manifold || (collision.manifold = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var manifold;
            (function (manifold) {
                /**
                 * Full constructor.
                 * @param {*} id the id for this manifold point
                 * @param {org.dyn4j.geometry.Vector2} point the manifold point in world coordinates
                 * @param {number} depth the penetration depth
                 * @class
                 * @author William Bittle
                 */
                class ManifoldPoint {
                    constructor(id, point, depth) {
                        if (((id != null && (id.constructor != null && id.constructor["__interfaces"] != null && id.constructor["__interfaces"].indexOf("org.dyn4j.collision.manifold.ManifoldPointId") >= 0)) || id === null) && ((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((typeof depth === 'number') || depth === null)) {
                            let __args = arguments;
                            if (this.id === undefined) {
                                this.id = null;
                            }
                            if (this.point === undefined) {
                                this.point = null;
                            }
                            if (this.depth === undefined) {
                                this.depth = 0;
                            }
                            this.id = id;
                            this.point = point;
                            this.depth = depth;
                        }
                        else if (((id != null && (id.constructor != null && id.constructor["__interfaces"] != null && id.constructor["__interfaces"].indexOf("org.dyn4j.collision.manifold.ManifoldPointId") >= 0)) || id === null) && point === undefined && depth === undefined) {
                            let __args = arguments;
                            if (this.id === undefined) {
                                this.id = null;
                            }
                            if (this.point === undefined) {
                                this.point = null;
                            }
                            if (this.depth === undefined) {
                                this.depth = 0;
                            }
                            this.id = id;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("ManifoldPoint[Id=").append(this.id).append("|Point=").append(this.point).append("|Depth=").append(this.depth).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the id for this manifold point.
                     * @return {*} {@link ManifoldPointId}
                     */
                    getId() {
                        return this.id;
                    }
                    /**
                     * Returns the contact point.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the point in world coordinates
                     */
                    getPoint() {
                        return this.point;
                    }
                    /**
                     * Sets the contact point.
                     * @param {org.dyn4j.geometry.Vector2} point the point in world coordinates
                     * @since 3.1.5
                     */
                    setPoint(point) {
                        this.point = point;
                    }
                    /**
                     * Returns the collision depth of the manifold point.
                     * @return {number} double
                     */
                    getDepth() {
                        return this.depth;
                    }
                    /**
                     * Sets the collision depth of the manifold point.
                     * @param {number} depth the depth
                     * @since 3.1.5
                     */
                    setDepth(depth) {
                        this.depth = depth;
                    }
                }
                manifold.ManifoldPoint = ManifoldPoint;
                ManifoldPoint["__class"] = "org.dyn4j.collision.manifold.ManifoldPoint";
            })(manifold = collision.manifold || (collision.manifold = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Minimal constructor.
                 * @param {number} sortIndex the sort index
                 * @class
                 * @author William Bittle
                 */
                class AbstractFallbackCondition {
                    constructor(sortIndex) {
                        if (this.sortIndex === undefined) {
                            this.sortIndex = 0;
                        }
                        this.sortIndex = sortIndex;
                    }
                    /**
                     *
                     * @param {*} o
                     * @return {number}
                     */
                    compareTo(o) {
                        return this.getSortIndex() - o.getSortIndex();
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let result = 1;
                        result = 31 * result + this.sortIndex;
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj)
                            return true;
                        if (obj == null)
                            return false;
                        if (obj != null && obj instanceof org.dyn4j.collision.narrowphase.AbstractFallbackCondition) {
                            const other = obj;
                            if (this.sortIndex === other.sortIndex) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getSortIndex() {
                        return this.sortIndex;
                    }
                }
                narrowphase.AbstractFallbackCondition = AbstractFallbackCondition;
                AbstractFallbackCondition["__class"] = "org.dyn4j.collision.narrowphase.AbstractFallbackCondition";
                AbstractFallbackCondition["__interfaces"] = ["java.lang.Comparable", "org.dyn4j.collision.narrowphase.FallbackCondition"];
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Class devoted to improving performance of {@link Segment} detection queries.
                 * @author William Bittle
                 * @version 3.4.0
                 * @since 2.0.0
                 * @class
                 */
                class SegmentDetector {
                    constructor() {
                    }
                    /**
                     * Performs a ray cast against the given segment.
                     * @param {org.dyn4j.geometry.Ray} ray the {@link Ray}
                     * @param {number} maxLength the maximum ray length
                     * @param {org.dyn4j.geometry.Segment} segment the {@link Segment}
                     * @param {org.dyn4j.geometry.Transform} transform the {@link Segment}'s {@link Transform}
                     * @param {org.dyn4j.collision.narrowphase.Raycast} raycast the {@link Raycast} result
                     * @return {boolean} boolean true if the ray intersects the segment
                     * @since 2.0.0
                     */
                    static raycast(ray, maxLength, segment, transform, raycast) {
                        const p0 = ray.getStart();
                        const d0 = ray.getDirectionVector();
                        const p1 = transform.getTransformed$org_dyn4j_geometry_Vector2(segment.getPoint1());
                        const p2 = transform.getTransformed$org_dyn4j_geometry_Vector2(segment.getPoint2());
                        const d1 = p1.to$org_dyn4j_geometry_Vector2(p2);
                        if (segment.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(p0, transform))
                            return false;
                        const p0ToP1 = p1.difference$org_dyn4j_geometry_Vector2(p0);
                        const num = d1.cross$org_dyn4j_geometry_Vector2(p0ToP1);
                        const den = d1.cross$org_dyn4j_geometry_Vector2(d0);
                        if (Math.abs(den) <= org.dyn4j.Epsilon.E_$LI$()) {
                            const n = d0.getRightHandOrthogonalVector();
                            const nDotP0 = n.dot$org_dyn4j_geometry_Vector2(p0);
                            const nDotP1 = n.dot$org_dyn4j_geometry_Vector2(p1);
                            if (Math.abs(nDotP0 - nDotP1) < org.dyn4j.Epsilon.E_$LI$()) {
                                const d0DotP0 = d0.dot$org_dyn4j_geometry_Vector2(p0);
                                const d0DotP1 = d0.dot$org_dyn4j_geometry_Vector2(p1);
                                const d0DotP2 = d0.dot$org_dyn4j_geometry_Vector2(p2);
                                if (d0DotP1 < 0.0 || d0DotP2 < 0.0) {
                                    return false;
                                }
                                let d = 0.0;
                                let p = null;
                                if (d0DotP1 < d0DotP2) {
                                    d = d0DotP1 - d0DotP0;
                                    p = p1.copy();
                                }
                                else {
                                    d = d0DotP2 - d0DotP0;
                                    p = p2.copy();
                                }
                                if (maxLength > 0.0 && d > maxLength) {
                                    return false;
                                }
                                raycast.distance = d;
                                raycast.point = p;
                                raycast.normal = d0.getNegative();
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                        const t = num / den;
                        if (t < 0.0) {
                            return false;
                        }
                        if (maxLength > 0.0 && t > maxLength) {
                            return false;
                        }
                        let s = 0;
                        const isVertical = Math.abs(d1.x) <= org.dyn4j.Epsilon.E_$LI$();
                        const isHorizontal = Math.abs(d1.y) <= org.dyn4j.Epsilon.E_$LI$();
                        if (isVertical && isHorizontal) {
                            return false;
                        }
                        if (isVertical) {
                            s = (t * d0.y + p0.y - p1.y) / d1.y;
                        }
                        else {
                            s = (t * d0.x + p0.x - p1.x) / d1.x;
                        }
                        if (s < 0.0 || s > 1.0) {
                            return false;
                        }
                        const p = d0.product(t).add$org_dyn4j_geometry_Vector2(p0);
                        const l = p1.to$org_dyn4j_geometry_Vector2(p2);
                        l.normalize();
                        l.right();
                        const lDotD = l.dot$org_dyn4j_geometry_Vector2(d0);
                        if (lDotD > 0.0) {
                            l.negate();
                        }
                        raycast.point = p;
                        raycast.normal = l;
                        raycast.distance = t;
                        return true;
                    }
                }
                narrowphase.SegmentDetector = SegmentDetector;
                SegmentDetector["__class"] = "org.dyn4j.collision.narrowphase.SegmentDetector";
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * A {@link NarrowphasePostProcessor} specifically for the {@link Link} class to solve the
                 * internal edge problem when using a chain of segments.
                 * @author Willima Bittle
                 * @version 3.2.2
                 * @since 3.2.2
                 * @see <a href="https://bullet.googlecode.com/files/GDC10_Coumans_Erwin_Contact.pdf">Slides 46-54</a>
                 * @class
                 */
                class LinkPostProcessor {
                    process$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex1, transform1, convex2, transform2, penetration) {
                        if (convex1 != null && convex1 instanceof org.dyn4j.geometry.Link) {
                            this.process$org_dyn4j_geometry_Link$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex1, transform1, convex2, transform2, penetration);
                        }
                        else if (convex2 != null && convex2 instanceof org.dyn4j.geometry.Link) {
                            penetration.normal.negate();
                            this.process$org_dyn4j_geometry_Link$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex2, transform2, convex1, transform1, penetration);
                            penetration.normal.negate();
                        }
                    }
                    process$org_dyn4j_geometry_Link$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(link, transform1, convex, transform2, penetration) {
                        const n = penetration.getNormal();
                        const c = transform2.getTransformed$org_dyn4j_geometry_Vector2(convex.getCenter());
                        const p1 = transform1.getTransformed$org_dyn4j_geometry_Vector2(link.getPoint1());
                        const p2 = transform1.getTransformed$org_dyn4j_geometry_Vector2(link.getPoint2());
                        const p0 = link.getPoint0() != null ? transform1.getTransformed$org_dyn4j_geometry_Vector2(link.getPoint0()) : null;
                        const p3 = link.getPoint3() != null ? transform1.getTransformed$org_dyn4j_geometry_Vector2(link.getPoint3()) : null;
                        let convex1 = false;
                        let convex2 = false;
                        let edge0 = null;
                        let edge1 = null;
                        let edge2 = null;
                        let normal0 = null;
                        let normal1 = null;
                        let normal2 = null;
                        let normal = null;
                        let upper = null;
                        let lower = null;
                        let offset0 = 0;
                        let offset1 = 0;
                        let offset2 = 0;
                        edge1 = p1.to$org_dyn4j_geometry_Vector2(p2);
                        edge1.normalize();
                        normal1 = edge1.getLeftHandOrthogonalVector();
                        offset1 = normal1.dot$org_dyn4j_geometry_Vector2(p1.to$org_dyn4j_geometry_Vector2(c));
                        if (p0 != null) {
                            edge0 = p0.to$org_dyn4j_geometry_Vector2(p1);
                            edge0.normalize();
                            normal0 = edge0.getLeftHandOrthogonalVector();
                            convex1 = edge0.cross$org_dyn4j_geometry_Vector2(edge1) >= 0;
                            offset0 = normal0.dot$org_dyn4j_geometry_Vector2(p0.to$org_dyn4j_geometry_Vector2(c));
                        }
                        if (p3 != null) {
                            edge2 = p2.to$org_dyn4j_geometry_Vector2(p3);
                            edge2.normalize();
                            normal2 = edge2.getLeftHandOrthogonalVector();
                            convex2 = edge1.cross$org_dyn4j_geometry_Vector2(edge2) >= 0;
                            offset2 = normal2.dot$org_dyn4j_geometry_Vector2(p2.to$org_dyn4j_geometry_Vector2(c));
                        }
                        if (p0 != null && p3 != null) {
                            if (convex1 && convex2) {
                                const front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;
                                if (front) {
                                    normal = normal1;
                                    lower = normal0;
                                    upper = normal2;
                                }
                                else {
                                    normal = normal1.getNegative();
                                    lower = normal;
                                    upper = normal;
                                }
                            }
                            else if (convex1) {
                                const front = offset0 >= 0 || (offset1 >= 0 && offset2 >= 0);
                                if (front) {
                                    normal = normal1;
                                    lower = normal0;
                                    upper = normal1;
                                }
                                else {
                                    normal = normal1.getNegative();
                                    lower = normal2.getNegative();
                                    upper = normal1.getNegative();
                                }
                            }
                            else if (convex2) {
                                const front = offset2 >= 0 || (offset0 >= 0 && offset1 >= 0);
                                if (front) {
                                    normal = normal1;
                                    lower = normal1;
                                    upper = normal2;
                                }
                                else {
                                    normal = normal1.getNegative();
                                    lower = normal1.getNegative();
                                    upper = normal0.getNegative();
                                }
                            }
                            else {
                                const front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;
                                if (front) {
                                    normal = normal1;
                                    lower = normal1;
                                    upper = normal1;
                                }
                                else {
                                    normal = normal1.getNegative();
                                    lower = normal2.getNegative();
                                    upper = normal0.getNegative();
                                }
                            }
                        }
                        else if (p0 != null) {
                            if (convex1) {
                                const front = offset0 >= 0 || offset1 >= 0;
                                if (front) {
                                    normal = normal1;
                                    lower = normal0;
                                    upper = normal1.getNegative();
                                }
                                else {
                                    normal = normal1.getNegative();
                                    lower = normal1;
                                    upper = normal1.getNegative();
                                }
                            }
                            else {
                                const front = offset0 >= 0 && offset1 >= 0;
                                if (front) {
                                    normal = normal1;
                                    lower = normal1;
                                    upper = normal1.getNegative();
                                }
                                else {
                                    normal = normal1.getNegative();
                                    lower = normal1;
                                    upper = normal0.getNegative();
                                }
                            }
                        }
                        else if (p3 != null) {
                            if (convex2) {
                                const front = offset1 >= 0 || offset2 >= 0;
                                if (front) {
                                    normal = normal1;
                                    lower = normal1.getNegative();
                                    upper = normal2;
                                }
                                else {
                                    normal = normal1.getNegative();
                                    lower = normal1.getNegative();
                                    upper = normal1;
                                }
                            }
                            else {
                                const front = offset1 >= 0 && offset2 >= 0;
                                if (front) {
                                    normal = normal1;
                                    lower = normal1.getNegative();
                                    upper = normal1;
                                }
                                else {
                                    normal = normal1.getNegative();
                                    lower = normal2.getNegative();
                                    upper = normal1;
                                }
                            }
                        }
                        else {
                            const front = offset1 >= 0;
                            if (front) {
                                normal = normal1;
                                lower = normal1.getNegative();
                                upper = normal1.getNegative();
                            }
                            else {
                                normal = normal1.getNegative();
                                lower = normal1;
                                upper = normal1;
                            }
                        }
                        const perp = normal.getRightHandOrthogonalVector();
                        if (n.dot$org_dyn4j_geometry_Vector2(perp) >= 0) {
                            if (n.difference$org_dyn4j_geometry_Vector2(upper).dot$org_dyn4j_geometry_Vector2(normal) < 0) {
                                penetration.normal = upper;
                                penetration.depth = upper.dot$org_dyn4j_geometry_Vector2(n) * penetration.depth;
                            }
                        }
                        else {
                            if (n.difference$org_dyn4j_geometry_Vector2(lower).dot$org_dyn4j_geometry_Vector2(normal) < 0) {
                                penetration.normal = lower;
                                penetration.depth = lower.dot$org_dyn4j_geometry_Vector2(n) * penetration.depth;
                            }
                        }
                    }
                    /**
                     * Attempts to use the connectivity information to determine if the normal found in the narrow-phase is valid.
                     * If not, the normal is modified to within the valid range of normals based on the connectivity and the collision
                     * depth is adjusted.
                     * @param {org.dyn4j.geometry.Link} link the link
                     * @param {org.dyn4j.geometry.Transform} transform1 the link's transform
                     * @param {*} convex the other convex
                     * @param {org.dyn4j.geometry.Transform} transform2 the other convex transform
                     * @param {org.dyn4j.collision.narrowphase.Penetration} penetration the narrow-phase collision information
                     */
                    process(link, transform1, convex, transform2, penetration) {
                        if (((link != null && link instanceof org.dyn4j.geometry.Link) || link === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && ((penetration != null && penetration instanceof org.dyn4j.collision.narrowphase.Penetration) || penetration === null)) {
                            return this.process$org_dyn4j_geometry_Link$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(link, transform1, convex, transform2, penetration);
                        }
                        else if (((link != null && (link.constructor != null && link.constructor["__interfaces"] != null && link.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || link === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && ((penetration != null && penetration instanceof org.dyn4j.collision.narrowphase.Penetration) || penetration === null)) {
                            return this.process$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(link, transform1, convex, transform2, penetration);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    constructor() {
                    }
                }
                narrowphase.LinkPostProcessor = LinkPostProcessor;
                LinkPostProcessor["__class"] = "org.dyn4j.collision.narrowphase.LinkPostProcessor";
                LinkPostProcessor["__interfaces"] = ["org.dyn4j.collision.narrowphase.NarrowphasePostProcessor"];
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.geometry.Vector2} supportPoint1 the support point in the first {@link Convex} {@link Shape}
                 * @param {org.dyn4j.geometry.Vector2} supportPoint2 the support point in the second {@link Convex} {@link Shape}
                 * @class
                 * @author William Bittle
                 */
                class MinkowskiSumPoint {
                    constructor(supportPoint1, supportPoint2) {
                        if (this.supportPoint1 === undefined) {
                            this.supportPoint1 = null;
                        }
                        if (this.supportPoint2 === undefined) {
                            this.supportPoint2 = null;
                        }
                        if (this.point === undefined) {
                            this.point = null;
                        }
                        this.supportPoint1 = supportPoint1;
                        this.supportPoint2 = supportPoint2;
                        this.point = supportPoint1.difference$org_dyn4j_geometry_Vector2(supportPoint2);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("MinkowskiSum.Point[Point=").append(this.point).append("|SupportPoint1=").append(this.supportPoint1).append("|SupportPoint2=").append(this.supportPoint2).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the support point for the first {@link Convex} {@link Shape}.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getSupportPoint1() {
                        return this.supportPoint1;
                    }
                    /**
                     * Returns the support point for the second {@link Convex} {@link Shape}.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getSupportPoint2() {
                        return this.supportPoint2;
                    }
                    /**
                     * Returns the Minkowski sum point given the two support points.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getPoint() {
                        return this.point;
                    }
                }
                narrowphase.MinkowskiSumPoint = MinkowskiSumPoint;
                MinkowskiSumPoint["__class"] = "org.dyn4j.collision.narrowphase.MinkowskiSumPoint";
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Full constructor.
                 * @param {*} primaryNarrowphaseDetector the primary {@link NarrowphaseDetector}
                 * @param {*} fallbackNarrowphaseDetector the fallback {@link NarrowphaseDetector}
                 * @param {*} conditions the fallback conditions
                 * @throws NullPointerException if either the primary or fallback {@link NarrowphaseDetector}s are null
                 * @class
                 * @author William Bittle
                 */
                class FallbackNarrowphaseDetector {
                    constructor(primaryNarrowphaseDetector, fallbackNarrowphaseDetector, conditions) {
                        if (((primaryNarrowphaseDetector != null && (primaryNarrowphaseDetector.constructor != null && primaryNarrowphaseDetector.constructor["__interfaces"] != null && primaryNarrowphaseDetector.constructor["__interfaces"].indexOf("org.dyn4j.collision.narrowphase.NarrowphaseDetector") >= 0)) || primaryNarrowphaseDetector === null) && ((fallbackNarrowphaseDetector != null && (fallbackNarrowphaseDetector.constructor != null && fallbackNarrowphaseDetector.constructor["__interfaces"] != null && fallbackNarrowphaseDetector.constructor["__interfaces"].indexOf("org.dyn4j.collision.narrowphase.NarrowphaseDetector") >= 0)) || fallbackNarrowphaseDetector === null) && ((conditions != null && (conditions.constructor != null && conditions.constructor["__interfaces"] != null && conditions.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || conditions === null)) {
                            let __args = arguments;
                            if (this.primaryNarrowphaseDetector === undefined) {
                                this.primaryNarrowphaseDetector = null;
                            }
                            if (this.fallbackNarrowphaseDetector === undefined) {
                                this.fallbackNarrowphaseDetector = null;
                            }
                            if (this.fallbackConditions === undefined) {
                                this.fallbackConditions = null;
                            }
                            if (primaryNarrowphaseDetector == null)
                                throw new java.lang.NullPointerException();
                            if (fallbackNarrowphaseDetector == null)
                                throw new java.lang.NullPointerException();
                            this.primaryNarrowphaseDetector = primaryNarrowphaseDetector;
                            this.fallbackNarrowphaseDetector = fallbackNarrowphaseDetector;
                            if (conditions != null) {
                                this.fallbackConditions = conditions;
                            }
                            else {
                                this.fallbackConditions = (new java.util.ArrayList());
                            }
                        }
                        else if (((primaryNarrowphaseDetector != null && (primaryNarrowphaseDetector.constructor != null && primaryNarrowphaseDetector.constructor["__interfaces"] != null && primaryNarrowphaseDetector.constructor["__interfaces"].indexOf("org.dyn4j.collision.narrowphase.NarrowphaseDetector") >= 0)) || primaryNarrowphaseDetector === null) && ((fallbackNarrowphaseDetector != null && (fallbackNarrowphaseDetector.constructor != null && fallbackNarrowphaseDetector.constructor["__interfaces"] != null && fallbackNarrowphaseDetector.constructor["__interfaces"].indexOf("org.dyn4j.collision.narrowphase.NarrowphaseDetector") >= 0)) || fallbackNarrowphaseDetector === null) && conditions === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let conditions = new java.util.ArrayList();
                                if (this.primaryNarrowphaseDetector === undefined) {
                                    this.primaryNarrowphaseDetector = null;
                                }
                                if (this.fallbackNarrowphaseDetector === undefined) {
                                    this.fallbackNarrowphaseDetector = null;
                                }
                                if (this.fallbackConditions === undefined) {
                                    this.fallbackConditions = null;
                                }
                                if (primaryNarrowphaseDetector == null)
                                    throw new java.lang.NullPointerException();
                                if (fallbackNarrowphaseDetector == null)
                                    throw new java.lang.NullPointerException();
                                this.primaryNarrowphaseDetector = primaryNarrowphaseDetector;
                                this.fallbackNarrowphaseDetector = fallbackNarrowphaseDetector;
                                if (conditions != null) {
                                    this.fallbackConditions = conditions;
                                }
                                else {
                                    this.fallbackConditions = (new java.util.ArrayList());
                                }
                            }
                            if (this.primaryNarrowphaseDetector === undefined) {
                                this.primaryNarrowphaseDetector = null;
                            }
                            if (this.fallbackNarrowphaseDetector === undefined) {
                                this.fallbackNarrowphaseDetector = null;
                            }
                            if (this.fallbackConditions === undefined) {
                                this.fallbackConditions = null;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Adds the given condition to the list of fallback conditions.
                     * @param {*} condition the condition
                     */
                    addCondition(condition) {
                        this.fallbackConditions.add(condition);
                        java.util.Collections.sort(this.fallbackConditions);
                    }
                    /**
                     * Removes the given condition to the list of fallback conditions and
                     * returns true if the operation was successful.
                     * @param {*} condition the condition
                     * @return {boolean} boolean
                     */
                    removeCondition(condition) {
                        return this.fallbackConditions.remove(condition);
                    }
                    /**
                     * Returns true if the given condition is contained in this detector.
                     * @param {*} condition the fallback condition
                     * @return {boolean} boolean
                     */
                    containsCondition(condition) {
                        return this.fallbackConditions.contains(condition);
                    }
                    /**
                     * Returns the number of fallback conditions.
                     * @return {number} int
                     */
                    getConditionCount() {
                        return this.fallbackConditions.size();
                    }
                    /**
                     * Returns the fallback condition at the given index.
                     * @param {number} index the index
                     * @return {*} {@link FallbackCondition}
                     * @throws IndexOutOfBoundsException if index is not between 0 and {@link #getConditionCount()}
                     */
                    getCondition(index) {
                        return this.fallbackConditions.get(index);
                    }
                    /**
                     * Returns true if the fallback {@link NarrowphaseDetector} should be used rather
                     * than the primary.
                     * @param {*} convex1 the first convex
                     * @param {*} convex2 the second convex
                     * @return {boolean} boolean
                     */
                    isFallbackRequired(convex1, convex2) {
                        const size = this.fallbackConditions.size();
                        for (let i = 0; i < size; i++) {
                            {
                                const condition = this.fallbackConditions.get(i);
                                if (condition != null && condition.isMatch(convex1, convex2)) {
                                    return true;
                                }
                            }
                            ;
                        }
                        return false;
                    }
                    detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform(convex1, transform1, convex2, transform2) {
                        if (this.isFallbackRequired(convex1, convex2)) {
                            return this.fallbackNarrowphaseDetector['detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform'](convex1, transform1, convex2, transform2);
                        }
                        return this.primaryNarrowphaseDetector['detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform'](convex1, transform1, convex2, transform2);
                    }
                    detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex1, transform1, convex2, transform2, penetration) {
                        if (this.isFallbackRequired(convex1, convex2)) {
                            return this.fallbackNarrowphaseDetector['detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration'](convex1, transform1, convex2, transform2, penetration);
                        }
                        return this.primaryNarrowphaseDetector['detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration'](convex1, transform1, convex2, transform2, penetration);
                    }
                    /**
                     *
                     * @param {*} convex1
                     * @param {org.dyn4j.geometry.Transform} transform1
                     * @param {*} convex2
                     * @param {org.dyn4j.geometry.Transform} transform2
                     * @param {org.dyn4j.collision.narrowphase.Penetration} penetration
                     * @return {boolean}
                     */
                    detect(convex1, transform1, convex2, transform2, penetration) {
                        if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && ((penetration != null && penetration instanceof org.dyn4j.collision.narrowphase.Penetration) || penetration === null)) {
                            return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex1, transform1, convex2, transform2, penetration);
                        }
                        else if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && penetration === undefined) {
                            return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform(convex1, transform1, convex2, transform2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Returns the primary {@link NarrowphaseDetector}.
                     * @return {*} {@link NarrowphaseDetector}
                     */
                    getPrimaryNarrowphaseDetector() {
                        return this.primaryNarrowphaseDetector;
                    }
                    /**
                     * Returns the fallback {@link NarrowphaseDetector}.
                     * @return {*} {@link NarrowphaseDetector}
                     */
                    getFallbackNarrowphaseDetector() {
                        return this.fallbackNarrowphaseDetector;
                    }
                }
                narrowphase.FallbackNarrowphaseDetector = FallbackNarrowphaseDetector;
                FallbackNarrowphaseDetector["__class"] = "org.dyn4j.collision.narrowphase.FallbackNarrowphaseDetector";
                FallbackNarrowphaseDetector["__interfaces"] = ["org.dyn4j.collision.narrowphase.NarrowphaseDetector"];
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Class devoted to {@link Circle} detection queries.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 2.0.0
                 * @class
                 */
                class CircleDetector {
                    constructor() {
                    }
                    static detect$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(circle1, transform1, circle2, transform2, penetration) {
                        const ce1 = transform1.getTransformed$org_dyn4j_geometry_Vector2(circle1.getCenter());
                        const ce2 = transform2.getTransformed$org_dyn4j_geometry_Vector2(circle2.getCenter());
                        const v = ce2.subtract$org_dyn4j_geometry_Vector2(ce1);
                        const radii = circle1.getRadius$() + circle2.getRadius$();
                        const mag = v.getMagnitudeSquared();
                        if (mag < radii * radii) {
                            penetration.normal = v;
                            penetration.depth = radii - v.normalize();
                            return true;
                        }
                        return false;
                    }
                    /**
                     * Fast method for determining a collision between two {@link Circle}s.
                     * <p>
                     * Returns true if the given {@link Circle}s are intersecting and places the
                     * penetration vector and depth in the given {@link Penetration} object.
                     * <p>
                     * If the {@link Circle} centers are coincident then the penetration {@link Vector2}
                     * will be the zero {@link Vector2}, however, the penetration depth will be
                     * correct.  In this case its up to the caller to determine a reasonable penetration
                     * {@link Vector2}.
                     * @param {org.dyn4j.geometry.Circle} circle1 the first {@link Circle}
                     * @param {org.dyn4j.geometry.Transform} transform1 the first {@link Circle}'s {@link Transform}
                     * @param {org.dyn4j.geometry.Circle} circle2 the second {@link Circle}
                     * @param {org.dyn4j.geometry.Transform} transform2 the second {@link Circle}'s {@link Transform}
                     * @param {org.dyn4j.collision.narrowphase.Penetration} penetration the {@link Penetration} object to fill
                     * @return {boolean} boolean
                     */
                    static detect(circle1, transform1, circle2, transform2, penetration) {
                        if (((circle1 != null && circle1 instanceof org.dyn4j.geometry.Circle) || circle1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((circle2 != null && circle2 instanceof org.dyn4j.geometry.Circle) || circle2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && ((penetration != null && penetration instanceof org.dyn4j.collision.narrowphase.Penetration) || penetration === null)) {
                            return org.dyn4j.collision.narrowphase.CircleDetector.detect$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(circle1, transform1, circle2, transform2, penetration);
                        }
                        else if (((circle1 != null && circle1 instanceof org.dyn4j.geometry.Circle) || circle1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((circle2 != null && circle2 instanceof org.dyn4j.geometry.Circle) || circle2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && penetration === undefined) {
                            return org.dyn4j.collision.narrowphase.CircleDetector.detect$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform(circle1, transform1, circle2, transform2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static detect$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform(circle1, transform1, circle2, transform2) {
                        const ce1 = transform1.getTransformed$org_dyn4j_geometry_Vector2(circle1.getCenter());
                        const ce2 = transform2.getTransformed$org_dyn4j_geometry_Vector2(circle2.getCenter());
                        const v = ce2.subtract$org_dyn4j_geometry_Vector2(ce1);
                        const radii = circle1.getRadius$() + circle2.getRadius$();
                        const mag = v.getMagnitudeSquared();
                        if (mag < radii * radii) {
                            return true;
                        }
                        return false;
                    }
                    /**
                     * Fast method for determining the distance between two {@link Circle}s.
                     * <p>
                     * Returns true if the given {@link Circle}s are separated and places the
                     * separating vector and distance in the given {@link Separation} object.
                     * @param {org.dyn4j.geometry.Circle} circle1 the first {@link Circle}
                     * @param {org.dyn4j.geometry.Transform} transform1 the first {@link Circle}'s {@link Transform}
                     * @param {org.dyn4j.geometry.Circle} circle2 the second {@link Circle}
                     * @param {org.dyn4j.geometry.Transform} transform2 the second {@link Circle}'s {@link Transform}
                     * @param {org.dyn4j.collision.narrowphase.Separation} separation the {@link Separation} object to fill
                     * @return {boolean} boolean
                     */
                    static distance(circle1, transform1, circle2, transform2, separation) {
                        const ce1 = transform1.getTransformed$org_dyn4j_geometry_Vector2(circle1.getCenter());
                        const ce2 = transform2.getTransformed$org_dyn4j_geometry_Vector2(circle2.getCenter());
                        const r1 = circle1.getRadius$();
                        const r2 = circle2.getRadius$();
                        const v = ce1.to$org_dyn4j_geometry_Vector2(ce2);
                        const radii = r1 + r2;
                        const mag = v.getMagnitudeSquared();
                        if (mag >= radii * radii) {
                            separation.normal = v;
                            separation.distance = v.normalize() - radii;
                            separation.point1 = ce1.add$double$double(v.x * r1, v.y * r1);
                            separation.point2 = ce2.add$double$double(-v.x * r2, -v.y * r2);
                            return true;
                        }
                        return false;
                    }
                    /**
                     * Performs a ray cast against the given circle.
                     * @param {org.dyn4j.geometry.Ray} ray the {@link Ray}
                     * @param {number} maxLength the maximum ray length
                     * @param {org.dyn4j.geometry.Circle} circle the {@link Circle}
                     * @param {org.dyn4j.geometry.Transform} transform the {@link Circle}'s {@link Transform}
                     * @param {org.dyn4j.collision.narrowphase.Raycast} raycast the {@link Raycast} result
                     * @return {boolean} boolean true if the ray intersects the circle
                     * @since 2.0.0
                     */
                    static raycast(ray, maxLength, circle, transform, raycast) {
                        const s = ray.getStart();
                        const d = ray.getDirectionVector();
                        const ce = transform.getTransformed$org_dyn4j_geometry_Vector2(circle.getCenter());
                        const r = circle.getRadius$();
                        if (circle.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(s, transform))
                            return false;
                        const sMinusC = s.difference$org_dyn4j_geometry_Vector2(ce);
                        const a = d.dot$org_dyn4j_geometry_Vector2(d);
                        const b = 2 * d.dot$org_dyn4j_geometry_Vector2(sMinusC);
                        const c = sMinusC.dot$org_dyn4j_geometry_Vector2(sMinusC) - r * r;
                        const inv2a = 1.0 / (2.0 * a);
                        const b24ac = b * b - 4 * a * c;
                        if (b24ac < 0.0) {
                            return false;
                        }
                        const sqrt = Math.sqrt(b24ac);
                        const t0 = (-b + sqrt) * inv2a;
                        const t1 = (-b - sqrt) * inv2a;
                        let t = 0.0;
                        if (t0 < 0.0) {
                            if (t1 < 0.0) {
                                return false;
                            }
                            else {
                                t = t1;
                            }
                        }
                        else {
                            if (t1 < 0.0) {
                                t = t0;
                            }
                            else if (t0 < t1) {
                                t = t0;
                            }
                            else {
                                t = t1;
                            }
                        }
                        if (maxLength > 0.0 && t > maxLength) {
                            return false;
                        }
                        const p = d.product(t).add$org_dyn4j_geometry_Vector2(s);
                        const n = ce.to$org_dyn4j_geometry_Vector2(p);
                        n.normalize();
                        raycast.point = p;
                        raycast.normal = n;
                        raycast.distance = t;
                        return true;
                    }
                }
                narrowphase.CircleDetector = CircleDetector;
                CircleDetector["__class"] = "org.dyn4j.collision.narrowphase.CircleDetector";
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.geometry.Vector2} point the hit point
                 * @param {org.dyn4j.geometry.Vector2} normal the normal at the hit point
                 * @param {number} distance the distance from the start of the {@link Ray} to the hit point
                 * @class
                 * @author William Bittle
                 */
                class Raycast {
                    constructor(point, normal, distance) {
                        if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((normal != null && normal instanceof org.dyn4j.geometry.Vector2) || normal === null) && ((typeof distance === 'number') || distance === null)) {
                            let __args = arguments;
                            if (this.point === undefined) {
                                this.point = null;
                            }
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            if (this.distance === undefined) {
                                this.distance = 0;
                            }
                            this.point = point;
                            this.normal = normal;
                            this.distance = distance;
                        }
                        else if (point === undefined && normal === undefined && distance === undefined) {
                            let __args = arguments;
                            if (this.point === undefined) {
                                this.point = null;
                            }
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            if (this.distance === undefined) {
                                this.distance = 0;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("Raycast[Point=").append(this.point).append("|Normal=").append(this.normal).append("|Distance=").append(this.distance).append("]");
                        return sb.toString();
                    }
                    /**
                     * Clears this object setting all values to
                     * their default values.
                     */
                    clear() {
                        this.point = null;
                        this.normal = null;
                        this.distance = 0.0;
                    }
                    /**
                     * Returns the hit point.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getPoint() {
                        return this.point;
                    }
                    /**
                     * Sets the hit point.
                     * @param {org.dyn4j.geometry.Vector2} point the hit point
                     */
                    setPoint(point) {
                        this.point = point;
                    }
                    /**
                     * Returns the normal at the hit point.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getNormal() {
                        return this.normal;
                    }
                    /**
                     * Sets the normal at the hit point.
                     * @param {org.dyn4j.geometry.Vector2} normal the normal at the hit point
                     */
                    setNormal(normal) {
                        this.normal = normal;
                    }
                    /**
                     * Returns the distance from the start of the
                     * {@link Ray} to the hit point.
                     * @return {number} double
                     */
                    getDistance() {
                        return this.distance;
                    }
                    /**
                     * Sets the distance from the start of the
                     * {@link Ray} to the hit point.
                     * @param {number} distance the distance
                     */
                    setDistance(distance) {
                        this.distance = distance;
                    }
                }
                narrowphase.Raycast = Raycast;
                Raycast["__class"] = "org.dyn4j.collision.narrowphase.Raycast";
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.geometry.Vector2} normal the penetration normal from {@link Convex}1 to {@link Convex}2
                 * @param {number} depth the penetration depth
                 * @class
                 * @author William Bittle
                 */
                class Penetration {
                    constructor(normal, depth) {
                        if (((normal != null && normal instanceof org.dyn4j.geometry.Vector2) || normal === null) && ((typeof depth === 'number') || depth === null)) {
                            let __args = arguments;
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            if (this.depth === undefined) {
                                this.depth = 0;
                            }
                            this.normal = normal;
                            this.depth = depth;
                        }
                        else if (normal === undefined && depth === undefined) {
                            let __args = arguments;
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            if (this.depth === undefined) {
                                this.depth = 0;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("Penetration[Normal=").append(this.normal).append("|Depth=").append(this.depth).append("]");
                        return sb.toString();
                    }
                    /**
                     * Clears the penetration information.
                     */
                    clear() {
                        this.normal = null;
                        this.depth = 0;
                    }
                    /**
                     * Returns the penetration normal.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getNormal() {
                        return this.normal;
                    }
                    /**
                     * Returns the penetration depth.
                     * @return {number} double
                     */
                    getDepth() {
                        return this.depth;
                    }
                    /**
                     * Sets the penetration normal.
                     * <p>
                     * Must be normalized.
                     * @param {org.dyn4j.geometry.Vector2} normal the penetration normal
                     */
                    setNormal(normal) {
                        this.normal = normal;
                    }
                    /**
                     * Sets the penetration depth.
                     * @param {number} depth the penetration depth
                     */
                    setDepth(depth) {
                        this.depth = depth;
                    }
                }
                narrowphase.Penetration = Penetration;
                Penetration["__class"] = "org.dyn4j.collision.narrowphase.Penetration";
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.geometry.Vector2} point1 the first point
                 * @param {org.dyn4j.geometry.Vector2} point2 the second point
                 * @param {number} winding the winding
                 * @class
                 * @author William Bittle
                 */
                class ExpandingSimplexEdge {
                    constructor(point1, point2, winding) {
                        if (this.point1 === undefined) {
                            this.point1 = null;
                        }
                        if (this.point2 === undefined) {
                            this.point2 = null;
                        }
                        if (this.normal === undefined) {
                            this.normal = null;
                        }
                        if (this.distance === undefined) {
                            this.distance = 0;
                        }
                        this.normal = new org.dyn4j.geometry.Vector2(point2.x - point1.x, point2.y - point1.y);
                        if (winding < 0) {
                            this.normal.right();
                        }
                        else {
                            this.normal.left();
                        }
                        this.normal.normalize();
                        this.distance = Math.abs(point1.x * this.normal.x + point1.y * this.normal.y);
                        this.point1 = point1;
                        this.point2 = point2;
                    }
                    /**
                     *
                     * @param {org.dyn4j.collision.narrowphase.ExpandingSimplexEdge} o
                     * @return {number}
                     */
                    compareTo(o) {
                        if (this.distance < o.distance)
                            return -1;
                        if (this.distance > o.distance)
                            return 1;
                        return 0;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("ExpandingSimplexEdge[Point1=").append(this.point1).append("|Point2=").append(this.point2).append("|Normal=").append(this.normal).append("|Distance=").append(this.distance).append("]");
                        return sb.toString();
                    }
                }
                narrowphase.ExpandingSimplexEdge = ExpandingSimplexEdge;
                ExpandingSimplexEdge["__class"] = "org.dyn4j.collision.narrowphase.ExpandingSimplexEdge";
                ExpandingSimplexEdge["__interfaces"] = ["java.lang.Comparable"];
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Minimal constructor.
                 * @param {*} simplex the starting simplex from GJK
                 * @class
                 * @author William Bittle
                 */
                class ExpandingSimplex {
                    constructor(simplex) {
                        if (this.winding === undefined) {
                            this.winding = 0;
                        }
                        if (this.queue === undefined) {
                            this.queue = null;
                        }
                        this.winding = this.getWinding(simplex);
                        this.queue = (new java.util.PriorityQueue());
                        const size = simplex.size();
                        for (let i = 0; i < size; i++) {
                            {
                                const j = i + 1 === size ? 0 : i + 1;
                                const a = simplex.get(i);
                                const b = simplex.get(j);
                                this.queue.add(new org.dyn4j.collision.narrowphase.ExpandingSimplexEdge(a, b, this.winding));
                            }
                            ;
                        }
                    }
                    /**
                     * Returns the winding of the given simplex.
                     * <p>
                     * Returns -1 if the winding is Clockwise.<br>
                     * Returns 1 if the winding is Counter-Clockwise.
                     * <p>
                     * This method will continue checking all edges until
                     * an edge is found whose cross product is less than
                     * or greater than zero.
                     * <p>
                     * This is used to get the correct edge normal of
                     * the simplex.
                     * @param {*} simplex the simplex
                     * @return {number} int the winding
                     */
                    getWinding(simplex) {
                        const size = simplex.size();
                        for (let i = 0; i < size; i++) {
                            {
                                const j = i + 1 === size ? 0 : i + 1;
                                const a = simplex.get(i);
                                const b = simplex.get(j);
                                if (a.cross$org_dyn4j_geometry_Vector2(b) > 0) {
                                    return 1;
                                }
                                else if (a.cross$org_dyn4j_geometry_Vector2(b) < 0) {
                                    return -1;
                                }
                            }
                            ;
                        }
                        return 0;
                    }
                    /**
                     * Returns the edge on the simplex that is closest to the origin.
                     * @return {org.dyn4j.collision.narrowphase.ExpandingSimplexEdge} {@link ExpandingSimplexEdge} the closest edge to the origin
                     */
                    getClosestEdge() {
                        return this.queue.peek();
                    }
                    /**
                     * Expands the simplex by the given point.
                     * <p>
                     * Removes the closest edge to the origin and adds
                     * two new edges using the given point and the removed
                     * edge's vertices.
                     * @param {org.dyn4j.geometry.Vector2} point the new point
                     */
                    expand(point) {
                        const edge = this.queue.poll();
                        const edge1 = new org.dyn4j.collision.narrowphase.ExpandingSimplexEdge(edge.point1, point, this.winding);
                        const edge2 = new org.dyn4j.collision.narrowphase.ExpandingSimplexEdge(point, edge.point2, this.winding);
                        this.queue.add(edge1);
                        this.queue.add(edge2);
                    }
                }
                narrowphase.ExpandingSimplex = ExpandingSimplex;
                ExpandingSimplex["__class"] = "org.dyn4j.collision.narrowphase.ExpandingSimplex";
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Implementation of the Separating Axis Theorem (SAT) for collision detection.
                 * <p>
                 * {@link Sat} states that &quot;if two {@link Convex} objects are not penetrating, there exists an axis (vector)
                 * for which the projection of the objects does not overlap.&quot;
                 * <p>
                 * The axes that must be tested are <strong>all</strong> the edge normals of both {@link Convex} {@link Shape}s.  For each
                 * edge normal we project the {@link Convex} {@link Shape}s onto it yielding a 1 dimensional {@link Interval}.  If any
                 * {@link Interval} doesn't overlap, then we can conclude the {@link Convex} {@link Shape}s do not intersect.  If all the
                 * {@link Interval}s overlap, then we can conclude that the {@link Convex} {@link Shape}s intersect.
                 * <p>
                 * If the {@link Convex} {@link Shape}s are penetrating, a {@link Penetration} object can be built from the {@link Interval}s
                 * with the least overlap.  The normal will be the edge normal of the {@link Interval} and the depth will be the {@link Interval}
                 * overlap.
                 * @author William Bittle
                 * @version 3.0.2
                 * @since 1.0.0
                 * @see <a href="http://www.dyn4j.org/2010/01/sat/" target="_blank">SAT (Separating Axis Theorem)</a>
                 * @class
                 */
                class Sat {
                    detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex1, transform1, convex2, transform2, penetration) {
                        if ((convex1 != null && convex1 instanceof org.dyn4j.geometry.Circle) && (convex2 != null && convex2 instanceof org.dyn4j.geometry.Circle)) {
                            return org.dyn4j.collision.narrowphase.CircleDetector.detect$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex1, transform1, convex2, transform2, penetration);
                        }
                        penetration.clear();
                        let n = null;
                        let overlap = javaemul.internal.DoubleHelper.MAX_VALUE;
                        const foci1 = convex1.getFoci(transform1);
                        const foci2 = convex2.getFoci(transform2);
                        const axes1 = convex1.getAxes(foci2, transform1);
                        const axes2 = convex2.getAxes(foci1, transform2);
                        if (axes1 != null) {
                            const size = axes1.length;
                            for (let i = 0; i < size; i++) {
                                {
                                    const axis = axes1[i];
                                    if (!axis.isZero()) {
                                        const intervalA = convex1['project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](axis, transform1);
                                        const intervalB = convex2['project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](axis, transform2);
                                        if (!intervalA.overlaps(intervalB)) {
                                            return false;
                                        }
                                        else {
                                            let o = intervalA.getOverlap(intervalB);
                                            if (intervalA.contains(intervalB) || intervalB.contains(intervalA)) {
                                                const max = Math.abs(intervalA.getMax() - intervalB.getMax());
                                                const min = Math.abs(intervalA.getMin() - intervalB.getMin());
                                                if (max > min) {
                                                    axis.negate();
                                                    o += min;
                                                }
                                                else {
                                                    o += max;
                                                }
                                            }
                                            if (o < overlap) {
                                                overlap = o;
                                                n = axis;
                                            }
                                        }
                                    }
                                }
                                ;
                            }
                        }
                        if (axes2 != null) {
                            const size = axes2.length;
                            for (let i = 0; i < size; i++) {
                                {
                                    const axis = axes2[i];
                                    if (!axis.isZero()) {
                                        const intervalA = convex1['project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](axis, transform1);
                                        const intervalB = convex2['project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](axis, transform2);
                                        if (!intervalA.overlaps(intervalB)) {
                                            return false;
                                        }
                                        else {
                                            let o = intervalA.getOverlap(intervalB);
                                            if (intervalA.contains(intervalB) || intervalB.contains(intervalA)) {
                                                const max = Math.abs(intervalA.getMax() - intervalB.getMax());
                                                const min = Math.abs(intervalA.getMin() - intervalB.getMin());
                                                if (max > min) {
                                                    axis.negate();
                                                    o += min;
                                                }
                                                else {
                                                    o += max;
                                                }
                                            }
                                            if (o < overlap) {
                                                overlap = o;
                                                n = axis;
                                            }
                                        }
                                    }
                                }
                                ;
                            }
                        }
                        const c1 = transform1.getTransformed$org_dyn4j_geometry_Vector2(convex1.getCenter());
                        const c2 = transform2.getTransformed$org_dyn4j_geometry_Vector2(convex2.getCenter());
                        const cToc = c1.to$org_dyn4j_geometry_Vector2(c2);
                        if (cToc.dot$org_dyn4j_geometry_Vector2(n) < 0) {
                            n.negate();
                        }
                        penetration.normal = n;
                        penetration.depth = overlap;
                        return true;
                    }
                    /**
                     *
                     * @param {*} convex1
                     * @param {org.dyn4j.geometry.Transform} transform1
                     * @param {*} convex2
                     * @param {org.dyn4j.geometry.Transform} transform2
                     * @param {org.dyn4j.collision.narrowphase.Penetration} penetration
                     * @return {boolean}
                     */
                    detect(convex1, transform1, convex2, transform2, penetration) {
                        if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && ((penetration != null && penetration instanceof org.dyn4j.collision.narrowphase.Penetration) || penetration === null)) {
                            return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex1, transform1, convex2, transform2, penetration);
                        }
                        else if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && penetration === undefined) {
                            return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform(convex1, transform1, convex2, transform2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform(convex1, transform1, convex2, transform2) {
                        if ((convex1 != null && convex1 instanceof org.dyn4j.geometry.Circle) && (convex2 != null && convex2 instanceof org.dyn4j.geometry.Circle)) {
                            return org.dyn4j.collision.narrowphase.CircleDetector.detect$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform(convex1, transform1, convex2, transform2);
                        }
                        const foci1 = convex1.getFoci(transform1);
                        const foci2 = convex2.getFoci(transform2);
                        const axes1 = convex1.getAxes(foci2, transform1);
                        const axes2 = convex2.getAxes(foci1, transform2);
                        if (axes1 != null) {
                            const size = axes1.length;
                            for (let i = 0; i < size; i++) {
                                {
                                    const axis = axes1[i];
                                    if (!axis.isZero()) {
                                        const intervalA = convex1['project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](axis, transform1);
                                        const intervalB = convex2['project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](axis, transform2);
                                        if (!intervalA.overlaps(intervalB)) {
                                            return false;
                                        }
                                    }
                                }
                                ;
                            }
                        }
                        if (axes2 != null) {
                            const size = axes2.length;
                            for (let i = 0; i < size; i++) {
                                {
                                    const axis = axes2[i];
                                    if (!axis.isZero()) {
                                        const intervalA = convex1['project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](axis, transform1);
                                        const intervalB = convex2['project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](axis, transform2);
                                        if (!intervalA.overlaps(intervalB)) {
                                            return false;
                                        }
                                    }
                                }
                                ;
                            }
                        }
                        return true;
                    }
                    constructor() {
                    }
                }
                narrowphase.Sat = Sat;
                Sat["__class"] = "org.dyn4j.collision.narrowphase.Sat";
                Sat["__interfaces"] = ["org.dyn4j.collision.narrowphase.NarrowphaseDetector"];
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.geometry.Vector2} normal the penetration normal
                 * @param {number} distance the separation distance
                 * @param {org.dyn4j.geometry.Vector2} point1 the closest point on the first {@link Convex} {@link Shape} to the second
                 * @param {org.dyn4j.geometry.Vector2} point2 the closest point on the second {@link Convex} {@link Shape} to the first
                 * @class
                 * @author William Bittle
                 */
                class Separation {
                    constructor(normal, distance, point1, point2) {
                        if (((normal != null && normal instanceof org.dyn4j.geometry.Vector2) || normal === null) && ((typeof distance === 'number') || distance === null) && ((point1 != null && point1 instanceof org.dyn4j.geometry.Vector2) || point1 === null) && ((point2 != null && point2 instanceof org.dyn4j.geometry.Vector2) || point2 === null)) {
                            let __args = arguments;
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            if (this.distance === undefined) {
                                this.distance = 0;
                            }
                            if (this.point1 === undefined) {
                                this.point1 = null;
                            }
                            if (this.point2 === undefined) {
                                this.point2 = null;
                            }
                            this.normal = normal;
                            this.distance = distance;
                            this.point1 = point1;
                            this.point2 = point2;
                        }
                        else if (normal === undefined && distance === undefined && point1 === undefined && point2 === undefined) {
                            let __args = arguments;
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            if (this.distance === undefined) {
                                this.distance = 0;
                            }
                            if (this.point1 === undefined) {
                                this.point1 = null;
                            }
                            if (this.point2 === undefined) {
                                this.point2 = null;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("Separation[Point1=").append(this.point1).append("|Point2=").append(this.point2).append("|Normal=").append(this.normal).append("|Distance=").append(this.distance).append("]");
                        return sb.toString();
                    }
                    /**
                     * Clears the separation information.
                     */
                    clear() {
                        this.normal = null;
                        this.distance = 0;
                        this.point1 = null;
                        this.point2 = null;
                    }
                    /**
                     * Returns the separation normal.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getNormal() {
                        return this.normal;
                    }
                    /**
                     * Returns the separation distance.
                     * @return {number} double
                     */
                    getDistance() {
                        return this.distance;
                    }
                    /**
                     * Returns the closest point on the first {@link Convex} {@link Shape}.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getPoint1() {
                        return this.point1;
                    }
                    /**
                     * Returns the closest point on the second {@link Convex} {@link Shape}.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getPoint2() {
                        return this.point2;
                    }
                    /**
                     * Sets the separation normal.
                     * <p>
                     * Must be normalized.
                     * @param {org.dyn4j.geometry.Vector2} normal the separation normal
                     */
                    setNormal(normal) {
                        this.normal = normal;
                    }
                    /**
                     * Sets the separation distance.
                     * @param {number} distance the separation distance
                     */
                    setDistance(distance) {
                        this.distance = distance;
                    }
                    /**
                     * Sets the closest point on the first {@link Convex} {@link Shape}.
                     * @param {org.dyn4j.geometry.Vector2} point1 the closest point on the first {@link Convex} {@link Shape}
                     */
                    setPoint1(point1) {
                        this.point1 = point1;
                    }
                    /**
                     * Sets the closest point on the second {@link Convex} {@link Shape}.
                     * @param {org.dyn4j.geometry.Vector2} point2 the closest point on the second {@link Convex} {@link Shape}
                     */
                    setPoint2(point2) {
                        this.point2 = point2;
                    }
                }
                narrowphase.Separation = Separation;
                Separation["__class"] = "org.dyn4j.collision.narrowphase.Separation";
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Full constructor.
                 * @param {*} convex1 the first {@link Convex}
                 * @param {org.dyn4j.geometry.Transform} transform1 the first {@link Convex}'s {@link Transform}
                 * @param {*} convex2 the second {@link Convex}
                 * @param {org.dyn4j.geometry.Transform} transform2 the second {@link Convex}'s {@link Transform}
                 * @class
                 * @author William Bittle
                 */
                class MinkowskiSum {
                    constructor(convex1, transform1, convex2, transform2) {
                        if (this.convex1 === undefined) {
                            this.convex1 = null;
                        }
                        if (this.convex2 === undefined) {
                            this.convex2 = null;
                        }
                        if (this.transform1 === undefined) {
                            this.transform1 = null;
                        }
                        if (this.transform2 === undefined) {
                            this.transform2 = null;
                        }
                        this.convex1 = convex1;
                        this.convex2 = convex2;
                        this.transform1 = transform1;
                        this.transform2 = transform2;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("MinkowskiSum[Convex1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.convex1)).append("|Transform1=").append(this.transform1).append("|Convex2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.convex2)).append("|Transform2=").append(this.transform2).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the farthest point in the Minkowski sum given the direction.
                     * @param {org.dyn4j.geometry.Vector2} direction the search direction
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the point farthest in the Minkowski sum in the given direction
                     */
                    getSupportPoint(direction) {
                        const point1 = this.convex1.getFarthestPoint(direction, this.transform1);
                        direction.negate();
                        const point2 = this.convex2.getFarthestPoint(direction, this.transform2);
                        direction.negate();
                        return point1.subtract$org_dyn4j_geometry_Vector2(point2);
                    }
                    /**
                     * Returns the farthest point, and the support points in the shapes, in the Minkowski sum given the direction.
                     * @param {org.dyn4j.geometry.Vector2} direction the search direction
                     * @return {org.dyn4j.collision.narrowphase.MinkowskiSumPoint} {@link MinkowskiSumPoint} the point farthest in the Minkowski sum in the given direction
                     */
                    getSupportPoints(direction) {
                        const point1 = this.convex1.getFarthestPoint(direction, this.transform1);
                        direction.negate();
                        const point2 = this.convex2.getFarthestPoint(direction, this.transform2);
                        direction.negate();
                        return new org.dyn4j.collision.narrowphase.MinkowskiSumPoint(point1, point2);
                    }
                    /**
                     * Returns the first {@link Convex} {@link Shape}.
                     * @return {*} {@link Convex}
                     */
                    getConvex1() {
                        return this.convex1;
                    }
                    /**
                     * Returns the second {@link Convex} {@link Shape}.
                     * @return {*} {@link Convex}
                     */
                    getConvex2() {
                        return this.convex2;
                    }
                    /**
                     * Returns the first {@link Convex} {@link Shape}'s {@link Transform}.
                     * @return {org.dyn4j.geometry.Transform} {@link Transform}
                     */
                    getTransform1() {
                        return this.transform1;
                    }
                    /**
                     * Returns the second {@link Convex} {@link Shape}'s {@link Transform}.
                     * @return {org.dyn4j.geometry.Transform} {@link Transform}
                     */
                    getTransform2() {
                        return this.transform2;
                    }
                }
                narrowphase.MinkowskiSum = MinkowskiSum;
                MinkowskiSum["__class"] = "org.dyn4j.collision.narrowphase.MinkowskiSum";
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            /**
             * Full constructor.
             * @param {number} category the category bits
             * @param {number} mask the mask bits
             * @class
             * @author William Bittle
             */
            class CategoryFilter {
                constructor(category, mask) {
                    if (((typeof category === 'number') || category === null) && ((typeof mask === 'number') || mask === null)) {
                        let __args = arguments;
                        if (this.category === undefined) {
                            this.category = 0;
                        }
                        if (this.mask === undefined) {
                            this.mask = 0;
                        }
                        this.category = category;
                        this.mask = mask;
                    }
                    else if (category === undefined && mask === undefined) {
                        let __args = arguments;
                        if (this.category === undefined) {
                            this.category = 0;
                        }
                        if (this.mask === undefined) {
                            this.mask = 0;
                        }
                        this.category = 1;
                        this.mask = javaemul.internal.LongHelper.MAX_VALUE;
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns true if the given {@link Filter} and this {@link Filter}
                 * allow the objects to interact.
                 * <p>
                 * If the given {@link Filter} is not the same type as this {@link Filter}
                 * then a value of true is returned.
                 * <p>
                 * If the given {@link Filter} is null, a value of true is returned.
                 * @param {*} filter the other {@link Filter}
                 * @return {boolean} boolean
                 */
                isAllowed(filter) {
                    if (filter == null)
                        return true;
                    if (filter != null && filter instanceof org.dyn4j.collision.CategoryFilter) {
                        const cf = filter;
                        return (this.category & cf.mask) > 0 && (cf.category & this.mask) > 0;
                    }
                    return true;
                }
                /**
                 *
                 * @param {*} obj
                 * @return {boolean}
                 */
                equals(obj) {
                    if (obj == null)
                        return false;
                    if (obj === this)
                        return true;
                    if (obj != null && obj instanceof org.dyn4j.collision.CategoryFilter) {
                        const filter = obj;
                        return filter.category === this.category && filter.mask === this.mask;
                    }
                    return false;
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    let hash = 17;
                    hash = hash * 31 + (((this.category >>> 32) ^ this.category) | 0);
                    hash = hash * 31 + (((this.mask >>> 32) ^ this.mask) | 0);
                    return hash;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("CategoryFilter[Category=").append(this.category).append("|Mask=").append(this.mask).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the category bits.
                 * @return {number} long the category bits
                 */
                getCategory() {
                    return this.category;
                }
                /**
                 * Returns the mask bits.
                 * @return {number} long the mask bits
                 */
                getMask() {
                    return this.mask;
                }
                /**
                 * Sets the category bits.
                 * @param {number} category the category bits
                 */
                setCategory(category) {
                    this.category = category;
                }
                /**
                 * Sets the mask bits.
                 * @param {number} mask the mask bits
                 */
                setMask(mask) {
                    this.mask = mask;
                }
            }
            collision.CategoryFilter = CategoryFilter;
            CategoryFilter["__class"] = "org.dyn4j.collision.CategoryFilter";
            CategoryFilter["__interfaces"] = ["org.dyn4j.collision.Filter"];
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var continuous;
            (function (continuous) {
                /**
                 * Full constructor.
                 * @param {number} time the time of impact; in the range [0, 1]
                 * @param {org.dyn4j.collision.narrowphase.Separation} separation the separation at the time of impact
                 * @class
                 * @author William Bittle
                 */
                class TimeOfImpact {
                    constructor(time, separation) {
                        if (((typeof time === 'number') || time === null) && ((separation != null && separation instanceof org.dyn4j.collision.narrowphase.Separation) || separation === null)) {
                            let __args = arguments;
                            if (this.time === undefined) {
                                this.time = 0;
                            }
                            if (this.separation === undefined) {
                                this.separation = null;
                            }
                            this.time = time;
                            this.separation = separation;
                        }
                        else if (time === undefined && separation === undefined) {
                            let __args = arguments;
                            if (this.time === undefined) {
                                this.time = 0;
                            }
                            if (this.separation === undefined) {
                                this.separation = null;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("TimeOfImpact[Time=").append(this.time).append("|Separation=").append(this.separation).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the time of impact in the range [0, 1].
                     * @return {number} double
                     * @since 3.1.5
                     */
                    getTime() {
                        return this.time;
                    }
                    /**
                     * Sets the time of impact.
                     * @param {number} time the time of impact in the range [0, 1]
                     * @since 3.1.5
                     */
                    setTime(time) {
                        this.time = time;
                    }
                    /**
                     * Returns the separation at the time of impact.
                     * @return {org.dyn4j.collision.narrowphase.Separation} {@link Separation}
                     */
                    getSeparation() {
                        return this.separation;
                    }
                    /**
                     * Sets the separation at the time of impact.
                     * @param {org.dyn4j.collision.narrowphase.Separation} separation the separation
                     */
                    setSeparation(separation) {
                        this.separation = separation;
                    }
                }
                continuous.TimeOfImpact = TimeOfImpact;
                TimeOfImpact["__class"] = "org.dyn4j.collision.continuous.TimeOfImpact";
            })(continuous = collision.continuous || (collision.continuous = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            let Filter;
            (function (Filter) {
                function DEFAULT_FILTER_$LI$() { if (Filter.DEFAULT_FILTER == null) {
                    Filter.DEFAULT_FILTER = new Filter.Filter$0(this);
                } return Filter.DEFAULT_FILTER; }
                Filter.DEFAULT_FILTER_$LI$ = DEFAULT_FILTER_$LI$;
                ;
            })(Filter = collision.Filter || (collision.Filter = {}));
            (function (Filter) {
                class Filter$0 {
                    constructor(__parent) {
                        this.__parent = __parent;
                    }
                    /**
                     *
                     * @param {*} filter
                     * @return {boolean}
                     */
                    isAllowed(filter) {
                        return true;
                    }
                    toString() {
                        return "DefaultFilter[]";
                    }
                }
                Filter.Filter$0 = Filter$0;
                Filter$0["__interfaces"] = ["org.dyn4j.collision.Filter"];
            })(Filter = collision.Filter || (collision.Filter = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            /**
             * Optional constructor.
             * @param {number} x the initial x translation of the bounds
             * @param {number} y the initial x translation of the bounds
             * @class
             * @author William Bittle
             */
            class AbstractBounds {
                constructor(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            if (this.transform === undefined) {
                                this.transform = null;
                            }
                            this.transform = new org.dyn4j.geometry.Transform();
                        }
                        if (this.transform === undefined) {
                            this.transform = null;
                        }
                        (() => {
                            this.translate$double$double(x, y);
                        })();
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        let __args = arguments;
                        let translation = __args[0];
                        {
                            let __args = arguments;
                            if (this.transform === undefined) {
                                this.transform = null;
                            }
                            this.transform = new org.dyn4j.geometry.Transform();
                        }
                        if (this.transform === undefined) {
                            this.transform = null;
                        }
                        (() => {
                            this.translate$org_dyn4j_geometry_Vector2(translation);
                        })();
                    }
                    else if (x === undefined && y === undefined) {
                        let __args = arguments;
                        if (this.transform === undefined) {
                            this.transform = null;
                        }
                        this.transform = new org.dyn4j.geometry.Transform();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getTranslation() {
                    return this.transform.getTranslation();
                }
                translate$double$double(x, y) {
                    this.transform.translate$double$double(x, y);
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$org_dyn4j_geometry_Vector2(vector) {
                    this.transform.translate$org_dyn4j_geometry_Vector2(vector);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} shift
                 */
                shift(shift) {
                    this.transform.translate$org_dyn4j_geometry_Vector2(shift);
                }
            }
            collision.AbstractBounds = AbstractBounds;
            AbstractBounds["__class"] = "org.dyn4j.collision.AbstractBounds";
            AbstractBounds["__interfaces"] = ["org.dyn4j.collision.Bounds", "org.dyn4j.geometry.Shiftable", "org.dyn4j.geometry.Translatable"];
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            let Collidable;
            (function (Collidable) {
                /**
                 * Number of fixtures typically attached to a {@link Collidable}
                 */
                Collidable.TYPICAL_FIXTURE_COUNT = 1;
            })(Collidable = collision.Collidable || (collision.Collidable = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            /**
             * Minimal constructor.
             * @param {*} shape the {@link Convex} {@link Shape} for this fixture
             * @throws NullPointerException if shape is null
             * @class
             * @author William Bittle
             */
            class Fixture {
                constructor(shape) {
                    if (this.id === undefined) {
                        this.id = null;
                    }
                    if (this.shape === undefined) {
                        this.shape = null;
                    }
                    if (this.filter === undefined) {
                        this.filter = null;
                    }
                    if (this.sensor === undefined) {
                        this.sensor = false;
                    }
                    if (this.userData === undefined) {
                        this.userData = null;
                    }
                    if (shape == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("collision.fixture.nullShape"));
                    this.id = new org.dyn4j.RandomUUID();
                    this.shape = shape;
                    this.filter = org.dyn4j.collision.Filter.DEFAULT_FILTER_$LI$();
                    this.sensor = false;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Fixture[Id=").append(this.id).append("|Shape=").append(this.shape).append("|Filter=").append(this.filter).append("|IsSensor=").append(this.sensor).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the id for this fixture.
                 * <p>
                 * This identifier is constant for the life of this {@link Fixture}.
                 * @deprecated ID schemes should be implemented by the user where needed; since 3.4.0
                 * @return {org.dyn4j.RandomUUID} UUID
                 */
                getId() {
                    return this.id;
                }
                /**
                 * The {@link Convex} {@link Shape} representing the geometry of this fixture.
                 * @return {*} {@link Convex}
                 */
                getShape() {
                    return this.shape;
                }
                /**
                 * Sets the shape of fixture
                 * @param {*} shape
                 */
                setShape(shape) {
                    if (shape == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("collision.fixture.nullShape"));
                    this.shape = shape;
                }
                /**
                 * Returns the collision filter for this fixture.
                 * @return {*} {@link Filter}
                 */
                getFilter() {
                    return this.filter;
                }
                /**
                 * Sets the collision filter for this fixture.
                 * @param {*} filter the collision filter
                 * @throws NullPointerException if filter is null; Use {@link Filter#DEFAULT_FILTER} instead
                 */
                setFilter(filter) {
                    if (filter == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("collision.fixture.nullFilter"));
                    this.filter = filter;
                }
                /**
                 * Returns true if this fixture is a sensor.
                 * <p>
                 * A sensor fixture is a fixture that participates in collision detection but does not
                 * participate in collision resolution (response).
                 * @return {boolean} boolean
                 */
                isSensor() {
                    return this.sensor;
                }
                /**
                 * Toggles this fixture as a sensor fixture.
                 * <p>
                 * A sensor fixture is a fixture that participates in collision detection but does not
                 * participate in collision resolution (response).
                 * @param {boolean} flag true if this fixture should only sense contacts
                 */
                setSensor(flag) {
                    this.sensor = flag;
                }
                getUserData() {
                    return this.userData;
                }
                setUserData(userData) {
                    this.userData = userData;
                }
            }
            collision.Fixture = Fixture;
            Fixture["__class"] = "org.dyn4j.collision.Fixture";
            Fixture["__interfaces"] = ["org.dyn4j.DataContainer"];
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact) {
                /**
                 * Full constructor.
                 * <p>
                 * The initial capacity is used to help performance in the event that the developer
                 * knows the number of bodies the world will contain.  The {@link WarmStartingContactManager}
                 * will grow past the initial capacity if necessary.
                 * @param {org.dyn4j.dynamics.Capacity} initialCapacity the estimated number of {@link Body}s
                 * @throws NullPointerException if initialCapacity is null
                 * @since 3.2.0
                 * @class
                 * @extends org.dyn4j.dynamics.contact.DefaultContactManager
                 * @author William Bittle
                 */
                class WarmStartingContactManager extends org.dyn4j.dynamics.contact.DefaultContactManager {
                    constructor(initialCapacity = org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$()) {
                        super(initialCapacity);
                        this.__org_dyn4j_dynamics_contact_WarmStartingContactManager_constraints1 = null;
                    }
                }
                contact.WarmStartingContactManager = WarmStartingContactManager;
                WarmStartingContactManager["__class"] = "org.dyn4j.dynamics.contact.WarmStartingContactManager";
                WarmStartingContactManager["__interfaces"] = ["org.dyn4j.dynamics.contact.ContactManager", "org.dyn4j.geometry.Shiftable"];
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact) {
                /**
                 * Full constructor.
                 * <p>
                 * The initial capacity is used to help performance in the event that the developer
                 * knows the number of bodies the world will contain. The {@link ContactManager}
                 * will grow past the initial capacity if necessary.
                 * @param {org.dyn4j.dynamics.Capacity} initialCapacity the estimated number of {@link Body}s
                 * @throws NullPointerException if initialCapacity is null
                 * @since 3.2.0
                 * @class
                 * @extends org.dyn4j.dynamics.contact.DefaultContactManager
                 * @author William Bittle
                 */
                class SimpleContactManager extends org.dyn4j.dynamics.contact.DefaultContactManager {
                    constructor(initialCapacity) {
                        if (((initialCapacity != null && initialCapacity instanceof org.dyn4j.dynamics.Capacity) || initialCapacity === null)) {
                            let __args = arguments;
                            super(initialCapacity);
                            this.setWarmStartingEnabled(false);
                        }
                        else if (initialCapacity === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let initialCapacity = org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$();
                                super(initialCapacity);
                                this.setWarmStartingEnabled(false);
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                contact.SimpleContactManager = SimpleContactManager;
                SimpleContactManager["__class"] = "org.dyn4j.dynamics.contact.SimpleContactManager";
                SimpleContactManager["__interfaces"] = ["org.dyn4j.dynamics.contact.ContactManager", "org.dyn4j.geometry.Shiftable"];
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.dynamics.contact.ContactPointId} id the contact point id
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body} in contact
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture1 the first {@link Body}'s {@link BodyFixture}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body} in contact
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture2 the second {@link Body}'s {@link BodyFixture}
                 * @param {org.dyn4j.geometry.Vector2} point the world space contact point
                 * @param {org.dyn4j.geometry.Vector2} normal the world space contact normal
                 * @param {number} depth the penetration depth
                 * @param {org.dyn4j.geometry.Vector2} oldPoint the previous world space contact point
                 * @param {org.dyn4j.geometry.Vector2} oldNormal the previous world space contact normal
                 * @param {number} oldDepth the previous penetration depth
                 * @param {boolean} sensor true if the contact is a sensor contact
                 * @class
                 * @extends org.dyn4j.dynamics.contact.ContactPoint
                 * @author William Bittle
                 */
                class PersistedContactPoint extends org.dyn4j.dynamics.contact.ContactPoint {
                    constructor(id, body1, fixture1, body2, fixture2, point, normal, depth, oldPoint, oldNormal, oldDepth, sensor) {
                        if (((id != null && id instanceof org.dyn4j.dynamics.contact.ContactPointId) || id === null) && ((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((fixture1 != null && fixture1 instanceof org.dyn4j.dynamics.BodyFixture) || fixture1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((fixture2 != null && fixture2 instanceof org.dyn4j.dynamics.BodyFixture) || fixture2 === null) && ((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((normal != null && normal instanceof org.dyn4j.geometry.Vector2) || normal === null) && ((typeof depth === 'number') || depth === null) && ((oldPoint != null && oldPoint instanceof org.dyn4j.geometry.Vector2) || oldPoint === null) && ((oldNormal != null && oldNormal instanceof org.dyn4j.geometry.Vector2) || oldNormal === null) && ((typeof oldDepth === 'number') || oldDepth === null) && ((typeof sensor === 'boolean') || sensor === null)) {
                            let __args = arguments;
                            super(id, body1, fixture1, body2, fixture2, point, normal, depth, sensor);
                            if (this.oldPoint === undefined) {
                                this.oldPoint = null;
                            }
                            if (this.oldNormal === undefined) {
                                this.oldNormal = null;
                            }
                            if (this.oldDepth === undefined) {
                                this.oldDepth = 0;
                            }
                            this.oldPoint = oldPoint;
                            this.oldNormal = oldNormal;
                            this.oldDepth = oldDepth;
                        }
                        else if (((id != null && id instanceof org.dyn4j.dynamics.contact.ContactConstraint) || id === null) && ((body1 != null && body1 instanceof org.dyn4j.dynamics.contact.Contact) || body1 === null) && ((fixture1 != null && fixture1 instanceof org.dyn4j.dynamics.contact.ContactConstraint) || fixture1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.contact.Contact) || body2 === null) && fixture2 === undefined && point === undefined && normal === undefined && depth === undefined && oldPoint === undefined && oldNormal === undefined && oldDepth === undefined && sensor === undefined) {
                            let __args = arguments;
                            let newConstraint = __args[0];
                            let newContact = __args[1];
                            let oldConstraint = __args[2];
                            let oldContact = __args[3];
                            super(newConstraint, newContact);
                            if (this.oldPoint === undefined) {
                                this.oldPoint = null;
                            }
                            if (this.oldNormal === undefined) {
                                this.oldNormal = null;
                            }
                            if (this.oldDepth === undefined) {
                                this.oldDepth = 0;
                            }
                            this.oldDepth = oldContact.depth;
                            this.oldNormal = oldConstraint.normal;
                            this.oldPoint = oldContact.p;
                        }
                        else if (((id != null && id instanceof org.dyn4j.dynamics.contact.PersistedContactPoint) || id === null) && body1 === undefined && fixture1 === undefined && body2 === undefined && fixture2 === undefined && point === undefined && normal === undefined && depth === undefined && oldPoint === undefined && oldNormal === undefined && oldDepth === undefined && sensor === undefined) {
                            let __args = arguments;
                            let pcp = __args[0];
                            super(pcp);
                            if (this.oldPoint === undefined) {
                                this.oldPoint = null;
                            }
                            if (this.oldNormal === undefined) {
                                this.oldNormal = null;
                            }
                            if (this.oldDepth === undefined) {
                                this.oldDepth = 0;
                            }
                            this.oldPoint = pcp.oldPoint;
                            this.oldNormal = pcp.oldNormal;
                            this.oldDepth = pcp.oldDepth;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("PersistedContactPoint[Id=").append(this.id).append("|Body1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body1)).append("|Fixture1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture1)).append("|Body2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body2)).append("|Fixture2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture2)).append("|Point=").append(this.point).append("|Normal=").append(this.normal).append("|Depth=").append(this.depth).append("|PreviousPoint=").append(this.oldPoint).append("|PreviousNormal=").append(this.oldNormal).append("|PreviousDepth=").append(this.oldDepth).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the old contact point.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getOldPoint() {
                        return this.oldPoint;
                    }
                    /**
                     * Returns the old contact normal.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getOldNormal() {
                        return this.oldNormal;
                    }
                    /**
                     * Returns the old depth.
                     * @return {number} double
                     */
                    getOldDepth() {
                        return this.oldDepth;
                    }
                }
                contact.PersistedContactPoint = PersistedContactPoint;
                PersistedContactPoint["__class"] = "org.dyn4j.dynamics.contact.PersistedContactPoint";
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact_4) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.dynamics.contact.ContactPointId} id the contact point id
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body} in contact
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture1 the first {@link Body}'s {@link BodyFixture}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body} in contact
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture2 the second {@link Body}'s {@link BodyFixture}
                 * @param {org.dyn4j.geometry.Vector2} point the world space contact point
                 * @param {org.dyn4j.geometry.Vector2} normal the world space contact normal
                 * @param {number} depth the penetration depth
                 * @param {number} normalImpulse the accumulated normal impulse
                 * @param {number} tangentialImpulse the accumulated tangential impulse
                 * @class
                 * @extends org.dyn4j.dynamics.contact.ContactPoint
                 * @author William Bittle
                 */
                class SolvedContactPoint extends org.dyn4j.dynamics.contact.ContactPoint {
                    constructor(id, body1, fixture1, body2, fixture2, point, normal, depth, normalImpulse, tangentialImpulse) {
                        if (((id != null && id instanceof org.dyn4j.dynamics.contact.ContactPointId) || id === null) && ((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((fixture1 != null && fixture1 instanceof org.dyn4j.dynamics.BodyFixture) || fixture1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((fixture2 != null && fixture2 instanceof org.dyn4j.dynamics.BodyFixture) || fixture2 === null) && ((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((normal != null && normal instanceof org.dyn4j.geometry.Vector2) || normal === null) && ((typeof depth === 'number') || depth === null) && ((typeof normalImpulse === 'number') || normalImpulse === null) && ((typeof tangentialImpulse === 'number') || tangentialImpulse === null)) {
                            let __args = arguments;
                            super(id, body1, fixture1, body2, fixture2, point, normal, depth, false);
                            if (this.normalImpulse === undefined) {
                                this.normalImpulse = 0;
                            }
                            if (this.tangentialImpulse === undefined) {
                                this.tangentialImpulse = 0;
                            }
                            this.normalImpulse = normalImpulse;
                            this.tangentialImpulse = tangentialImpulse;
                        }
                        else if (((id != null && id instanceof org.dyn4j.dynamics.contact.ContactConstraint) || id === null) && ((body1 != null && body1 instanceof org.dyn4j.dynamics.contact.Contact) || body1 === null) && fixture1 === undefined && body2 === undefined && fixture2 === undefined && point === undefined && normal === undefined && depth === undefined && normalImpulse === undefined && tangentialImpulse === undefined) {
                            let __args = arguments;
                            let constraint = __args[0];
                            let contact = __args[1];
                            super(constraint, contact);
                            if (this.normalImpulse === undefined) {
                                this.normalImpulse = 0;
                            }
                            if (this.tangentialImpulse === undefined) {
                                this.tangentialImpulse = 0;
                            }
                            this.normalImpulse = contact.jn;
                            this.tangentialImpulse = contact.jt;
                        }
                        else if (((id != null && id instanceof org.dyn4j.dynamics.contact.SolvedContactPoint) || id === null) && body1 === undefined && fixture1 === undefined && body2 === undefined && fixture2 === undefined && point === undefined && normal === undefined && depth === undefined && normalImpulse === undefined && tangentialImpulse === undefined) {
                            let __args = arguments;
                            let scp = __args[0];
                            super(scp);
                            if (this.normalImpulse === undefined) {
                                this.normalImpulse = 0;
                            }
                            if (this.tangentialImpulse === undefined) {
                                this.tangentialImpulse = 0;
                            }
                            this.normalImpulse = scp.normalImpulse;
                            this.tangentialImpulse = scp.tangentialImpulse;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("SolvedContactPoint[Id=").append(this.id).append("|Body1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body1)).append("|Fixture1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture1)).append("|Body2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body2)).append("|Fixture2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture2)).append("|Point=").append(this.point).append("|Normal=").append(this.normal).append("|Depth=").append(this.depth).append("|NormalImpulse=").append(this.normalImpulse).append("|TangentImpulse=").append(this.tangentialImpulse).append("]");
                        return sb.toString();
                    }
                    /**
                     * Returns the accumulated normal impulse.
                     * @return {number} double
                     */
                    getNormalImpulse() {
                        return this.normalImpulse;
                    }
                    /**
                     * Returns the accumulated tangential impulse.
                     * @return {number} double
                     */
                    getTangentialImpulse() {
                        return this.tangentialImpulse;
                    }
                }
                contact_4.SolvedContactPoint = SolvedContactPoint;
                SolvedContactPoint["__class"] = "org.dyn4j.dynamics.contact.SolvedContactPoint";
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * @param {org.dyn4j.dynamics.Body} other the other {@link Body} in contact
             * @param {org.dyn4j.dynamics.contact.ContactConstraint} contactConstraint the {@link ContactConstraint} between the {@link Body}s
             * @class
             * @extends org.dyn4j.dynamics.InteractionEdge
             * @author William Bittle
             */
            class ContactEdge extends org.dyn4j.dynamics.InteractionEdge {
                constructor(other, contactConstraint) {
                    super(other, contactConstraint);
                }
            }
            dynamics.ContactEdge = ContactEdge;
            ContactEdge["__class"] = "org.dyn4j.dynamics.ContactEdge";
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * @param {org.dyn4j.dynamics.Body} other the linked {@link Body}
             * @param {org.dyn4j.dynamics.joint.Joint} joint the {@link Joint}
             * @class
             * @extends org.dyn4j.dynamics.InteractionEdge
             * @author William Bittle
             */
            class JointEdge extends org.dyn4j.dynamics.InteractionEdge {
                constructor(other, joint) {
                    super(other, joint);
                }
            }
            dynamics.JointEdge = JointEdge;
            JointEdge["__class"] = "org.dyn4j.dynamics.JointEdge";
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var contact;
            (function (contact_5) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture1 the first {@link Body}'s {@link BodyFixture}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture2 the second {@link Body}'s {@link BodyFixture}
                 * @param {org.dyn4j.collision.manifold.Manifold} manifold the contact {@link Manifold}
                 * @param {number} friction the friction for the contact constraint
                 * @param {number} restitution the restitution for the contact constraint
                 * @class
                 * @extends org.dyn4j.dynamics.Constraint
                 * @author William Bittle
                 */
                class ContactConstraint extends org.dyn4j.dynamics.Constraint {
                    constructor(body1, fixture1, body2, fixture2, manifold, friction, restitution) {
                        super(body1, body2);
                        if (this.id === undefined) {
                            this.id = null;
                        }
                        if (this.fixture1 === undefined) {
                            this.fixture1 = null;
                        }
                        if (this.fixture2 === undefined) {
                            this.fixture2 = null;
                        }
                        if (this.contacts === undefined) {
                            this.contacts = null;
                        }
                        if (this.normal === undefined) {
                            this.normal = null;
                        }
                        if (this.tangent === undefined) {
                            this.tangent = null;
                        }
                        if (this.friction === undefined) {
                            this.friction = 0;
                        }
                        if (this.restitution === undefined) {
                            this.restitution = 0;
                        }
                        if (this.sensor === undefined) {
                            this.sensor = false;
                        }
                        if (this.tangentSpeed === undefined) {
                            this.tangentSpeed = 0;
                        }
                        if (this.enabled === undefined) {
                            this.enabled = false;
                        }
                        if (this.K === undefined) {
                            this.K = null;
                        }
                        if (this.invK === undefined) {
                            this.invK = null;
                        }
                        this.fixture1 = fixture1;
                        this.fixture2 = fixture2;
                        this.id = new org.dyn4j.dynamics.contact.ContactConstraintId(body1, fixture1, body2, fixture2);
                        const points = manifold.getPoints();
                        const mSize = points.size();
                        this.contacts = (new java.util.ArrayList(mSize));
                        for (let l = 0; l < mSize; l++) {
                            {
                                const point = points.get(l);
                                const contact = new org.dyn4j.dynamics.contact.Contact(point.getId(), point.getPoint(), point.getDepth(), this.body1.getLocalPoint(point.getPoint()), this.body2.getLocalPoint(point.getPoint()));
                                this.contacts.add(contact);
                            }
                            ;
                        }
                        this.normal = manifold.getNormal();
                        this.tangent = this.normal.getLeftHandOrthogonalVector();
                        this.friction = friction;
                        this.restitution = restitution;
                        this.sensor = fixture1.isSensor() || fixture2.isSensor();
                        this.tangentSpeed = 0;
                        this.enabled = true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("ContactConstraint[").append(super.toString()).append("|Body1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body1)).append("|Fixture1=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture1)).append("|Body2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.body2)).append("|Fixture2=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture2)).append("|Normal=").append(this.normal).append("|Tangent=").append(this.tangent).append("|Friction=").append(this.friction).append("|Restitution=").append(this.restitution).append("|IsSensor=").append(this.sensor).append("|TangentSpeed=").append(this.tangentSpeed).append("|Enabled=").append(this.enabled).append("|Contacts={");
                        const size = this.contacts.size();
                        for (let i = 0; i < size; i++) {
                            {
                                if (i !== 0)
                                    sb.append(",");
                                sb.append(this.contacts.get(i));
                            }
                            ;
                        }
                        sb.append("}]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                        const size = this.contacts.size();
                        for (let i = 0; i < size; i++) {
                            {
                                const c = this.contacts.get(i);
                                c.p.add$org_dyn4j_geometry_Vector2(shift);
                            }
                            ;
                        }
                    }
                    /**
                     * Returns the contact constraint id.
                     * @return {org.dyn4j.dynamics.contact.ContactConstraintId} {@link ContactConstraintId}
                     */
                    getId() {
                        return this.id;
                    }
                    /**
                     * Returns the collision normal.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the collision normal
                     */
                    getNormal() {
                        return this.normal;
                    }
                    /**
                     * Returns the collision tangent.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the collision tangent
                     */
                    getTangent() {
                        return this.tangent;
                    }
                    /**
                     * Returns the list of {@link Contact}s.
                     * <p>
                     * Modification of the list is permitted.
                     * @return {*} List&lt;{@link Contact}&gt; the list of {@link Contact}s
                     */
                    getContacts() {
                        return this.contacts;
                    }
                    /**
                     * Returns the first {@link Body}.
                     * @return {org.dyn4j.dynamics.Body} {@link Body} the first {@link Body}
                     */
                    getBody1() {
                        return this.body1;
                    }
                    /**
                     * Returns the first {@link Body}'s {@link BodyFixture}.
                     * @return {org.dyn4j.dynamics.BodyFixture} {@link BodyFixture} the first {@link Body}'s {@link BodyFixture}
                     */
                    getFixture1() {
                        return this.fixture1;
                    }
                    /**
                     * Returns the second {@link Body}.
                     * @return {org.dyn4j.dynamics.Body} {@link Body} the second {@link Body}
                     */
                    getBody2() {
                        return this.body2;
                    }
                    /**
                     * Returns the second {@link Body}'s {@link BodyFixture}.
                     * @return {org.dyn4j.dynamics.BodyFixture} {@link BodyFixture} the second {@link Body}'s {@link BodyFixture}
                     */
                    getFixture2() {
                        return this.fixture2;
                    }
                    /**
                     * Returns the coefficient of friction for this contact constraint.
                     * @return {number} double
                     */
                    getFriction() {
                        return this.friction;
                    }
                    /**
                     * Sets the coefficient of friction for this contact constraint.
                     * @param {number} friction the friction
                     * @since 3.0.2
                     */
                    setFriction(friction) {
                        this.friction = friction;
                    }
                    /**
                     * Returns the coefficient of restitution for this contact constraint.
                     * @return {number} double
                     */
                    getRestitution() {
                        return this.restitution;
                    }
                    /**
                     * Sets the coefficient of restitution for this contact constraint.
                     * @param {number} restitution the restitution
                     * @since 3.0.2
                     */
                    setRestitution(restitution) {
                        this.restitution = restitution;
                    }
                    /**
                     * Returns true if this {@link ContactConstraint} is a sensor.
                     * <p>
                     * By default a contact constraint is a sensor if either of the
                     * two {@link BodyFixture}s are sensor fixtures.  This can be
                     * overridden using the {@link #setSensor(boolean)} method.
                     * @return {boolean} boolean
                     * @since 1.0.1
                     */
                    isSensor() {
                        return this.sensor;
                    }
                    /**
                     * Sets this contact constraint to a sensor if flag is true.
                     * <p>
                     * A sensor constraint is not solved.
                     * @param {boolean} flag true if this contact constraint should be a sensor
                     * @since 3.0.2
                     */
                    setSensor(flag) {
                        this.sensor = flag;
                    }
                    /**
                     * Returns the surface speed of the contact constraint.
                     * <p>
                     * This will always be zero unless specified manually. This can
                     * be used to set the target velocity at the contact to simulate
                     * a conveyor belt type effect.
                     * @return {number} double
                     * @since 3.0.2
                     */
                    getTangentSpeed() {
                        return this.tangentSpeed;
                    }
                    /**
                     * Sets the target surface speed of the contact constraint.
                     * <p>
                     * The surface speed, in meters / second, is used to simulate a
                     * conveyor belt.
                     * <p>
                     * A value of zero deactivates this feature.
                     * @param {number} speed the speed in Meters / Second
                     * @since 3.0.2
                     */
                    setTangentSpeed(speed) {
                        this.tangentSpeed = speed;
                    }
                    /**
                     * Sets the enabled flag.
                     * <p>
                     * A value of true would enable the contact to be processed by the
                     * collision resolution step. A value of false would disable the
                     * processing of this constraint for this step only.
                     * <p>
                     * True by default.
                     * @param {boolean} flag true if the contact should be enabled
                     * @since 3.3.0
                     */
                    setEnabled(flag) {
                        this.enabled = flag;
                    }
                    /**
                     * Returns true if this contact constraint is enabled for processing
                     * by the collision resolution step.
                     * @return {boolean} boolean
                     * @since 3.3.0
                     */
                    isEnabled() {
                        return this.enabled;
                    }
                }
                contact_5.ContactConstraint = ContactConstraint;
                ContactConstraint["__class"] = "org.dyn4j.dynamics.contact.ContactConstraint";
                ContactConstraint["__interfaces"] = ["org.dyn4j.geometry.Shiftable"];
            })(contact = dynamics.contact || (dynamics.contact = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {boolean} collisionAllowed true if the joined {@link Body}s can take part in collision detection
                 * @throws NullPointerException if body1 or body2 is null
                 * @class
                 * @extends org.dyn4j.dynamics.Constraint
                 * @author William Bittle
                 */
                class Joint extends org.dyn4j.dynamics.Constraint {
                    constructor(body1, body2, collisionAllowed) {
                        if (((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((typeof collisionAllowed === 'boolean') || collisionAllowed === null)) {
                            let __args = arguments;
                            super(body1, body2);
                            if (this.collisionAllowed === undefined) {
                                this.collisionAllowed = false;
                            }
                            if (this.userData === undefined) {
                                this.userData = null;
                            }
                            if (this.dynamicallyAdded === undefined) {
                                this.dynamicallyAdded = false;
                            }
                            if (this.selected === undefined) {
                                this.selected = false;
                            }
                            this.id = new org.dyn4j.RandomUUID();
                            this.name = "joint";
                            this.renderable = true;
                            this.size = 1;
                            this.collisionAllowed = collisionAllowed;
                        }
                        else if (((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && collisionAllowed === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let collisionAllowed = false;
                                super(body1, body2);
                                if (this.collisionAllowed === undefined) {
                                    this.collisionAllowed = false;
                                }
                                if (this.userData === undefined) {
                                    this.userData = null;
                                }
                                if (this.dynamicallyAdded === undefined) {
                                    this.dynamicallyAdded = false;
                                }
                                if (this.selected === undefined) {
                                    this.selected = false;
                                }
                                this.id = new org.dyn4j.RandomUUID();
                                this.name = "joint";
                                this.renderable = true;
                                this.size = 1;
                                this.collisionAllowed = collisionAllowed;
                            }
                            if (this.collisionAllowed === undefined) {
                                this.collisionAllowed = false;
                            }
                            if (this.userData === undefined) {
                                this.userData = null;
                            }
                            if (this.dynamicallyAdded === undefined) {
                                this.dynamicallyAdded = false;
                            }
                            if (this.selected === undefined) {
                                this.selected = false;
                            }
                            this.id = new org.dyn4j.RandomUUID();
                            this.name = "joint";
                            this.renderable = true;
                            this.size = 1;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("Id=").append(this.id).append("|").append(super.toString()).append("|IsCollisionAllowed=").append(this.collisionAllowed);
                        return sb.toString();
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                    }
                    /**
                     * Returns the unique identifier for this joint instance.
                     * @return {org.dyn4j.RandomUUID} String
                     * @since 3.0.1
                     */
                    getId() {
                        return this.id;
                    }
                    /**
                     * Returns true if this {@link Joint} is active.
                     * <p>
                     * A joint is only active if both joined {@link Body}s are active.
                     * @return {boolean} boolean
                     */
                    isActive() {
                        return this.body1.isActive() && this.body2.isActive();
                    }
                    /**
                     * Returns true if collision between the joined {@link Body}s is allowed.
                     * @return {boolean} boolean
                     */
                    isCollisionAllowed() {
                        return this.collisionAllowed;
                    }
                    /**
                     * Sets whether collision is allowed between the joined {@link Body}s.
                     * @param {boolean} flag true if collisions are allowed
                     */
                    setCollisionAllowed(flag) {
                        if (this.collisionAllowed !== flag) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                            this.collisionAllowed = flag;
                        }
                    }
                    getUserData() {
                        return this.userData;
                    }
                    setUserData(userData) {
                        this.userData = userData;
                    }
                    /**
                     * returns name of the joint
                     * @return
                     * @return {string}
                     */
                    getName() {
                        return this.name;
                    }
                    /**
                     * sets name of joint
                     * @param {string} name
                     */
                    setName(name) {
                        this.name = name;
                    }
                    /**
                     * @return {boolean} true if joint is renderable
                     */
                    isVisible() {
                        return this.renderable;
                    }
                    /**
                     * @param {boolean} renderable the renderable to set
                     */
                    setVisible(renderable) {
                        this.renderable = renderable;
                    }
                    /**
                     * size of the joint (size=1 means default size) size >1 scales up size
                     * while size<1 scales down the size (max size=5)
                     * @param {number} size
                     */
                    setSize(size) {
                        if (size <= 0)
                            return;
                        if (size > 5)
                            size = 5;
                        this.size = size;
                    }
                    /**
                     * size of the joint
                     * @return
                     * @return {number}
                     */
                    getSize() {
                        return this.size;
                    }
                    /**
                     * returns true if joint is added using script
                     * @return
                     * @return {boolean}
                     */
                    isDynamicallyAdded() {
                        return this.dynamicallyAdded;
                    }
                    /**
                     * Sets flag whether joint is added using script, if this flag is true joint is not added to simulation tree
                     *
                     * @param {boolean} dynamicallyAdded
                     */
                    setDynamicallyAdded(dynamicallyAdded) {
                        this.dynamicallyAdded = dynamicallyAdded;
                    }
                }
                joint.Joint = Joint;
                Joint["__class"] = "org.dyn4j.dynamics.joint.Joint";
                Joint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                var input;
                (function (input) {
                    class AbstractKeyboardInputHandler extends org.dyn4j.samples.framework.input.AbstractInputHandler {
                        constructor(component) {
                            super();
                            if (this.component === undefined) {
                                this.component = null;
                            }
                            this.component = component;
                        }
                        /**
                         *
                         */
                        install() {
                            window.addEventListener("keydown", (event) => {
                                if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                                    this.onKeyPressed((event.keyCode | 0), event.key);
                                    event.preventDefault();
                                }
                                return null;
                            }, true);
                            window.addEventListener("keyup", (event) => {
                                if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                                    this.onKeyReleased((event.keyCode | 0), event.key);
                                    event.preventDefault();
                                }
                                return null;
                            }, true);
                        }
                        /**
                         *
                         */
                        uninstall() {
                        }
                        onKeyPressed(keyCode, key) {
                        }
                        onKeyReleased(keyCode, key) {
                        }
                    }
                    input.AbstractKeyboardInputHandler = AbstractKeyboardInputHandler;
                    AbstractKeyboardInputHandler["__class"] = "org.dyn4j.samples.framework.input.AbstractKeyboardInputHandler";
                    AbstractKeyboardInputHandler["__interfaces"] = ["org.dyn4j.samples.framework.input.InputHandler"];
                })(input = framework.input || (framework.input = {}));
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                var input;
                (function (input) {
                    class AbstractMouseInputHandler extends org.dyn4j.samples.framework.input.AbstractInputHandler {
                        constructor(component, camera, button) {
                            super();
                            if (this.component === undefined) {
                                this.component = null;
                            }
                            if (this.camera === undefined) {
                                this.camera = null;
                            }
                            if (this.button === undefined) {
                                this.button = 0;
                            }
                            if (this.dragCurrent === undefined) {
                                this.dragCurrent = null;
                            }
                            if (this.dragStart === undefined) {
                                this.dragStart = null;
                            }
                            if (this.wheelRotation === undefined) {
                                this.wheelRotation = 0;
                            }
                            this.component = component;
                            this.camera = camera;
                            this.button = button;
                        }
                        toWorldCoordinates(p) {
                            return this.camera.toWorldCoordinates(this.component.width, this.component.height, p);
                        }
                        /**
                         *
                         */
                        install() {
                            this.component.addEventListener("mousedown", (event) => {
                                this.dragCurrent = new org.dyn4j.geometry.Vector2(event.pageX, event.pageY);
                                this.dragStart = this.dragCurrent;
                                if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                                    this.onMousePressed(this.dragStart);
                                }
                                return null;
                            }, true);
                            this.component.addEventListener("mousemove", (event) => {
                                if (event.buttons > 0) {
                                    this.dragCurrent = new org.dyn4j.geometry.Vector2(event.pageX, event.pageY);
                                    if (this.isEnabled() && !this.isDependentBehaviorActive() && this.dragStart != null) {
                                        this.onMouseDrag(this.dragStart, this.dragCurrent);
                                    }
                                }
                                return null;
                            }, true);
                            this.component.addEventListener("mouseup", (event) => {
                                this.dragCurrent = null;
                                this.dragStart = null;
                                if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                                    this.onMouseRelease();
                                }
                                return null;
                            }, true);
                            this.component.addEventListener("mousewheel", (event) => {
                                if (this.isEnabled() && !this.isDependentBehaviorActive()) {
                                     event.preventDefault();
                                    if (event.ctrlKey) {
                                        this.onMouseWheel(event.wheelDelta);
                                    }
                                    else {
                                        this.dragStart = new org.dyn4j.geometry.Vector2(event.pageX, event.pageY);
                                 
                                        this.onMousePressed(this.dragStart);
                                        this.onMouseDrag(this.dragStart, this.dragStart.sum(-event.deltaX ,-event.deltaY));
                                    }
                                    
                                }
                                event.stopPropagation();
                                return null;
                            }, true);
                        }
                        /**
                         *
                         */
                        uninstall() {
                        }
                        /**
                         *
                         * @param {boolean} flag
                         */
                        setEnabled(flag) {
                            super.setEnabled(flag);
                            if (!flag) {
                                this.dragCurrent = null;
                                this.dragStart = null;
                                this.wheelRotation = 0.0;
                            }
                        }
                        onMousePressed(point) {
                        }
                        onMouseDrag(start, current) {
                        }
                        onMouseRelease() {
                        }
                        onMouseWheel(rotation) {
                        }
                    }
                    input.AbstractMouseInputHandler = AbstractMouseInputHandler;
                    AbstractMouseInputHandler["__class"] = "org.dyn4j.samples.framework.input.AbstractMouseInputHandler";
                    AbstractMouseInputHandler["__interfaces"] = ["org.dyn4j.samples.framework.input.InputHandler"];
                })(input = framework.input || (framework.input = {}));
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            /**
             * An example of using a "Concave" body.
             * @author William Bittle
             * @since 4.1.1
             * @version 4.1.1
             * @class
             * @extends org.dyn4j.samples.WorldCreator
             */
            class Concave extends org.dyn4j.samples.WorldCreator {
                /**
                 * The serial version id
                 * @param {org.dyn4j.dynamics.World} world
                 */
                populateWorld(world) {
                    world.getSettings().setContinuousDetectionMode(org.dyn4j.dynamics.ContinuousDetectionMode.NONE);
                    world.setBroadphaseDetector((new org.dyn4j.collision.broadphase.LazyAABBTree()));
                    world.setNarrowphaseDetector(new org.dyn4j.collision.narrowphase.Sat());
                    const ground = new org.dyn4j.samples.framework.SimulationBody();
                    ground.addFixture$org_dyn4j_geometry_Convex(org.dyn4j.geometry.Geometry.createRectangle(15.0, 1.0));
                    ground.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.INFINITE);
                    world.addBody(ground);
                    const table = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(3.0, 1.0);
                        c['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(0.0, 0.5));
                        table.addFixture$org_dyn4j_geometry_Convex(c);
                    }
                    ;
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(1.0, 1.0);
                        c['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(-1.0, -0.5));
                        table.addFixture$org_dyn4j_geometry_Convex(c);
                    }
                    ;
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(1.0, 1.0);
                        c['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(1.0, -0.5));
                        table.addFixture$org_dyn4j_geometry_Convex(c);
                    }
                    ;
                    table.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(0.0, 4.0));
                    table.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(table);
                    table.setAutoSleepingEnabled(false);
                    const box = new org.dyn4j.samples.framework.SimulationBody();
                    box.addFixture$org_dyn4j_geometry_Convex(org.dyn4j.geometry.Geometry.createSquare(0.5));
                    box.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(-3, 4.0));
                    box.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(box);
                    const disc = new org.dyn4j.samples.framework.SimulationBody();
                    disc.addFixture$org_dyn4j_geometry_Convex(org.dyn4j.geometry.Geometry.createCircle(0.4));
                    disc.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(-6, 4.0));
                    disc.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(disc);
                    const jt1 = new org.dyn4j.dynamics.joint.SpringJoint(box, ground, new org.dyn4j.geometry.Vector2(-3, 4), new org.dyn4j.geometry.Vector2(-4, 5), 20, 0.1);
                    const jt3 = new org.dyn4j.dynamics.joint.PrismaticJoint(box, ground, new org.dyn4j.geometry.Vector2(-3, 4), new org.dyn4j.geometry.Vector2(-3, 2), new org.dyn4j.geometry.Vector2(0, 1));
                    jt3.setLimits(0.5, 3);
                    jt3.setLimitEnabled(true);
                    const jt2 = new org.dyn4j.dynamics.joint.SpringJoint(table, ground, new org.dyn4j.geometry.Vector2(0, 4), new org.dyn4j.geometry.Vector2(0, 6), 120, 0);
                    const jt4 = new org.dyn4j.dynamics.joint.DistanceJoint(disc, ground, new org.dyn4j.geometry.Vector2(-6, 4), new org.dyn4j.geometry.Vector2(-5, 6));
                    const jt5 = new org.dyn4j.dynamics.joint.RevoluteJoint(table, ground, new org.dyn4j.geometry.Vector2(1, 4));
                    world.addJoint(jt1);
                    world.addJoint(jt2);
                    world.addJoint(jt3);
                    world.addJoint(jt4);
                    world.addJoint(jt5);
                }
            }
            samples.Concave = Concave;
            Concave["__class"] = "org.dyn4j.samples.Concave";
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            /**
             * A scene where a truck is carrying other objects.
             * @author William Bittle
             * @since 4.1.1
             * @version 4.1.1
             * @class
             * @extends org.dyn4j.samples.WorldCreator
             */
            class Truck extends org.dyn4j.samples.WorldCreator {
                /**
                 * Creates game objects and adds them to the world.
                 * @param {org.dyn4j.dynamics.World} world
                 */
                populateWorld(world) {
                    world.getSettings().setContinuousDetectionMode(org.dyn4j.dynamics.ContinuousDetectionMode.NONE);
                    world.setBroadphaseDetector((new org.dyn4j.collision.broadphase.LazyAABBTree()));
                    const ground = new org.dyn4j.samples.framework.SimulationBody();
                    ground.addFixture$org_dyn4j_geometry_Convex$double$double$double(org.dyn4j.geometry.Geometry.createRectangle(50.0, 1.0), 1.0, 0.5, 0.0);
                    ground.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(-2.0, -4.0));
                    ground.setMassType(org.dyn4j.geometry.MassType.INFINITE);
                    world.addBody(ground);
                    const ramp = new org.dyn4j.samples.framework.SimulationBody();
                    ramp.addFixture$org_dyn4j_geometry_Convex(org.dyn4j.geometry.Geometry.createRectangle(10.0, 0.2));
                    ramp.rotate$double(/* toRadians */ (x => x * Math.PI / 180)(10.0));
                    ramp.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(0.0, -3.0));
                    ramp.setMassType(org.dyn4j.geometry.MassType.INFINITE);
                    world.addBody(ramp);
                    const truck = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        truck.addFixture$org_dyn4j_geometry_Convex(org.dyn4j.geometry.Geometry.createRectangle(5.0, 0.25));
                    }
                    ;
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(5.2, 0.5);
                        c['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(0.0, 0.5));
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        truck.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.25, 0.5);
                        c['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(-2.4, 1.0));
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        truck.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(2.0, 2.0);
                        c['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(2.4, 1.0));
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        truck.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    truck.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(-23.0, -3.0));
                    truck.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(truck);
                    const rearWheel = new org.dyn4j.samples.framework.SimulationBody();
                    rearWheel.addFixture$org_dyn4j_geometry_Convex$double$double$double(org.dyn4j.geometry.Geometry.createCircle(0.5), 1.0, 0.5, 0.0);
                    rearWheel.translate$double$double(-25.0, -3.0);
                    rearWheel.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(rearWheel);
                    const frontWheel = new org.dyn4j.samples.framework.SimulationBody();
                    frontWheel.addFixture$org_dyn4j_geometry_Convex$double$double$double(org.dyn4j.geometry.Geometry.createCircle(0.5), 1.0, 0.5, 0.0);
                    frontWheel.translate$double$double(-21.0, -3.0);
                    frontWheel.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(frontWheel);
                    const rearWheelJoint = new org.dyn4j.dynamics.joint.RevoluteJoint(truck, rearWheel, new org.dyn4j.geometry.Vector2(-25.0, -3.0));
                    world.addJoint(rearWheelJoint);
                    const frontWheelJoint = new org.dyn4j.dynamics.joint.RevoluteJoint(truck, frontWheel, new org.dyn4j.geometry.Vector2(-21.0, -3.0));
                    world.addJoint(frontWheelJoint);
                    const x = -24;
                    const y = -2.0;
                    const s = 0.25;
                    for (let i = 0; i < 5; i++) {
                        {
                            for (let j = 0; j < 2; j++) {
                                {
                                    const box = new org.dyn4j.samples.framework.SimulationBody();
                                    box.addFixture$org_dyn4j_geometry_Convex$double$double$double(org.dyn4j.geometry.Geometry.createSquare(s), 1.0, 0.2, 0.0);
                                    box.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(x + (i * s), y + (j * s)));
                                    box.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                                    world.addBody(box);
                                }
                                ;
                            }
                        }
                        ;
                    }
                }
            }
            samples.Truck = Truck;
            Truck["__class"] = "org.dyn4j.samples.Truck";
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            /**
             * A somewhat complex scene with a ragdoll.
             *
             * @class
             * @extends org.dyn4j.samples.WorldCreator
             */
            class Ragdoll extends org.dyn4j.samples.WorldCreator {
                /**
                 * Creates game objects and adds them to the world.
                 * @param {org.dyn4j.dynamics.World} world
                 */
                populateWorld(world) {
                    world.getSettings().setContinuousDetectionMode(org.dyn4j.dynamics.ContinuousDetectionMode.NONE);
                    world.setBroadphaseDetector((new org.dyn4j.collision.broadphase.LazyAABBTree()));
                    const ground = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(100.0, 1.0);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        ground.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    ground.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(0.6875, -6.75));
                    ground.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.INFINITE);
                    world.addBody(ground);
                    const head = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createCircle(0.25);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        head.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    head.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(head);
                    const torso = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.5, 1.0);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        torso.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(1.0, 0.25);
                        c['translate$org_dyn4j_geometry_Vector2'](new org.dyn4j.geometry.Vector2(0.00390625, 0.375));
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        torso.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    torso.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(0.0234375, -0.8125));
                    torso.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(torso);
                    const rightHumerus = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.25, 0.5);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        rightHumerus.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    rightHumerus.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(0.4375, -0.609375));
                    rightHumerus.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(rightHumerus);
                    const rightUlna = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.25, 0.4);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        rightUlna.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    rightUlna.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(0.44140625, -0.98828125));
                    rightUlna.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(rightUlna);
                    const neck = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.15, 0.2);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        neck.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    neck.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(0.015625, -0.2734375));
                    neck.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(neck);
                    const leftHumerus = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.25, 0.5);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        leftHumerus.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    leftHumerus.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(-0.3828125, -0.609375));
                    leftHumerus.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(leftHumerus);
                    const leftUlna = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.25, 0.4);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        leftUlna.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    leftUlna.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(-0.3828125, -0.9765625));
                    leftUlna.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(leftUlna);
                    const rightFemur = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.25, 0.75);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        rightFemur.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    rightFemur.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(0.1796875, -1.5703125));
                    rightFemur.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(rightFemur);
                    const leftFemur = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.25, 0.75);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        leftFemur.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    leftFemur.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(-0.1328125, -1.5703125));
                    leftFemur.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(leftFemur);
                    const rightTibia = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.25, 0.5);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        rightTibia.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    rightTibia.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(0.18359375, -2.11328125));
                    rightTibia.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(rightTibia);
                    const leftTibia = new org.dyn4j.samples.framework.SimulationBody();
                    {
                        const c = org.dyn4j.geometry.Geometry.createRectangle(0.25, 0.5);
                        const bf = new org.dyn4j.dynamics.BodyFixture(c);
                        leftTibia.addFixture$org_dyn4j_dynamics_BodyFixture(bf);
                    }
                    ;
                    leftTibia.translate$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(-0.1328125, -2.1171875));
                    leftTibia.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                    world.addBody(leftTibia);
                    const headToNeck = new org.dyn4j.dynamics.joint.RevoluteJoint(head, neck, new org.dyn4j.geometry.Vector2(0.01, -0.2));
                    headToNeck.setLimitEnabled(false);
                    headToNeck.setLimits(/* toRadians */ (x => x * Math.PI / 180)(0.0), /* toRadians */ (x => x * Math.PI / 180)(0.0));
                    headToNeck.setReferenceAngle(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    headToNeck.setMotorEnabled(false);
                    headToNeck.setMotorSpeed(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    headToNeck.setMaximumMotorTorque(0.0);
                    headToNeck.setCollisionAllowed(false);
                    world.addJoint(headToNeck);
                    const neckToTorso = new org.dyn4j.dynamics.joint.RevoluteJoint(neck, torso, new org.dyn4j.geometry.Vector2(0.01, -0.35));
                    neckToTorso.setLimitEnabled(false);
                    neckToTorso.setLimits(/* toRadians */ (x => x * Math.PI / 180)(0.0), /* toRadians */ (x => x * Math.PI / 180)(0.0));
                    neckToTorso.setReferenceAngle(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    neckToTorso.setMotorEnabled(false);
                    neckToTorso.setMotorSpeed(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    neckToTorso.setMaximumMotorTorque(0.0);
                    neckToTorso.setCollisionAllowed(false);
                    world.addJoint(neckToTorso);
                    const torsoToLeftHumerus = new org.dyn4j.dynamics.joint.RevoluteJoint(torso, leftHumerus, new org.dyn4j.geometry.Vector2(-0.4, -0.4));
                    torsoToLeftHumerus.setLimitEnabled(false);
                    torsoToLeftHumerus.setLimits(/* toRadians */ (x => x * Math.PI / 180)(0.0), /* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToLeftHumerus.setReferenceAngle(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToLeftHumerus.setMotorEnabled(false);
                    torsoToLeftHumerus.setMotorSpeed(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToLeftHumerus.setMaximumMotorTorque(0.0);
                    torsoToLeftHumerus.setCollisionAllowed(false);
                    world.addJoint(torsoToLeftHumerus);
                    const torsoToRightHumerus = new org.dyn4j.dynamics.joint.RevoluteJoint(torso, rightHumerus, new org.dyn4j.geometry.Vector2(0.4, -0.4));
                    torsoToRightHumerus.setLimitEnabled(false);
                    torsoToRightHumerus.setLimits(/* toRadians */ (x => x * Math.PI / 180)(0.0), /* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToRightHumerus.setReferenceAngle(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToRightHumerus.setMotorEnabled(false);
                    torsoToRightHumerus.setMotorSpeed(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToRightHumerus.setMaximumMotorTorque(0.0);
                    torsoToRightHumerus.setCollisionAllowed(false);
                    world.addJoint(torsoToRightHumerus);
                    const rightHumerusToRightUlna = new org.dyn4j.dynamics.joint.RevoluteJoint(rightHumerus, rightUlna, new org.dyn4j.geometry.Vector2(0.43, -0.82));
                    rightHumerusToRightUlna.setLimitEnabled(false);
                    rightHumerusToRightUlna.setLimits(/* toRadians */ (x => x * Math.PI / 180)(0.0), /* toRadians */ (x => x * Math.PI / 180)(0.0));
                    rightHumerusToRightUlna.setReferenceAngle(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    rightHumerusToRightUlna.setMotorEnabled(false);
                    rightHumerusToRightUlna.setMotorSpeed(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    rightHumerusToRightUlna.setMaximumMotorTorque(0.0);
                    rightHumerusToRightUlna.setCollisionAllowed(false);
                    world.addJoint(rightHumerusToRightUlna);
                    const leftHumerusToLeftUlna = new org.dyn4j.dynamics.joint.RevoluteJoint(leftHumerus, leftUlna, new org.dyn4j.geometry.Vector2(-0.4, -0.81));
                    leftHumerusToLeftUlna.setLimitEnabled(false);
                    leftHumerusToLeftUlna.setLimits(/* toRadians */ (x => x * Math.PI / 180)(0.0), /* toRadians */ (x => x * Math.PI / 180)(0.0));
                    leftHumerusToLeftUlna.setReferenceAngle(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    leftHumerusToLeftUlna.setMotorEnabled(false);
                    leftHumerusToLeftUlna.setMotorSpeed(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    leftHumerusToLeftUlna.setMaximumMotorTorque(0.0);
                    leftHumerusToLeftUlna.setCollisionAllowed(false);
                    world.addJoint(leftHumerusToLeftUlna);
                    const torsoToRightFemur = new org.dyn4j.dynamics.joint.RevoluteJoint(torso, rightFemur, new org.dyn4j.geometry.Vector2(0.16, -1.25));
                    torsoToRightFemur.setLimitEnabled(false);
                    torsoToRightFemur.setLimits(/* toRadians */ (x => x * Math.PI / 180)(0.0), /* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToRightFemur.setReferenceAngle(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToRightFemur.setMotorEnabled(false);
                    torsoToRightFemur.setMotorSpeed(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToRightFemur.setMaximumMotorTorque(0.0);
                    torsoToRightFemur.setCollisionAllowed(false);
                    world.addJoint(torsoToRightFemur);
                    const torsoToLeftFemur = new org.dyn4j.dynamics.joint.RevoluteJoint(torso, leftFemur, new org.dyn4j.geometry.Vector2(-0.13, -1.25));
                    torsoToLeftFemur.setLimitEnabled(false);
                    torsoToLeftFemur.setLimits(/* toRadians */ (x => x * Math.PI / 180)(0.0), /* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToLeftFemur.setReferenceAngle(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToLeftFemur.setMotorEnabled(false);
                    torsoToLeftFemur.setMotorSpeed(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    torsoToLeftFemur.setMaximumMotorTorque(0.0);
                    torsoToLeftFemur.setCollisionAllowed(false);
                    world.addJoint(torsoToLeftFemur);
                    const rightFemurToRightTibia = new org.dyn4j.dynamics.joint.RevoluteJoint(rightFemur, rightTibia, new org.dyn4j.geometry.Vector2(0.17, -1.9));
                    rightFemurToRightTibia.setLimitEnabled(false);
                    rightFemurToRightTibia.setLimits(/* toRadians */ (x => x * Math.PI / 180)(0.0), /* toRadians */ (x => x * Math.PI / 180)(0.0));
                    rightFemurToRightTibia.setReferenceAngle(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    rightFemurToRightTibia.setMotorEnabled(false);
                    rightFemurToRightTibia.setMotorSpeed(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    rightFemurToRightTibia.setMaximumMotorTorque(0.0);
                    rightFemurToRightTibia.setCollisionAllowed(false);
                    world.addJoint(rightFemurToRightTibia);
                    const leftFemurToLeftTibia = new org.dyn4j.dynamics.joint.RevoluteJoint(leftFemur, leftTibia, new org.dyn4j.geometry.Vector2(-0.14, -1.9));
                    leftFemurToLeftTibia.setLimitEnabled(false);
                    leftFemurToLeftTibia.setLimits(/* toRadians */ (x => x * Math.PI / 180)(0.0), /* toRadians */ (x => x * Math.PI / 180)(0.0));
                    leftFemurToLeftTibia.setReferenceAngle(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    leftFemurToLeftTibia.setMotorEnabled(false);
                    leftFemurToLeftTibia.setMotorSpeed(/* toRadians */ (x => x * Math.PI / 180)(0.0));
                    leftFemurToLeftTibia.setMaximumMotorTorque(0.0);
                    leftFemurToLeftTibia.setCollisionAllowed(false);
                    world.addJoint(leftFemurToLeftTibia);
                }
            }
            samples.Ragdoll = Ragdoll;
            Ragdoll["__class"] = "org.dyn4j.samples.Ragdoll";
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            var decompose;
            (function (decompose) {
                /**
                 * Implementation of the Ear Clipping convex decomposition algorithm for simple polygons.
                 * <p>
                 * This algorithm operates only on simple polygons.  A simple polygon is a polygon that
                 * has vertices that are connected by edges where:
                 * <ul>
                 * <li>Edges can only intersect at vertices</li>
                 * <li>Vertices have at most two edge connections</li>
                 * </ul>
                 * <p>
                 * This implementation does not handle polygons with holes, but accepts both counter-clockwise
                 * and clockwise polygons.
                 * <p>
                 * The polygon to decompose must be 4 or more vertices.
                 * <p>
                 * This algorithm creates a valid triangulation (N - 2) triangles, then employs the Hertel-Mehlhorn
                 * algorithm to reduce the number of convex pieces.
                 * <p>
                 * This algorithm is O(n<sup>2</sup>).
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 2.2.0
                 * @class
                 */
                class EarClipping {
                    constructor() {
                    }
                    static CONTAINS_EPSILON_$LI$() { if (EarClipping.CONTAINS_EPSILON == null) {
                        EarClipping.CONTAINS_EPSILON = Math.sqrt(org.dyn4j.Epsilon.E_$LI$());
                    } return EarClipping.CONTAINS_EPSILON; }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2[]} points
                     * @return {*}
                     */
                    decompose(...points) {
                        const dcel = this.createTriangulation.apply(this, points);
                        dcel.hertelMehlhorn();
                        return dcel.getConvexDecomposition();
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2[]} points
                     * @return {*}
                     */
                    triangulate(...points) {
                        const dcel = this.createTriangulation.apply(this, points);
                        return dcel.getTriangulation();
                    }
                    /**
                     * Creates a triangulation of the given simple polygon and places it into the returned
                     * doubly-connected edge list (DCEL).
                     * @param {org.dyn4j.geometry.Vector2[]} points the simple polygon vertices
                     * @return {org.dyn4j.geometry.decompose.DoubleEdgeList} {@link DoubleEdgeList}
                     * @since 3.1.9
                     */
                    createTriangulation(...points) {
                        if (points == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.decompose.nullArray"));
                        const size = points.length;
                        if (size < 4)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.decompose.invalidSize"));
                        const winding = org.dyn4j.geometry.Geometry.getWinding$org_dyn4j_geometry_Vector2_A.apply(null, points);
                        if (winding < 0.0) {
                            org.dyn4j.geometry.Geometry.reverseWinding$org_dyn4j_geometry_Vector2_A.apply(null, points);
                        }
                        const dcel = new org.dyn4j.geometry.decompose.DoubleEdgeList(points);
                        let root = null;
                        let curr = null;
                        let prev = null;
                        for (let i = 0; i < size; i++) {
                            {
                                const p = points[i];
                                curr = new org.dyn4j.geometry.decompose.EarClippingVertex(p);
                                const p0 = points[i === 0 ? size - 1 : i - 1];
                                const p1 = points[i + 1 === size ? 0 : i + 1];
                                const v1 = p.to$org_dyn4j_geometry_Vector2(p0);
                                const v2 = p.to$org_dyn4j_geometry_Vector2(p1);
                                if (v2.isZero()) {
                                    throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.decompose.coincident"));
                                }
                                if (v1.cross$org_dyn4j_geometry_Vector2(v2) >= 0.0) {
                                    curr.reflex = true;
                                }
                                else {
                                    curr.reflex = false;
                                }
                                curr.prev = prev;
                                if (prev != null) {
                                    prev.next = curr;
                                }
                                curr.index = i;
                                prev = curr;
                                if (root == null) {
                                    root = curr;
                                }
                            }
                            ;
                        }
                        root.prev = prev;
                        prev.next = root;
                        let node = root;
                        for (let i = 0; i < size; i++) {
                            {
                                node.ear = this.isEar(node, size);
                                node = node.next;
                            }
                            ;
                        }
                        node = root;
                        let n = size;
                        for (; n > 3;) {
                            {
                                if (node.ear) {
                                    dcel.addHalfEdges$int$int(node.next.index, node.prev.index);
                                    const pNode = node.prev;
                                    const nNode = node.next;
                                    pNode.next = node.next;
                                    nNode.prev = node.prev;
                                    if (pNode.reflex) {
                                        pNode.reflex = this.isReflex(pNode);
                                    }
                                    if (nNode.reflex) {
                                        nNode.reflex = this.isReflex(nNode);
                                    }
                                    if (!pNode.reflex) {
                                        pNode.ear = this.isEar(pNode, n);
                                    }
                                    if (!nNode.reflex) {
                                        nNode.ear = this.isEar(nNode, n);
                                    }
                                    n--;
                                }
                                node = node.next;
                            }
                            ;
                        }
                        return dcel;
                    }
                    /**
                     * Returns true if the given vertex is a reflex vertex.
                     * <p>
                     * A reflex vertex is a vertex who's adjacent vertices create an
                     * an angle greater than 180 degrees (or the cross product is
                     * positive) for CCW vertex winding.
                     * @param {org.dyn4j.geometry.decompose.EarClippingVertex} vertex the vertex to test
                     * @return {boolean} boolean true if the given vertex is considered a reflex vertex
                     */
                    isReflex(vertex) {
                        const p = vertex.point;
                        const p0 = vertex.prev.point;
                        const p1 = vertex.next.point;
                        const v1 = p.to$org_dyn4j_geometry_Vector2(p0);
                        const v2 = p.to$org_dyn4j_geometry_Vector2(p1);
                        if (v1.cross$org_dyn4j_geometry_Vector2(v2) < 0.0) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    /**
                     * Returns true if the given vertex is considered an ear vertex.
                     * <p>
                     * A vertex is an ear vertex if the triangle created by the adjacent vertices
                     * of the given vertex does not contain any other vertices within it.
                     * <p>
                     * A reflex vertex cannot be an ear.
                     * @param {org.dyn4j.geometry.decompose.EarClippingVertex} vertex the vertex to test for ear-ness
                     * @param {number} n the number of vertices
                     * @return {boolean} boolean true if the given vertex is considered an ear vertex
                     */
                    isEar(vertex, n) {
                        if (vertex.reflex)
                            return false;
                        let ear = true;
                        const a = vertex.point;
                        const b = vertex.next.point;
                        const c = vertex.prev.point;
                        let tNode = vertex.next.next;
                        for (let j = 0; j < n - 3; j++) {
                            {
                                if (tNode.reflex) {
                                    if (this.contains(a, b, c, tNode.point)) {
                                        ear = false;
                                        break;
                                    }
                                }
                                tNode = tNode.next;
                            }
                            ;
                        }
                        return ear;
                    }
                    /**
                     * Returns true if the given point, p, is contained in the triangle created
                     * by a, b, and c.
                     * @param {org.dyn4j.geometry.Vector2} a the first point of the triangle
                     * @param {org.dyn4j.geometry.Vector2} b the second point of the triangle
                     * @param {org.dyn4j.geometry.Vector2} c the third point of the triangle
                     * @param {org.dyn4j.geometry.Vector2} p the point to test for containment
                     * @return {boolean} boolean true if the given point is contained in the given triangle
                     */
                    contains(a, b, c, p) {
                        const ab = a.to$org_dyn4j_geometry_Vector2(b);
                        const ac = a.to$org_dyn4j_geometry_Vector2(c);
                        const pa = a.to$org_dyn4j_geometry_Vector2(p);
                        const dot00 = ac.dot$org_dyn4j_geometry_Vector2(ac);
                        const dot01 = ac.dot$org_dyn4j_geometry_Vector2(ab);
                        const dot02 = ac.dot$org_dyn4j_geometry_Vector2(pa);
                        const dot11 = ab.dot$org_dyn4j_geometry_Vector2(ab);
                        const dot12 = ab.dot$org_dyn4j_geometry_Vector2(pa);
                        const denominator = dot00 * dot11 - dot01 * dot01;
                        const u = (dot11 * dot02 - dot01 * dot12) / denominator;
                        const v = (dot00 * dot12 - dot01 * dot02) / denominator;
                        return u > 0 && v > 0 && (u + v <= 1 + EarClipping.CONTAINS_EPSILON_$LI$());
                    }
                }
                decompose.EarClipping = EarClipping;
                EarClipping["__class"] = "org.dyn4j.geometry.decompose.EarClipping";
                EarClipping["__interfaces"] = ["org.dyn4j.geometry.decompose.Triangulator", "org.dyn4j.geometry.decompose.Decomposer"];
            })(decompose = geometry.decompose || (geometry.decompose = {}));
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * {@link Epa}, or Expanding Polytope Algorithm, is used to find the
                 * penetration depth and vector given the final simplex of {@link Gjk}.
                 * <p>
                 * {@link Epa} expands the given simplex in the direction of the origin until it cannot
                 * be expanded any further.  {@link Gjk} guarantees that the simplex points are on the
                 * edge of the Minkowski sum which creates a convex polytope from which to start the
                 * {@link Epa} algorithm.
                 * <p>
                 * Expansion is achieved by breaking edges of the simplex.  Find the edge on the simplex
                 * closest to the origin, then use that edge's normal to find another support point (using
                 * the same support method that {@link Gjk} uses).  Add the new support point to
                 * the simplex between the points that made the closest edge.  Repeat this process until
                 * the polytope cannot be expanded further.
                 * <p>
                 * This implementation has three termination cases:
                 * <ul>
                 * <li>If the new support point is not past the edge along the edge normal given some epsilon.</li>
                 * <li>If the distance between the last support point and the new support point is below a given epsilon.</li>
                 * <li>Maximum iteration count.</li>
                 * </ul>
                 * Once {@link Epa} terminates, the penetration vector is the current closest edge normal
                 * and the penetration depth is the distance from the origin to the edge along the normal.
                 * <p>
                 * {@link Epa} will terminate in a finite number of iterations if the two shapes are {@link Polygon}s.
                 * If either shape has curved surfaces the algorithm requires an expected accuracy epsilon: {@link #distanceEpsilon}.
                 * In the case that the {@link #distanceEpsilon} is too small, the {@link #maxIterations} will prevent the
                 * algorithm from running forever.
                 * @author William Bittle
                 * @version 3.2.0
                 * @since 1.0.0
                 * @see Gjk
                 * @see <a href="http://www.dyn4j.org/2010/05/epa-expanding-polytope-algorithm/" target="_blank">EPA (Expanding Polytope Algorithm)</a>
                 * @class
                 */
                class Epa {
                    constructor() {
                        this.maxIterations = Epa.DEFAULT_MAX_ITERATIONS;
                        this.distanceEpsilon = Epa.DEFAULT_DISTANCE_EPSILON_$LI$();
                    }
                    static DEFAULT_DISTANCE_EPSILON_$LI$() { if (Epa.DEFAULT_DISTANCE_EPSILON == null) {
                        Epa.DEFAULT_DISTANCE_EPSILON = Math.sqrt(org.dyn4j.Epsilon.E_$LI$());
                    } return Epa.DEFAULT_DISTANCE_EPSILON; }
                    getPenetration(simplex, minkowskiSum, penetration) {
                        const smplx = new org.dyn4j.collision.narrowphase.ExpandingSimplex(simplex);
                        let edge = null;
                        let point = null;
                        for (let i = 0; i < this.maxIterations; i++) {
                            {
                                edge = smplx.getClosestEdge();
                                point = minkowskiSum.getSupportPoint(edge.normal);
                                const projection = point.dot$org_dyn4j_geometry_Vector2(edge.normal);
                                if ((projection - edge.distance) < this.distanceEpsilon) {
                                    penetration.normal = edge.normal;
                                    penetration.depth = projection;
                                    return;
                                }
                                smplx.expand(point);
                            }
                            ;
                        }
                        penetration.normal = edge.normal;
                        penetration.depth = point.dot$org_dyn4j_geometry_Vector2(edge.normal);
                    }
                    /**
                     * Returns the maximum number of iterations the algorithm will perform before exiting.
                     * @return {number} int
                     * @see #setMaxIterations(int)
                     */
                    getMaxIterations() {
                        return this.maxIterations;
                    }
                    /**
                     * Sets the maximum number of iterations the algorithm will perform before exiting.
                     * @param {number} maxIterations the maximum number of iterations in the range [5, &infin;]
                     * @throws IllegalArgumentException if maxIterations is less than 5
                     */
                    setMaxIterations(maxIterations) {
                        if (maxIterations < 5)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.narrowphase.epa.invalidMaximumIterations"));
                        this.maxIterations = maxIterations;
                    }
                    /**
                     * Returns the distance epsilon.
                     * @return {number} double
                     * @see #setDistanceEpsilon(double)
                     */
                    getDistanceEpsilon() {
                        return this.distanceEpsilon;
                    }
                    /**
                     * The minimum distance between two iterations of the algorithm.
                     * <p>
                     * The distance epsilon is used to determine when the algorithm is close enough to the
                     * edge of the minkowski sum to conclude that it can no longer expand.  This is primarily
                     * used when one of the {@link Convex} {@link Shape}s in question has a curved shape.
                     * @param {number} distanceEpsilon the distance epsilon in the range (0, &infin;]
                     * @throws IllegalArgumentException if distanceEpsilon is less than or equal to zero
                     */
                    setDistanceEpsilon(distanceEpsilon) {
                        if (distanceEpsilon <= 0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.narrowphase.epa.invalidDistanceEpsilon"));
                        this.distanceEpsilon = distanceEpsilon;
                    }
                }
                /**
                 * The default {@link Epa} maximum iterations
                 */
                Epa.DEFAULT_MAX_ITERATIONS = 100;
                narrowphase.Epa = Epa;
                Epa["__class"] = "org.dyn4j.collision.narrowphase.Epa";
                Epa["__interfaces"] = ["org.dyn4j.collision.narrowphase.MinkowskiPenetrationSolver"];
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var continuous;
            (function (continuous) {
                /**
                 * Optional constructor.
                 * @param {*} distanceDetector the distance detector
                 * @throws NullPointerException if distanceDetector is null
                 * @class
                 * @author William Bittle
                 */
                class ConservativeAdvancement {
                    constructor(distanceDetector) {
                        if (((distanceDetector != null && (distanceDetector.constructor != null && distanceDetector.constructor["__interfaces"] != null && distanceDetector.constructor["__interfaces"].indexOf("org.dyn4j.collision.narrowphase.DistanceDetector") >= 0)) || distanceDetector === null)) {
                            let __args = arguments;
                            this.distanceDetector = new org.dyn4j.collision.narrowphase.Gjk();
                            this.distanceEpsilon = ConservativeAdvancement.DEFAULT_DISTANCE_EPSILON_$LI$();
                            this.maxIterations = ConservativeAdvancement.DEFAULT_MAX_ITERATIONS;
                            if (distanceDetector == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("collision.continuous.conservativeAdvancement.nullDistanceDetector"));
                            this.distanceDetector = distanceDetector;
                        }
                        else if (distanceDetector === undefined) {
                            let __args = arguments;
                            this.distanceDetector = new org.dyn4j.collision.narrowphase.Gjk();
                            this.distanceEpsilon = ConservativeAdvancement.DEFAULT_DISTANCE_EPSILON_$LI$();
                            this.maxIterations = ConservativeAdvancement.DEFAULT_MAX_ITERATIONS;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static DEFAULT_DISTANCE_EPSILON_$LI$() { if (ConservativeAdvancement.DEFAULT_DISTANCE_EPSILON == null) {
                        ConservativeAdvancement.DEFAULT_DISTANCE_EPSILON = /* cbrt */ Math.pow(org.dyn4j.Epsilon.E_$LI$(), 1 / 3);
                    } return ConservativeAdvancement.DEFAULT_DISTANCE_EPSILON; }
                    getTimeOfImpact$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_collision_continuous_TimeOfImpact(convex1, transform1, dp1, da1, convex2, transform2, dp2, da2, toi) {
                        return this.getTimeOfImpact$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_collision_continuous_TimeOfImpact(convex1, transform1, dp1, da1, convex2, transform2, dp2, da2, 0.0, 1.0, toi);
                    }
                    getTimeOfImpact$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_collision_continuous_TimeOfImpact(convex1, transform1, dp1, da1, convex2, transform2, dp2, da2, t1, t2, toi) {
                        let iterations = 0;
                        const lerpTx1 = new org.dyn4j.geometry.Transform();
                        const lerpTx2 = new org.dyn4j.geometry.Transform();
                        const separation = new org.dyn4j.collision.narrowphase.Separation();
                        let separated = this.distanceDetector.distance(convex1, transform1, convex2, transform2, separation);
                        if (!separated) {
                            return false;
                        }
                        let d = separation.getDistance();
                        if (d < this.distanceEpsilon) {
                            toi.time = 0.0;
                            toi.separation = separation;
                            return true;
                        }
                        let n = separation.getNormal();
                        const rmax1 = convex1['getRadius$']();
                        const rmax2 = convex2['getRadius$']();
                        const rv = dp1.difference$org_dyn4j_geometry_Vector2(dp2);
                        const rvl = rv.getMagnitude();
                        const amax = rmax1 * Math.abs(da1) + rmax2 * Math.abs(da2);
                        if (rvl + amax === 0.0) {
                            return false;
                        }
                        let l = t1;
                        let l0 = l;
                        while ((d > this.distanceEpsilon && iterations < this.maxIterations)) {
                            {
                                const rvDotN = rv.dot$org_dyn4j_geometry_Vector2(n);
                                const drel = rvDotN + amax;
                                if (drel <= org.dyn4j.Epsilon.E_$LI$()) {
                                    return false;
                                }
                                else {
                                    const dt = d / drel;
                                    l += dt;
                                    if (l < t1) {
                                        return false;
                                    }
                                    if (l > t2) {
                                        return false;
                                    }
                                    if (l <= l0) {
                                        break;
                                    }
                                    l0 = l;
                                }
                                iterations++;
                                transform1.lerp$org_dyn4j_geometry_Vector2$double$double$org_dyn4j_geometry_Transform(dp1, da1, l, lerpTx1);
                                transform2.lerp$org_dyn4j_geometry_Vector2$double$double$org_dyn4j_geometry_Transform(dp2, da2, l, lerpTx2);
                                separated = this.distanceDetector.distance(convex1, lerpTx1, convex2, lerpTx2, separation);
                                d = separation.getDistance();
                                if (!separated) {
                                    l -= 0.5 * this.distanceEpsilon / drel;
                                    transform1.lerp$org_dyn4j_geometry_Vector2$double$double$org_dyn4j_geometry_Transform(dp1, da1, l, lerpTx1);
                                    transform2.lerp$org_dyn4j_geometry_Vector2$double$double$org_dyn4j_geometry_Transform(dp2, da2, l, lerpTx2);
                                    this.distanceDetector.distance(convex1, lerpTx1, convex2, lerpTx2, separation);
                                    d = separation.getDistance();
                                    break;
                                }
                                n = separation.getNormal();
                                d = separation.getDistance();
                            }
                        }
                        ;
                        toi.time = l;
                        toi.separation = separation;
                        return true;
                    }
                    /**
                     *
                     * @param {*} convex1
                     * @param {org.dyn4j.geometry.Transform} transform1
                     * @param {org.dyn4j.geometry.Vector2} dp1
                     * @param {number} da1
                     * @param {*} convex2
                     * @param {org.dyn4j.geometry.Transform} transform2
                     * @param {org.dyn4j.geometry.Vector2} dp2
                     * @param {number} da2
                     * @param {number} t1
                     * @param {number} t2
                     * @param {org.dyn4j.collision.continuous.TimeOfImpact} toi
                     * @return {boolean}
                     */
                    getTimeOfImpact(convex1, transform1, dp1, da1, convex2, transform2, dp2, da2, t1, t2, toi) {
                        if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((dp1 != null && dp1 instanceof org.dyn4j.geometry.Vector2) || dp1 === null) && ((typeof da1 === 'number') || da1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && ((dp2 != null && dp2 instanceof org.dyn4j.geometry.Vector2) || dp2 === null) && ((typeof da2 === 'number') || da2 === null) && ((typeof t1 === 'number') || t1 === null) && ((typeof t2 === 'number') || t2 === null) && ((toi != null && toi instanceof org.dyn4j.collision.continuous.TimeOfImpact) || toi === null)) {
                            return this.getTimeOfImpact$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_collision_continuous_TimeOfImpact(convex1, transform1, dp1, da1, convex2, transform2, dp2, da2, t1, t2, toi);
                        }
                        else if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((dp1 != null && dp1 instanceof org.dyn4j.geometry.Vector2) || dp1 === null) && ((typeof da1 === 'number') || da1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && ((dp2 != null && dp2 instanceof org.dyn4j.geometry.Vector2) || dp2 === null) && ((typeof da2 === 'number') || da2 === null) && ((t1 != null && t1 instanceof org.dyn4j.collision.continuous.TimeOfImpact) || t1 === null) && t2 === undefined && toi === undefined) {
                            return this.getTimeOfImpact$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_collision_continuous_TimeOfImpact(convex1, transform1, dp1, da1, convex2, transform2, dp2, da2, t1);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Returns the {@link DistanceDetector} that is used.
                     * @return {*} {@link DistanceDetector}
                     */
                    getDistanceDetector() {
                        return this.distanceDetector;
                    }
                    /**
                     * Sets the {@link DistanceDetector} to be used.
                     * @param {*} distanceDetector the distance detector
                     * @throws NullPointerException if distanceDetector is null
                     */
                    setDistanceDetector(distanceDetector) {
                        if (distanceDetector == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("collision.continuous.conservativeAdvancement.nullDistanceDetector"));
                        this.distanceDetector = distanceDetector;
                    }
                    /**
                     * Returns the distance epsilon used to determine when a sufficient solution
                     * has been found.
                     * @return {number} double the distance epsilon
                     */
                    getDistanceEpsilon() {
                        return this.distanceEpsilon;
                    }
                    /**
                     * Sets the distance epsilon used to determine when a sufficient solution
                     * has been found.
                     * @param {number} distanceEpsilon the distance epsilon; must be greater than zero
                     * @throws IllegalArgumentException if distanceEpsilon is less than or equal to zero
                     */
                    setDistanceEpsilon(distanceEpsilon) {
                        if (distanceEpsilon <= 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.continuous.conservativeAdvancement.invalidDistanceEpsilon"));
                        this.distanceEpsilon = distanceEpsilon;
                    }
                    /**
                     * Returns the maximum number of iterations that will be
                     * performed by the root finder.
                     * @return {number} the maximum number of iterations the root finder will perform
                     */
                    getMaxIterations() {
                        return this.maxIterations;
                    }
                    /**
                     * Sets the maximum number of iterations that will be
                     * performed by the root finder.
                     * <p>
                     * Lower values increase performance yet decrease accuracy whereas
                     * higher values decrease performance and increase accuracy.
                     * @param {number} maxIterations the maximum number of iterations in the range [5, &infin;]
                     * @throws IllegalArgumentException if maxIterations is less than 5
                     */
                    setMaxIterations(maxIterations) {
                        if (maxIterations < 5)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.continuous.conservativeAdvancement.invalidMaximumIterations"));
                        this.maxIterations = maxIterations;
                    }
                }
                /**
                 * The default maximum number of iterations
                 */
                ConservativeAdvancement.DEFAULT_MAX_ITERATIONS = 30;
                continuous.ConservativeAdvancement = ConservativeAdvancement;
                ConservativeAdvancement["__class"] = "org.dyn4j.collision.continuous.ConservativeAdvancement";
                ConservativeAdvancement["__interfaces"] = ["org.dyn4j.collision.continuous.TimeOfImpactDetector"];
            })(continuous = collision.continuous || (collision.continuous = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Base implementation of the {@link Shape} interface.
             * @author William Bittle
             * @version 3.4.0
             * @since 1.0.0
             * @class
             */
            class AbstractShape {
                constructor(center, radius) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null) && ((typeof radius === 'number') || radius === null)) {
                        let __args = arguments;
                        if (this.center === undefined) {
                            this.center = null;
                        }
                        if (this.radius === undefined) {
                            this.radius = 0;
                        }
                        if (this.userData === undefined) {
                            this.userData = null;
                        }
                        this.id = new org.dyn4j.RandomUUID();
                        this.center = center;
                        this.radius = radius;
                    }
                    else if (((typeof center === 'number') || center === null) && radius === undefined) {
                        let __args = arguments;
                        let radius = __args[0];
                        {
                            let __args = arguments;
                            let center = new org.dyn4j.geometry.Vector2();
                            if (this.center === undefined) {
                                this.center = null;
                            }
                            if (this.radius === undefined) {
                                this.radius = 0;
                            }
                            if (this.userData === undefined) {
                                this.userData = null;
                            }
                            this.id = new org.dyn4j.RandomUUID();
                            this.center = center;
                            this.radius = radius;
                        }
                        if (this.center === undefined) {
                            this.center = null;
                        }
                        if (this.radius === undefined) {
                            this.radius = 0;
                        }
                        if (this.userData === undefined) {
                            this.userData = null;
                        }
                        this.id = new org.dyn4j.RandomUUID();
                    }
                    else
                        throw new Error('invalid overload');
                }
                static IDENTITY_$LI$() { if (AbstractShape.IDENTITY == null) {
                    AbstractShape.IDENTITY = new org.dyn4j.geometry.Transform();
                } return AbstractShape.IDENTITY; }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Id=").append(this.id).append("|Center=").append(this.center).append("|Radius=").append(this.radius);
                    return sb.toString();
                }
                /**
                 *
                 * @return {org.dyn4j.RandomUUID}
                 */
                getId() {
                    return this.id;
                }
                /**
                 *
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getCenter() {
                    return this.center;
                }
                getRadius$() {
                    return this.radius;
                }
                /**
                 *
                 * @return {*}
                 */
                getUserData() {
                    return this.userData;
                }
                /**
                 *
                 * @param {*} userData
                 */
                setUserData(userData) {
                    this.userData = userData;
                }
                rotate$double(theta) {
                    this.rotate$double$double$double(theta, 0.0, 0.0);
                }
                rotate$org_dyn4j_geometry_Rotation(rotation) {
                    this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, 0.0, 0.0);
                }
                /**
                 *
                 * @param {number} theta
                 */
                rotateAboutCenter(theta) {
                    this.rotate$double$double$double(theta, this.center.x, this.center.y);
                }
                rotate$double$org_dyn4j_geometry_Vector2(theta, point) {
                    this.rotate$double$double$double(theta, point.x, point.y);
                }
                rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, point) {
                    this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, point.x, point.y);
                }
                rotate$double$double$double(theta, x, y) {
                    this.rotate$org_dyn4j_geometry_Rotation$double$double(new org.dyn4j.geometry.Rotation(theta), x, y);
                }
                rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    if (!this.center.equals$double$double(x, y)) {
                        this.center.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    }
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$double$double(x, y) {
                    this.center.add$double$double(x, y);
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$org_dyn4j_geometry_Vector2(vector) {
                    this.translate$double$double(vector.x, vector.y);
                }
                project$org_dyn4j_geometry_Vector2(n) {
                    return this['project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](n, AbstractShape.IDENTITY_$LI$());
                }
                contains$org_dyn4j_geometry_Vector2(point) {
                    return this['contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](point, AbstractShape.IDENTITY_$LI$());
                }
                createAABB$() {
                    return this['createAABB$org_dyn4j_geometry_Transform'](AbstractShape.IDENTITY_$LI$());
                }
            }
            geometry.AbstractShape = AbstractShape;
            AbstractShape["__class"] = "org.dyn4j.geometry.AbstractShape";
            AbstractShape["__interfaces"] = ["org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * <p>
             * Defaults to using {@link #EARTH_GRAVITY}, {@link DynamicAABBTree} broad-phase,
             * {@link Gjk} narrow-phase, and {@link ClippingManifoldSolver}.
             * <p>
             * The initial capacity specifies the estimated number of bodies that the simulation
             * will have at any one time.  This is used to size internal structures to improve
             * performance.  The internal structures can grow past the initial capacity.
             * @param {org.dyn4j.dynamics.Capacity} initialCapacity the initial capacity settings
             * @param {*} bounds the bounds of the {@link World}; can be null
             * @throws NullPointerException if initialCapacity is null
             * @since 3.1.1
             * @class
             * @author William Bittle
             */
            class World {
                constructor(initialCapacity, bounds) {
                    if (((initialCapacity != null && initialCapacity instanceof org.dyn4j.dynamics.Capacity) || initialCapacity === null) && ((bounds != null && (bounds.constructor != null && bounds.constructor["__interfaces"] != null && bounds.constructor["__interfaces"].indexOf("org.dyn4j.collision.Bounds") >= 0)) || bounds === null)) {
                        let __args = arguments;
                        if (this.settings === undefined) {
                            this.settings = null;
                        }
                        if (this.__step === undefined) {
                            this.__step = null;
                        }
                        if (this.gravity === undefined) {
                            this.gravity = null;
                        }
                        if (this.bounds === undefined) {
                            this.bounds = null;
                        }
                        if (this.broadphaseDetector === undefined) {
                            this.broadphaseDetector = null;
                        }
                        if (this.detectBroadphaseFilter === undefined) {
                            this.detectBroadphaseFilter = null;
                        }
                        if (this.narrowphaseDetector === undefined) {
                            this.narrowphaseDetector = null;
                        }
                        if (this.narrowphasePostProcessor === undefined) {
                            this.narrowphasePostProcessor = null;
                        }
                        if (this.manifoldSolver === undefined) {
                            this.manifoldSolver = null;
                        }
                        if (this.timeOfImpactDetector === undefined) {
                            this.timeOfImpactDetector = null;
                        }
                        if (this.raycastDetector === undefined) {
                            this.raycastDetector = null;
                        }
                        if (this.contactManager === undefined) {
                            this.contactManager = null;
                        }
                        if (this.coefficientMixer === undefined) {
                            this.coefficientMixer = null;
                        }
                        if (this.contactConstraintSolver === undefined) {
                            this.contactConstraintSolver = null;
                        }
                        if (this.timeOfImpactSolver === undefined) {
                            this.timeOfImpactSolver = null;
                        }
                        if (this.userData === undefined) {
                            this.userData = null;
                        }
                        if (this.listeners === undefined) {
                            this.listeners = null;
                        }
                        if (this.bodies === undefined) {
                            this.bodies = null;
                        }
                        if (this.joints === undefined) {
                            this.joints = null;
                        }
                        if (this.island === undefined) {
                            this.island = null;
                        }
                        if (this.time === undefined) {
                            this.time = 0;
                        }
                        if (this.updateRequired === undefined) {
                            this.updateRequired = false;
                        }
                        this.id = new org.dyn4j.RandomUUID();
                        if (initialCapacity == null)
                            initialCapacity = org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$();
                        this.settings = new org.dyn4j.dynamics.Settings();
                        this.__step = new org.dyn4j.dynamics.Step(this.settings.getStepFrequency());
                        this.gravity = World.EARTH_GRAVITY_$LI$();
                        this.bounds = bounds;
                        this.broadphaseDetector = (new org.dyn4j.collision.broadphase.DynamicAABBTree(initialCapacity.getBodyCount()));
                        this.detectBroadphaseFilter = new org.dyn4j.dynamics.DetectBroadphaseFilter();
                        this.narrowphaseDetector = new org.dyn4j.collision.narrowphase.Gjk();
                        this.narrowphasePostProcessor = new org.dyn4j.collision.narrowphase.LinkPostProcessor();
                        this.manifoldSolver = new org.dyn4j.collision.manifold.ClippingManifoldSolver();
                        this.timeOfImpactDetector = new org.dyn4j.collision.continuous.ConservativeAdvancement();
                        this.raycastDetector = new org.dyn4j.collision.narrowphase.Gjk();
                        this.coefficientMixer = org.dyn4j.dynamics.CoefficientMixer.DEFAULT_MIXER_$LI$();
                        this.contactManager = new org.dyn4j.dynamics.contact.DefaultContactManager(initialCapacity);
                        this.contactConstraintSolver = new org.dyn4j.dynamics.contact.SequentialImpulses();
                        this.timeOfImpactSolver = new org.dyn4j.dynamics.contact.TimeOfImpactSolver();
                        this.bodies = (new java.util.ArrayList(initialCapacity.getBodyCount()));
                        this.joints = (new java.util.ArrayList(initialCapacity.getJointCount()));
                        this.listeners = (new java.util.ArrayList(initialCapacity.getListenerCount()));
                        this.island = new org.dyn4j.dynamics.Island(initialCapacity);
                        this.time = 0.0;
                        this.updateRequired = true;
                    }
                    else if (((initialCapacity != null && initialCapacity instanceof org.dyn4j.dynamics.Capacity) || initialCapacity === null) && bounds === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let bounds = null;
                            if (this.settings === undefined) {
                                this.settings = null;
                            }
                            if (this.__step === undefined) {
                                this.__step = null;
                            }
                            if (this.gravity === undefined) {
                                this.gravity = null;
                            }
                            if (this.bounds === undefined) {
                                this.bounds = null;
                            }
                            if (this.broadphaseDetector === undefined) {
                                this.broadphaseDetector = null;
                            }
                            if (this.detectBroadphaseFilter === undefined) {
                                this.detectBroadphaseFilter = null;
                            }
                            if (this.narrowphaseDetector === undefined) {
                                this.narrowphaseDetector = null;
                            }
                            if (this.narrowphasePostProcessor === undefined) {
                                this.narrowphasePostProcessor = null;
                            }
                            if (this.manifoldSolver === undefined) {
                                this.manifoldSolver = null;
                            }
                            if (this.timeOfImpactDetector === undefined) {
                                this.timeOfImpactDetector = null;
                            }
                            if (this.raycastDetector === undefined) {
                                this.raycastDetector = null;
                            }
                            if (this.contactManager === undefined) {
                                this.contactManager = null;
                            }
                            if (this.coefficientMixer === undefined) {
                                this.coefficientMixer = null;
                            }
                            if (this.contactConstraintSolver === undefined) {
                                this.contactConstraintSolver = null;
                            }
                            if (this.timeOfImpactSolver === undefined) {
                                this.timeOfImpactSolver = null;
                            }
                            if (this.userData === undefined) {
                                this.userData = null;
                            }
                            if (this.listeners === undefined) {
                                this.listeners = null;
                            }
                            if (this.bodies === undefined) {
                                this.bodies = null;
                            }
                            if (this.joints === undefined) {
                                this.joints = null;
                            }
                            if (this.island === undefined) {
                                this.island = null;
                            }
                            if (this.time === undefined) {
                                this.time = 0;
                            }
                            if (this.updateRequired === undefined) {
                                this.updateRequired = false;
                            }
                            this.id = new org.dyn4j.RandomUUID();
                            if (initialCapacity == null)
                                initialCapacity = org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$();
                            this.settings = new org.dyn4j.dynamics.Settings();
                            this.__step = new org.dyn4j.dynamics.Step(this.settings.getStepFrequency());
                            this.gravity = World.EARTH_GRAVITY_$LI$();
                            this.bounds = bounds;
                            this.broadphaseDetector = (new org.dyn4j.collision.broadphase.DynamicAABBTree(initialCapacity.getBodyCount()));
                            this.detectBroadphaseFilter = new org.dyn4j.dynamics.DetectBroadphaseFilter();
                            this.narrowphaseDetector = new org.dyn4j.collision.narrowphase.Gjk();
                            this.narrowphasePostProcessor = new org.dyn4j.collision.narrowphase.LinkPostProcessor();
                            this.manifoldSolver = new org.dyn4j.collision.manifold.ClippingManifoldSolver();
                            this.timeOfImpactDetector = new org.dyn4j.collision.continuous.ConservativeAdvancement();
                            this.raycastDetector = new org.dyn4j.collision.narrowphase.Gjk();
                            this.coefficientMixer = org.dyn4j.dynamics.CoefficientMixer.DEFAULT_MIXER_$LI$();
                            this.contactManager = new org.dyn4j.dynamics.contact.DefaultContactManager(initialCapacity);
                            this.contactConstraintSolver = new org.dyn4j.dynamics.contact.SequentialImpulses();
                            this.timeOfImpactSolver = new org.dyn4j.dynamics.contact.TimeOfImpactSolver();
                            this.bodies = (new java.util.ArrayList(initialCapacity.getBodyCount()));
                            this.joints = (new java.util.ArrayList(initialCapacity.getJointCount()));
                            this.listeners = (new java.util.ArrayList(initialCapacity.getListenerCount()));
                            this.island = new org.dyn4j.dynamics.Island(initialCapacity);
                            this.time = 0.0;
                            this.updateRequired = true;
                        }
                        if (this.settings === undefined) {
                            this.settings = null;
                        }
                        if (this.__step === undefined) {
                            this.__step = null;
                        }
                        if (this.gravity === undefined) {
                            this.gravity = null;
                        }
                        if (this.bounds === undefined) {
                            this.bounds = null;
                        }
                        if (this.broadphaseDetector === undefined) {
                            this.broadphaseDetector = null;
                        }
                        if (this.detectBroadphaseFilter === undefined) {
                            this.detectBroadphaseFilter = null;
                        }
                        if (this.narrowphaseDetector === undefined) {
                            this.narrowphaseDetector = null;
                        }
                        if (this.narrowphasePostProcessor === undefined) {
                            this.narrowphasePostProcessor = null;
                        }
                        if (this.manifoldSolver === undefined) {
                            this.manifoldSolver = null;
                        }
                        if (this.timeOfImpactDetector === undefined) {
                            this.timeOfImpactDetector = null;
                        }
                        if (this.raycastDetector === undefined) {
                            this.raycastDetector = null;
                        }
                        if (this.contactManager === undefined) {
                            this.contactManager = null;
                        }
                        if (this.coefficientMixer === undefined) {
                            this.coefficientMixer = null;
                        }
                        if (this.contactConstraintSolver === undefined) {
                            this.contactConstraintSolver = null;
                        }
                        if (this.timeOfImpactSolver === undefined) {
                            this.timeOfImpactSolver = null;
                        }
                        if (this.userData === undefined) {
                            this.userData = null;
                        }
                        if (this.listeners === undefined) {
                            this.listeners = null;
                        }
                        if (this.bodies === undefined) {
                            this.bodies = null;
                        }
                        if (this.joints === undefined) {
                            this.joints = null;
                        }
                        if (this.island === undefined) {
                            this.island = null;
                        }
                        if (this.time === undefined) {
                            this.time = 0;
                        }
                        if (this.updateRequired === undefined) {
                            this.updateRequired = false;
                        }
                        this.id = new org.dyn4j.RandomUUID();
                    }
                    else if (((initialCapacity != null && (initialCapacity.constructor != null && initialCapacity.constructor["__interfaces"] != null && initialCapacity.constructor["__interfaces"].indexOf("org.dyn4j.collision.Bounds") >= 0)) || initialCapacity === null) && bounds === undefined) {
                        let __args = arguments;
                        let bounds = __args[0];
                        {
                            let __args = arguments;
                            let initialCapacity = org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$();
                            if (this.settings === undefined) {
                                this.settings = null;
                            }
                            if (this.__step === undefined) {
                                this.__step = null;
                            }
                            if (this.gravity === undefined) {
                                this.gravity = null;
                            }
                            if (this.bounds === undefined) {
                                this.bounds = null;
                            }
                            if (this.broadphaseDetector === undefined) {
                                this.broadphaseDetector = null;
                            }
                            if (this.detectBroadphaseFilter === undefined) {
                                this.detectBroadphaseFilter = null;
                            }
                            if (this.narrowphaseDetector === undefined) {
                                this.narrowphaseDetector = null;
                            }
                            if (this.narrowphasePostProcessor === undefined) {
                                this.narrowphasePostProcessor = null;
                            }
                            if (this.manifoldSolver === undefined) {
                                this.manifoldSolver = null;
                            }
                            if (this.timeOfImpactDetector === undefined) {
                                this.timeOfImpactDetector = null;
                            }
                            if (this.raycastDetector === undefined) {
                                this.raycastDetector = null;
                            }
                            if (this.contactManager === undefined) {
                                this.contactManager = null;
                            }
                            if (this.coefficientMixer === undefined) {
                                this.coefficientMixer = null;
                            }
                            if (this.contactConstraintSolver === undefined) {
                                this.contactConstraintSolver = null;
                            }
                            if (this.timeOfImpactSolver === undefined) {
                                this.timeOfImpactSolver = null;
                            }
                            if (this.userData === undefined) {
                                this.userData = null;
                            }
                            if (this.listeners === undefined) {
                                this.listeners = null;
                            }
                            if (this.bodies === undefined) {
                                this.bodies = null;
                            }
                            if (this.joints === undefined) {
                                this.joints = null;
                            }
                            if (this.island === undefined) {
                                this.island = null;
                            }
                            if (this.time === undefined) {
                                this.time = 0;
                            }
                            if (this.updateRequired === undefined) {
                                this.updateRequired = false;
                            }
                            this.id = new org.dyn4j.RandomUUID();
                            if (initialCapacity == null)
                                initialCapacity = org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$();
                            this.settings = new org.dyn4j.dynamics.Settings();
                            this.__step = new org.dyn4j.dynamics.Step(this.settings.getStepFrequency());
                            this.gravity = World.EARTH_GRAVITY_$LI$();
                            this.bounds = bounds;
                            this.broadphaseDetector = (new org.dyn4j.collision.broadphase.DynamicAABBTree(initialCapacity.getBodyCount()));
                            this.detectBroadphaseFilter = new org.dyn4j.dynamics.DetectBroadphaseFilter();
                            this.narrowphaseDetector = new org.dyn4j.collision.narrowphase.Gjk();
                            this.narrowphasePostProcessor = new org.dyn4j.collision.narrowphase.LinkPostProcessor();
                            this.manifoldSolver = new org.dyn4j.collision.manifold.ClippingManifoldSolver();
                            this.timeOfImpactDetector = new org.dyn4j.collision.continuous.ConservativeAdvancement();
                            this.raycastDetector = new org.dyn4j.collision.narrowphase.Gjk();
                            this.coefficientMixer = org.dyn4j.dynamics.CoefficientMixer.DEFAULT_MIXER_$LI$();
                            this.contactManager = new org.dyn4j.dynamics.contact.DefaultContactManager(initialCapacity);
                            this.contactConstraintSolver = new org.dyn4j.dynamics.contact.SequentialImpulses();
                            this.timeOfImpactSolver = new org.dyn4j.dynamics.contact.TimeOfImpactSolver();
                            this.bodies = (new java.util.ArrayList(initialCapacity.getBodyCount()));
                            this.joints = (new java.util.ArrayList(initialCapacity.getJointCount()));
                            this.listeners = (new java.util.ArrayList(initialCapacity.getListenerCount()));
                            this.island = new org.dyn4j.dynamics.Island(initialCapacity);
                            this.time = 0.0;
                            this.updateRequired = true;
                        }
                        if (this.settings === undefined) {
                            this.settings = null;
                        }
                        if (this.__step === undefined) {
                            this.__step = null;
                        }
                        if (this.gravity === undefined) {
                            this.gravity = null;
                        }
                        if (this.bounds === undefined) {
                            this.bounds = null;
                        }
                        if (this.broadphaseDetector === undefined) {
                            this.broadphaseDetector = null;
                        }
                        if (this.detectBroadphaseFilter === undefined) {
                            this.detectBroadphaseFilter = null;
                        }
                        if (this.narrowphaseDetector === undefined) {
                            this.narrowphaseDetector = null;
                        }
                        if (this.narrowphasePostProcessor === undefined) {
                            this.narrowphasePostProcessor = null;
                        }
                        if (this.manifoldSolver === undefined) {
                            this.manifoldSolver = null;
                        }
                        if (this.timeOfImpactDetector === undefined) {
                            this.timeOfImpactDetector = null;
                        }
                        if (this.raycastDetector === undefined) {
                            this.raycastDetector = null;
                        }
                        if (this.contactManager === undefined) {
                            this.contactManager = null;
                        }
                        if (this.coefficientMixer === undefined) {
                            this.coefficientMixer = null;
                        }
                        if (this.contactConstraintSolver === undefined) {
                            this.contactConstraintSolver = null;
                        }
                        if (this.timeOfImpactSolver === undefined) {
                            this.timeOfImpactSolver = null;
                        }
                        if (this.userData === undefined) {
                            this.userData = null;
                        }
                        if (this.listeners === undefined) {
                            this.listeners = null;
                        }
                        if (this.bodies === undefined) {
                            this.bodies = null;
                        }
                        if (this.joints === undefined) {
                            this.joints = null;
                        }
                        if (this.island === undefined) {
                            this.island = null;
                        }
                        if (this.time === undefined) {
                            this.time = 0;
                        }
                        if (this.updateRequired === undefined) {
                            this.updateRequired = false;
                        }
                        this.id = new org.dyn4j.RandomUUID();
                    }
                    else if (initialCapacity === undefined && bounds === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let initialCapacity = org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$();
                            let bounds = null;
                            if (this.settings === undefined) {
                                this.settings = null;
                            }
                            if (this.__step === undefined) {
                                this.__step = null;
                            }
                            if (this.gravity === undefined) {
                                this.gravity = null;
                            }
                            if (this.bounds === undefined) {
                                this.bounds = null;
                            }
                            if (this.broadphaseDetector === undefined) {
                                this.broadphaseDetector = null;
                            }
                            if (this.detectBroadphaseFilter === undefined) {
                                this.detectBroadphaseFilter = null;
                            }
                            if (this.narrowphaseDetector === undefined) {
                                this.narrowphaseDetector = null;
                            }
                            if (this.narrowphasePostProcessor === undefined) {
                                this.narrowphasePostProcessor = null;
                            }
                            if (this.manifoldSolver === undefined) {
                                this.manifoldSolver = null;
                            }
                            if (this.timeOfImpactDetector === undefined) {
                                this.timeOfImpactDetector = null;
                            }
                            if (this.raycastDetector === undefined) {
                                this.raycastDetector = null;
                            }
                            if (this.contactManager === undefined) {
                                this.contactManager = null;
                            }
                            if (this.coefficientMixer === undefined) {
                                this.coefficientMixer = null;
                            }
                            if (this.contactConstraintSolver === undefined) {
                                this.contactConstraintSolver = null;
                            }
                            if (this.timeOfImpactSolver === undefined) {
                                this.timeOfImpactSolver = null;
                            }
                            if (this.userData === undefined) {
                                this.userData = null;
                            }
                            if (this.listeners === undefined) {
                                this.listeners = null;
                            }
                            if (this.bodies === undefined) {
                                this.bodies = null;
                            }
                            if (this.joints === undefined) {
                                this.joints = null;
                            }
                            if (this.island === undefined) {
                                this.island = null;
                            }
                            if (this.time === undefined) {
                                this.time = 0;
                            }
                            if (this.updateRequired === undefined) {
                                this.updateRequired = false;
                            }
                            this.id = new org.dyn4j.RandomUUID();
                            if (initialCapacity == null)
                                initialCapacity = org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$();
                            this.settings = new org.dyn4j.dynamics.Settings();
                            this.__step = new org.dyn4j.dynamics.Step(this.settings.getStepFrequency());
                            this.gravity = World.EARTH_GRAVITY_$LI$();
                            this.bounds = bounds;
                            this.broadphaseDetector = (new org.dyn4j.collision.broadphase.DynamicAABBTree(initialCapacity.getBodyCount()));
                            this.detectBroadphaseFilter = new org.dyn4j.dynamics.DetectBroadphaseFilter();
                            this.narrowphaseDetector = new org.dyn4j.collision.narrowphase.Gjk();
                            this.narrowphasePostProcessor = new org.dyn4j.collision.narrowphase.LinkPostProcessor();
                            this.manifoldSolver = new org.dyn4j.collision.manifold.ClippingManifoldSolver();
                            this.timeOfImpactDetector = new org.dyn4j.collision.continuous.ConservativeAdvancement();
                            this.raycastDetector = new org.dyn4j.collision.narrowphase.Gjk();
                            this.coefficientMixer = org.dyn4j.dynamics.CoefficientMixer.DEFAULT_MIXER_$LI$();
                            this.contactManager = new org.dyn4j.dynamics.contact.DefaultContactManager(initialCapacity);
                            this.contactConstraintSolver = new org.dyn4j.dynamics.contact.SequentialImpulses();
                            this.timeOfImpactSolver = new org.dyn4j.dynamics.contact.TimeOfImpactSolver();
                            this.bodies = (new java.util.ArrayList(initialCapacity.getBodyCount()));
                            this.joints = (new java.util.ArrayList(initialCapacity.getJointCount()));
                            this.listeners = (new java.util.ArrayList(initialCapacity.getListenerCount()));
                            this.island = new org.dyn4j.dynamics.Island(initialCapacity);
                            this.time = 0.0;
                            this.updateRequired = true;
                        }
                        if (this.settings === undefined) {
                            this.settings = null;
                        }
                        if (this.__step === undefined) {
                            this.__step = null;
                        }
                        if (this.gravity === undefined) {
                            this.gravity = null;
                        }
                        if (this.bounds === undefined) {
                            this.bounds = null;
                        }
                        if (this.broadphaseDetector === undefined) {
                            this.broadphaseDetector = null;
                        }
                        if (this.detectBroadphaseFilter === undefined) {
                            this.detectBroadphaseFilter = null;
                        }
                        if (this.narrowphaseDetector === undefined) {
                            this.narrowphaseDetector = null;
                        }
                        if (this.narrowphasePostProcessor === undefined) {
                            this.narrowphasePostProcessor = null;
                        }
                        if (this.manifoldSolver === undefined) {
                            this.manifoldSolver = null;
                        }
                        if (this.timeOfImpactDetector === undefined) {
                            this.timeOfImpactDetector = null;
                        }
                        if (this.raycastDetector === undefined) {
                            this.raycastDetector = null;
                        }
                        if (this.contactManager === undefined) {
                            this.contactManager = null;
                        }
                        if (this.coefficientMixer === undefined) {
                            this.coefficientMixer = null;
                        }
                        if (this.contactConstraintSolver === undefined) {
                            this.contactConstraintSolver = null;
                        }
                        if (this.timeOfImpactSolver === undefined) {
                            this.timeOfImpactSolver = null;
                        }
                        if (this.userData === undefined) {
                            this.userData = null;
                        }
                        if (this.listeners === undefined) {
                            this.listeners = null;
                        }
                        if (this.bodies === undefined) {
                            this.bodies = null;
                        }
                        if (this.joints === undefined) {
                            this.joints = null;
                        }
                        if (this.island === undefined) {
                            this.island = null;
                        }
                        if (this.time === undefined) {
                            this.time = 0;
                        }
                        if (this.updateRequired === undefined) {
                            this.updateRequired = false;
                        }
                        this.id = new org.dyn4j.RandomUUID();
                    }
                    else
                        throw new Error('invalid overload');
                }
                static IDENTITY_$LI$() { if (World.IDENTITY == null) {
                    World.IDENTITY = new org.dyn4j.geometry.Transform();
                } return World.IDENTITY; }
                static EARTH_GRAVITY_$LI$() { if (World.EARTH_GRAVITY == null) {
                    World.EARTH_GRAVITY = new org.dyn4j.geometry.Vector2(0.0, -9.8);
                } return World.EARTH_GRAVITY; }
                static ZERO_GRAVITY_$LI$() { if (World.ZERO_GRAVITY == null) {
                    World.ZERO_GRAVITY = new org.dyn4j.geometry.Vector2(0.0, 0.0);
                } return World.ZERO_GRAVITY; }
                update$double(elapsedTime) {
                    return this.update$double$double$int(elapsedTime, -1.0, 1);
                }
                update$double$int(elapsedTime, maximumSteps) {
                    return this.update$double$double$int(elapsedTime, -1.0, maximumSteps);
                }
                update$double$double(elapsedTime, stepElapsedTime) {
                    return this.update$double$double$int(elapsedTime, stepElapsedTime, 1);
                }
                update$double$double$int(elapsedTime, stepElapsedTime, maximumSteps) {
                    if (elapsedTime < 0.0)
                        elapsedTime = 0.0;
                    this.time += elapsedTime;
                    const invhz = this.settings.getStepFrequency();
                    let steps = 0;
                    while ((this.time >= invhz && steps < maximumSteps)) {
                        {
                            this.__step.update(stepElapsedTime <= 0 ? invhz : stepElapsedTime);
                            this.time = this.time - invhz;
                            this.step$();
                            steps++;
                        }
                    }
                    ;
                    return steps > 0;
                }
                /**
                 * Updates the {@link World}.
                 * <p>
                 * This method will only update the world given the step frequency contained
                 * in the {@link Settings} object.  You can use the {@link StepListener} interface
                 * to listen for when a step is actually performed.
                 * <p>
                 * Unlike the {@link #update(double)} method, this method will perform more than one
                 * step based on the given elapsed time.  For example, if the given elapsed time + the
                 * remaining time from the last call of this method is 2 * step frequency, then 2 steps
                 * will be performed.  Use the maximumSteps parameter to put an upper bound on the
                 * number of steps performed.
                 * <p>
                 * The stepElapsedTime parameter provides a way for the {@link World} to continue to
                 * update at the frequency defined in the {@link Settings} object, but advance the
                 * simulation by the given time.
                 * <p>
                 * Alternatively you can call the {@link #updatev(double)} method to use a variable
                 * time step.
                 * @see #update(double)
                 * @see #updatev(double)
                 * @see #getAccumulatedTime()
                 * @param {number} elapsedTime the elapsed time in seconds
                 * @param {number} stepElapsedTime the time, in seconds, that the simulation should be advanced for each step; if less than or equal to zero {@link Settings#getStepFrequency()} will be used
                 * @param {number} maximumSteps the maximum number of steps to perform
                 * @return {boolean} boolean true if the {@link World} performed at least one simulation step
                 * @since 3.2.4
                 */
                update(elapsedTime, stepElapsedTime, maximumSteps) {
                    if (((typeof elapsedTime === 'number') || elapsedTime === null) && ((typeof stepElapsedTime === 'number') || stepElapsedTime === null) && ((typeof maximumSteps === 'number') || maximumSteps === null)) {
                        return this.update$double$double$int(elapsedTime, stepElapsedTime, maximumSteps);
                    }
                    else if (((typeof elapsedTime === 'number') || elapsedTime === null) && ((typeof stepElapsedTime === 'number') || stepElapsedTime === null) && maximumSteps === undefined) {
                        return this.update$double$int(elapsedTime, stepElapsedTime);
                    }
                    else if (((typeof elapsedTime === 'number') || elapsedTime === null) && ((typeof stepElapsedTime === 'number') || stepElapsedTime === null) && maximumSteps === undefined) {
                        return this.update$double$double(elapsedTime, stepElapsedTime);
                    }
                    else if (((typeof elapsedTime === 'number') || elapsedTime === null) && stepElapsedTime === undefined && maximumSteps === undefined) {
                        return this.update$double(elapsedTime);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Updates the {@link World}.
                 * <p>
                 * This method will update the world on every call.  Unlike the {@link #update(double)}
                 * method, this method uses the given elapsed time and does not attempt to update the world
                 * on a set interval.
                 * <p>
                 * This method immediately returns if the given elapsedTime is less than or equal to
                 * zero.
                 * @see #update(double)
                 * @see #update(double, int)
                 * @param {number} elapsedTime the elapsed time in seconds
                 */
                updatev(elapsedTime) {
                    if (elapsedTime <= 0.0)
                        return;
                    this.__step.update(elapsedTime);
                    this.step$();
                }
                step$int(steps) {
                    const invhz = this.settings.getStepFrequency();
                    this.step$int$double(steps, invhz);
                }
                step$int$double(steps, elapsedTime) {
                    if (steps <= 0)
                        return;
                    if (elapsedTime <= 0.0)
                        return;
                    for (let i = 0; i < steps; i++) {
                        {
                            this.__step.update(elapsedTime);
                            this.step$();
                        }
                        ;
                    }
                }
                /**
                 * Performs the given number of simulation steps using the given elapsed time for each step.
                 * <p>
                 * This method immediately returns if the given elapsedTime or step count is less than or equal to
                 * zero.
                 * @param {number} steps the number of simulation steps to perform
                 * @param {number} elapsedTime the elapsed time for each step
                 */
                step(steps, elapsedTime) {
                    if (((typeof steps === 'number') || steps === null) && ((typeof elapsedTime === 'number') || elapsedTime === null)) {
                        return this.step$int$double(steps, elapsedTime);
                    }
                    else if (((typeof steps === 'number') || steps === null) && elapsedTime === undefined) {
                        return this.step$int(steps);
                    }
                    else if (steps === undefined && elapsedTime === undefined) {
                        return this.step$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                step$() {
                    const stepListeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.StepListener");
                    const contactListeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.contact.ContactListener");
                    const sSize = stepListeners.size();
                    for (let i = 0; i < sSize; i++) {
                        {
                            const sl = stepListeners.get(i);
                            sl.begin(this.__step, this);
                        }
                        ;
                    }
                    if (this.updateRequired) {
                        this.detect$();
                        for (let i = 0; i < sSize; i++) {
                            {
                                const sl = stepListeners.get(i);
                                sl.updatePerformed(this.__step, this);
                            }
                            ;
                        }
                        this.updateRequired = false;
                    }
                    this.contactManager.preSolveNotify(contactListeners);
                    const continuousDetectionMode = this.settings.getContinuousDetectionMode();
                    const size = this.bodies.size();
                    for (let i = 0; i < size; i++) {
                        {
                            const body = this.bodies.get(i);
                            body.setOnIsland(false);
                            body.transform0.set(body.getTransform());
                        }
                        ;
                    }
                    const jSize = this.joints.size();
                    for (let i = 0; i < jSize; i++) {
                        {
                            const joint = this.joints.get(i);
                            joint.setOnIsland(false);
                        }
                        ;
                    }
                    const stack = (new java.util.ArrayDeque(size));
                    let joint;
                    let contactConstraint;
                    let constraint;
                    for (let i = 0; i < size; i++) {
                        {
                            const seed = this.bodies.get(i);
                            if (seed.isOnIsland() || seed.isAsleep() || !seed.isActive() || seed.isStatic())
                                continue;
                            const island = this.island;
                            island.clear();
                            stack.clear();
                            stack.push(seed);
                            while ((stack.size() > 0)) {
                                {
                                    const body = stack.pop();
                                    island.add$org_dyn4j_dynamics_Body(body);
                                    body.setOnIsland(true);
                                    body.setAsleep(false);
                                    if (body.isStatic())
                                        continue;
                                    const ceSize = body.contacts.size();
                                    for (let j = 0; j < ceSize; j++) {
                                        {
                                            const contactEdge = body.contacts.get(j);
                                            constraint = contactConstraint = contactEdge.interaction;
                                            if (!contactConstraint.isEnabled() || contactConstraint.isSensor() || constraint.isOnIsland())
                                                continue;
                                            const other = contactEdge.other;
                                            island.add$org_dyn4j_dynamics_contact_ContactConstraint(contactConstraint);
                                            constraint.setOnIsland(true);
                                            if (!other.isOnIsland()) {
                                                stack.push(other);
                                                other.setOnIsland(true);
                                            }
                                        }
                                        ;
                                    }
                                    const jeSize = body.joints.size();
                                    for (let j = 0; j < jeSize; j++) {
                                        {
                                            const jointEdge = body.joints.get(j);
                                            constraint = joint = jointEdge.interaction;
                                            if (!joint.isActive() || constraint.isOnIsland())
                                                continue;
                                            const other = jointEdge.other;
                                            if (!other.isActive())
                                                continue;
                                            island.add$org_dyn4j_dynamics_joint_Joint(joint);
                                            constraint.setOnIsland(true);
                                            if (!other.isOnIsland()) {
                                                stack.push(other);
                                                other.setOnIsland(true);
                                            }
                                        }
                                        ;
                                    }
                                }
                            }
                            ;
                            island.solve(this.contactConstraintSolver, this.gravity, this.__step, this.settings);
                            const isize = island.bodies.size();
                            for (let j = 0; j < isize; j++) {
                                {
                                    const body = island.bodies.get(j);
                                    if (body.isStatic()) {
                                        body.setOnIsland(false);
                                    }
                                }
                                ;
                            }
                        }
                        ;
                    }
                    stack.clear();
                    this.island.clear();
                    this.contactManager.postSolveNotify(contactListeners);
                    if (continuousDetectionMode !== org.dyn4j.dynamics.ContinuousDetectionMode.NONE) {
                        this.solveTOI$org_dyn4j_dynamics_ContinuousDetectionMode(continuousDetectionMode);
                    }
                    for (let i = 0; i < sSize; i++) {
                        {
                            const sl = stepListeners.get(i);
                            sl.postSolve(this.__step, this);
                        }
                        ;
                    }
                    this.detect$();
                    this.updateRequired = false;
                    for (let i = 0; i < sSize; i++) {
                        {
                            const sl = stepListeners.get(i);
                            sl.end(this.__step, this);
                        }
                        ;
                    }
                }
                detect$() {
                    const boundsListeners = this.getListeners$java_lang_Class("org.dyn4j.collision.BoundsListener");
                    const collisionListeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.CollisionListener");
                    const size = this.bodies.size();
                    const blSize = boundsListeners.size();
                    const clSize = collisionListeners.size();
                    if (this.broadphaseDetector != null && (this.broadphaseDetector.constructor != null && this.broadphaseDetector.constructor["__interfaces"] != null && this.broadphaseDetector.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BatchBroadphaseDetector") >= 0)) {
                        for (let i = 0; i < size; i++) {
                            {
                                const body = this.bodies.get(i);
                                if (!body.isActive())
                                    continue;
                                body.contacts.clear();
                                if (this.bounds != null && this.bounds.isOutside(body)) {
                                    body.setActive(false);
                                    for (let j = 0; j < blSize; j++) {
                                        {
                                            const bl = boundsListeners.get(j);
                                            bl.outside(body);
                                        }
                                        ;
                                    }
                                }
                            }
                            ;
                        }
                        this.broadphaseDetector.batchUpdate();
                    }
                    else {
                        for (let i = 0; i < size; i++) {
                            {
                                const body = this.bodies.get(i);
                                if (!body.isActive())
                                    continue;
                                body.contacts.clear();
                                if (this.bounds != null && this.bounds.isOutside(body)) {
                                    body.setActive(false);
                                    for (let j = 0; j < blSize; j++) {
                                        {
                                            const bl = boundsListeners.get(j);
                                            bl.outside(body);
                                        }
                                        ;
                                    }
                                }
                                this.broadphaseDetector.update(body);
                            }
                            ;
                        }
                    }
                    if (size > 0) {
                        const pairs = this.broadphaseDetector['detect$org_dyn4j_collision_broadphase_BroadphaseFilter'](this.detectBroadphaseFilter);
                        const pSize = pairs.size();
                        let allow = true;
                        for (let i = 0; i < pSize; i++) {
                            {
                                const pair = pairs.get(i);
                                const body1 = pair.getCollidable1();
                                const body2 = pair.getCollidable2();
                                const fixture1 = pair.getFixture1();
                                const fixture2 = pair.getFixture2();
                                allow = true;
                                for (let j = 0; j < clSize; j++) {
                                    {
                                        const cl = collisionListeners.get(j);
                                        if (!cl['collision$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture'](body1, fixture1, body2, fixture2)) {
                                            allow = false;
                                        }
                                    }
                                    ;
                                }
                                if (!allow)
                                    continue;
                                const transform1 = body1.getTransform();
                                const transform2 = body2.getTransform();
                                const convex2 = fixture2.getShape();
                                const convex1 = fixture1.getShape();
                                const penetration = new org.dyn4j.collision.narrowphase.Penetration();
                                if (this.narrowphaseDetector['detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration'](convex1, transform1, convex2, transform2, penetration)) {
                                    if (penetration.getDepth() === 0.0) {
                                        continue;
                                    }
                                    if (this.narrowphasePostProcessor != null) {
                                        this.narrowphasePostProcessor.process(convex1, transform1, convex2, transform2, penetration);
                                    }
                                    allow = true;
                                    for (let j = 0; j < clSize; j++) {
                                        {
                                            const cl = collisionListeners.get(j);
                                            if (!cl['collision$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_narrowphase_Penetration'](body1, fixture1, body2, fixture2, penetration)) {
                                                allow = false;
                                            }
                                        }
                                        ;
                                    }
                                    if (!allow)
                                        continue;
                                    const manifold = new org.dyn4j.collision.manifold.Manifold();
                                    if (this.manifoldSolver.getManifold(penetration, convex1, transform1, convex2, transform2, manifold)) {
                                        if (manifold.getPoints().size() === 0) {
                                            continue;
                                        }
                                        allow = true;
                                        for (let j = 0; j < clSize; j++) {
                                            {
                                                const cl = collisionListeners.get(j);
                                                if (!cl['collision$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_manifold_Manifold'](body1, fixture1, body2, fixture2, manifold)) {
                                                    allow = false;
                                                }
                                            }
                                            ;
                                        }
                                        if (!allow)
                                            continue;
                                        const contactConstraint = new org.dyn4j.dynamics.contact.ContactConstraint(body1, fixture1, body2, fixture2, manifold, this.coefficientMixer.mixFriction(fixture1.getFriction(), fixture2.getFriction()), this.coefficientMixer.mixRestitution(fixture1.getRestitution(), fixture2.getRestitution()));
                                        allow = true;
                                        for (let j = 0; j < clSize; j++) {
                                            {
                                                const cl = collisionListeners.get(j);
                                                if (!cl['collision$org_dyn4j_dynamics_contact_ContactConstraint'](contactConstraint)) {
                                                    allow = false;
                                                }
                                            }
                                            ;
                                        }
                                        if (!allow)
                                            continue;
                                        const contactEdge1 = new org.dyn4j.dynamics.ContactEdge(body2, contactConstraint);
                                        const contactEdge2 = new org.dyn4j.dynamics.ContactEdge(body1, contactConstraint);
                                        body1.contacts.add(contactEdge1);
                                        body2.contacts.add(contactEdge2);
                                        this.contactManager.queue(contactConstraint);
                                    }
                                }
                            }
                            ;
                        }
                    }
                    this.contactManager.updateAndNotify(this.getListeners$java_lang_Class("org.dyn4j.dynamics.contact.ContactListener"), this.settings);
                }
                solveTOI$org_dyn4j_dynamics_ContinuousDetectionMode(mode) {
                    const listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.TimeOfImpactListener");
                    const size = this.bodies.size();
                    const bulletsOnly = (mode === org.dyn4j.dynamics.ContinuousDetectionMode.BULLETS_ONLY);
                    for (let i = 0; i < size; i++) {
                        {
                            const body = this.bodies.get(i);
                            if (bulletsOnly && !body.isBullet())
                                continue;
                            if (body.mass.isInfinite())
                                continue;
                            if (!body.isOnIsland() || body.isAsleep())
                                continue;
                            this.solveTOI$org_dyn4j_dynamics_Body$java_util_List(body, listeners);
                        }
                        ;
                    }
                }
                solveTOI$org_dyn4j_dynamics_Body$java_util_List(body1, listeners) {
                    const size = this.bodies.size();
                    const aabb1 = body1.createSweptAABB$();
                    const bullet = body1.isBullet();
                    const t1 = 0.0;
                    let t2 = 1.0;
                    let minToi = null;
                    let minBody = null;
                    for (let i = 0; i < size; i++) {
                        {
                            const body2 = this.bodies.get(i);
                            if (body1 === body2)
                                continue;
                            if (!body2.isActive())
                                continue;
                            if (body2.isDynamic() && !bullet)
                                continue;
                            if (body1.isConnected$org_dyn4j_dynamics_Body$boolean(body2, false))
                                continue;
                            if (body1.isInContact(body2))
                                continue;
                            const aabb2 = body2.createSweptAABB$();
                            if (!aabb1.overlaps(aabb2))
                                continue;
                            const toi = new org.dyn4j.collision.continuous.TimeOfImpact();
                            const fc1 = body1.getFixtureCount();
                            const fc2 = body2.getFixtureCount();
                            const dt = this.__step.getDeltaTime();
                            const v1 = body1.getLinearVelocity$().product(dt);
                            const v2 = body2.getLinearVelocity$().product(dt);
                            const av1 = body1.getAngularVelocity() * dt;
                            const av2 = body2.getAngularVelocity() * dt;
                            const tx1 = body1.getInitialTransform();
                            const tx2 = body2.getInitialTransform();
                            for (let j = 0; j < fc1; j++) {
                                {
                                    const f1 = body1.getFixture$int(j);
                                    if (f1.isSensor())
                                        continue;
                                    for (let k = 0; k < fc2; k++) {
                                        {
                                            const f2 = body2.getFixture$int(k);
                                            if (f2.isSensor())
                                                continue;
                                            const filter1 = f1.getFilter();
                                            const filter2 = f2.getFilter();
                                            if (!filter1.isAllowed(filter2)) {
                                                continue;
                                            }
                                            const c1 = f1.getShape();
                                            const c2 = f2.getShape();
                                            if (this.timeOfImpactDetector['getTimeOfImpact$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_collision_continuous_TimeOfImpact'](c1, tx1, v1, av1, c2, tx2, v2, av2, t1, t2, toi)) {
                                                const t = toi.getTime();
                                                if (t < t2) {
                                                    let allow = true;
                                                    for (let index = listeners.iterator(); index.hasNext();) {
                                                        let tl = index.next();
                                                        {
                                                            if (!tl.collision(body1, f1, body2, f2, toi)) {
                                                                allow = false;
                                                            }
                                                        }
                                                    }
                                                    if (allow) {
                                                        t2 = t;
                                                        minToi = toi;
                                                        minBody = body2;
                                                    }
                                                }
                                            }
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                        }
                        ;
                    }
                    if (minToi != null) {
                        const t = minToi.getTime();
                        body1.transform0.lerp$org_dyn4j_geometry_Transform$double$org_dyn4j_geometry_Transform(body1.getTransform(), t, body1.getTransform());
                        if (minBody.isDynamic()) {
                            minBody.transform0.lerp$org_dyn4j_geometry_Transform$double$org_dyn4j_geometry_Transform(minBody.getTransform(), t, minBody.getTransform());
                        }
                        this.timeOfImpactSolver.solve(body1, minBody, minToi, this.settings);
                    }
                }
                /**
                 * Solves the time of impact for the given {@link Body}.
                 * <p>
                 * This method will find the first {@link Body} that the given {@link Body}
                 * collides with unless ignored via the {@link TimeOfImpactListener}.
                 * <p>
                 * If any {@link TimeOfImpactListener} doesn't allow the collision then the collision
                 * is ignored.
                 * <p>
                 * After the first {@link Body} is found the two {@link Body}s are interpolated
                 * to the time of impact.
                 * <p>
                 * Then the {@link Body}s are position solved using the {@link TimeOfImpactSolver}
                 * to force the {@link Body}s into collision.  This causes the discrete collision
                 * detector to detect the collision on the next time step.
                 * @param {org.dyn4j.dynamics.Body} body1 the {@link Body}
                 * @param {*} listeners the list of {@link TimeOfImpactListener}s
                 * @since 3.1.0
                 */
                solveTOI(body1, listeners) {
                    if (((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((listeners != null && (listeners.constructor != null && listeners.constructor["__interfaces"] != null && listeners.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || listeners === null)) {
                        return this.solveTOI$org_dyn4j_dynamics_Body$java_util_List(body1, listeners);
                    }
                    else if (((typeof body1 === 'number') || body1 === null) && listeners === undefined) {
                        return this.solveTOI$org_dyn4j_dynamics_ContinuousDetectionMode(body1);
                    }
                    else
                        throw new Error('invalid overload');
                }
                raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$boolean$boolean$java_util_List(start, end, ignoreSensors, all, results) {
                    return this.raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(start, end, null, ignoreSensors, true, all, results);
                }
                raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$boolean$boolean$boolean$java_util_List(start, end, ignoreSensors, ignoreInactive, all, results) {
                    return this.raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(start, end, null, ignoreSensors, ignoreInactive, all, results);
                }
                raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(start, end, filter, ignoreSensors, ignoreInactive, all, results) {
                    const d = start.to$org_dyn4j_geometry_Vector2(end);
                    const maxLength = d.normalize();
                    const ray = new org.dyn4j.geometry.Ray(start, d);
                    return this.raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(ray, maxLength, filter, ignoreSensors, ignoreInactive, all, results);
                }
                /**
                 * Performs a raycast against all the {@link Body}s in the {@link World}.
                 * <p>
                 * The given {@link RaycastResult} list, results, will be filled with the raycast results
                 * if the given ray intersected any bodies.
                 * <p>
                 * The {@link RaycastResult} class implements the Comparable interface to allow sorting by
                 * distance from the ray's origin.
                 * <p>
                 * If the all flag is false, the results list will only contain the closest result (if any).
                 * <p>
                 * All raycasts pass through the {@link RaycastListener}s before being tested.  If <b>any</b>
                 * {@link RaycastListener} doesn't allow the raycast then the body will not be tested.
                 * <p>
                 * Bodies that contain the start of the ray will not be included in the results.
                 * @param {org.dyn4j.geometry.Vector2} start the start point
                 * @param {org.dyn4j.geometry.Vector2} end the end point
                 * @param {*} filter the {@link Filter} to use against the fixtures; can be null
                 * @param {boolean} ignoreSensors true if sensor {@link BodyFixture}s should be ignored
                 * @param {boolean} ignoreInactive true if inactive bodies should be ignored
                 * @param {boolean} all true if all intersected {@link Body}s should be returned; false if only the closest {@link Body} should be returned
                 * @param {*} results a list to contain the results of the raycast
                 * @return {boolean} boolean true if at least one {@link Body} was intersected by the {@link Ray}
                 * @throws NullPointerException if start, end, or results is null
                 * @see #raycast(Ray, double, Filter, boolean, boolean, boolean, List)
                 * @see RaycastListener#allow(Ray, Body, BodyFixture)
                 * @since 3.1.9
                 */
                raycast(start, end, filter, ignoreSensors, ignoreInactive, all, results) {
                    if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((end != null && end instanceof org.dyn4j.geometry.Vector2) || end === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((typeof ignoreInactive === 'boolean') || ignoreInactive === null) && ((typeof all === 'boolean') || all === null) && ((results != null && (results.constructor != null && results.constructor["__interfaces"] != null && results.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || results === null)) {
                        return this.raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(start, end, filter, ignoreSensors, ignoreInactive, all, results);
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof end === 'number') || end === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((typeof ignoreInactive === 'boolean') || ignoreInactive === null) && ((typeof all === 'boolean') || all === null) && ((results != null && (results.constructor != null && results.constructor["__interfaces"] != null && results.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || results === null)) {
                        return this.raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(start, end, filter, ignoreSensors, ignoreInactive, all, results);
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((end != null && end instanceof org.dyn4j.geometry.Vector2) || end === null) && ((filter != null && filter instanceof org.dyn4j.dynamics.Body) || filter === null) && ((ignoreSensors != null && (ignoreSensors.constructor != null && ignoreSensors.constructor["__interfaces"] != null && ignoreSensors.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || ignoreSensors === null) && ((typeof ignoreInactive === 'boolean') || ignoreInactive === null) && ((all != null && all instanceof org.dyn4j.dynamics.RaycastResult) || all === null) && results === undefined) {
                        return this.raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_RaycastResult(start, end, filter, ignoreSensors, ignoreInactive, all);
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((end != null && end instanceof org.dyn4j.dynamics.Body) || end === null) && ((typeof filter === 'number') || filter === null) && ((ignoreSensors != null && (ignoreSensors.constructor != null && ignoreSensors.constructor["__interfaces"] != null && ignoreSensors.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || ignoreSensors === null) && ((typeof ignoreInactive === 'boolean') || ignoreInactive === null) && ((all != null && all instanceof org.dyn4j.dynamics.RaycastResult) || all === null) && results === undefined) {
                        return this.raycast$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$double$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_RaycastResult(start, end, filter, ignoreSensors, ignoreInactive, all);
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((end != null && end instanceof org.dyn4j.geometry.Vector2) || end === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((typeof ignoreInactive === 'boolean') || ignoreInactive === null) && ((all != null && (all.constructor != null && all.constructor["__interfaces"] != null && all.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || all === null) && results === undefined) {
                        return this.raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$boolean$boolean$boolean$java_util_List(start, end, filter, ignoreSensors, ignoreInactive, all);
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof end === 'number') || end === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((typeof ignoreInactive === 'boolean') || ignoreInactive === null) && ((all != null && (all.constructor != null && all.constructor["__interfaces"] != null && all.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || all === null) && results === undefined) {
                        return this.raycast$org_dyn4j_geometry_Ray$double$boolean$boolean$boolean$java_util_List(start, end, filter, ignoreSensors, ignoreInactive, all);
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((end != null && end instanceof org.dyn4j.geometry.Vector2) || end === null) && ((filter != null && filter instanceof org.dyn4j.dynamics.Body) || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((ignoreInactive != null && ignoreInactive instanceof org.dyn4j.dynamics.RaycastResult) || ignoreInactive === null) && all === undefined && results === undefined) {
                        return this.raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_dynamics_Body$boolean$org_dyn4j_dynamics_RaycastResult(start, end, filter, ignoreSensors, ignoreInactive);
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((end != null && end instanceof org.dyn4j.geometry.Vector2) || end === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((ignoreInactive != null && (ignoreInactive.constructor != null && ignoreInactive.constructor["__interfaces"] != null && ignoreInactive.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreInactive === null) && all === undefined && results === undefined) {
                        return this.raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$boolean$boolean$java_util_List(start, end, filter, ignoreSensors, ignoreInactive);
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((end != null && end instanceof org.dyn4j.dynamics.Body) || end === null) && ((typeof filter === 'number') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((ignoreInactive != null && ignoreInactive instanceof org.dyn4j.dynamics.RaycastResult) || ignoreInactive === null) && all === undefined && results === undefined) {
                        return this.raycast$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$double$boolean$org_dyn4j_dynamics_RaycastResult(start, end, filter, ignoreSensors, ignoreInactive);
                    }
                    else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof end === 'number') || end === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((ignoreInactive != null && (ignoreInactive.constructor != null && ignoreInactive.constructor["__interfaces"] != null && ignoreInactive.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreInactive === null) && all === undefined && results === undefined) {
                        return this.raycast$org_dyn4j_geometry_Ray$double$boolean$boolean$java_util_List(start, end, filter, ignoreSensors, ignoreInactive);
                    }
                    else
                        throw new Error('invalid overload');
                }
                raycast$org_dyn4j_geometry_Ray$double$boolean$boolean$java_util_List(ray, maxLength, ignoreSensors, all, results) {
                    return this.raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(ray, maxLength, null, ignoreSensors, true, all, results);
                }
                raycast$org_dyn4j_geometry_Ray$double$boolean$boolean$boolean$java_util_List(ray, maxLength, ignoreSensors, ignoreInactive, all, results) {
                    return this.raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(ray, maxLength, null, ignoreSensors, ignoreInactive, all, results);
                }
                raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(ray, maxLength, filter, ignoreSensors, ignoreInactive, all, results) {
                    const listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.RaycastListener");
                    const rlSize = listeners.size();
                    let max = 0.0;
                    if (maxLength > 0.0) {
                        max = maxLength;
                    }
                    let result = null;
                    const bpFilter = new org.dyn4j.dynamics.RaycastBroadphaseFilter(ignoreInactive, ignoreSensors, filter);
                    const items = this.broadphaseDetector['raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_broadphase_BroadphaseFilter'](ray, maxLength, bpFilter);
                    const size = items.size();
                    let found = false;
                    let allow = true;
                    for (let i = 0; i < size; i++) {
                        {
                            const item = items.get(i);
                            const body = item.getCollidable();
                            const fixture = item.getFixture();
                            const transform = body.getTransform();
                            const raycast = new org.dyn4j.collision.narrowphase.Raycast();
                            allow = true;
                            for (let j = 0; j < rlSize; j++) {
                                {
                                    const rl = listeners.get(j);
                                    if (!rl['allow$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture'](ray, body, fixture)) {
                                        allow = false;
                                    }
                                }
                                ;
                            }
                            if (!allow)
                                continue;
                            const convex = fixture.getShape();
                            if (this.raycastDetector.raycast(ray, max, convex, transform, raycast)) {
                                allow = true;
                                for (let j = 0; j < rlSize; j++) {
                                    {
                                        const rl = listeners.get(j);
                                        if (!rl['allow$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_narrowphase_Raycast'](ray, body, fixture, raycast)) {
                                            allow = false;
                                        }
                                    }
                                    ;
                                }
                                if (!allow)
                                    continue;
                                if (!all) {
                                    if (result == null) {
                                        result = new org.dyn4j.dynamics.RaycastResult(body, fixture, raycast);
                                        results.add(result);
                                        found = true;
                                    }
                                    else {
                                        result.body = body;
                                        result.fixture = fixture;
                                        result.raycast = raycast;
                                    }
                                    max = result.raycast.getDistance();
                                }
                                else {
                                    results.add(new org.dyn4j.dynamics.RaycastResult(body, fixture, raycast));
                                    found = true;
                                }
                            }
                        }
                        ;
                    }
                    return found;
                }
                raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_dynamics_Body$boolean$org_dyn4j_dynamics_RaycastResult(start, end, body, ignoreSensors, result) {
                    return this.raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_RaycastResult(start, end, body, null, ignoreSensors, result);
                }
                raycast$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_RaycastResult(start, end, body, filter, ignoreSensors, result) {
                    const d = start.to$org_dyn4j_geometry_Vector2(end);
                    const maxLength = d.normalize();
                    const ray = new org.dyn4j.geometry.Ray(start, d);
                    return this.raycast$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$double$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_RaycastResult(ray, body, maxLength, filter, ignoreSensors, result);
                }
                raycast$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$double$boolean$org_dyn4j_dynamics_RaycastResult(ray, body, maxLength, ignoreSensors, result) {
                    return this.raycast$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$double$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_RaycastResult(ray, body, maxLength, null, ignoreSensors, result);
                }
                raycast$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$double$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_RaycastResult(ray, body, maxLength, filter, ignoreSensors, result) {
                    const listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.RaycastListener");
                    const rlSize = listeners.size();
                    let allow = true;
                    const size = body.getFixtureCount();
                    const transform = body.getTransform();
                    let max = 0.0;
                    if (maxLength > 0.0) {
                        max = maxLength;
                    }
                    const raycast = new org.dyn4j.collision.narrowphase.Raycast();
                    let found = false;
                    for (let i = 0; i < size; i++) {
                        {
                            const fixture = body.getFixture$int(i);
                            if (ignoreSensors && fixture.isSensor()) {
                                continue;
                            }
                            if (filter != null && !filter.isAllowed(fixture.getFilter())) {
                                continue;
                            }
                            allow = true;
                            for (let j = 0; j < rlSize; j++) {
                                {
                                    const rl = listeners.get(j);
                                    if (!rl['allow$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture'](ray, body, fixture)) {
                                        allow = false;
                                    }
                                }
                                ;
                            }
                            if (!allow)
                                continue;
                            const convex = fixture.getShape();
                            if (this.raycastDetector.raycast(ray, max, convex, transform, raycast)) {
                                allow = true;
                                for (let j = 0; j < rlSize; j++) {
                                    {
                                        const rl = listeners.get(j);
                                        if (!rl['allow$org_dyn4j_geometry_Ray$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_narrowphase_Raycast'](ray, body, fixture, raycast)) {
                                            allow = false;
                                        }
                                    }
                                    ;
                                }
                                if (!allow)
                                    continue;
                                max = raycast.getDistance();
                                result.fixture = fixture;
                                found = true;
                            }
                        }
                        ;
                    }
                    if (found) {
                        result.body = body;
                        result.raycast = raycast;
                    }
                    return found;
                }
                convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$boolean$boolean$java_util_List(convex, transform, deltaPosition, ignoreSensors, all, results) {
                    return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, deltaPosition, 0.0, null, ignoreSensors, true, all, results);
                }
                convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$boolean$boolean$boolean$java_util_List(convex, transform, deltaPosition, ignoreSensors, ignoreInactive, all, results) {
                    return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, deltaPosition, 0.0, null, ignoreSensors, ignoreInactive, all, results);
                }
                convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$boolean$boolean$java_util_List(convex, transform, deltaPosition, deltaAngle, ignoreSensors, all, results) {
                    return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, deltaPosition, deltaAngle, null, ignoreSensors, true, all, results);
                }
                convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$boolean$boolean$boolean$java_util_List(convex, transform, deltaPosition, deltaAngle, ignoreSensors, ignoreInactive, all, results) {
                    return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, deltaPosition, deltaAngle, null, ignoreSensors, ignoreInactive, all, results);
                }
                convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, deltaPosition, deltaAngle, filter, ignoreSensors, ignoreInactive, all, results) {
                    const listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.ConvexCastListener");
                    const clSize = listeners.size();
                    const radius = convex['getRadius$']();
                    const startWorldCenter = transform.getTransformed$org_dyn4j_geometry_Vector2(convex.getCenter());
                    const startAABB = new org.dyn4j.geometry.AABB(startWorldCenter, radius);
                    const finalTransform = transform.lerped$org_dyn4j_geometry_Vector2$double$double(deltaPosition, deltaAngle, 1.0);
                    const endWorldCenter = finalTransform.getTransformed$org_dyn4j_geometry_Vector2(convex.getCenter());
                    const endAABB = new org.dyn4j.geometry.AABB(endWorldCenter, radius);
                    const aabb = startAABB.getUnion(endAABB);
                    let min = null;
                    const dp2 = new org.dyn4j.geometry.Vector2();
                    let t2 = 1.0;
                    let found = false;
                    let allow = true;
                    const bpFilter = new org.dyn4j.dynamics.AABBBroadphaseFilter(ignoreInactive, ignoreSensors, filter);
                    const items = this.broadphaseDetector['detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter'](aabb, bpFilter);
                    for (let index = items.iterator(); index.hasNext();) {
                        let item = index.next();
                        {
                            const body = item.getCollidable();
                            const fixture = item.getFixture();
                            let ft2 = t2;
                            let bodyMinToi = null;
                            let bodyMinFixture = null;
                            const bodyTransform = body.getTransform();
                            allow = true;
                            for (let j = 0; j < clSize; j++) {
                                {
                                    const ccl = listeners.get(j);
                                    if (!ccl['allow$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture'](convex, body, fixture)) {
                                        allow = false;
                                    }
                                }
                                ;
                            }
                            if (!allow)
                                continue;
                            const c = fixture.getShape();
                            const timeOfImpact = new org.dyn4j.collision.continuous.TimeOfImpact();
                            if (this.timeOfImpactDetector['getTimeOfImpact$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_collision_continuous_TimeOfImpact'](convex, transform, deltaPosition, deltaAngle, c, bodyTransform, dp2, 0.0, 0.0, ft2, timeOfImpact)) {
                                allow = true;
                                for (let j = 0; j < clSize; j++) {
                                    {
                                        const ccl = listeners.get(j);
                                        if (!ccl['allow$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_continuous_TimeOfImpact'](convex, body, fixture, timeOfImpact)) {
                                            allow = false;
                                        }
                                    }
                                    ;
                                }
                                if (!allow)
                                    continue;
                                if (bodyMinToi == null || timeOfImpact.getTime() < bodyMinToi.getTime()) {
                                    ft2 = timeOfImpact.getTime();
                                    bodyMinToi = timeOfImpact;
                                    bodyMinFixture = fixture;
                                }
                            }
                            if (bodyMinToi != null) {
                                if (!all) {
                                    t2 = bodyMinToi.getTime();
                                    if (min == null || bodyMinToi.getTime() < min.timeOfImpact.getTime()) {
                                        min = new org.dyn4j.dynamics.ConvexCastResult(body, bodyMinFixture, bodyMinToi);
                                    }
                                }
                                else {
                                    const result = new org.dyn4j.dynamics.ConvexCastResult(body, fixture, timeOfImpact);
                                    results.add(result);
                                }
                                found = true;
                            }
                        }
                    }
                    if (min != null) {
                        results.add(min);
                    }
                    return found;
                }
                /**
                 * Performs a linear convex cast on the world, placing any detected collisions into the given results list.
                 * <p>
                 * This method does a static test of bodies (in other words, does not take into account the bodies linear
                 * or angular velocity, but rather assumes they are stationary).
                 * <p>
                 * The <code>deltaPosition</code> parameter is the linear cast vector determining the direction and magnitude of the cast.
                 * The <code>deltaAngle</code> parameter is the change in angle over the linear cast and is interpolated linearly
                 * during detection.
                 * <p>
                 * The {@link ConvexCastResult} class implements the Comparable interface to allow sorting by
                 * the time of impact.
                 * <p>
                 * If the all flag is false, the results list will only contain the closest result (if any).
                 * <p>
                 * All convex casts pass through the {@link ConvexCastListener}s before being tested.  If <b>any</b>
                 * {@link ConvexCastListener} doesn't allow the convex cast, then the body will not be tested.
                 * <p>
                 * For multi-fixtured bodies, only the fixture that has the minimum time of impact will be added to the
                 * results list.
                 * <p>
                 * Bodies in collision with the given convex at the beginning of the cast are not included in the results.
                 * @param {*} convex the convex to cast
                 * @param {org.dyn4j.geometry.Transform} transform the initial position and orientation of the convex
                 * @param {org.dyn4j.geometry.Vector2} deltaPosition &Delta;position; the change in position (the cast length and direction basically)
                 * @param {number} deltaAngle &Delta;angle; the change in the angle; this is the change in the angle over the linear period
                 * @param {*} filter the {@link Filter} to use against the fixtures; can be null
                 * @param {boolean} ignoreSensors true if sensor fixtures should be ignored in the tests
                 * @param {boolean} ignoreInactive true if inactive bodies should be ignored in the tests
                 * @param {boolean} all true if all hits should be returned; false if only the first should be returned
                 * @param {*} results the list to add the results to
                 * @return {boolean} boolean true if a collision was found
                 * @since 3.1.9
                 */
                convexCast(convex, transform, deltaPosition, deltaAngle, filter, ignoreSensors, ignoreInactive, all, results) {
                    if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((deltaPosition != null && deltaPosition instanceof org.dyn4j.geometry.Vector2) || deltaPosition === null) && ((typeof deltaAngle === 'number') || deltaAngle === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((typeof ignoreInactive === 'boolean') || ignoreInactive === null) && ((typeof all === 'boolean') || all === null) && ((results != null && (results.constructor != null && results.constructor["__interfaces"] != null && results.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || results === null)) {
                        return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, deltaPosition, deltaAngle, filter, ignoreSensors, ignoreInactive, all, results);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((deltaPosition != null && deltaPosition instanceof org.dyn4j.geometry.Vector2) || deltaPosition === null) && ((typeof deltaAngle === 'number') || deltaAngle === null) && ((filter != null && filter instanceof org.dyn4j.dynamics.Body) || filter === null) && ((ignoreSensors != null && (ignoreSensors.constructor != null && ignoreSensors.constructor["__interfaces"] != null && ignoreSensors.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || ignoreSensors === null) && ((typeof ignoreInactive === 'boolean') || ignoreInactive === null) && ((all != null && all instanceof org.dyn4j.dynamics.ConvexCastResult) || all === null) && results === undefined) {
                        return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_ConvexCastResult(convex, transform, deltaPosition, deltaAngle, filter, ignoreSensors, ignoreInactive, all);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((deltaPosition != null && deltaPosition instanceof org.dyn4j.geometry.Vector2) || deltaPosition === null) && ((typeof deltaAngle === 'number') || deltaAngle === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((typeof ignoreInactive === 'boolean') || ignoreInactive === null) && ((all != null && (all.constructor != null && all.constructor["__interfaces"] != null && all.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || all === null) && results === undefined) {
                        return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$boolean$boolean$boolean$java_util_List(convex, transform, deltaPosition, deltaAngle, filter, ignoreSensors, ignoreInactive, all);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((deltaPosition != null && deltaPosition instanceof org.dyn4j.geometry.Vector2) || deltaPosition === null) && ((typeof deltaAngle === 'number') || deltaAngle === null) && ((filter != null && filter instanceof org.dyn4j.dynamics.Body) || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((ignoreInactive != null && ignoreInactive instanceof org.dyn4j.dynamics.ConvexCastResult) || ignoreInactive === null) && all === undefined && results === undefined) {
                        return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_dynamics_Body$boolean$org_dyn4j_dynamics_ConvexCastResult(convex, transform, deltaPosition, deltaAngle, filter, ignoreSensors, ignoreInactive);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((deltaPosition != null && deltaPosition instanceof org.dyn4j.geometry.Vector2) || deltaPosition === null) && ((typeof deltaAngle === 'boolean') || deltaAngle === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((ignoreInactive != null && (ignoreInactive.constructor != null && ignoreInactive.constructor["__interfaces"] != null && ignoreInactive.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreInactive === null) && all === undefined && results === undefined) {
                        return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$boolean$boolean$boolean$java_util_List(convex, transform, deltaPosition, deltaAngle, filter, ignoreSensors, ignoreInactive);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((deltaPosition != null && deltaPosition instanceof org.dyn4j.geometry.Vector2) || deltaPosition === null) && ((typeof deltaAngle === 'number') || deltaAngle === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((ignoreInactive != null && (ignoreInactive.constructor != null && ignoreInactive.constructor["__interfaces"] != null && ignoreInactive.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreInactive === null) && all === undefined && results === undefined) {
                        return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$boolean$boolean$java_util_List(convex, transform, deltaPosition, deltaAngle, filter, ignoreSensors, ignoreInactive);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((deltaPosition != null && deltaPosition instanceof org.dyn4j.geometry.Vector2) || deltaPosition === null) && ((deltaAngle != null && deltaAngle instanceof org.dyn4j.dynamics.Body) || deltaAngle === null) && ((typeof filter === 'boolean') || filter === null) && ((ignoreSensors != null && ignoreSensors instanceof org.dyn4j.dynamics.ConvexCastResult) || ignoreSensors === null) && ignoreInactive === undefined && all === undefined && results === undefined) {
                        return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$org_dyn4j_dynamics_Body$boolean$org_dyn4j_dynamics_ConvexCastResult(convex, transform, deltaPosition, deltaAngle, filter, ignoreSensors);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((deltaPosition != null && deltaPosition instanceof org.dyn4j.geometry.Vector2) || deltaPosition === null) && ((typeof deltaAngle === 'boolean') || deltaAngle === null) && ((typeof filter === 'boolean') || filter === null) && ((ignoreSensors != null && (ignoreSensors.constructor != null && ignoreSensors.constructor["__interfaces"] != null && ignoreSensors.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreSensors === null) && ignoreInactive === undefined && all === undefined && results === undefined) {
                        return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$boolean$boolean$java_util_List(convex, transform, deltaPosition, deltaAngle, filter, ignoreSensors);
                    }
                    else
                        throw new Error('invalid overload');
                }
                convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$org_dyn4j_dynamics_Body$boolean$org_dyn4j_dynamics_ConvexCastResult(convex, transform, deltaPosition, body, ignoreSensors, result) {
                    return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_ConvexCastResult(convex, transform, deltaPosition, 0, body, null, ignoreSensors, result);
                }
                convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_dynamics_Body$boolean$org_dyn4j_dynamics_ConvexCastResult(convex, transform, deltaPosition, deltaAngle, body, ignoreSensors, result) {
                    return this.convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_ConvexCastResult(convex, transform, deltaPosition, deltaAngle, body, null, ignoreSensors, result);
                }
                convexCast$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$org_dyn4j_dynamics_ConvexCastResult(convex, transform, deltaPosition, deltaAngle, body, filter, ignoreSensors, result) {
                    const listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.ConvexCastListener");
                    const clSize = listeners.size();
                    let allow = true;
                    let found = false;
                    const dp2 = new org.dyn4j.geometry.Vector2();
                    let t2 = 1.0;
                    const bSize = body.getFixtureCount();
                    const bodyTransform = body.getTransform();
                    for (let i = 0; i < bSize; i++) {
                        {
                            const bodyFixture = body.getFixture$int(i);
                            if (ignoreSensors && bodyFixture.isSensor())
                                continue;
                            if (filter != null && !filter.isAllowed(bodyFixture.getFilter()))
                                continue;
                            allow = true;
                            for (let j = 0; j < clSize; j++) {
                                {
                                    const ccl = listeners.get(j);
                                    if (!ccl['allow$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture'](convex, body, bodyFixture)) {
                                        allow = false;
                                    }
                                }
                                ;
                            }
                            if (!allow)
                                return false;
                            const c = bodyFixture.getShape();
                            const toi = new org.dyn4j.collision.continuous.TimeOfImpact();
                            if (this.timeOfImpactDetector['getTimeOfImpact$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_collision_continuous_TimeOfImpact'](convex, transform, deltaPosition, deltaAngle, c, bodyTransform, dp2, 0.0, 0.0, t2, toi)) {
                                allow = true;
                                for (let j = 0; j < clSize; j++) {
                                    {
                                        const ccl = listeners.get(j);
                                        if (!ccl['allow$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_collision_continuous_TimeOfImpact'](convex, body, bodyFixture, toi)) {
                                            allow = false;
                                        }
                                    }
                                    ;
                                }
                                if (!allow)
                                    continue;
                                t2 = toi.getTime();
                                result.fixture = bodyFixture;
                                result.timeOfImpact = toi;
                                result.body = body;
                                found = true;
                            }
                        }
                        ;
                    }
                    return found;
                }
                detect$org_dyn4j_geometry_AABB$java_util_List(aabb, results) {
                    return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(aabb, null, false, true, results);
                }
                detect$org_dyn4j_geometry_AABB$boolean$java_util_List(aabb, ignoreInactive, results) {
                    return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(aabb, null, false, ignoreInactive, results);
                }
                detect$org_dyn4j_geometry_AABB$boolean$boolean$java_util_List(aabb, ignoreSensors, ignoreInactive, results) {
                    return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(aabb, null, ignoreSensors, ignoreInactive, results);
                }
                detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(aabb, filter, ignoreSensors, ignoreInactive, results) {
                    const listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.DetectListener");
                    const dlSize = listeners.size();
                    const bpFilter = new org.dyn4j.dynamics.AABBBroadphaseFilter(ignoreInactive, ignoreSensors, filter);
                    const collisions = this.broadphaseDetector['detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter'](aabb, bpFilter);
                    let found = false;
                    const bSize = collisions.size();
                    let allow;
                    for (let i = 0; i < bSize; i++) {
                        {
                            const item = collisions.get(i);
                            const body = item.getCollidable();
                            const fixture = item.getFixture();
                            const transform = body.getTransform();
                            allow = true;
                            for (let j = 0; j < dlSize; j++) {
                                {
                                    const dl = listeners.get(j);
                                    if (!dl['allow$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture'](aabb, body, fixture)) {
                                        allow = false;
                                    }
                                }
                                ;
                            }
                            if (!allow) {
                                continue;
                            }
                            const faabb = fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](transform);
                            if (aabb.overlaps(faabb)) {
                                const result = new org.dyn4j.dynamics.DetectResult(body, fixture);
                                results.add(result);
                                found = true;
                            }
                        }
                        ;
                    }
                    return found;
                }
                detect$org_dyn4j_geometry_Convex$java_util_List(convex, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, World.IDENTITY_$LI$(), null, false, true, false, results);
                }
                detect$org_dyn4j_geometry_Convex$boolean$java_util_List(convex, ignoreSensors, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, World.IDENTITY_$LI$(), null, ignoreSensors, true, false, results);
                }
                detect$org_dyn4j_geometry_Convex$boolean$boolean$java_util_List(convex, ignoreSensors, ignoreInactive, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, World.IDENTITY_$LI$(), null, ignoreSensors, ignoreInactive, false, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, filter, ignoreSensors, ignoreInactive, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, World.IDENTITY_$LI$(), filter, ignoreSensors, ignoreInactive, false, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, filter, ignoreSensors, ignoreInactive, includeCollisionData, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, World.IDENTITY_$LI$(), filter, ignoreSensors, ignoreInactive, includeCollisionData, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$java_util_List(convex, transform, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, null, false, true, false, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$boolean$java_util_List(convex, transform, ignoreSensors, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, null, ignoreSensors, true, false, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$boolean$boolean$java_util_List(convex, transform, ignoreSensors, ignoreInactive, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, null, ignoreSensors, ignoreInactive, false, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, transform, filter, ignoreSensors, ignoreInactive, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, filter, ignoreSensors, ignoreInactive, false, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, filter, ignoreSensors, ignoreInactive, includeCollisionData, results) {
                    const listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.DetectListener");
                    const dlSize = listeners.size();
                    let allow = true;
                    const aabb = convex['createAABB$org_dyn4j_geometry_Transform'](transform);
                    const bpFilter = new org.dyn4j.dynamics.AABBBroadphaseFilter(ignoreInactive, ignoreSensors, filter);
                    const items = this.broadphaseDetector['detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter'](aabb, bpFilter);
                    const bSize = items.size();
                    let found = false;
                    for (let i = 0; i < bSize; i++) {
                        {
                            const item = items.get(i);
                            const body = item.getCollidable();
                            const fixture = item.getFixture();
                            const bt = body.getTransform();
                            allow = true;
                            for (let j = 0; j < dlSize; j++) {
                                {
                                    const dl = listeners.get(j);
                                    if (!dl['allow$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture'](convex, transform, body, fixture)) {
                                        allow = false;
                                    }
                                }
                                ;
                            }
                            if (!allow) {
                                continue;
                            }
                            const bc = fixture.getShape();
                            let collision = false;
                            const penetration = (includeCollisionData ? new org.dyn4j.collision.narrowphase.Penetration() : null);
                            if (includeCollisionData) {
                                collision = this.narrowphaseDetector['detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration'](convex, transform, bc, bt, penetration);
                            }
                            else {
                                collision = this.narrowphaseDetector['detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform'](convex, transform, bc, bt);
                            }
                            if (collision) {
                                const result = new org.dyn4j.dynamics.DetectResult(body, fixture, penetration);
                                results.add(result);
                                found = true;
                            }
                        }
                        ;
                    }
                    return found;
                }
                detect$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$boolean$java_util_List(aabb, body, ignoreSensors, results) {
                    return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$java_util_List(aabb, body, null, ignoreSensors, results);
                }
                detect$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$java_util_List(aabb, body, filter, ignoreSensors, results) {
                    const listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.DetectListener");
                    const dlSize = listeners.size();
                    let allow = true;
                    let found = false;
                    let baabb = this.broadphaseDetector.getAABB(body);
                    if (baabb == null) {
                        baabb = body.createAABB$();
                    }
                    if (aabb.overlaps(baabb)) {
                        const transform = body.getTransform();
                        const fSize = body.getFixtureCount();
                        for (let j = 0; j < fSize; j++) {
                            {
                                const fixture = body.getFixture$int(j);
                                if (ignoreSensors && fixture.isSensor())
                                    continue;
                                if (filter != null && !filter.isAllowed(fixture.getFilter()))
                                    continue;
                                allow = true;
                                for (let k = 0; k < dlSize; k++) {
                                    {
                                        const dl = listeners.get(k);
                                        if (!dl['allow$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture'](aabb, body, fixture)) {
                                            allow = false;
                                        }
                                    }
                                    ;
                                }
                                if (!allow) {
                                    continue;
                                }
                                const faabb = fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](transform);
                                if (aabb.overlaps(faabb)) {
                                    const result = new org.dyn4j.dynamics.DetectResult(body, fixture);
                                    results.add(result);
                                    found = true;
                                }
                            }
                            ;
                        }
                    }
                    return found;
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$boolean$java_util_List(convex, body, ignoreSensors, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, World.IDENTITY_$LI$(), body, null, ignoreSensors, false, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$java_util_List(convex, body, filter, ignoreSensors, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, World.IDENTITY_$LI$(), body, filter, ignoreSensors, false, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, body, filter, ignoreSensors, includeCollisionData, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, World.IDENTITY_$LI$(), body, filter, ignoreSensors, includeCollisionData, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$boolean$java_util_List(convex, transform, body, ignoreSensors, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, transform, body, null, ignoreSensors, false, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$java_util_List(convex, transform, body, filter, ignoreSensors, results) {
                    return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, transform, body, filter, ignoreSensors, false, results);
                }
                detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, transform, body, filter, ignoreSensors, includeCollisionData, results) {
                    const listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.DetectListener");
                    const dlSize = listeners.size();
                    let allow = true;
                    for (let i = 0; i < dlSize; i++) {
                        {
                            const dl = listeners.get(i);
                            if (!dl['allow$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body'](convex, transform, body)) {
                                allow = false;
                            }
                        }
                        ;
                    }
                    if (!allow)
                        return false;
                    const aabb = convex['createAABB$org_dyn4j_geometry_Transform'](transform);
                    let baabb = this.broadphaseDetector.getAABB(body);
                    if (baabb == null) {
                        baabb = body.createAABB$();
                    }
                    let found = false;
                    if (aabb.overlaps(baabb)) {
                        const bt = body.getTransform();
                        const fSize = body.getFixtureCount();
                        for (let i = 0; i < fSize; i++) {
                            {
                                const fixture = body.getFixture$int(i);
                                if (ignoreSensors && fixture.isSensor())
                                    continue;
                                const ff = fixture.getFilter();
                                if (filter != null && !ff.isAllowed(filter))
                                    continue;
                                allow = true;
                                for (let j = 0; j < dlSize; j++) {
                                    {
                                        const dl = listeners.get(j);
                                        if (!dl['allow$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture'](convex, transform, body, fixture)) {
                                            allow = false;
                                        }
                                    }
                                    ;
                                }
                                if (!allow) {
                                    continue;
                                }
                                const bc = fixture.getShape();
                                let collision = false;
                                const penetration = (includeCollisionData ? new org.dyn4j.collision.narrowphase.Penetration() : null);
                                if (includeCollisionData) {
                                    collision = this.narrowphaseDetector['detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration'](convex, transform, bc, bt, penetration);
                                }
                                else {
                                    collision = this.narrowphaseDetector['detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform'](convex, transform, bc, bt);
                                }
                                if (collision) {
                                    const result = new org.dyn4j.dynamics.DetectResult(body, fixture, penetration);
                                    results.add(result);
                                    found = true;
                                }
                            }
                            ;
                        }
                    }
                    return found;
                }
                /**
                 * Returns true if the given {@link Convex} overlaps the given body in the world.
                 * <p>
                 * If this method returns true, the results list will contain the bodies and
                 * fixtures that the convex overlaps.
                 * <p>
                 * Use the {@link Body#isInContact(Body)} method instead if you want to test if two bodies
                 * are colliding.
                 * <p>
                 * Use the <code>includeCollisionData</code> parameter to have the {@link Penetration} object
                 * filled in the {@link DetectResult}s.  Including this information negatively impacts performance.
                 * @param {*} convex the {@link Convex} in local coordinates
                 * @param {org.dyn4j.geometry.Transform} transform the convex shape's world {@link Transform}
                 * @param {org.dyn4j.dynamics.Body} body the {@link Body} to test against
                 * @param {*} filter the {@link Filter} to use against the fixtures; can be null
                 * @param {boolean} includeCollisionData true if the overlap {@link Penetration} should be returned
                 * @param {boolean} ignoreSensors true if sensor fixtures should be ignored
                 * @param {*} results the list of overlapping bodies and fixtures
                 * @return {boolean} boolean true if an overlap was found
                 * @since 3.1.9
                 */
                detect(convex, transform, body, filter, ignoreSensors, includeCollisionData, results) {
                    if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((typeof includeCollisionData === 'boolean') || includeCollisionData === null) && ((results != null && (results.constructor != null && results.constructor["__interfaces"] != null && results.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || results === null)) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, transform, body, filter, ignoreSensors, includeCollisionData, results);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((body != null && (body.constructor != null && body.constructor["__interfaces"] != null && body.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || body === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((typeof includeCollisionData === 'boolean') || includeCollisionData === null) && ((results != null && (results.constructor != null && results.constructor["__interfaces"] != null && results.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || results === null)) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, body, filter, ignoreSensors, includeCollisionData, results);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((includeCollisionData != null && (includeCollisionData.constructor != null && includeCollisionData.constructor["__interfaces"] != null && includeCollisionData.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || includeCollisionData === null) && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$java_util_List(convex, transform, body, filter, ignoreSensors, includeCollisionData);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((body != null && (body.constructor != null && body.constructor["__interfaces"] != null && body.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || body === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((includeCollisionData != null && (includeCollisionData.constructor != null && includeCollisionData.constructor["__interfaces"] != null && includeCollisionData.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || includeCollisionData === null) && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, transform, body, filter, ignoreSensors, includeCollisionData);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.dynamics.Body) || transform === null) && ((body != null && (body.constructor != null && body.constructor["__interfaces"] != null && body.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || body === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((includeCollisionData != null && (includeCollisionData.constructor != null && includeCollisionData.constructor["__interfaces"] != null && includeCollisionData.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || includeCollisionData === null) && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, transform, body, filter, ignoreSensors, includeCollisionData);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && (transform.constructor != null && transform.constructor["__interfaces"] != null && transform.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || transform === null) && ((typeof body === 'boolean') || body === null) && ((typeof filter === 'boolean') || filter === null) && ((typeof ignoreSensors === 'boolean') || ignoreSensors === null) && ((includeCollisionData != null && (includeCollisionData.constructor != null && includeCollisionData.constructor["__interfaces"] != null && includeCollisionData.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || includeCollisionData === null) && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_collision_Filter$boolean$boolean$boolean$java_util_List(convex, transform, body, filter, ignoreSensors, includeCollisionData);
                    }
                    else if (((convex != null && convex instanceof org.dyn4j.geometry.AABB) || convex === null) && ((transform != null && transform instanceof org.dyn4j.dynamics.Body) || transform === null) && ((body != null && (body.constructor != null && body.constructor["__interfaces"] != null && body.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || body === null) && ((typeof filter === 'boolean') || filter === null) && ((ignoreSensors != null && (ignoreSensors.constructor != null && ignoreSensors.constructor["__interfaces"] != null && ignoreSensors.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreSensors === null) && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$java_util_List(convex, transform, body, filter, ignoreSensors);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.dynamics.Body) || transform === null) && ((body != null && (body.constructor != null && body.constructor["__interfaces"] != null && body.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || body === null) && ((typeof filter === 'boolean') || filter === null) && ((ignoreSensors != null && (ignoreSensors.constructor != null && ignoreSensors.constructor["__interfaces"] != null && ignoreSensors.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreSensors === null) && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$org_dyn4j_collision_Filter$boolean$java_util_List(convex, transform, body, filter, ignoreSensors);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((typeof filter === 'boolean') || filter === null) && ((ignoreSensors != null && (ignoreSensors.constructor != null && ignoreSensors.constructor["__interfaces"] != null && ignoreSensors.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreSensors === null) && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_dynamics_Body$boolean$java_util_List(convex, transform, body, filter, ignoreSensors);
                    }
                    else if (((convex != null && convex instanceof org.dyn4j.geometry.AABB) || convex === null) && ((transform != null && (transform.constructor != null && transform.constructor["__interfaces"] != null && transform.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || transform === null) && ((typeof body === 'boolean') || body === null) && ((typeof filter === 'boolean') || filter === null) && ((ignoreSensors != null && (ignoreSensors.constructor != null && ignoreSensors.constructor["__interfaces"] != null && ignoreSensors.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreSensors === null) && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, transform, body, filter, ignoreSensors);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && (transform.constructor != null && transform.constructor["__interfaces"] != null && transform.constructor["__interfaces"].indexOf("org.dyn4j.collision.Filter") >= 0)) || transform === null) && ((typeof body === 'boolean') || body === null) && ((typeof filter === 'boolean') || filter === null) && ((ignoreSensors != null && (ignoreSensors.constructor != null && ignoreSensors.constructor["__interfaces"] != null && ignoreSensors.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreSensors === null) && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_collision_Filter$boolean$boolean$java_util_List(convex, transform, body, filter, ignoreSensors);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((typeof body === 'boolean') || body === null) && ((typeof filter === 'boolean') || filter === null) && ((ignoreSensors != null && (ignoreSensors.constructor != null && ignoreSensors.constructor["__interfaces"] != null && ignoreSensors.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || ignoreSensors === null) && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$boolean$boolean$java_util_List(convex, transform, body, filter, ignoreSensors);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((typeof body === 'boolean') || body === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || filter === null) && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$boolean$java_util_List(convex, transform, body, filter);
                    }
                    else if (((convex != null && convex instanceof org.dyn4j.geometry.AABB) || convex === null) && ((transform != null && transform instanceof org.dyn4j.dynamics.Body) || transform === null) && ((typeof body === 'boolean') || body === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || filter === null) && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$boolean$java_util_List(convex, transform, body, filter);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.dynamics.Body) || transform === null) && ((typeof body === 'boolean') || body === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || filter === null) && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_dynamics_Body$boolean$java_util_List(convex, transform, body, filter);
                    }
                    else if (((convex != null && convex instanceof org.dyn4j.geometry.AABB) || convex === null) && ((typeof transform === 'boolean') || transform === null) && ((typeof body === 'boolean') || body === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || filter === null) && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_AABB$boolean$boolean$java_util_List(convex, transform, body, filter);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((typeof transform === 'boolean') || transform === null) && ((typeof body === 'boolean') || body === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || filter === null) && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$boolean$boolean$java_util_List(convex, transform, body, filter);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((body != null && (body.constructor != null && body.constructor["__interfaces"] != null && body.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || body === null) && filter === undefined && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$java_util_List(convex, transform, body);
                    }
                    else if (((convex != null && convex instanceof org.dyn4j.geometry.AABB) || convex === null) && ((typeof transform === 'boolean') || transform === null) && ((body != null && (body.constructor != null && body.constructor["__interfaces"] != null && body.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || body === null) && filter === undefined && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_AABB$boolean$java_util_List(convex, transform, body);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((typeof transform === 'boolean') || transform === null) && ((body != null && (body.constructor != null && body.constructor["__interfaces"] != null && body.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || body === null) && filter === undefined && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$boolean$java_util_List(convex, transform, body);
                    }
                    else if (((convex != null && convex instanceof org.dyn4j.geometry.AABB) || convex === null) && ((transform != null && (transform.constructor != null && transform.constructor["__interfaces"] != null && transform.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || transform === null) && body === undefined && filter === undefined && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_AABB$java_util_List(convex, transform);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((transform != null && (transform.constructor != null && transform.constructor["__interfaces"] != null && transform.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || transform === null) && body === undefined && filter === undefined && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$org_dyn4j_geometry_Convex$java_util_List(convex, transform);
                    }
                    else if (convex === undefined && transform === undefined && body === undefined && filter === undefined && ignoreSensors === undefined && includeCollisionData === undefined && results === undefined) {
                        return this.detect$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Shifts the coordinates of the entire world by the given amount.
                 * <pre>
                 * NewPosition = OldPosition + shift
                 * </pre>
                 * This method is useful in situations where the world is very large
                 * causing very large numbers to be used in the computations.  Shifting
                 * the coordinate system allows the computations to be localized and
                 * retain accuracy.
                 * <p>
                 * This method modifies the coordinates of every body and joint in the world.
                 * <p>
                 * Adding joints or bodies after this method is called should consider that
                 * everything has been shifted.
                 * <p>
                 * This method does <b>NOT</b> require a call to {@link #setUpdateRequired(boolean)}.
                 * @param {org.dyn4j.geometry.Vector2} shift the distance to shift along the x and y axes
                 * @since 3.2.0
                 */
                shift(shift) {
                    const bSize = this.bodies.size();
                    for (let i = 0; i < bSize; i++) {
                        {
                            const body = this.bodies.get(i);
                            body.shift(shift);
                        }
                        ;
                    }
                    const jSize = this.joints.size();
                    for (let i = 0; i < jSize; i++) {
                        {
                            const joint = this.joints.get(i);
                            joint.shift(shift);
                        }
                        ;
                    }
                    this.broadphaseDetector.shift(shift);
                    if (this.bounds != null) {
                        this.bounds.shift(shift);
                    }
                    this.contactManager.shift(shift);
                }
                /**
                 * Adds the given {@link Body} to the {@link World}.
                 * @param {org.dyn4j.dynamics.Body} body the {@link Body} to add
                 * @throws NullPointerException if body is null
                 * @throws IllegalArgumentException if body has already been added to this world or if its a member of another world instance
                 * @since 3.1.1
                 */
                addBody(body) {
                    if (body == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.addNullBody"));
                    if (body.world === this)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.world.addExistingBody"));
                    if (body.world != null)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.world.addOtherWorldBody"));
                    this.bodies.add(body);
                    body.world = this;
                    this.broadphaseDetector.add(body);
                }
                /**
                 * Adds the given {@link Joint} to the {@link World}.
                 * @param {org.dyn4j.dynamics.joint.Joint} joint the {@link Joint} to add
                 * @throws NullPointerException if joint is null
                 * @throws IllegalArgumentException if joint has already been added to this world or if its a member of another world instance
                 * @since 3.1.1
                 */
                addJoint(joint) {
                    if (joint == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.addNullJoint"));
                    const constraint = joint;
                    if (constraint.world === this)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.world.addExistingBody"));
                    if (constraint.world != null)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.world.addOtherWorldBody"));
                    this.joints.add(joint);
                    constraint.world = this;
                    const body1 = joint.getBody1();
                    const body2 = joint.getBody2();
                    const jointEdge1 = new org.dyn4j.dynamics.JointEdge(body2, joint);
                    body1.joints.add(jointEdge1);
                    const jointEdge2 = new org.dyn4j.dynamics.JointEdge(body1, joint);
                    body2.joints.add(jointEdge2);
                }
                /**
                 * Returns true if this world contains the given body.
                 * @param {org.dyn4j.dynamics.Body} body the {@link Body} to test for
                 * @return {boolean} boolean true if the body is contained in this world
                 * @since 3.1.1
                 */
                containsBody(body) {
                    return this.bodies.contains(body);
                }
                /**
                 * Returns true if this world contains the given joint.
                 * @param {org.dyn4j.dynamics.joint.Joint} joint the {@link Joint} to test for
                 * @return {boolean} boolean true if the joint is contained in this world
                 * @since 3.1.1
                 */
                containsJoint(joint) {
                    return this.joints.contains(joint);
                }
                removeBody$int(index) {
                    return this.removeBody$int$boolean(index, false);
                }
                removeBody$int$boolean(index, notify) {
                    const body = this.bodies.get(index);
                    return this.removeBody$org_dyn4j_dynamics_Body$boolean(body, notify);
                }
                removeBody$org_dyn4j_dynamics_Body(body) {
                    return this.removeBody$org_dyn4j_dynamics_Body$boolean(body, false);
                }
                removeBody$org_dyn4j_dynamics_Body$boolean(body, notify) {
                    let listeners = null;
                    if (notify) {
                        listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.DestructionListener");
                    }
                    if (body == null)
                        return false;
                    const removed = this.bodies.remove(body);
                    if (removed) {
                        body.world = null;
                        this.broadphaseDetector.remove(body);
                        const aIterator = body.joints.iterator();
                        while ((aIterator.hasNext())) {
                            {
                                const jointEdge = aIterator.next();
                                aIterator.remove();
                                const joint = jointEdge.interaction;
                                const constraint = joint;
                                constraint.world = null;
                                const other = jointEdge.other;
                                other.setAsleep(false);
                                const bIterator = other.joints.iterator();
                                while ((bIterator.hasNext())) {
                                    {
                                        const otherJointEdge = bIterator.next();
                                        const otherJoint = otherJointEdge.interaction;
                                        if (otherJoint === joint) {
                                            bIterator.remove();
                                            break;
                                        }
                                    }
                                }
                                ;
                                if (notify) {
                                    for (let index = listeners.iterator(); index.hasNext();) {
                                        let dl = index.next();
                                        {
                                            dl['destroyed$org_dyn4j_dynamics_joint_Joint'](joint);
                                        }
                                    }
                                }
                                this.joints.remove(joint);
                            }
                        }
                        ;
                        const acIterator = body.contacts.iterator();
                        while ((acIterator.hasNext())) {
                            {
                                const contactEdge = acIterator.next();
                                acIterator.remove();
                                const contactConstraint = contactEdge.interaction;
                                const other = contactEdge.other;
                                other.setAsleep(false);
                                const iterator = other.contacts.iterator();
                                while ((iterator.hasNext())) {
                                    {
                                        const otherContactEdge = iterator.next();
                                        const otherContactConstraint = otherContactEdge.interaction;
                                        if (otherContactConstraint === contactConstraint) {
                                            iterator.remove();
                                            break;
                                        }
                                    }
                                }
                                ;
                                this.contactManager.end(contactConstraint);
                                const contacts = contactConstraint.getContacts();
                                const size = contacts.size();
                                for (let j = 0; j < size; j++) {
                                    {
                                        const contact = contacts.get(j);
                                        const contactPoint = new org.dyn4j.dynamics.contact.ContactPoint(contactConstraint, contact);
                                        if (notify) {
                                            for (let index = listeners.iterator(); index.hasNext();) {
                                                let dl = index.next();
                                                {
                                                    dl['destroyed$org_dyn4j_dynamics_contact_ContactPoint'](contactPoint);
                                                }
                                            }
                                        }
                                        contactPoint.getBody1().setColliding(false, 0, null);
                                        contactPoint.getBody2().setColliding(false, 0, null);
                                    }
                                    ;
                                }
                            }
                        }
                        ;
                    }
                    return removed;
                }
                /**
                 * Removes the given {@link Body} from this {@link World}.
                 * <p>
                 * When a body is removed, joints and contacts may be implicitly destroyed.
                 * Pass true to the notify parameter to be notified of the destruction of these objects
                 * via the {@link DestructionListener}s.
                 * <p>
                 * This method does not trigger {@link ContactListener#end(ContactPoint)} events
                 * for the contacts that are being removed.
                 * @param {org.dyn4j.dynamics.Body} body the {@link Body} to remove
                 * @param {boolean} notify true if implicit destruction should be notified
                 * @return {boolean} boolean true if the body was removed
                 * @since 3.1.1
                 */
                removeBody(body, notify) {
                    if (((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((typeof notify === 'boolean') || notify === null)) {
                        return this.removeBody$org_dyn4j_dynamics_Body$boolean(body, notify);
                    }
                    else if (((typeof body === 'number') || body === null) && ((typeof notify === 'boolean') || notify === null)) {
                        return this.removeBody$int$boolean(body, notify);
                    }
                    else if (((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && notify === undefined) {
                        return this.removeBody$org_dyn4j_dynamics_Body(body);
                    }
                    else if (((typeof body === 'number') || body === null) && notify === undefined) {
                        return this.removeBody$int(body);
                    }
                    else
                        throw new Error('invalid overload');
                }
                removeJoint$int(index) {
                    const joint = this.joints.get(index);
                    return this.removeJoint$org_dyn4j_dynamics_joint_Joint(joint);
                }
                removeJoint$org_dyn4j_dynamics_joint_Joint(joint) {
                    if (joint == null)
                        return false;
                    const removed = this.joints.remove(joint);
                    if (removed) {
                        const constraint = joint;
                        constraint.world = null;
                        const body1 = joint.getBody1();
                        const body2 = joint.getBody2();
                        let iterator = body1.joints.iterator();
                        while ((iterator.hasNext())) {
                            {
                                const jointEdge = iterator.next();
                                if (jointEdge.interaction === joint) {
                                    iterator.remove();
                                    break;
                                }
                            }
                        }
                        ;
                        iterator = body2.joints.iterator();
                        while ((iterator.hasNext())) {
                            {
                                const jointEdge = iterator.next();
                                if (jointEdge.interaction === joint) {
                                    iterator.remove();
                                    break;
                                }
                            }
                        }
                        ;
                        body1.setAsleep(false);
                        body2.setAsleep(false);
                    }
                    return removed;
                }
                /**
                 * Removes the given {@link Joint} from this {@link World}.
                 * <p>
                 * No other objects are implicitly destroyed with joints are removed.
                 * @param {org.dyn4j.dynamics.joint.Joint} joint the {@link Joint} to remove
                 * @return {boolean} boolean true if the {@link Joint} was removed
                 */
                removeJoint(joint) {
                    if (((joint != null && joint instanceof org.dyn4j.dynamics.joint.Joint) || joint === null)) {
                        return this.removeJoint$org_dyn4j_dynamics_joint_Joint(joint);
                    }
                    else if (((typeof joint === 'number') || joint === null)) {
                        return this.removeJoint$int(joint);
                    }
                    else
                        throw new Error('invalid overload');
                }
                removeAllBodiesAndJoints$() {
                    this.removeAllBodiesAndJoints$boolean(false);
                }
                removeAllBodiesAndJoints$boolean(notify) {
                    let listeners = null;
                    if (notify) {
                        listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.DestructionListener");
                    }
                    const bsize = this.bodies.size();
                    for (let i = 0; i < bsize; i++) {
                        {
                            const body = this.bodies.get(i);
                            body.joints.clear();
                            if (notify) {
                                const aIterator = body.contacts.iterator();
                                while ((aIterator.hasNext())) {
                                    {
                                        const contactEdge = aIterator.next();
                                        const other = contactEdge.other;
                                        const contactConstraint = contactEdge.interaction;
                                        const bIterator = other.contacts.iterator();
                                        while ((bIterator.hasNext())) {
                                            {
                                                const otherContactEdge = bIterator.next();
                                                const otherContactConstraint = otherContactEdge.interaction;
                                                if (otherContactConstraint === contactConstraint) {
                                                    bIterator.remove();
                                                    break;
                                                }
                                            }
                                        }
                                        ;
                                        const contacts = contactConstraint.getContacts();
                                        const csize = contacts.size();
                                        for (let j = 0; j < csize; j++) {
                                            {
                                                const contact = contacts.get(j);
                                                const contactPoint = new org.dyn4j.dynamics.contact.ContactPoint(contactConstraint, contact);
                                                for (let index = listeners.iterator(); index.hasNext();) {
                                                    let dl = index.next();
                                                    {
                                                        dl['destroyed$org_dyn4j_dynamics_contact_ContactPoint'](contactPoint);
                                                    }
                                                }
                                            }
                                            ;
                                        }
                                    }
                                }
                                ;
                                for (let index = listeners.iterator(); index.hasNext();) {
                                    let dl = index.next();
                                    {
                                        dl['destroyed$org_dyn4j_dynamics_Body'](body);
                                    }
                                }
                            }
                            body.contacts.clear();
                            body.world = null;
                        }
                        ;
                    }
                    if (notify) {
                        const jsize = this.joints.size();
                        for (let i = 0; i < jsize; i++) {
                            {
                                const joint = this.joints.get(i);
                                const constraint = joint;
                                constraint.world = null;
                                for (let index = listeners.iterator(); index.hasNext();) {
                                    let dl = index.next();
                                    {
                                        dl['destroyed$org_dyn4j_dynamics_joint_Joint'](joint);
                                    }
                                }
                            }
                            ;
                        }
                    }
                    this.broadphaseDetector.clear();
                    this.joints.clear();
                    this.bodies.clear();
                    this.contactManager.clear();
                }
                /**
                 * Removes all the joints and bodies from this world.
                 * @param {boolean} notify true if destruction of joints and contacts should be notified of by the {@link DestructionListener}
                 * @since 3.1.1
                 */
                removeAllBodiesAndJoints(notify) {
                    if (((typeof notify === 'boolean') || notify === null)) {
                        return this.removeAllBodiesAndJoints$boolean(notify);
                    }
                    else if (notify === undefined) {
                        return this.removeAllBodiesAndJoints$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                removeAllBodies$() {
                    this.removeAllBodiesAndJoints$boolean(false);
                }
                removeAllBodies$boolean(notify) {
                    this.removeAllBodiesAndJoints$boolean(notify);
                }
                /**
                 * This is a convenience method for the {@link #removeAllBodiesAndJoints(boolean)} method since all joints will be removed
                 * when all bodies are removed anyway.
                 * @param {boolean} notify true if destruction of joints and contacts should be notified of by the {@link DestructionListener}
                 * @since 3.0.1
                 */
                removeAllBodies(notify) {
                    if (((typeof notify === 'boolean') || notify === null)) {
                        return this.removeAllBodies$boolean(notify);
                    }
                    else if (notify === undefined) {
                        return this.removeAllBodies$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                removeAllJoints$() {
                    this.removeAllJoints$boolean(false);
                }
                removeAllJoints$boolean(notify) {
                    let listeners = null;
                    if (notify) {
                        listeners = this.getListeners$java_lang_Class("org.dyn4j.dynamics.DestructionListener");
                    }
                    const jSize = this.joints.size();
                    for (let i = 0; i < jSize; i++) {
                        {
                            const joint = this.joints.get(i);
                            const constraint = joint;
                            constraint.world = null;
                            const body1 = joint.getBody1();
                            const body2 = joint.getBody2();
                            let iterator = body1.joints.iterator();
                            while ((iterator.hasNext())) {
                                {
                                    const jointEdge = iterator.next();
                                    if (jointEdge.interaction === joint) {
                                        iterator.remove();
                                        break;
                                    }
                                }
                            }
                            ;
                            iterator = body2.joints.iterator();
                            while ((iterator.hasNext())) {
                                {
                                    const jointEdge = iterator.next();
                                    if (jointEdge.interaction === joint) {
                                        iterator.remove();
                                        break;
                                    }
                                }
                            }
                            ;
                            body1.setAsleep(false);
                            body2.setAsleep(false);
                            if (notify) {
                                for (let index = listeners.iterator(); index.hasNext();) {
                                    let dl = index.next();
                                    {
                                        dl['destroyed$org_dyn4j_dynamics_joint_Joint'](joint);
                                    }
                                }
                            }
                        }
                        ;
                    }
                    this.joints.clear();
                }
                /**
                 * Removes all {@link Joint}s from this {@link World}.
                 * @param {boolean} notify true if destruction of joints should be notified of by the {@link DestructionListener}
                 * @since 3.0.1
                 */
                removeAllJoints(notify) {
                    if (((typeof notify === 'boolean') || notify === null)) {
                        return this.removeAllJoints$boolean(notify);
                    }
                    else if (notify === undefined) {
                        return this.removeAllJoints$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns true if upon the next time step the contacts must be updated.
                 * <p>
                 * This is typically set via user code when something about the simulation changes
                 * that can affect collision detection.
                 * @return {boolean} boolean
                 * @see #setUpdateRequired(boolean)
                 */
                isUpdateRequired() {
                    return this.updateRequired;
                }
                /**
                 * Sets the update required flag.
                 * <p>
                 * Set this flag to true if any of the following conditions have been met:
                 * <ul>
                 * <li>If a Body has been added or removed from the World</li>
                 * <li>If a Body has been translated or rotated</li>
                 * <li>If a Body's state has been manually changed via the Body.setActive(boolean) method</li>
                 * <li>If a BodyFixture has been added or removed from a Body</li>
                 * <li>If a BodyFixture's sensor flag has been manually changed via the BodyFixture.setSensor(boolean) method</li>
                 * <li>If a BodyFixture's filter has been manually changed via the BodyFixture.setFilter(boolean) method</li>
                 * <li>If a BodyFixture's restitution or friction coefficient has changed</li>
                 * <li>If a BodyFixture's Shape has been translated or rotated</li>
                 * <li>If a BodyFixture's Shape has been changed (vertices, radius, etc.)</li>
                 * <li>If a Body's type has changed to or from Static (this is caused by the using setMassType(Mass.INFINITE/Mass.NORMAL) method)</li>
                 * <li>If a Joint has been added or removed from the World in which the joined bodies should not be allowed to collide</li>
                 * <li>If the World's CoefficientMixer has been changed</li>
                 * </ul>
                 * @param {boolean} flag the flag
                 */
                setUpdateRequired(flag) {
                    this.updateRequired = flag;
                }
                /**
                 * Returns the world id.
                 * @deprecated ID schemes should be implemented by the user where needed; since 3.4.0
                 * @return {org.dyn4j.RandomUUID} UUID
                 * @since 3.2.0
                 */
                getId() {
                    return this.id;
                }
                /**
                 * Returns the settings for this world.
                 * @return {org.dyn4j.dynamics.Settings} {@link Settings}
                 * @since 3.0.3
                 */
                getSettings() {
                    return this.settings;
                }
                /**
                 * Sets the dynamics settings for this world.
                 * @param {org.dyn4j.dynamics.Settings} settings the desired settings
                 * @throws NullPointerException if the given settings is null
                 * @since 3.0.3
                 */
                setSettings(settings) {
                    if (settings == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullSettings"));
                    this.settings = settings;
                }
                /**
                 * Sets the acceleration due to gravity.
                 * @param {org.dyn4j.geometry.Vector2} gravity the gravity in meters/second<sup>2</sup>
                 * @throws NullPointerException if gravity is null
                 */
                setGravity(gravity) {
                    if (gravity == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullGravity"));
                    this.gravity = gravity;
                }
                /**
                 * Returns the acceleration due to gravity.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the gravity in meters/second<sup>2</sup>
                 */
                getGravity() {
                    return this.gravity;
                }
                /**
                 * Sets the bounds of this {@link World}.
                 * @param {*} bounds the bounds; can be null
                 */
                setBounds(bounds) {
                    this.bounds = bounds;
                }
                /**
                 * Returns the bounds of this world.
                 * <p>
                 * This will return null if no bounds were initially set
                 * or if it was set to null via the {@link #setBounds(Bounds)}
                 * method.
                 * @return {*} {@link Bounds} the bounds or null
                 */
                getBounds() {
                    return this.bounds;
                }
                getListeners$java_lang_Class(clazz) {
                    if (clazz == null)
                        return null;
                    const listeners = (new java.util.ArrayList());
                    this.getListeners$java_lang_Class$java_util_List(clazz, listeners);
                    return listeners;
                }
                getListeners$java_lang_Class$java_util_List(clazz, listeners) {
                    if (clazz == null || listeners == null)
                        return;
                    const lSize = this.listeners.size();
                    for (let i = 0; i < lSize; i++) {
                        {
                            const listener = this.listeners.get(i);
                            if (clazz.isInstance(listener)) {
                                listeners.add(clazz.cast(listener));
                            }
                        }
                        ;
                    }
                }
                /**
                 * Returns the listeners of the given type (or sub types) in the given list.
                 * <p>
                 * This method does <b>not</b> clear the given listeners list before
                 * adding the listeners.
                 * <p>
                 * If clazz or listeners is null, this method immediately returns.
                 * <p>
                 * Example usage:
                 * <pre>
                 * List&lt;ContactListener&gt; list = ...;
                 * world.getListeners(ContactListener.class, list);
                 * </pre>
                 * @param <T> the listener type
                 * @param {java.lang.Class} clazz the type of listener to get
                 * @param {*} listeners the list to add the listeners to
                 * @since 3.1.1
                 */
                getListeners(clazz, listeners) {
                    if (((clazz != null && (clazz["__class"] != null || ((t) => { try {
                        new t;
                        return true;
                    }
                    catch (_a) {
                        return false;
                    } })(clazz))) || clazz === null) && ((listeners != null && (listeners.constructor != null && listeners.constructor["__interfaces"] != null && listeners.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || listeners === null)) {
                        return this.getListeners$java_lang_Class$java_util_List(clazz, listeners);
                    }
                    else if (((clazz != null && (clazz["__class"] != null || ((t) => { try {
                        new t;
                        return true;
                    }
                    catch (_a) {
                        return false;
                    } })(clazz))) || clazz === null) && listeners === undefined) {
                        return this.getListeners$java_lang_Class(clazz);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Adds the given listener to the list of listeners.
                 * @param {*} listener the listener
                 * @throws NullPointerException if the given listener is null
                 * @throws IllegalArgumentException if the given listener has already been added to this world
                 * @since 3.1.0
                 */
                addListener(listener) {
                    if (listener == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullListener"));
                    if (this.listeners.contains(listener))
                        throw new java.lang.IllegalArgumentException("dynamics.world.addExistingListener");
                    this.listeners.add(listener);
                }
                /**
                 * Returns true if the given listener is already attached to this world.
                 * @param {*} listener the listener
                 * @return {boolean} boolean
                 * @since 3.1.1
                 */
                containsListener(listener) {
                    return this.listeners.contains(listener);
                }
                /**
                 * Removes the given listener from this world.
                 * @param {*} listener the listener to remove
                 * @return {boolean} boolean true if the listener was removed
                 * @since 3.1.0
                 */
                removeListener(listener) {
                    return this.listeners.remove(listener);
                }
                removeAllListeners$() {
                    const count = this.listeners.size();
                    this.listeners.clear();
                    return count;
                }
                removeAllListeners$java_lang_Class(clazz) {
                    if (clazz == null)
                        return 0;
                    if (this.listeners.isEmpty())
                        return 0;
                    let count = 0;
                    const listenerIterator = this.listeners.iterator();
                    while ((listenerIterator.hasNext())) {
                        {
                            const listener = listenerIterator.next();
                            if (clazz.isInstance(listener)) {
                                listenerIterator.remove();
                                count++;
                            }
                        }
                    }
                    ;
                    return count;
                }
                /**
                 * Removes all the listeners of the specified type (or sub types).
                 * <p>
                 * Returns zero if the given type is null or there are zero listeners
                 * attached.
                 * <p>
                 * Example usage:
                 * <pre>
                 * world.removeAllListeners(ContactListener.class);
                 * </pre>
                 * @param <T> the listener type
                 * @param {java.lang.Class} clazz the listener type
                 * @return {number} int the number of listeners removed
                 * @since 3.1.1
                 */
                removeAllListeners(clazz) {
                    if (((clazz != null && (clazz["__class"] != null || ((t) => { try {
                        new t;
                        return true;
                    }
                    catch (_a) {
                        return false;
                    } })(clazz))) || clazz === null)) {
                        return this.removeAllListeners$java_lang_Class(clazz);
                    }
                    else if (clazz === undefined) {
                        return this.removeAllListeners$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                getListenerCount$() {
                    return this.listeners.size();
                }
                getListenerCount$java_lang_Class(clazz) {
                    if (clazz == null)
                        return 0;
                    let count = 0;
                    const lSize = this.listeners.size();
                    for (let i = 0; i < lSize; i++) {
                        {
                            const listener = this.listeners.get(i);
                            if (clazz.isInstance(listener)) {
                                count++;
                            }
                        }
                        ;
                    }
                    return count;
                }
                /**
                 * Returns the total number of listeners of the given type (or sub types)
                 * attached to this world.
                 * <p>
                 * Returns zero if the given class type is null.
                 * <p>
                 * Example usage:
                 * <pre>
                 * world.getListenerCount(BoundsListener.class);
                 * </pre>
                 * @param <T> the listener type
                 * @param {java.lang.Class} clazz the listener type
                 * @return {number} int
                 * @since 3.1.1
                 */
                getListenerCount(clazz) {
                    if (((clazz != null && (clazz["__class"] != null || ((t) => { try {
                        new t;
                        return true;
                    }
                    catch (_a) {
                        return false;
                    } })(clazz))) || clazz === null)) {
                        return this.getListenerCount$java_lang_Class(clazz);
                    }
                    else if (clazz === undefined) {
                        return this.getListenerCount$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Sets the broad-phase collision detection algorithm.
                 * @param {*} broadphaseDetector the broad-phase collision detection algorithm
                 * @throws NullPointerException if broadphaseDetector is null
                 */
                setBroadphaseDetector(broadphaseDetector) {
                    if (broadphaseDetector == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullBroadphaseDetector"));
                    this.broadphaseDetector = broadphaseDetector;
                    const size = this.bodies.size();
                    for (let i = 0; i < size; i++) {
                        {
                            this.broadphaseDetector.add(this.bodies.get(i));
                        }
                        ;
                    }
                }
                /**
                 * Returns the broad-phase collision detection algorithm.
                 * @return {*} {@link BroadphaseDetector} the broad-phase collision detection algorithm
                 */
                getBroadphaseDetector() {
                    return this.broadphaseDetector;
                }
                /**
                 * Sets the {@link BroadphaseFilter} used when detecting collisions for each time step.
                 * <p>
                 * This should always be an instance of a class that extends the {@link DetectBroadphaseFilter}
                 * so that the standard filters are retained.
                 * @param {*} filter the filter
                 * @since 3.2.2
                 */
                setDetectBroadphaseFilter(filter) {
                    if (filter == null) {
                        this.detectBroadphaseFilter = new org.dyn4j.dynamics.DetectBroadphaseFilter();
                    }
                    else {
                        this.detectBroadphaseFilter = filter;
                    }
                }
                /**
                 * Returns the {@link BroadphaseFilter} used when detecting collisions for each time step.
                 * @return {*} {@link BroadphaseFilter}
                 * @since 3.2.2
                 */
                getDetectBroadphaseFilter() {
                    return this.detectBroadphaseFilter;
                }
                /**
                 * Sets the narrow-phase collision detection algorithm.
                 * @param {*} narrowphaseDetector the narrow-phase collision detection algorithm
                 * @throws NullPointerException if narrowphaseDetector is null
                 */
                setNarrowphaseDetector(narrowphaseDetector) {
                    if (narrowphaseDetector == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullNarrowphaseDetector"));
                    this.narrowphaseDetector = narrowphaseDetector;
                }
                /**
                 * Returns the narrow-phase collision detection algorithm.
                 * @return {*} {@link NarrowphaseDetector} the narrow-phase collision detection algorithm
                 */
                getNarrowphaseDetector() {
                    return this.narrowphaseDetector;
                }
                /**
                 * Sets the manifold solver.
                 * @param {*} manifoldSolver the manifold solver
                 * @throws NullPointerException if manifoldSolver is null
                 */
                setManifoldSolver(manifoldSolver) {
                    if (manifoldSolver == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullManifoldSolver"));
                    this.manifoldSolver = manifoldSolver;
                }
                /**
                 * Returns the manifold solver.
                 * @return {*} {@link ManifoldSolver} the manifold solver
                 */
                getManifoldSolver() {
                    return this.manifoldSolver;
                }
                /**
                 * Sets the time of impact detector.
                 * @param {*} timeOfImpactDetector the time of impact detector
                 * @throws NullPointerException if timeOfImpactDetector is null
                 * @since 1.2.0
                 */
                setTimeOfImpactDetector(timeOfImpactDetector) {
                    if (timeOfImpactDetector == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullTimeOfImpactDetector"));
                    this.timeOfImpactDetector = timeOfImpactDetector;
                }
                /**
                 * Returns the time of impact detector.
                 * @return {*} {@link TimeOfImpactDetector} the time of impact detector
                 * @since 1.2.0
                 */
                getTimeOfImpactDetector() {
                    return this.timeOfImpactDetector;
                }
                /**
                 * Sets the raycast detector.
                 * @param {*} raycastDetector the raycast detector
                 * @throws NullPointerException if raycastDetector is null
                 * @since 2.0.0
                 */
                setRaycastDetector(raycastDetector) {
                    if (raycastDetector == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullRaycastDetector"));
                    this.raycastDetector = raycastDetector;
                }
                /**
                 * Returns the raycast detector.
                 * @return {*} {@link RaycastDetector} the raycast detector
                 * @since 2.0.0
                 */
                getRaycastDetector() {
                    return this.raycastDetector;
                }
                /**
                 * Returns the {@link CoefficientMixer}.
                 * @return {*} {@link CoefficientMixer}
                 * @see #setCoefficientMixer(CoefficientMixer)
                 */
                getCoefficientMixer() {
                    return this.coefficientMixer;
                }
                /**
                 * Sets the {@link CoefficientMixer}.
                 * <p>
                 * A {@link CoefficientMixer} is an implementation of mixing functions for various
                 * coefficients used in contact solving.  Common coefficients are restitution and
                 * friction.  Since each {@link BodyFixture} can have it's own value for these
                 * coefficients, the {@link CoefficientMixer} is used to mathematically combine them
                 * into one coefficient to be used in contact resolution.
                 * <p>
                 * {@link CoefficientMixer#DEFAULT_MIXER} is the default.
                 * @param {*} coefficientMixer the coefficient mixer
                 * @throws NullPointerException if coefficientMixer is null
                 * @see CoefficientMixer
                 */
                setCoefficientMixer(coefficientMixer) {
                    if (coefficientMixer == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullCoefficientMixer"));
                    this.coefficientMixer = coefficientMixer;
                }
                /**
                 * Sets the {@link ContactManager}.
                 * <p>
                 * A {@link ContactManager} manages the contacts detected in the {@link World#detect()} method
                 * and performs notification of {@link ContactListener}s.  {@link ContactManager}s can also contain
                 * specialized logic for improving performance and simulation quality.
                 * <p>
                 * Changing the contact manager requires an update to be performed on the next update of this
                 * world and any cached information will be lost.
                 * <p>
                 * The default is the {@link DefaultContactManager}.
                 * @param {*} contactManager the contact manager
                 * @throws NullPointerException if contactManager is null
                 * @see ContactManager
                 * @since 3.2.0
                 */
                setContactManager(contactManager) {
                    if (contactManager == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullContactManager"));
                    this.contactManager = contactManager;
                    this.updateRequired = true;
                }
                /**
                 * Returns the {@link ContactManager}.
                 * @return {*} {@link ContactManager}
                 * @since 1.0.2
                 * @see #setContactManager(ContactManager)
                 */
                getContactManager() {
                    return this.contactManager;
                }
                /**
                 * Sets the {@link ContactConstraintSolver} for this world.
                 * @param {*} constraintSolver the contact constraint solver
                 * @throws NullPointerException if contactManager is null
                 * @see ContactConstraintSolver
                 * @since 3.2.0
                 */
                setContactConstraintSolver(constraintSolver) {
                    if (constraintSolver == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.world.nullContactConstraintSolver"));
                    this.contactConstraintSolver = constraintSolver;
                }
                /**
                 * Returns the {@link ContactConstraintSolver}.
                 * @return {*} {@link ContactConstraintSolver}
                 * @since 3.2.0
                 * @see #setContactConstraintSolver(ContactConstraintSolver)
                 */
                getContactConstraintSolver() {
                    return this.contactConstraintSolver;
                }
                getUserData() {
                    return this.userData;
                }
                setUserData(userData) {
                    this.userData = userData;
                }
                /**
                 * Returns the number of {@link Body}s in this {@link World}.
                 * @return {number} int the number of bodies
                 */
                getBodyCount() {
                    return this.bodies.size();
                }
                /**
                 * Returns the {@link Body} at the given index.
                 * @param {number} index the index
                 * @return {org.dyn4j.dynamics.Body} {@link Body}
                 */
                getBody(index) {
                    return this.bodies.get(index);
                }
                /**
                 * Returns an unmodifiable list containing all the bodies in this world.
                 * <p>
                 * The returned list is backed by the internal list, therefore adding or removing bodies while
                 * iterating through the returned list is not permitted.  Use the {@link #getBodyIterator()}
                 * method instead.
                 * @return {*} List&lt;{@link Body}&gt;
                 * @since 3.1.5
                 * @see #getBodyIterator()
                 */
                getBodies() {
                    return java.util.Collections.unmodifiableList(this.bodies);
                }
                /**
                 * Returns an iterator for iterating over the bodies in this world.
                 * <p>
                 * The returned iterator supports the <code>remove</code> method.
                 * @return {*} Iterator&lt;{@link Body}&gt;
                 * @since 3.2.0
                 */
                getBodyIterator() {
                    return new org.dyn4j.dynamics.BodyIterator(this);
                }
                /**
                 * Returns the number of {@link Joint}s in this {@link World}.
                 * @return {number} int the number of joints
                 */
                getJointCount() {
                    return this.joints.size();
                }
                /**
                 * Returns the {@link Joint} at the given index.
                 * @param {number} index the index
                 * @return {org.dyn4j.dynamics.joint.Joint} {@link Joint}
                 */
                getJoint(index) {
                    return this.joints.get(index);
                }
                /**
                 * Returns an unmodifiable list containing all the joints in this world.
                 * <p>
                 * The returned list is backed by the internal list, therefore adding or removing joints while
                 * iterating through the returned list is not permitted.  Use the {@link #getJointIterator()}
                 * method instead.
                 * @return {*} List&lt;{@link Joint}&gt;
                 * @since 3.1.5
                 * @see #getJointIterator()
                 */
                getJoints() {
                    return java.util.Collections.unmodifiableList(this.joints);
                }
                /**
                 * Returns an iterator for iterating over the joints in this world.
                 * <p>
                 * The returned iterator supports the <code>remove</code> method.
                 * @return {*} Iterator&lt;{@link Joint}&gt;
                 * @since 3.2.0
                 */
                getJointIterator() {
                    return new org.dyn4j.dynamics.JointIterator(this);
                }
                /**
                 * Returns the {@link Step} object used to advance
                 * the simulation.
                 * <p>
                 * The returned object contains the step information (elapsed time)
                 * for the last and the previous time step.
                 * @return {org.dyn4j.dynamics.Step} {@link Step} the current step object
                 */
                getStep() {
                    return this.__step;
                }
                /**
                 * Returns true if this world doesn't contain any
                 * bodies or joints.
                 * @return {boolean} boolean
                 * @since 3.0.1
                 */
                isEmpty() {
                    const bSize = this.bodies.size();
                    const jSize = this.joints.size();
                    return bSize === 0 && jSize === 0;
                }
                /**
                 * Returns the current accumulated time.
                 * <p>
                 * This is the time that has elapsed since the last step
                 * of the engine.
                 * <p>
                 * This time is used and/or accumulated on each call of the
                 * {@link #update(double)} and {@link #update(double, int)} methods.
                 * <p>
                 * This time is reduced by the step frequency for each step
                 * of the engine.
                 * @return {number} double
                 * @since 3.1.10
                 */
                getAccumulatedTime() {
                    return this.time;
                }
                /**
                 * Sets the current accumulated time.
                 * <p>
                 * A typical use case would be to throw away any remaining time
                 * that the {@link #update(double)} or {@link #update(double, int)}
                 * methods didn't use:
                 * <pre>
                 * boolean updated = world.update(elapsedTime);
                 * // the check if the world actually updated is crutial in this example
                 * if (updated) {
                 * // throw away any remaining time we didnt use
                 * world.setAccumulatedTime(0);
                 * }
                 * </pre>
                 * Or, in the case of reusing the same World object, you could use this
                 * method to clear any accumulated time.
                 * <p>
                 * If elapsedTime is less than zero, this method immediately returns.
                 * @see #getAccumulatedTime()
                 * @param {number} elapsedTime the desired elapsed time
                 * @since 3.1.10
                 */
                setAccumulatedTime(elapsedTime) {
                    if (elapsedTime < 0.0)
                        return;
                    this.time = elapsedTime;
                }
                /**
                 * Sorts the bodies list according to comparator
                 * @param {*} comp Comparator
                 */
                sortBodiesList(comp) {
                    java.util.Collections.sort(this.bodies, (((funcInst) => { if (typeof funcInst == 'function') {
                        return funcInst;
                    } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(comp)));
                }
            }
            dynamics.World = World;
            World["__class"] = "org.dyn4j.dynamics.World";
            World["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Optional constructor.
                 * @param {*} minkowskiPenetrationSolver the {@link MinkowskiPenetrationSolver} to use
                 * @throws NullPointerException if minkowskiPenetrationSolver is null
                 * @class
                 * @author William Bittle
                 */
                class Gjk {
                    constructor(minkowskiPenetrationSolver) {
                        if (((minkowskiPenetrationSolver != null && (minkowskiPenetrationSolver.constructor != null && minkowskiPenetrationSolver.constructor["__interfaces"] != null && minkowskiPenetrationSolver.constructor["__interfaces"].indexOf("org.dyn4j.collision.narrowphase.MinkowskiPenetrationSolver") >= 0)) || minkowskiPenetrationSolver === null)) {
                            let __args = arguments;
                            this.minkowskiPenetrationSolver = new org.dyn4j.collision.narrowphase.Epa();
                            this.maxDetectIterations = Gjk.DEFAULT_MAX_ITERATIONS;
                            this.maxDistanceIterations = Gjk.DEFAULT_MAX_ITERATIONS;
                            this.maxRaycastIterations = Gjk.DEFAULT_MAX_ITERATIONS;
                            this.detectEpsilon = Gjk.DEFAULT_DETECT_EPSILON;
                            this.distanceEpsilon = Gjk.DEFAULT_DISTANCE_EPSILON_$LI$();
                            this.raycastEpsilon = Gjk.DEFAULT_DISTANCE_EPSILON_$LI$();
                            if (minkowskiPenetrationSolver == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("collision.narrowphase.gjk.nullMinkowskiPenetrationSolver"));
                            this.minkowskiPenetrationSolver = minkowskiPenetrationSolver;
                        }
                        else if (minkowskiPenetrationSolver === undefined) {
                            let __args = arguments;
                            this.minkowskiPenetrationSolver = new org.dyn4j.collision.narrowphase.Epa();
                            this.maxDetectIterations = Gjk.DEFAULT_MAX_ITERATIONS;
                            this.maxDistanceIterations = Gjk.DEFAULT_MAX_ITERATIONS;
                            this.maxRaycastIterations = Gjk.DEFAULT_MAX_ITERATIONS;
                            this.detectEpsilon = Gjk.DEFAULT_DETECT_EPSILON;
                            this.distanceEpsilon = Gjk.DEFAULT_DISTANCE_EPSILON_$LI$();
                            this.raycastEpsilon = Gjk.DEFAULT_DISTANCE_EPSILON_$LI$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static ORIGIN_$LI$() { if (Gjk.ORIGIN == null) {
                        Gjk.ORIGIN = new org.dyn4j.geometry.Vector2();
                    } return Gjk.ORIGIN; }
                    static DEFAULT_DISTANCE_EPSILON_$LI$() { if (Gjk.DEFAULT_DISTANCE_EPSILON == null) {
                        Gjk.DEFAULT_DISTANCE_EPSILON = Math.sqrt(org.dyn4j.Epsilon.E_$LI$());
                    } return Gjk.DEFAULT_DISTANCE_EPSILON; }
                    static DEFAULT_RAYCAST_EPSILON_$LI$() { if (Gjk.DEFAULT_RAYCAST_EPSILON == null) {
                        Gjk.DEFAULT_RAYCAST_EPSILON = Gjk.DEFAULT_DISTANCE_EPSILON_$LI$();
                    } return Gjk.DEFAULT_RAYCAST_EPSILON; }
                    detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex1, transform1, convex2, transform2, penetration) {
                        if ((convex1 != null && convex1 instanceof org.dyn4j.geometry.Circle) && (convex2 != null && convex2 instanceof org.dyn4j.geometry.Circle)) {
                            return org.dyn4j.collision.narrowphase.CircleDetector.detect$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex1, transform1, convex2, transform2, penetration);
                        }
                        const simplex = (new java.util.ArrayList(3));
                        const ms = new org.dyn4j.collision.narrowphase.MinkowskiSum(convex1, transform1, convex2, transform2);
                        const d = this.getInitialDirection(convex1, transform1, convex2, transform2);
                        if (this.detect$org_dyn4j_collision_narrowphase_MinkowskiSum$java_util_List$org_dyn4j_geometry_Vector2(ms, simplex, d)) {
                            this.minkowskiPenetrationSolver.getPenetration(simplex, ms, penetration);
                            return true;
                        }
                        return false;
                    }
                    /**
                     *
                     * @param {*} convex1
                     * @param {org.dyn4j.geometry.Transform} transform1
                     * @param {*} convex2
                     * @param {org.dyn4j.geometry.Transform} transform2
                     * @param {org.dyn4j.collision.narrowphase.Penetration} penetration
                     * @return {boolean}
                     */
                    detect(convex1, transform1, convex2, transform2, penetration) {
                        if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && ((penetration != null && penetration instanceof org.dyn4j.collision.narrowphase.Penetration) || penetration === null)) {
                            return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_collision_narrowphase_Penetration(convex1, transform1, convex2, transform2, penetration);
                        }
                        else if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null) && penetration === undefined) {
                            return this.detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform(convex1, transform1, convex2, transform2);
                        }
                        else if (((convex1 != null && convex1 instanceof org.dyn4j.collision.narrowphase.MinkowskiSum) || convex1 === null) && ((transform1 != null && (transform1.constructor != null && transform1.constructor["__interfaces"] != null && transform1.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || transform1 === null) && ((convex2 != null && convex2 instanceof org.dyn4j.geometry.Vector2) || convex2 === null) && transform2 === undefined && penetration === undefined) {
                            return this.detect$org_dyn4j_collision_narrowphase_MinkowskiSum$java_util_List$org_dyn4j_geometry_Vector2(convex1, transform1, convex2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    detect$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Transform(convex1, transform1, convex2, transform2) {
                        if ((convex1 != null && convex1 instanceof org.dyn4j.geometry.Circle) && (convex2 != null && convex2 instanceof org.dyn4j.geometry.Circle)) {
                            return org.dyn4j.collision.narrowphase.CircleDetector.detect$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Circle$org_dyn4j_geometry_Transform(convex1, transform1, convex2, transform2);
                        }
                        const simplex = (new java.util.ArrayList(3));
                        const ms = new org.dyn4j.collision.narrowphase.MinkowskiSum(convex1, transform1, convex2, transform2);
                        const d = this.getInitialDirection(convex1, transform1, convex2, transform2);
                        return this.detect$org_dyn4j_collision_narrowphase_MinkowskiSum$java_util_List$org_dyn4j_geometry_Vector2(ms, simplex, d);
                    }
                    /**
                     * Returns a vector for the initial direction for the GJK algorithm in world coordinates.
                     * <p>
                     * This implementation returns the vector from the center of the first convex to the center of the second.
                     * @param {*} convex1 the first convex
                     * @param {org.dyn4j.geometry.Transform} transform1 the first convex's transform
                     * @param {*} convex2 the second convex
                     * @param {org.dyn4j.geometry.Transform} transform2 the second convex's transform
                     * @return {org.dyn4j.geometry.Vector2} Vector2
                     */
                    getInitialDirection(convex1, transform1, convex2, transform2) {
                        const c1 = transform1.getTransformed$org_dyn4j_geometry_Vector2(convex1.getCenter());
                        const c2 = transform2.getTransformed$org_dyn4j_geometry_Vector2(convex2.getCenter());
                        return c2.subtract$org_dyn4j_geometry_Vector2(c1);
                    }
                    detect$org_dyn4j_collision_narrowphase_MinkowskiSum$java_util_List$org_dyn4j_geometry_Vector2(ms, simplex, d) {
                        if (d.isZero())
                            d.set$double$double(1.0, 0.0);
                        simplex.add(ms.getSupportPoint(d));
                        if (simplex.get(0).dot$org_dyn4j_geometry_Vector2(d) <= 0.0) {
                            return false;
                        }
                        d.negate();
                        for (let i = 0; i < this.maxDetectIterations; i++) {
                            {
                                const supportPoint = ms.getSupportPoint(d);
                                simplex.add(supportPoint);
                                if (supportPoint.dot$org_dyn4j_geometry_Vector2(d) <= this.detectEpsilon) {
                                    return false;
                                }
                                else {
                                    if (this.checkSimplex(simplex, d)) {
                                        return true;
                                    }
                                }
                            }
                            ;
                        }
                        return false;
                    }
                    /**
                     * Determines whether the given simplex contains the origin.  If it does contain the origin,
                     * then this method will return true.  If it does not, this method will update both the given
                     * simplex and also the given search direction.
                     * <p>
                     * This method only handles the line segment and triangle simplex cases, however, these two cases
                     * should be the only ones needed for 2 dimensional {@link Gjk}.  The single point case is handled
                     * in {@link #detect(MinkowskiSum, List, Vector2)}.
                     * <p>
                     * This method also assumes that the last point in the simplex is the most recently added point.
                     * This matters because optimizations are available when you know this information.
                     * @param {*} simplex the simplex
                     * @param {org.dyn4j.geometry.Vector2} direction the search direction
                     * @return {boolean} boolean true if the simplex contains the origin
                     */
                    checkSimplex(simplex, direction) {
                        const a = simplex.get(simplex.size() - 1);
                        const ao = a.getNegative();
                        if (simplex.size() === 3) {
                            const b = simplex.get(1);
                            const c = simplex.get(0);
                            const ab = a.to$org_dyn4j_geometry_Vector2(b);
                            const ac = a.to$org_dyn4j_geometry_Vector2(c);
                            const acPerp = new org.dyn4j.geometry.Vector2();
                            const dot = ab.x * ac.y - ac.x * ab.y;
                            acPerp.x = -ac.y * dot;
                            acPerp.y = ac.x * dot;
                            const acLocation = acPerp.dot$org_dyn4j_geometry_Vector2(ao);
                            if (acLocation >= 0.0) {
                                simplex.remove(1);
                                direction.set$org_dyn4j_geometry_Vector2(acPerp);
                            }
                            else {
                                const abPerp = new org.dyn4j.geometry.Vector2();
                                abPerp.x = ab.y * dot;
                                abPerp.y = -ab.x * dot;
                                const abLocation = abPerp.dot$org_dyn4j_geometry_Vector2(ao);
                                if (abLocation < 0.0) {
                                    return true;
                                }
                                else {
                                    simplex.remove(0);
                                    direction.set$org_dyn4j_geometry_Vector2(abPerp);
                                }
                            }
                        }
                        else {
                            const b = simplex.get(0);
                            const ab = a.to$org_dyn4j_geometry_Vector2(b);
                            direction.set$org_dyn4j_geometry_Vector2(org.dyn4j.geometry.Vector2.tripleProduct(ab, ao, ab));
                            if (direction.getMagnitudeSquared() <= org.dyn4j.Epsilon.E_$LI$()) {
                                direction.set$org_dyn4j_geometry_Vector2(ab.left());
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @param {*} convex1
                     * @param {org.dyn4j.geometry.Transform} transform1
                     * @param {*} convex2
                     * @param {org.dyn4j.geometry.Transform} transform2
                     * @param {org.dyn4j.collision.narrowphase.Separation} separation
                     * @return {boolean}
                     */
                    distance(convex1, transform1, convex2, transform2, separation) {
                        if ((convex1 != null && convex1 instanceof org.dyn4j.geometry.Circle) && (convex2 != null && convex2 instanceof org.dyn4j.geometry.Circle)) {
                            return org.dyn4j.collision.narrowphase.CircleDetector.distance(convex1, transform1, convex2, transform2, separation);
                        }
                        const ms = new org.dyn4j.collision.narrowphase.MinkowskiSum(convex1, transform1, convex2, transform2);
                        let a = null;
                        let b = null;
                        let c = null;
                        const c1 = transform1.getTransformed$org_dyn4j_geometry_Vector2(convex1.getCenter());
                        const c2 = transform2.getTransformed$org_dyn4j_geometry_Vector2(convex2.getCenter());
                        let d = c1.to$org_dyn4j_geometry_Vector2(c2);
                        if (d.isZero())
                            return false;
                        a = ms.getSupportPoints(d);
                        d.negate();
                        b = ms.getSupportPoints(d);
                        d = org.dyn4j.geometry.Segment.getPointOnSegmentClosestToPoint(Gjk.ORIGIN_$LI$(), b.point, a.point);
                        for (let i = 0; i < this.maxDistanceIterations; i++) {
                            {
                                d.negate();
                                if (d.getMagnitudeSquared() <= org.dyn4j.Epsilon.E_$LI$()) {
                                    return false;
                                }
                                c = ms.getSupportPoints(d);
                                if (this.containsOrigin(a.point, b.point, c.point)) {
                                    return false;
                                }
                                const projection = c.point.dot$org_dyn4j_geometry_Vector2(d);
                                if ((projection - a.point.dot$org_dyn4j_geometry_Vector2(d)) < this.distanceEpsilon) {
                                    d.normalize();
                                    separation.normal = d;
                                    separation.distance = -c.point.dot$org_dyn4j_geometry_Vector2(d);
                                    this.findClosestPoints(a, b, separation);
                                    return true;
                                }
                                const p1 = org.dyn4j.geometry.Segment.getPointOnSegmentClosestToPoint(Gjk.ORIGIN_$LI$(), a.point, c.point);
                                const p2 = org.dyn4j.geometry.Segment.getPointOnSegmentClosestToPoint(Gjk.ORIGIN_$LI$(), c.point, b.point);
                                const p1Mag = p1.getMagnitudeSquared();
                                const p2Mag = p2.getMagnitudeSquared();
                                if (p1Mag <= org.dyn4j.Epsilon.E_$LI$()) {
                                    d.normalize();
                                    separation.distance = p1.normalize();
                                    separation.normal = d;
                                    this.findClosestPoints(a, c, separation);
                                    return true;
                                }
                                else if (p2Mag <= org.dyn4j.Epsilon.E_$LI$()) {
                                    d.normalize();
                                    separation.distance = p2.normalize();
                                    separation.normal = d;
                                    this.findClosestPoints(c, b, separation);
                                    return true;
                                }
                                if (p1Mag < p2Mag) {
                                    b = c;
                                    d = p1;
                                }
                                else {
                                    a = c;
                                    d = p2;
                                }
                            }
                            ;
                        }
                        d.normalize();
                        separation.normal = d;
                        separation.distance = -c.point.dot$org_dyn4j_geometry_Vector2(d);
                        this.findClosestPoints(a, b, separation);
                        return true;
                    }
                    /**
                     * Finds the closest points on A and B given the termination simplex and places
                     * them into point1 and point2 of the given {@link Separation} object.
                     * <p>
                     * The support points used to obtain a and b are not good enough since the support
                     * methods of {@link Convex} {@link Shape}s only return the farthest <em>vertex</em>, not
                     * necessarily the farthest point.
                     * @param {org.dyn4j.collision.narrowphase.MinkowskiSumPoint} a the first simplex point
                     * @param {org.dyn4j.collision.narrowphase.MinkowskiSumPoint} b the second simplex point
                     * @param {org.dyn4j.collision.narrowphase.Separation} separation the {@link Separation} object to populate
                     * @see <a href="http://www.dyn4j.org/2010/04/gjk-distance-closest-points/" target="_blank">GJK - Distance &amp; Closest Points</a>
                     */
                    findClosestPoints(a, b, separation) {
                        const p1 = new org.dyn4j.geometry.Vector2();
                        const p2 = new org.dyn4j.geometry.Vector2();
                        const l = a.point.to$org_dyn4j_geometry_Vector2(b.point);
                        if (l.isZero()) {
                            p1.set$org_dyn4j_geometry_Vector2(a.supportPoint1);
                            p2.set$org_dyn4j_geometry_Vector2(a.supportPoint2);
                        }
                        else {
                            const ll = l.dot$org_dyn4j_geometry_Vector2(l);
                            const l2 = -l.dot$org_dyn4j_geometry_Vector2(a.point) / ll;
                            if (l2 > 1) {
                                p1.set$org_dyn4j_geometry_Vector2(b.supportPoint1);
                                p2.set$org_dyn4j_geometry_Vector2(b.supportPoint2);
                            }
                            else if (l2 < 0) {
                                p1.set$org_dyn4j_geometry_Vector2(a.supportPoint1);
                                p2.set$org_dyn4j_geometry_Vector2(a.supportPoint2);
                            }
                            else {
                                p1.x = a.supportPoint1.x + l2 * (b.supportPoint1.x - a.supportPoint1.x);
                                p1.y = a.supportPoint1.y + l2 * (b.supportPoint1.y - a.supportPoint1.y);
                                p2.x = a.supportPoint2.x + l2 * (b.supportPoint2.x - a.supportPoint2.x);
                                p2.y = a.supportPoint2.y + l2 * (b.supportPoint2.y - a.supportPoint2.y);
                            }
                        }
                        separation.point1 = p1;
                        separation.point2 = p2;
                    }
                    /**
                     * Returns true if the origin is within the triangle given by
                     * a, b, and c.
                     * <p>
                     * If the origin lies on the same side of all the points then we
                     * know that the origin is in the triangle.
                     * <pre> sign(location(origin, a, b)) == sign(location(origin, b, c)) == sign(location(origin, c, a))</pre>
                     * The {@link Segment#getLocation(Vector2, Vector2, Vector2)} method
                     * can be simplified because we are using the origin as the search point:
                     * <pre> = (b.x - a.x) * (origin.y - a.y) - (origin.x - a.x) * (b.y - a.y)
                     * = (b.x - a.x) * (-a.y) - (-a.x) * (b.y - a.y)
                     * = -a.y * b.x + a.y * a.x + a.x * b.y - a.x * a.y
                     * = -a.y * b.x + a.x * b.y
                     * = a.x * b.y - a.y * b.x
                     * = a.cross(b)</pre>
                     * @param {org.dyn4j.geometry.Vector2} a the first point
                     * @param {org.dyn4j.geometry.Vector2} b the second point
                     * @param {org.dyn4j.geometry.Vector2} c the third point
                     * @return {boolean} boolean
                     */
                    containsOrigin(a, b, c) {
                        const sa = a.cross$org_dyn4j_geometry_Vector2(b);
                        const sb = b.cross$org_dyn4j_geometry_Vector2(c);
                        const sc = c.cross$org_dyn4j_geometry_Vector2(a);
                        return (sa * sb > 0 && sa * sc > 0);
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Ray} ray
                     * @param {number} maxLength
                     * @param {*} convex
                     * @param {org.dyn4j.geometry.Transform} transform
                     * @param {org.dyn4j.collision.narrowphase.Raycast} raycast
                     * @return {boolean}
                     */
                    raycast(ray, maxLength, convex, transform, raycast) {
                        if (convex != null && convex instanceof org.dyn4j.geometry.Circle) {
                            return org.dyn4j.collision.narrowphase.CircleDetector.raycast(ray, maxLength, convex, transform, raycast);
                        }
                        if (convex != null && convex instanceof org.dyn4j.geometry.Segment) {
                            return org.dyn4j.collision.narrowphase.SegmentDetector.raycast(ray, maxLength, convex, transform, raycast);
                        }
                        let lambda = 0;
                        const lengthCheck = maxLength > 0;
                        let a = null;
                        let b = null;
                        const start = ray.getStart();
                        let x = start;
                        const r = ray.getDirectionVector();
                        const n = new org.dyn4j.geometry.Vector2();
                        if (convex['contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform'](start, transform)) {
                            return false;
                        }
                        const c = transform.getTransformed$org_dyn4j_geometry_Vector2(convex.getCenter());
                        let d = c.to$org_dyn4j_geometry_Vector2(x);
                        let distanceSqrd = javaemul.internal.DoubleHelper.MAX_VALUE;
                        let iterations = 0;
                        while ((distanceSqrd > this.raycastEpsilon)) {
                            {
                                const p = convex.getFarthestPoint(d, transform);
                                const w = p.to$org_dyn4j_geometry_Vector2(x);
                                const dDotW = d.dot$org_dyn4j_geometry_Vector2(w);
                                if (dDotW > 0.0) {
                                    const dDotR = d.dot$org_dyn4j_geometry_Vector2(r);
                                    if (dDotR >= 0.0) {
                                        return false;
                                    }
                                    else {
                                        lambda = lambda - dDotW / dDotR;
                                        if (lengthCheck && lambda > maxLength) {
                                            return false;
                                        }
                                        x = r.product(lambda).add$org_dyn4j_geometry_Vector2(start);
                                        n.set$org_dyn4j_geometry_Vector2(d);
                                    }
                                }
                                if (a != null) {
                                    if (b != null) {
                                        const p1 = org.dyn4j.geometry.Segment.getPointOnSegmentClosestToPoint(x, a, p);
                                        const p2 = org.dyn4j.geometry.Segment.getPointOnSegmentClosestToPoint(x, p, b);
                                        if (p1.distanceSquared$org_dyn4j_geometry_Vector2(x) < p2.distanceSquared$org_dyn4j_geometry_Vector2(x)) {
                                            b.set$org_dyn4j_geometry_Vector2(p);
                                            distanceSqrd = p1.distanceSquared$org_dyn4j_geometry_Vector2(x);
                                        }
                                        else {
                                            a.set$org_dyn4j_geometry_Vector2(p);
                                            distanceSqrd = p2.distanceSquared$org_dyn4j_geometry_Vector2(x);
                                        }
                                        const ab = a.to$org_dyn4j_geometry_Vector2(b);
                                        const ax = a.to$org_dyn4j_geometry_Vector2(x);
                                        d = org.dyn4j.geometry.Vector2.tripleProduct(ab, ax, ab);
                                    }
                                    else {
                                        b = p;
                                        const ab = a.to$org_dyn4j_geometry_Vector2(b);
                                        const ax = a.to$org_dyn4j_geometry_Vector2(x);
                                        d = org.dyn4j.geometry.Vector2.tripleProduct(ab, ax, ab);
                                    }
                                }
                                else {
                                    a = p;
                                    d.negate();
                                }
                                if (iterations === this.maxRaycastIterations) {
                                    return false;
                                }
                                iterations++;
                            }
                        }
                        ;
                        raycast.point = x;
                        raycast.normal = n;
                        n.normalize();
                        raycast.distance = lambda;
                        return true;
                    }
                    /**
                     * Returns the maximum number of iterations the {@link Gjk} collision detection algorithm will perform
                     * before returning that two convex shapes are not overlapping.
                     * @return {number} int the number of {@link Gjk} detect iterations
                     * @see #setMaxDetectIterations(int)
                     * @since 3.3.0
                     */
                    getMaxDetectIterations() {
                        return this.maxDetectIterations;
                    }
                    /**
                     * Sets the maximum number of iterations the {@link Gjk} collision detection algorithm will perform when
                     * before return that two convex shapes are not overlapping.
                     * <p>
                     * Valid values are in the range [5, &infin;].
                     * @param {number} maxIterations the maximum number of {@link Gjk} detect iterations
                     * @throws IllegalArgumentException if maxIterations is less than 5
                     * @since 3.3.0
                     */
                    setMaxDetectIterations(maxIterations) {
                        if (maxIterations < 5)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.narrowphase.gjk.invalidMaximumIterations"));
                        this.maxDetectIterations = maxIterations;
                    }
                    /**
                     * Returns the maximum number of iterations the {@link Gjk} distance algorithm will perform
                     * before returning the distance between two separated convex shapes.
                     * @return {number} int the number of {@link Gjk} distance iterations
                     * @see #setMaxDistanceIterations(int)
                     * @since 3.3.0
                     */
                    getMaxDistanceIterations() {
                        return this.maxDistanceIterations;
                    }
                    /**
                     * Sets the maximum number of iterations the {@link Gjk} distance algorithm will perform when
                     * determining the distance between two convex shapes.
                     * <p>
                     * Valid values are in the range [5, &infin;].
                     * @param {number} maxIterations the maximum number of {@link Gjk} distance iterations
                     * @throws IllegalArgumentException if maxIterations is less than 5
                     * @since 3.3.0
                     */
                    setMaxDistanceIterations(maxIterations) {
                        if (maxIterations < 5)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.narrowphase.gjk.invalidMaximumIterations"));
                        this.maxDistanceIterations = maxIterations;
                    }
                    /**
                     * Returns the maximum number of iterations the {@link Gjk} raycast algorithm will perform
                     * before returning that the ray and the convex are not overlapping.
                     * @return {number} int the number of {@link Gjk} raycast iterations
                     * @see #setMaxRaycastIterations(int)
                     * @since 3.3.0
                     */
                    getMaxRaycastIterations() {
                        return this.maxRaycastIterations;
                    }
                    /**
                     * Sets the maximum number of iterations the {@link Gjk} raycast algorithm will perform when
                     * checking whether the ray intersects the convex.
                     * <p>
                     * Valid values are in the range [5, &infin;].
                     * @param {number} maxIterations the maximum number of {@link Gjk} raycast iterations
                     * @throws IllegalArgumentException if maxIterations is less than 5
                     * @since 3.3.0
                     */
                    setMaxRaycastIterations(maxIterations) {
                        if (maxIterations < 5)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.narrowphase.gjk.invalidMaximumIterations"));
                        this.maxRaycastIterations = maxIterations;
                    }
                    /**
                     * Returns the {@link Gjk} detect epsilon.
                     * @return {number} double the {@link Gjk} detect epsilon
                     * @see #setDetectEpsilon(double)
                     * @since 3.3.0
                     */
                    getDetectEpsilon() {
                        return this.detectEpsilon;
                    }
                    /**
                     * The minimum distance to determine that two shapes are not colliding.
                     * <p>
                     * Valid values are in the range [0, &infin;].
                     * @param {number} detectEpsilon the {@link Gjk} detect epsilon
                     * @throws IllegalArgumentException if detectEpsilon is less than zero
                     * @since 3.3.0
                     */
                    setDetectEpsilon(detectEpsilon) {
                        if (detectEpsilon < 0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.narrowphase.gjk.invalidDetectEpsilon"));
                        this.detectEpsilon = detectEpsilon;
                    }
                    /**
                     * Returns the {@link Gjk} raycast epsilon.
                     * @return {number} double the {@link Gjk} raycast epsilon
                     * @see #setRaycastEpsilon(double)
                     * @since 3.3.0
                     */
                    getRaycastEpsilon() {
                        return this.detectEpsilon;
                    }
                    /**
                     * The minimum distance between the ray and convex for the  {@link Gjk} raycast algorithm.
                     * <p>
                     * Valid values are in the range (0, &infin;].
                     * @param {number} raycastEpsilon the {@link Gjk} raycast epsilon
                     * @throws IllegalArgumentException if raycastEpsilon is less than or equal to zero
                     * @since 3.3.0
                     */
                    setRaycastEpsilon(raycastEpsilon) {
                        if (raycastEpsilon <= 0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.narrowphase.gjk.invalidDistanceEpsilon"));
                        this.raycastEpsilon = raycastEpsilon;
                    }
                    /**
                     * Returns the {@link Gjk} distance epsilon.
                     * @return {number} double the {@link Gjk} distance epsilon
                     * @see #setDistanceEpsilon(double)
                     */
                    getDistanceEpsilon() {
                        return this.distanceEpsilon;
                    }
                    /**
                     * The minimum distance between two iterations of the {@link Gjk} distance algorithm.
                     * <p>
                     * Valid values are in the range (0, &infin;].
                     * @param {number} distanceEpsilon the {@link Gjk} distance epsilon
                     * @throws IllegalArgumentException if distanceEpsilon is less than or equal to zero
                     */
                    setDistanceEpsilon(distanceEpsilon) {
                        if (distanceEpsilon <= 0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.narrowphase.gjk.invalidDistanceEpsilon"));
                        this.distanceEpsilon = distanceEpsilon;
                    }
                    /**
                     * Returns the {@link MinkowskiPenetrationSolver} used to obtain the
                     * penetration vector and depth.
                     * @return {*} {@link MinkowskiPenetrationSolver}
                     */
                    getMinkowskiPenetrationSolver() {
                        return this.minkowskiPenetrationSolver;
                    }
                    /**
                     * Sets the {@link MinkowskiPenetrationSolver} used to obtain the
                     * penetration vector and depth.
                     * @param {*} minkowskiPenetrationSolver the {@link MinkowskiPenetrationSolver}
                     * @throws NullPointerException if minkowskiPenetrationSolver is null
                     */
                    setMinkowskiPenetrationSolver(minkowskiPenetrationSolver) {
                        if (minkowskiPenetrationSolver == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("collision.narrowphase.gjk.nullMinkowskiPenetrationSolver"));
                        this.minkowskiPenetrationSolver = minkowskiPenetrationSolver;
                    }
                    /**
                     * Returns the maximum number of iterations the {@link Gjk} algorithm will perform when
                     * computing the distance between two separated bodies.
                     * @return {number} int the number of {@link Gjk} distance iterations
                     * @see #setMaxIterations(int)
                     * @deprecated replaced with {@link #getMaxDistanceIterations()} since 3.3.0
                     */
                    getMaxIterations() {
                        return this.maxDistanceIterations;
                    }
                    /**
                     * Sets the maximum number of iterations the {@link Gjk} algorithm will perform when
                     * computing the distance between two separated bodies.
                     * <p>
                     * Valid values are in the range [5, &infin;].
                     * @param {number} maxIterations the maximum number of {@link Gjk} iterations
                     * @throws IllegalArgumentException if maxIterations is less than 5
                     * @deprecated replaced with {@link #setMaxDistanceIterations(int)} since 3.3.0
                     */
                    setMaxIterations(maxIterations) {
                        if (maxIterations < 5)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.narrowphase.gjk.invalidMaximumIterations"));
                        this.maxDistanceIterations = maxIterations;
                    }
                }
                /**
                 * The default {@link Gjk} maximum iterations
                 */
                Gjk.DEFAULT_MAX_ITERATIONS = 30;
                /**
                 * The default epsilon in meters for collision detection
                 */
                Gjk.DEFAULT_DETECT_EPSILON = 0.0;
                narrowphase.Gjk = Gjk;
                Gjk["__class"] = "org.dyn4j.collision.narrowphase.Gjk";
                Gjk["__interfaces"] = ["org.dyn4j.collision.narrowphase.RaycastDetector", "org.dyn4j.collision.narrowphase.DistanceDetector", "org.dyn4j.collision.narrowphase.NarrowphaseDetector"];
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Creates an edge feature.
             * @param {org.dyn4j.geometry.PointFeature} vertex1 the first vertex of the edge
             * @param {org.dyn4j.geometry.PointFeature} vertex2 the second vertex of the edge
             * @param {org.dyn4j.geometry.PointFeature} max the maximum point
             * @param {org.dyn4j.geometry.Vector2} edge the vector representing the edge
             * @param {number} index the index of the edge
             * @class
             * @extends org.dyn4j.geometry.Feature
             * @author William Bittle
             */
            class EdgeFeature extends org.dyn4j.geometry.Feature {
                constructor(vertex1, vertex2, max, edge, index) {
                    super(index);
                    if (this.vertex1 === undefined) {
                        this.vertex1 = null;
                    }
                    if (this.vertex2 === undefined) {
                        this.vertex2 = null;
                    }
                    if (this.max === undefined) {
                        this.max = null;
                    }
                    if (this.edge === undefined) {
                        this.edge = null;
                    }
                    this.vertex1 = vertex1;
                    this.vertex2 = vertex2;
                    this.edge = edge;
                    this.max = max;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("EdgeFeature[Vertex1=").append(this.vertex1).append("|Vertex2=").append(this.vertex2).append("|Edge=").append(this.edge).append("|Max=").append(this.max).append("|Index=").append(this.index).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the first vertex of the edge.
                 * @return {org.dyn4j.geometry.PointFeature} {@link PointFeature}
                 */
                getVertex1() {
                    return this.vertex1;
                }
                /**
                 * Returns the second vertex of the edge.
                 * @return {org.dyn4j.geometry.PointFeature} {@link PointFeature}
                 */
                getVertex2() {
                    return this.vertex2;
                }
                /**
                 * Returns the vector representing this edge in
                 * counter-clockwise winding.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getEdge() {
                    return this.edge;
                }
                /**
                 * Returns the maximum point.
                 * @return {org.dyn4j.geometry.PointFeature} {@link PointFeature}
                 */
                getMaximum() {
                    return this.max;
                }
            }
            geometry.EdgeFeature = EdgeFeature;
            EdgeFeature["__class"] = "org.dyn4j.geometry.EdgeFeature";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * @param {org.dyn4j.geometry.Vector2} point the vertex point
             * @param {number} index the index
             * @class
             * @extends org.dyn4j.geometry.Feature
             * @author William Bittle
             */
            class PointFeature extends org.dyn4j.geometry.Feature {
                constructor(point, index) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((typeof index === 'number') || index === null)) {
                        let __args = arguments;
                        super(index);
                        if (this.point === undefined) {
                            this.point = null;
                        }
                        this.point = point;
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && index === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let index = org.dyn4j.geometry.Feature.NOT_INDEXED;
                            super(index);
                            if (this.point === undefined) {
                                this.point = null;
                            }
                            this.point = point;
                        }
                        if (this.point === undefined) {
                            this.point = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("PointFeature[Point=").append(this.point).append("|Index=").append(this.index).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the point.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getPoint() {
                    return this.point;
                }
            }
            geometry.PointFeature = PointFeature;
            PointFeature["__class"] = "org.dyn4j.geometry.PointFeature";
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Optional constructor.
             * <p>
             * Creates a new {@link Body} using the given estimated fixture count.
             * Assignment of the initial fixture count allows sizing of internal structures
             * for optimal memory/performance.  This estimated fixture count is <b>not</b> a
             * limit on the number of fixtures.
             * @param {number} fixtureCount the estimated number of fixtures
             * @throws IllegalArgumentException if fixtureCount less than zero
             * @since 3.1.1
             * @class
             * @extends org.dyn4j.collision.AbstractCollidable
             * @author William Bittle
             */
            class Body extends org.dyn4j.collision.AbstractCollidable {
                constructor(fixtureCount) {
                    if (((typeof fixtureCount === 'number') || fixtureCount === null)) {
                        let __args = arguments;
                        super(fixtureCount);
                        if (this.mass === undefined) {
                            this.mass = null;
                        }
                        if (this.velocity === undefined) {
                            this.velocity = null;
                        }
                        if (this.averageVelocity === undefined) {
                            this.averageVelocity = null;
                        }
                        if (this.angularVelocity === undefined) {
                            this.angularVelocity = 0;
                        }
                        if (this.averageAngularVelocity === undefined) {
                            this.averageAngularVelocity = 0;
                        }
                        if (this.linearDamping === undefined) {
                            this.linearDamping = 0;
                        }
                        if (this.angularDamping === undefined) {
                            this.angularDamping = 0;
                        }
                        if (this.gravityScale === undefined) {
                            this.gravityScale = 0;
                        }
                        if (this.transform0 === undefined) {
                            this.transform0 = null;
                        }
                        if (this.state === undefined) {
                            this.state = 0;
                        }
                        if (this.world === undefined) {
                            this.world = null;
                        }
                        if (this.sleepTime === undefined) {
                            this.sleepTime = 0;
                        }
                        if (this.force === undefined) {
                            this.force = null;
                        }
                        if (this.torque === undefined) {
                            this.torque = 0;
                        }
                        if (this.forces === undefined) {
                            this.forces = null;
                        }
                        if (this.torques === undefined) {
                            this.torques = null;
                        }
                        if (this.contacts === undefined) {
                            this.contacts = null;
                        }
                        if (this.joints === undefined) {
                            this.joints = null;
                        }
                        this.__isColliding = false;
                        this.collisionN = null;
                        this.world = null;
                        this.radius = 0.0;
                        this.mass = new org.dyn4j.geometry.Mass();
                        this.transform0 = new org.dyn4j.geometry.Transform();
                        this.velocity = new org.dyn4j.geometry.Vector2();
                        this.averageVelocity = new org.dyn4j.geometry.Vector2();
                        this.angularVelocity = 0.0;
                        this.averageAngularVelocity = 0.0;
                        this.force = new org.dyn4j.geometry.Vector2();
                        this.torque = 0.0;
                        this.forces = (new java.util.ArrayList(1));
                        this.torques = (new java.util.ArrayList(1));
                        this.state = (Body.AUTO_SLEEP | Body.ACTIVE);
                        this.sleepTime = 0.0;
                        this.linearDamping = Body.DEFAULT_LINEAR_DAMPING;
                        this.angularDamping = Body.DEFAULT_ANGULAR_DAMPING;
                        this.gravityScale = 1.0;
                        this.contacts = (new java.util.ArrayList(org.dyn4j.collision.Collisions.getEstimatedCollisionsPerObject()));
                        this.joints = (new java.util.ArrayList(0));
                    }
                    else if (fixtureCount === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let fixtureCount = org.dyn4j.collision.Collidable.TYPICAL_FIXTURE_COUNT;
                            super(fixtureCount);
                            if (this.mass === undefined) {
                                this.mass = null;
                            }
                            if (this.velocity === undefined) {
                                this.velocity = null;
                            }
                            if (this.averageVelocity === undefined) {
                                this.averageVelocity = null;
                            }
                            if (this.angularVelocity === undefined) {
                                this.angularVelocity = 0;
                            }
                            if (this.averageAngularVelocity === undefined) {
                                this.averageAngularVelocity = 0;
                            }
                            if (this.linearDamping === undefined) {
                                this.linearDamping = 0;
                            }
                            if (this.angularDamping === undefined) {
                                this.angularDamping = 0;
                            }
                            if (this.gravityScale === undefined) {
                                this.gravityScale = 0;
                            }
                            if (this.transform0 === undefined) {
                                this.transform0 = null;
                            }
                            if (this.state === undefined) {
                                this.state = 0;
                            }
                            if (this.world === undefined) {
                                this.world = null;
                            }
                            if (this.sleepTime === undefined) {
                                this.sleepTime = 0;
                            }
                            if (this.force === undefined) {
                                this.force = null;
                            }
                            if (this.torque === undefined) {
                                this.torque = 0;
                            }
                            if (this.forces === undefined) {
                                this.forces = null;
                            }
                            if (this.torques === undefined) {
                                this.torques = null;
                            }
                            if (this.contacts === undefined) {
                                this.contacts = null;
                            }
                            if (this.joints === undefined) {
                                this.joints = null;
                            }
                            this.__isColliding = false;
                            this.collisionN = null;
                            this.world = null;
                            this.radius = 0.0;
                            this.mass = new org.dyn4j.geometry.Mass();
                            this.transform0 = new org.dyn4j.geometry.Transform();
                            this.velocity = new org.dyn4j.geometry.Vector2();
                            this.averageVelocity = new org.dyn4j.geometry.Vector2();
                            this.angularVelocity = 0.0;
                            this.averageAngularVelocity = 0.0;
                            this.force = new org.dyn4j.geometry.Vector2();
                            this.torque = 0.0;
                            this.forces = (new java.util.ArrayList(1));
                            this.torques = (new java.util.ArrayList(1));
                            this.state = (Body.AUTO_SLEEP | Body.ACTIVE);
                            this.sleepTime = 0.0;
                            this.linearDamping = Body.DEFAULT_LINEAR_DAMPING;
                            this.angularDamping = Body.DEFAULT_ANGULAR_DAMPING;
                            this.gravityScale = 1.0;
                            this.contacts = (new java.util.ArrayList(org.dyn4j.collision.Collisions.getEstimatedCollisionsPerObject()));
                            this.joints = (new java.util.ArrayList(0));
                        }
                        if (this.mass === undefined) {
                            this.mass = null;
                        }
                        if (this.velocity === undefined) {
                            this.velocity = null;
                        }
                        if (this.averageVelocity === undefined) {
                            this.averageVelocity = null;
                        }
                        if (this.angularVelocity === undefined) {
                            this.angularVelocity = 0;
                        }
                        if (this.averageAngularVelocity === undefined) {
                            this.averageAngularVelocity = 0;
                        }
                        if (this.linearDamping === undefined) {
                            this.linearDamping = 0;
                        }
                        if (this.angularDamping === undefined) {
                            this.angularDamping = 0;
                        }
                        if (this.gravityScale === undefined) {
                            this.gravityScale = 0;
                        }
                        if (this.transform0 === undefined) {
                            this.transform0 = null;
                        }
                        if (this.state === undefined) {
                            this.state = 0;
                        }
                        if (this.world === undefined) {
                            this.world = null;
                        }
                        if (this.sleepTime === undefined) {
                            this.sleepTime = 0;
                        }
                        if (this.force === undefined) {
                            this.force = null;
                        }
                        if (this.torque === undefined) {
                            this.torque = 0;
                        }
                        if (this.forces === undefined) {
                            this.forces = null;
                        }
                        if (this.torques === undefined) {
                            this.torques = null;
                        }
                        if (this.contacts === undefined) {
                            this.contacts = null;
                        }
                        if (this.joints === undefined) {
                            this.joints = null;
                        }
                        this.__isColliding = false;
                        this.collisionN = null;
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Body[Id=").append(this.id).append("|Fixtures={");
                    const size = this.fixtures.size();
                    for (let i = 0; i < size; i++) {
                        {
                            if (i !== 0)
                                sb.append(",");
                            sb.append(this.fixtures.get(i));
                        }
                        ;
                    }
                    sb.append("}|InitialTransform=").append(this.transform0).append("|Transform=").append(this.transform).append("|RotationDiscRadius=").append(this.radius).append("|Mass=").append(this.mass).append("|Velocity=").append(this.velocity).append("|AngularVelocity=").append(this.angularVelocity).append("|Force=").append(this.force).append("|Torque=").append(this.torque).append("|AccumulatedForce=").append(this.getAccumulatedForce()).append("|AccumulatedTorque=").append(this.getAccumulatedTorque()).append("|IsAutoSleepingEnabled=").append(this.isAutoSleepingEnabled()).append("|IsAsleep=").append(this.isAsleep()).append("|IsActive=").append(this.isActive()).append("|IsBullet=").append(this.isBullet()).append("|LinearDamping=").append(this.linearDamping).append("|AngularDamping").append(this.angularDamping).append("|GravityScale=").append(this.gravityScale).append("]");
                    return sb.toString();
                }
                addFixture$org_dyn4j_geometry_Convex(convex) {
                    return this.addFixture$org_dyn4j_geometry_Convex$double$double$double(convex, org.dyn4j.dynamics.BodyFixture.DEFAULT_DENSITY, org.dyn4j.dynamics.BodyFixture.DEFAULT_FRICTION, org.dyn4j.dynamics.BodyFixture.DEFAULT_RESTITUTION);
                }
                addFixture$org_dyn4j_geometry_Convex$double(convex, density) {
                    return this.addFixture$org_dyn4j_geometry_Convex$double$double$double(convex, density, org.dyn4j.dynamics.BodyFixture.DEFAULT_FRICTION, org.dyn4j.dynamics.BodyFixture.DEFAULT_RESTITUTION);
                }
                addFixture$org_dyn4j_geometry_Convex$double$double$double(convex, density, friction, restitution) {
                    if (convex == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.addNullShape"));
                    const fixture = new org.dyn4j.dynamics.BodyFixture(convex);
                    fixture.setDensity(density);
                    fixture.setFriction(friction);
                    fixture.setRestitution(restitution);
                    this.fixtures.add(fixture);
                    if (this.world != null) {
                        this.world.broadphaseDetector.add(this, fixture);
                    }
                    return fixture;
                }
                /**
                 * Creates a {@link BodyFixture} for the given {@link Convex} {@link Shape},
                 * adds it to the {@link Body}, and returns it for configuration.
                 * <p>
                 * After adding or removing fixtures make sure to call the {@link #updateMass()}
                 * or {@link #setMassData(MassType)} method to compute the new total
                 * {@link Mass} for the body.
                 * <p>
                 * This is a convenience method for setting the properties of a {@link BodyFixture}.
                 * Use the {@link BodyFixture#DEFAULT_DENSITY}, {@link BodyFixture#DEFAULT_FRICTION},
                 * and {@link BodyFixture#DEFAULT_RESTITUTION} values if you need to only set one
                 * of these properties.
                 * @param {*} convex the {@link Convex} {@link Shape} to add to the {@link Body}
                 * @param {number} density the density of the shape in kg/m<sup>2</sup>; in the range (0.0, &infin;]
                 * @param {number} friction the coefficient of friction; in the range [0.0, &infin;]
                 * @param {number} restitution the coefficient of restitution; in the range [0.0, &infin;]
                 * @return {org.dyn4j.dynamics.BodyFixture} {@link BodyFixture} the fixture created using the given {@link Shape} and added to the {@link Body}
                 * @throws NullPointerException if convex is null
                 * @throws IllegalArgumentException if density is less than or equal to zero; if friction or restitution is less than zero
                 * @see #addFixture(Convex)
                 * @see #addFixture(Convex, double)
                 * @since 3.1.1
                 */
                addFixture(convex, density, friction, restitution) {
                    if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((typeof density === 'number') || density === null) && ((typeof friction === 'number') || friction === null) && ((typeof restitution === 'number') || restitution === null)) {
                        return this.addFixture$org_dyn4j_geometry_Convex$double$double$double(convex, density, friction, restitution);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && ((typeof density === 'number') || density === null) && friction === undefined && restitution === undefined) {
                        return this.addFixture$org_dyn4j_geometry_Convex$double(convex, density);
                    }
                    else if (((convex != null && (convex.constructor != null && convex.constructor["__interfaces"] != null && convex.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex === null) && density === undefined && friction === undefined && restitution === undefined) {
                        return this.addFixture$org_dyn4j_geometry_Convex(convex);
                    }
                    else if (((convex != null && convex instanceof org.dyn4j.dynamics.BodyFixture) || convex === null) && density === undefined && friction === undefined && restitution === undefined) {
                        return this.addFixture$org_dyn4j_dynamics_BodyFixture(convex);
                    }
                    else
                        throw new Error('invalid overload');
                }
                addFixture$org_dyn4j_dynamics_BodyFixture(fixture) {
                    if (fixture == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.addNullFixture"));
                    this.fixtures.add(fixture);
                    if (this.world != null) {
                        this.world.broadphaseDetector.add(this, fixture);
                    }
                    return this;
                }
                removeFixture$org_dyn4j_dynamics_BodyFixture(fixture) {
                    if (this.world != null) {
                        this.world.broadphaseDetector.remove(this, fixture);
                    }
                    return super.removeFixture(fixture);
                }
                /**
                 *
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture
                 * @return {boolean}
                 */
                removeFixture(fixture) {
                    if (((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null)) {
                        return this.removeFixture$org_dyn4j_dynamics_BodyFixture(fixture);
                    }
                    else if (((fixture != null && fixture instanceof org.dyn4j.geometry.Vector2) || fixture === null)) {
                        return this.removeFixture$org_dyn4j_geometry_Vector2(fixture);
                    }
                    else if (((fixture != null) || fixture === null)) {
                        return super.removeFixture(fixture);
                    }
                    else if (((fixture != null && fixture instanceof org.dyn4j.geometry.Vector2) || fixture === null)) {
                        return this.removeFixture$org_dyn4j_geometry_Vector2(fixture);
                    }
                    else if (((typeof fixture === 'number') || fixture === null)) {
                        return this.removeFixture$int(fixture);
                    }
                    else if (((typeof fixture === 'number') || fixture === null)) {
                        return this.removeFixture$int(fixture);
                    }
                    else
                        throw new Error('invalid overload');
                }
                removeFixture$int(index) {
                    const fixture = super.removeFixture$int(index);
                    if (this.world != null) {
                        this.world.broadphaseDetector.remove(this, fixture);
                    }
                    return fixture;
                }
                removeFixture$org_dyn4j_geometry_Vector2(point) {
                    const fixture = super.removeFixture$org_dyn4j_geometry_Vector2(point);
                    if (this.world != null) {
                        this.world.broadphaseDetector.remove(this, fixture);
                    }
                    return fixture;
                }
                /**
                 *
                 * @return {*}
                 */
                removeAllFixtures() {
                    const fixtures = super.removeAllFixtures();
                    if (this.world != null) {
                        this.world.broadphaseDetector.remove(this);
                    }
                    return fixtures;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} point
                 * @return {*}
                 */
                removeFixtures(point) {
                    const fixtures = super.removeFixtures(point);
                    if (this.world != null) {
                        const size = fixtures.size();
                        for (let i = 0; i < size; i++) {
                            {
                                this.world.broadphaseDetector.remove(this, fixtures.get(i));
                            }
                            ;
                        }
                    }
                    return fixtures;
                }
                setMassData$() {
                    return this.setMassData$org_dyn4j_geometry_MassType(org.dyn4j.geometry.MassType.NORMAL);
                }
                /**
                 * This is a shortcut method for the {@link #setMassData(org.dyn4j.geometry.MassType)}
                 * method that will use the current mass type as the mass type and
                 * then recompute the mass from the body's fixtures.
                 * @return {org.dyn4j.dynamics.Body} {@link Body} this body
                 * @since 3.2.0
                 * @see #setMassData(org.dyn4j.geometry.MassType)
                 */
                updateMass() {
                    return this.setMassData$org_dyn4j_geometry_MassType(this.mass.getType());
                }
                setMassData$org_dyn4j_geometry_MassType(type) {
                    if (type == null) {
                        type = this.mass.getType();
                    }
                    const size = this.fixtures.size();
                    if (size === 0) {
                        this.mass = new org.dyn4j.geometry.Mass();
                    }
                    else if (size === 1) {
                        this.mass = this.fixtures.get(0).createMass();
                    }
                    else {
                        const masses = (new java.util.ArrayList(size));
                        for (let i = 0; i < size; i++) {
                            {
                                const mass = this.fixtures.get(i).createMass();
                                masses.add(mass);
                            }
                            ;
                        }
                        this.mass = org.dyn4j.geometry.Mass.create(masses);
                    }
                    this.mass.setType(type);
                    this.setRotationDiscRadius();
                    this.velocity.set$double$double(this.mass.getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : this.velocity.x, this.mass.getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : this.velocity.y);
                    this.averageVelocity.set$org_dyn4j_geometry_Vector2(this.velocity);
                    return this;
                }
                /**
                 * This method should be called after fixture modification
                 * is complete.
                 * <p>
                 * This method will calculate a total mass for the body
                 * given the masses of the attached fixtures.
                 * <p>
                 * A {@link org.dyn4j.geometry.MassType} can be used to create special mass
                 * types.
                 * @param {org.dyn4j.geometry.MassType} type the mass type
                 * @return {org.dyn4j.dynamics.Body} {@link Body} this body
                 */
                setMassData(type) {
                    if (((typeof type === 'number') || type === null)) {
                        return this.setMassData$org_dyn4j_geometry_MassType(type);
                    }
                    else if (((type != null && type instanceof org.dyn4j.geometry.Mass) || type === null)) {
                        return this.setMassData$org_dyn4j_geometry_Mass(type);
                    }
                    else if (type === undefined) {
                        return this.setMassData$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                setMassData$org_dyn4j_geometry_Mass(mass) {
                    if (mass == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullMass"));
                    this.mass = mass;
                    this.setRotationDiscRadius();
                    this.velocity.set$double$double(mass.getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : this.velocity.x, mass.getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : this.velocity.y);
                    this.averageVelocity.set$org_dyn4j_geometry_Vector2(this.velocity);
                    return this;
                }
                /**
                 * Sets the {@link org.dyn4j.geometry.MassType} of this {@link Body}.
                 * <p>
                 * This method does not compute/recompute the mass of the body but solely
                 * sets the mass type to one of the special types.
                 * <p>
                 * Since its possible to create a {@link Mass} object with zero mass and/or
                 * zero inertia (<code>Mass m = new Mass(new Vector2(), 0, 0);</code> for example), setting the type
                 * to something other than MassType.INFINITE can have undefined results.
                 * @param {org.dyn4j.geometry.MassType} type the desired type
                 * @return {org.dyn4j.dynamics.Body} {@link Body} this body
                 * @throws NullPointerException if the given mass type is null
                 * @since 2.2.3
                 */
                setMassType(type) {
                    if (type == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullMassType"));
                    this.mass.setType(type);
                    this.setLinearVelocity$double$double(this.velocity.x, this.velocity.y);
                    return this;
                }
                /**
                 * Computes the rotation disc for this {@link Body}.
                 * <p>
                 * This method requires that the center of mass be computed first.
                 * <p>
                 * The rotation disc radius is the radius, from the center of mass,
                 * of the disc that encompasses the entire body as if it was rotated
                 * 360 degrees.
                 * @since 2.0.0
                 * @see #getRotationDiscRadius()
                 */
                setRotationDiscRadius() {
                    let r = 0.0;
                    const size = this.fixtures.size();
                    if (size === 0) {
                        this.radius = 0.0;
                        return;
                    }
                    const c = this.mass.getCenter();
                    for (let i = 0; i < size; i++) {
                        {
                            const fixture = this.fixtures.get(i);
                            const convex = fixture.getShape();
                            const cr = convex['getRadius$org_dyn4j_geometry_Vector2'](c);
                            r = Math.max(r, cr);
                        }
                        ;
                    }
                    this.radius = r;
                }
                /**
                 * Returns this {@link Body}'s mass information.
                 * @return {org.dyn4j.geometry.Mass} {@link Mass}
                 */
                getMassData() {
                    return this.mass;
                }
                applyForce$org_dyn4j_geometry_Vector2(force) {
                    if (force == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullForce"));
                    if (this.mass.getMass() === 0.0) {
                        return this;
                    }
                    this.forces.add(new org.dyn4j.dynamics.Force(force));
                    this.setAsleep(false);
                    return this;
                }
                applyForce$org_dyn4j_dynamics_Force(force) {
                    if (force == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullForce"));
                    if (this.mass.getMass() === 0.0) {
                        return this;
                    }
                    this.forces.add(force);
                    this.setAsleep(false);
                    return this;
                }
                applyTorque$double(torque) {
                    if (this.mass.getInertia() === 0.0) {
                        return this;
                    }
                    this.torques.add(new org.dyn4j.dynamics.Torque(torque));
                    this.setAsleep(false);
                    return this;
                }
                applyTorque$org_dyn4j_dynamics_Torque(torque) {
                    if (torque == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullTorque"));
                    if (this.mass.getInertia() === 0.0) {
                        return this;
                    }
                    this.torques.add(torque);
                    this.setAsleep(false);
                    return this;
                }
                /**
                 * Applies the given {@link Torque} to this {@link Body}.
                 * <p>
                 * This method will wake-up the body if its sleeping.
                 * <p>
                 * This method does not apply the torque if this body returns
                 * zero from the {@link Mass#getInertia()} method.
                 * <p>
                 * The torque is not applied immediately, but instead stored in the
                 * torque accumulator ({@link #getAccumulatedTorque()}).  This is to
                 * preserve the last time step's computed torque ({@link #getTorque()}.
                 * @param {org.dyn4j.dynamics.Torque} torque the torque
                 * @return {org.dyn4j.dynamics.Body} {@link Body} this body
                 * @throws NullPointerException if torque is null
                 * @since 3.1.1
                 */
                applyTorque(torque) {
                    if (((torque != null && torque instanceof org.dyn4j.dynamics.Torque) || torque === null)) {
                        return this.applyTorque$org_dyn4j_dynamics_Torque(torque);
                    }
                    else if (((typeof torque === 'number') || torque === null)) {
                        return this.applyTorque$double(torque);
                    }
                    else
                        throw new Error('invalid overload');
                }
                applyForce$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(force, point) {
                    if (force == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullForceForTorque"));
                    if (point == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullPointForTorque"));
                    let awaken = false;
                    if (this.mass.getMass() !== 0.0) {
                        this.forces.add(new org.dyn4j.dynamics.Force(force));
                        awaken = true;
                    }
                    if (this.mass.getInertia() !== 0.0) {
                        const r = this.getWorldCenter().to$org_dyn4j_geometry_Vector2(point);
                        if (!r.isZero()) {
                            const tao = r.cross$org_dyn4j_geometry_Vector2(force);
                            this.torques.add(new org.dyn4j.dynamics.Torque(tao));
                            awaken = true;
                        }
                    }
                    if (awaken) {
                        this.setAsleep(false);
                    }
                    return this;
                }
                /**
                 * Applies the given force to this {@link Body} at the
                 * given point (torque).
                 * <p>
                 * This method will wake-up the body if its sleeping.
                 * <p>
                 * This method does not apply the force if this body
                 * returns zero from the {@link Mass#getMassData()} method nor
                 * will it apply the torque if this body returns
                 * zero from the {@link Mass#getInertia()} method.
                 * <p>
                 * The force/torque is not applied immediately, but instead stored in the
                 * force/torque accumulators ({@link #getAccumulatedForce()} and
                 * {@link #getAccumulatedTorque()}).  This is to preserve the last time
                 * step's computed force ({@link #getForce()} and torque ({@link #getTorque()}).
                 * <p>
                 * The force and point are assumed to be in world space coordinates.
                 * @param {org.dyn4j.geometry.Vector2} force the force
                 * @param {org.dyn4j.geometry.Vector2} point the application point in world coordinates
                 * @return {org.dyn4j.dynamics.Body} {@link Body} this body
                 * @throws NullPointerException if force or point is null
                 * @since 3.1.1
                 */
                applyForce(force, point) {
                    if (((force != null && force instanceof org.dyn4j.geometry.Vector2) || force === null) && ((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null)) {
                        return this.applyForce$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(force, point);
                    }
                    else if (((force != null && force instanceof org.dyn4j.geometry.Vector2) || force === null) && point === undefined) {
                        return this.applyForce$org_dyn4j_geometry_Vector2(force);
                    }
                    else if (((force != null && force instanceof org.dyn4j.dynamics.Force) || force === null) && point === undefined) {
                        return this.applyForce$org_dyn4j_dynamics_Force(force);
                    }
                    else
                        throw new Error('invalid overload');
                }
                applyImpulse$org_dyn4j_geometry_Vector2(impulse) {
                    if (impulse == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullImpulse"));
                    const invM = this.mass.getInverseMass();
                    if (invM === 0.0) {
                        return this;
                    }
                    impulse.set$double$double(this.mass.getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : impulse.x, this.mass.getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : impulse.y);
                    this.velocity.add$double$double(this.mass.getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : impulse.x * invM, this.mass.getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : impulse.y * invM);
                    this.setAsleep(false);
                    return this;
                }
                applyImpulse$double(impulse) {
                    const invI = this.mass.getInverseInertia();
                    if (invI === 0.0) {
                        return this;
                    }
                    this.angularVelocity += invI * impulse;
                    this.setAsleep(false);
                    return this;
                }
                applyImpulse$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(impulse, point) {
                    if (impulse == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullImpulse"));
                    if (point == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullPointForImpulse"));
                    let awaken = false;
                    impulse.set$double$double(this.mass.getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : impulse.x, this.mass.getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : impulse.y);
                    const invM = this.mass.getInverseMass();
                    const invI = this.mass.getInverseInertia();
                    if (invM !== 0.0) {
                        this.velocity.add$double$double(impulse.x * invM, impulse.y * invM);
                        awaken = true;
                    }
                    if (invI !== 0.0) {
                        const r = this.getWorldCenter().to$org_dyn4j_geometry_Vector2(point);
                        this.angularVelocity += invI * r.cross$org_dyn4j_geometry_Vector2(impulse);
                        awaken = true;
                    }
                    if (awaken) {
                        this.setAsleep(false);
                    }
                    return this;
                }
                /**
                 * Applies an impulse to this {@link Body} at the given point.
                 * <p>
                 * This method will wake-up the body if its sleeping.
                 * <p>
                 * This method does not apply the linear impulse if this body
                 * returns zero from the {@link Mass#getMassData()} method nor
                 * will it apply the angular impulse if this body returns
                 * zero from the {@link Mass#getInertia()} method.
                 * <p>
                 * <b>NOTE:</b> Applying an impulse differs from applying a force and/or torque. Forces
                 * and torques are stored in accumulators, but impulses are applied to the
                 * velocities of the body immediately.
                 * <p>
                 * The impulse and point are assumed to be in world space coordinates.
                 * @param {org.dyn4j.geometry.Vector2} impulse the impulse to apply
                 * @param {org.dyn4j.geometry.Vector2} point the world space point to apply the impulse
                 * @return {org.dyn4j.dynamics.Body} {@link Body} this body
                 * @throws NullPointerException if impulse or point is null
                 * @since 3.1.1
                 */
                applyImpulse(impulse, point) {
                    if (((impulse != null && impulse instanceof org.dyn4j.geometry.Vector2) || impulse === null) && ((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null)) {
                        return this.applyImpulse$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(impulse, point);
                    }
                    else if (((impulse != null && impulse instanceof org.dyn4j.geometry.Vector2) || impulse === null) && point === undefined) {
                        return this.applyImpulse$org_dyn4j_geometry_Vector2(impulse);
                    }
                    else if (((typeof impulse === 'number') || impulse === null) && point === undefined) {
                        return this.applyImpulse$double(impulse);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Clears the last time step's force on the {@link Body}.
                 */
                clearForce() {
                    this.force.zero();
                }
                /**
                 * Clears the forces stored in the force accumulator.
                 * <p>
                 * Renamed from clearForces (3.0.0 and below).
                 * @since 3.0.1
                 */
                clearAccumulatedForce() {
                    this.forces.clear();
                }
                /**
                 * Clears the last time step's torque on the {@link Body}.
                 */
                clearTorque() {
                    this.torque = 0.0;
                }
                /**
                 * Clears the torques stored in the torque accumulator.
                 * <p>
                 * Renamed from clearTorques (3.0.0 and below).
                 * @since 3.0.1
                 */
                clearAccumulatedTorque() {
                    this.torques.clear();
                }
                /**
                 * Accumulates the forces and torques.
                 * @param {number} elapsedTime the elapsed time since the last call
                 * @since 3.1.0
                 */
                accumulate(elapsedTime) {
                    this.force.zero();
                    let size = this.forces.size();
                    if (size > 0) {
                        const it = this.forces.iterator();
                        while ((it.hasNext())) {
                            {
                                const force = it.next();
                                this.force.add$org_dyn4j_geometry_Vector2(force.force);
                                if (force.isComplete(elapsedTime)) {
                                    it.remove();
                                }
                            }
                        }
                        ;
                    }
                    this.torque = 0.0;
                    size = this.torques.size();
                    if (size > 0) {
                        const it = this.torques.iterator();
                        while ((it.hasNext())) {
                            {
                                const torque = it.next();
                                this.torque += torque.torque;
                                if (torque.isComplete(elapsedTime)) {
                                    it.remove();
                                }
                            }
                        }
                        ;
                    }
                }
                /**
                 * Returns true if this body has infinite mass and
                 * the velocity and angular velocity is zero.
                 * @return {boolean} boolean
                 */
                isStatic() {
                    return this.mass.getType() === org.dyn4j.geometry.MassType.INFINITE && Math.abs(this.velocity.x) <= org.dyn4j.Epsilon.E_$LI$() && Math.abs(this.velocity.y) <= org.dyn4j.Epsilon.E_$LI$() && Math.abs(this.angularVelocity) <= org.dyn4j.Epsilon.E_$LI$();
                }
                /**
                 * Returns true if this body has infinite mass and
                 * the velocity or angular velocity are NOT zero.
                 * @return {boolean} boolean
                 */
                isKinematic() {
                    return this.mass.getType() === org.dyn4j.geometry.MassType.INFINITE && (Math.abs(this.velocity.x) > org.dyn4j.Epsilon.E_$LI$() || Math.abs(this.velocity.y) > org.dyn4j.Epsilon.E_$LI$() || Math.abs(this.angularVelocity) > org.dyn4j.Epsilon.E_$LI$());
                }
                /**
                 * Returns true if this body does not have infinite mass.
                 * @return {boolean} boolean
                 */
                isDynamic() {
                    return this.mass.getType() !== org.dyn4j.geometry.MassType.INFINITE;
                }
                /**
                 * Returns whether 'state' has all the bits indicated by the binary mask 'mask' set.
                 *
                 * @param {number} mask The binary mask to select bits
                 * @return {boolean} boolean
                 */
                getState(mask) {
                    return (this.state & mask) === mask;
                }
                /**
                 * Sets (if flag == true) or clears (if flag == false) the bits indicated by the binary mask 'mask' in the 'state' field.
                 * @param {number} mask the binary mask to select bits
                 * @param {boolean} flag true to set, false to clear bits
                 */
                setState(mask, flag) {
                    if (flag) {
                        this.state |= mask;
                    }
                    else {
                        this.state &= ~mask;
                    }
                }
                /**
                 * Sets the {@link Body} to allow or disallow automatic sleeping.
                 * @param {boolean} flag true if the {@link Body} is allowed to sleep
                 * @since 1.2.0
                 */
                setAutoSleepingEnabled(flag) {
                    this.setState(Body.AUTO_SLEEP, flag);
                }
                /**
                 * Returns true if this {@link Body} is allowed to be
                 * put to sleep automatically.
                 * @return {boolean} boolean
                 * @since 1.2.0
                 */
                isAutoSleepingEnabled() {
                    return this.getState(Body.AUTO_SLEEP);
                }
                /**
                 * Returns true if this {@link Body} is sleeping.
                 * @return {boolean} boolean
                 */
                isAsleep() {
                    return this.getState(Body.ASLEEP);
                }
                /**
                 * Sets whether this {@link Body} is awake or not.
                 * <p>
                 * If flag is true, this body's velocity, angular velocity,
                 * force, torque, and accumulators are cleared.
                 * @param {boolean} flag true if the body should be put to sleep
                 */
                setAsleep(flag) {
                    if (flag) {
                        this.setState(Body.ASLEEP, true);
                        this.velocity.zero();
                        this.angularVelocity = 0.0;
                        this.forces.clear();
                        this.torques.clear();
                    }
                    else {
                        if (this.getState(Body.ASLEEP)) {
                            this.sleepTime = 0.0;
                            this.setState(Body.ASLEEP, false);
                        }
                    }
                }
                /**
                 * Returns true if this {@link Body} is active.
                 * @return {boolean} boolean
                 */
                isActive() {
                    return this.getState(Body.ACTIVE);
                }
                /**
                 * Sets whether this {@link Body} is active or not.
                 * @param {boolean} flag true if this {@link Body} should be active
                 */
                setActive(flag) {
                    this.setState(Body.ACTIVE, flag);
                }
                /**
                 * Returns true if this {@link Body} has been added to an {@link Island}.
                 * @return {boolean} boolean true if this {@link Body} has been added to an {@link Island}
                 */
                isOnIsland() {
                    return this.getState(Body.ISLAND);
                }
                /**
                 * Sets the flag indicating that the {@link Body} has been added to an {@link Island}.
                 * @param {boolean} flag true if the {@link Body} has been added to an {@link Island}
                 */
                setOnIsland(flag) {
                    this.setState(Body.ISLAND, flag);
                }
                /**
                 * Returns true if this {@link Body} is a bullet.
                 * @see #setBullet(boolean)
                 * @return {boolean} boolean
                 * @since 1.2.0
                 */
                isBullet() {
                    return this.getState(Body.BULLET);
                }
                /**
                 * Sets the bullet flag for this {@link Body}.
                 * <p>
                 * A bullet is a very fast moving body that requires
                 * continuous collision detection with <b>all</b> other
                 * {@link Body}s to ensure that no collisions are missed.
                 * @param {boolean} flag true if this {@link Body} is a bullet
                 * @since 1.2.0
                 */
                setBullet(flag) {
                    this.setState(Body.BULLET, flag);
                }
                isConnected$org_dyn4j_dynamics_Body(body) {
                    if (body == null)
                        return false;
                    const size = this.joints.size();
                    if (size === 0)
                        return false;
                    for (let i = 0; i < size; i++) {
                        {
                            const je = this.joints.get(i);
                            if (je.other === body) {
                                return true;
                            }
                        }
                        ;
                    }
                    return false;
                }
                isConnected$org_dyn4j_dynamics_Body$boolean(body, collisionAllowed) {
                    if (body == null)
                        return false;
                    const size = this.joints.size();
                    if (size === 0)
                        return false;
                    let allowed = false;
                    let connected = false;
                    for (let i = 0; i < size; i++) {
                        {
                            const je = this.joints.get(i);
                            if (je.other === body) {
                                const joint = je.interaction;
                                connected = true;
                                allowed = joint.isCollisionAllowed() || allowed;
                            }
                        }
                        ;
                    }
                    if (!connected)
                        return false;
                    if (allowed === collisionAllowed) {
                        return true;
                    }
                    return false;
                }
                /**
                 * Returns true if the given {@link Body} is connected to this
                 * {@link Body}, given the collision flag, via a {@link Joint}.
                 * <p>
                 * If the given collision flag is true, this method will return true
                 * only if collision is allowed between the two joined {@link Body}s.
                 * <p>
                 * If the given collision flag is false, this method will return true
                 * only if collision is <b>NOT</b> allowed between the two joined {@link Body}s.
                 * <p>
                 * If the {@link Body}s are connected by more than one joint, if any allows
                 * collision, then the bodies are considered connected AND allowing collision.
                 * <p>
                 * Returns false if the given body is null.
                 * @param {org.dyn4j.dynamics.Body} body the suspect connected body
                 * @param {boolean} collisionAllowed the collision allowed flag
                 * @return {boolean} boolean
                 */
                isConnected(body, collisionAllowed) {
                    if (((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((typeof collisionAllowed === 'boolean') || collisionAllowed === null)) {
                        return this.isConnected$org_dyn4j_dynamics_Body$boolean(body, collisionAllowed);
                    }
                    else if (((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && collisionAllowed === undefined) {
                        return this.isConnected$org_dyn4j_dynamics_Body(body);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns true if the given {@link Body} is in collision with this {@link Body}.
                 * <p>
                 * Returns false if the given body is null.
                 * @param {org.dyn4j.dynamics.Body} body the {@link Body} to test
                 * @return {boolean} boolean true if the given {@link Body} is in collision with this {@link Body}
                 * @since 1.2.0
                 */
                isInContact(body) {
                    if (body == null)
                        return false;
                    const size = this.contacts.size();
                    if (size === 0)
                        return false;
                    for (let i = 0; i < size; i++) {
                        {
                            const ce = this.contacts.get(i);
                            if (ce.other === body) {
                                return true;
                            }
                        }
                        ;
                    }
                    return false;
                }
                /**
                 * Returns the transform of the last iteration.
                 * <p>
                 * This transform represents the last frame's position and
                 * orientation.
                 * @return {org.dyn4j.geometry.Transform} {@link Transform}
                 */
                getInitialTransform() {
                    return this.transform0;
                }
                createSweptAABB$() {
                    return this.createSweptAABB$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Transform(this.transform0, this.transform);
                }
                createSweptAABB$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Transform(initialTransform, finalTransform) {
                    const iCenter = initialTransform.getTransformed$org_dyn4j_geometry_Vector2(this.mass.getCenter());
                    const fCenter = finalTransform.getTransformed$org_dyn4j_geometry_Vector2(this.mass.getCenter());
                    const sweptAABB = org.dyn4j.geometry.AABB.createAABBFromPoints$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(iCenter, fCenter);
                    sweptAABB.expand(this.radius * 2);
                    return sweptAABB;
                }
                /**
                 * Creates a swept {@link AABB} from the given start and end {@link Transform}s
                 * for this {@link Body}.
                 * <p>
                 * This method may return a degenerate AABB, where the min == max, if the body
                 * has not moved and does not have any fixtures.  If this body does have
                 * fixtures, but didn't move, an AABB encompassing the initial and final center
                 * points is returned.
                 * @param {org.dyn4j.geometry.Transform} initialTransform the initial {@link Transform}
                 * @param {org.dyn4j.geometry.Transform} finalTransform the final {@link Transform}
                 * @return {org.dyn4j.geometry.AABB} {@link AABB}
                 * @since 3.1.1
                 */
                createSweptAABB(initialTransform, finalTransform) {
                    if (((initialTransform != null && initialTransform instanceof org.dyn4j.geometry.Transform) || initialTransform === null) && ((finalTransform != null && finalTransform instanceof org.dyn4j.geometry.Transform) || finalTransform === null)) {
                        return this.createSweptAABB$org_dyn4j_geometry_Transform$org_dyn4j_geometry_Transform(initialTransform, finalTransform);
                    }
                    else if (initialTransform === undefined && finalTransform === undefined) {
                        return this.createSweptAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the change in position computed from last frame's transform
                 * and this frame's transform.
                 * @return {org.dyn4j.geometry.Vector2} Vector2
                 * @since 3.1.5
                 */
                getChangeInPosition() {
                    return this.transform.getTranslation().subtract$org_dyn4j_geometry_Vector2(this.transform0.getTranslation());
                }
                /**
                 * Returns the change in orientation computed from last frame's transform
                 * and this frame's transform.
                 * <p>
                 * This method will return a change in the range [0, 2&pi;).  This isn't as useful
                 * if the angular velocity is greater than 2&pi; per time step.  Since we don't have
                 * the timestep here, we can't compute the exact change in this case.
                 * @return {number} double
                 * @since 3.1.5
                 */
                getChangeInOrientation() {
                    let ri = this.transform0.getRotationAngle();
                    let rf = this.transform.getRotationAngle();
                    const twopi = 2.0 * Math.PI;
                    if (ri < 0)
                        ri += twopi;
                    if (rf < 0)
                        rf += twopi;
                    let r = rf - ri;
                    if (rf < ri && this.angularVelocity > 0)
                        r += twopi;
                    if (rf > ri && this.angularVelocity < 0)
                        r -= twopi;
                    return r;
                }
                /**
                 * Returns the center of mass for the body in local coordinates.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the center of mass in local coordinates
                 */
                getLocalCenter() {
                    return this.mass.getCenter();
                }
                /**
                 * Returns the center of mass for the body in world coordinates.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2} the center of mass in world coordinates
                 */
                getWorldCenter() {
                    return this.transform.getTransformed$org_dyn4j_geometry_Vector2(this.mass.getCenter());
                }
                getLinearVelocity$() {
                    return this.velocity;
                }
                getLinearVelocity$org_dyn4j_geometry_Vector2(point) {
                    const c = this.getWorldCenter();
                    const r = c.to$org_dyn4j_geometry_Vector2(point);
                    return r.cross$double(this.angularVelocity).add$org_dyn4j_geometry_Vector2(this.velocity);
                }
                /**
                 * Returns the velocity of this body at the given world space point.
                 * @param {org.dyn4j.geometry.Vector2} point the point in world space
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @since 3.1.5
                 */
                getLinearVelocity(point) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null)) {
                        return this.getLinearVelocity$org_dyn4j_geometry_Vector2(point);
                    }
                    else if (point === undefined) {
                        return this.getLinearVelocity$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                setLinearVelocity$org_dyn4j_geometry_Vector2(velocity) {
                    if (velocity == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.body.nullVelocity"));
                    this.velocity.set$double$double(this.mass.getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : velocity.x, this.mass.getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : velocity.y);
                    this.averageVelocity.set$org_dyn4j_geometry_Vector2(this.velocity);
                }
                setLinearVelocity$double$double(x, y) {
                    this.velocity.set$double$double(this.mass.getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : x, this.mass.getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : y);
                    this.averageVelocity.set$org_dyn4j_geometry_Vector2(this.velocity);
                }
                /**
                 * Sets the linear velocity.
                 * <p>
                 * Call the {@link #setAsleep(boolean)} method to wake up the {@link Body}
                 * if the {@link Body} is asleep and the velocity is not zero.
                 * @param {number} x the linear velocity along the x-axis
                 * @param {number} y the linear velocity along the y-axis
                 * @since 3.1.5
                 */
                setLinearVelocity(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.setLinearVelocity$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.setLinearVelocity$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the angular velocity.
                 * @return {number} double
                 */
                getAngularVelocity() {
                    return this.angularVelocity;
                }
                /**
                 * Sets the angular velocity in radians per second
                 * <p>
                 * Call the {@link #setAsleep(boolean)} method to wake up the {@link Body}
                 * if the {@link Body} is asleep and the velocity is not zero.
                 * @param {number} angularVelocity the angular velocity in radians per second
                 */
                setAngularVelocity(angularVelocity) {
                    this.angularVelocity = angularVelocity;
                    this.averageAngularVelocity = angularVelocity;
                }
                /**
                 * Returns the force applied in the last iteration.
                 * <p>
                 * This is the accumulated force from the last iteration.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getForce() {
                    return this.force.copy();
                }
                /**
                 * Returns the total force currently stored in the force accumulator.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @since 3.0.1
                 */
                getAccumulatedForce() {
                    const fSize = this.forces.size();
                    const force = new org.dyn4j.geometry.Vector2();
                    for (let i = 0; i < fSize; i++) {
                        {
                            const tf = this.forces.get(i).force;
                            force.add$org_dyn4j_geometry_Vector2(tf);
                        }
                        ;
                    }
                    return force;
                }
                /**
                 * Returns the torque applied in the last iteration.
                 * <p>
                 * This is the accumulated torque from the last iteration.
                 * @return {number} double
                 */
                getTorque() {
                    return this.torque;
                }
                /**
                 * Returns the total torque currently stored in the torque accumulator.
                 * @return {number} double
                 * @since 3.0.1
                 */
                getAccumulatedTorque() {
                    const tSize = this.torques.size();
                    let torque = 0.0;
                    for (let i = 0; i < tSize; i++) {
                        {
                            torque += this.torques.get(i).torque;
                        }
                        ;
                    }
                    return torque;
                }
                /**
                 * Returns the linear damping.
                 * @return {number} double
                 * @see #setLinearDamping(double)
                 */
                getLinearDamping() {
                    return this.linearDamping;
                }
                /**
                 * Sets the linear damping.
                 * <p>
                 * Linear damping is used to reduce the linear velocity over time.  The default is
                 * zero and larger values will cause the linear velocity to reduce faster.
                 * @param {number} linearDamping the linear damping; must be greater than or equal to zero
                 * @throws IllegalArgumentException if linearDamping is less than zero
                 */
                setLinearDamping(linearDamping) {
                    if (linearDamping < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.body.invalidLinearDamping"));
                    this.linearDamping = linearDamping;
                }
                /**
                 * Returns the angular damping.
                 * @return {number} double
                 * @see #setAngularDamping(double)
                 */
                getAngularDamping() {
                    return this.angularDamping;
                }
                /**
                 * Sets the angular damping.
                 * <p>
                 * Angular damping is used to reduce the angular velocity over time.  The default is
                 * zero and larger values will cause the angular velocity to reduce faster.
                 * @param {number} angularDamping the angular damping; must be greater than or equal to zero
                 * @throws IllegalArgumentException if angularDamping is less than zero
                 */
                setAngularDamping(angularDamping) {
                    if (angularDamping < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.body.invalidAngularDamping"));
                    this.angularDamping = angularDamping;
                }
                /**
                 * Returns the gravity scale.
                 * @return {number} double
                 * @since 3.0.0
                 * @see #setGravityScale(double)
                 */
                getGravityScale() {
                    return this.gravityScale;
                }
                /**
                 * Sets the gravity scale.
                 * <p>
                 * The gravity scale is a multiplier applied to the acceleration due to
                 * gravity before applying the force of gravity to the body.  This allows
                 * bodies to be affected differently under the same gravity.
                 * @param {number} scale the gravity scale for this body
                 * @since 3.0.0
                 */
                setGravityScale(scale) {
                    this.gravityScale = scale;
                }
                /**
                 * Returns a list of {@link Body}s connected
                 * by {@link Joint}s.
                 * <p>
                 * If a body is connected to another body with more
                 * than one joint, this method will return just one
                 * entry for the connected body.
                 * @return {*} List&lt;{@link Body}&gt;
                 * @since 1.0.1
                 */
                getJoinedBodies() {
                    const size = this.joints.size();
                    const bodies = (new java.util.ArrayList(size));
                    for (let i = 0; i < size; i++) {
                        {
                            const je = this.joints.get(i);
                            const other = je.other;
                            if (!bodies.contains(other)) {
                                bodies.add(other);
                            }
                        }
                        ;
                    }
                    return bodies;
                }
                /**
                 * Returns a list of {@link Joint}s that this
                 * {@link Body} is connected with.
                 * @return {*} List&lt;{@link Joint}&gt;
                 * @since 1.0.1
                 */
                getJoints() {
                    const size = this.joints.size();
                    const joints = (new java.util.ArrayList(size));
                    for (let i = 0; i < size; i++) {
                        {
                            const je = this.joints.get(i);
                            joints.add(je.interaction);
                        }
                        ;
                    }
                    return joints;
                }
                /**
                 * Returns a list of {@link Body}s that are in
                 * contact with this {@link Body}.
                 * <p>
                 * Passing a value of true results in a list containing only
                 * the sensed contacts for this body.  Passing a value of false
                 * results in a list containing only normal contacts.
                 * <p>
                 * Calling this method from any of the {@link CollisionListener} methods
                 * may produce incorrect results.
                 * <p>
                 * If this body has multiple contact constraints with another body (which can
                 * happen when either body has multiple fixtures), this method will only return
                 * one entry for the in contact body.
                 * @param {boolean} sensed true for only sensed contacts; false for only normal contacts
                 * @return {*} List&lt;{@link Body}&gt;
                 * @since 1.0.1
                 */
                getInContactBodies(sensed) {
                    const size = this.contacts.size();
                    const bodies = (new java.util.ArrayList(size));
                    for (let i = 0; i < size; i++) {
                        {
                            const ce = this.contacts.get(i);
                            const constraint = ce.interaction;
                            if (sensed === constraint.isSensor()) {
                                const other = ce.other;
                                if (!bodies.contains(other)) {
                                    bodies.add(other);
                                }
                            }
                        }
                        ;
                    }
                    return bodies;
                }
                /**
                 * Returns a list of {@link ContactPoint}s
                 * <p>
                 * Passing a value of true results in a list containing only
                 * the sensed contacts for this body.  Passing a value of false
                 * results in a list containing only normal contacts.
                 * <p>
                 * Calling this method from any of the {@link CollisionListener} methods
                 * may produce incorrect results.
                 * <p>
                 * Modifying the {@link ContactPoint}s returned is not advised.  Use the
                 * {@link ContactListener} methods instead.
                 * @param {boolean} sensed true for only sensed contacts; false for only normal contacts
                 * @return {*} List&lt;{@link ContactPoint}&gt;
                 * @since 1.0.1
                 */
                getContacts(sensed) {
                    const size = this.contacts.size();
                    const contactPoints = (new java.util.ArrayList(size * 2));
                    for (let i = 0; i < size; i++) {
                        {
                            const ce = this.contacts.get(i);
                            const constraint = ce.interaction;
                            if (sensed === constraint.isSensor()) {
                                const contacts = constraint.getContacts();
                                const csize = contacts.size();
                                for (let j = 0; j < csize; j++) {
                                    {
                                        const contact = contacts.get(j);
                                        const contactPoint = new org.dyn4j.dynamics.contact.ContactPoint(constraint, contact);
                                        contactPoints.add(contactPoint);
                                    }
                                    ;
                                }
                            }
                        }
                        ;
                    }
                    return contactPoints;
                }
                /**
                 * Returns the world this body belongs to.
                 * <p>
                 * Returns null if the body has not been added to a world
                 * or has been removed.
                 * @return {org.dyn4j.dynamics.World} {@link World}
                 * @since 3.0.3
                 */
                getWorld() {
                    return this.world;
                }
                isColliding() {
                    return this.__isColliding;
                }
                setColliding(isColliding, jn, collisionN) {
                    if (isColliding && collisionN != null) {
                        if (this.fixtures.size() > 0 && this.getFixture$int(0).getRestitution() > 0.75 && Math.abs(jn) > 1.0E-6) {
                            this.__isColliding = true;
                            this.collisionN = collisionN;
                        }
                    }
                    else {
                        this.__isColliding = false;
                    }
                }
            }
            /**
             * The default linear damping; value = {@link #DEFAULT_LINEAR_DAMPING}
             */
            Body.DEFAULT_LINEAR_DAMPING = 0.0;
            /**
             * The default angular damping; value = {@link #DEFAULT_ANGULAR_DAMPING}
             */
            Body.DEFAULT_ANGULAR_DAMPING = 0.0;
            /**
             * The state flag for allowing automatic sleeping
             */
            Body.AUTO_SLEEP = 1;
            /**
             * The state flag for the {@link Body} being asleep
             */
            Body.ASLEEP = 2;
            /**
             * The state flag for the {@link Body} being active (out of bounds for example)
             */
            Body.ACTIVE = 4;
            /**
             * The state flag indicating the {@link Body} has been added to an {@link Island}
             */
            Body.ISLAND = 8;
            /**
             * The state flag indicating the {@link Body} is a really fast object and requires CCD
             */
            Body.BULLET = 16;
            dynamics.Body = Body;
            Body["__class"] = "org.dyn4j.dynamics.Body";
            Body["__interfaces"] = ["org.dyn4j.collision.Collidable", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Minimal constructor.
                 * @param {*} collidable the collidable
                 * @param {org.dyn4j.collision.Fixture} fixture the fixture
                 * @class
                 * @extends org.dyn4j.collision.broadphase.LazyAABBTreeNode
                 * @author Manolis Tsamis
                 */
                class LazyAABBTreeLeaf extends org.dyn4j.collision.broadphase.LazyAABBTreeNode {
                    constructor(collidable, fixture) {
                        super();
                        if (this.collidable === undefined) {
                            this.collidable = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        this.onTree = false;
                        this.removed = false;
                        this.collidable = collidable;
                        this.fixture = fixture;
                        this.updateAABB();
                    }
                    /**
                     * Updates the AABB of this leaf
                     */
                    updateAABB() {
                        const transform = this.collidable.getTransform();
                        this.aabb = this.fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](transform);
                    }
                    /**
                     * @return {boolean} true if this leaf has been marked for removal, false otherwise
                     */
                    mustRemove() {
                        return this.removed;
                    }
                    /**
                     * Marks that this leaf must be removed
                     */
                    markForRemoval() {
                        this.removed = true;
                    }
                    /**
                     * Change the flag denoting if this leaf is on the tree or not
                     * @param {boolean} onTree the new flag value
                     */
                    setOnTree(onTree) {
                        this.onTree = onTree;
                        if (!onTree) {
                            this.left = null;
                            this.right = null;
                            this.parent = null;
                        }
                    }
                    /**
                     * @return {boolean} true if this leaf is on the tree, false otherwise
                     */
                    isOnTree() {
                        return this.onTree;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (obj == null)
                            return false;
                        if (obj === this)
                            return true;
                        if (obj != null && obj instanceof org.dyn4j.collision.broadphase.LazyAABBTreeLeaf) {
                            const leaf = obj;
                            if (leaf.collidable === this.collidable && leaf.fixture === this.fixture) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let hash = 17;
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable);
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture);
                        return hash;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("LazyAABBTreeLeaf[Collidable=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable)).append("|Fixture=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture)).append("|AABB=").append(this.aabb.toString()).append("|OnTree=").append(this.onTree).append("]");
                        return sb.toString();
                    }
                }
                broadphase.LazyAABBTreeLeaf = LazyAABBTreeLeaf;
                LazyAABBTreeLeaf["__class"] = "org.dyn4j.collision.broadphase.LazyAABBTreeLeaf";
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * @param {boolean} ignoreInactive true to ignore inactive bodies
             * @param {boolean} ignoreSensors true to ignore sensor fixtures
             * @param {*} filter the fixture filter
             * @class
             * @extends org.dyn4j.collision.broadphase.BroadphaseFilterAdapter
             * @author William Bittle
             */
            class RaycastBroadphaseFilter extends org.dyn4j.collision.broadphase.BroadphaseFilterAdapter {
                constructor(ignoreInactive, ignoreSensors, filter) {
                    super();
                    if (this.ignoreInactive === undefined) {
                        this.ignoreInactive = false;
                    }
                    if (this.ignoreSensors === undefined) {
                        this.ignoreSensors = false;
                    }
                    if (this.filter === undefined) {
                        this.filter = null;
                    }
                    this.ignoreInactive = ignoreInactive;
                    this.ignoreSensors = ignoreSensors;
                    this.filter = filter;
                }
                isAllowed$org_dyn4j_geometry_Ray$double$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(ray, length, body, fixture) {
                    if (this.ignoreInactive && !body.isActive())
                        return false;
                    if (this.ignoreSensors && fixture.isSensor()) {
                        return false;
                    }
                    if (this.filter != null && !this.filter.isAllowed(fixture.getFilter())) {
                        return false;
                    }
                    return super.isAllowed(ray, length, body, fixture);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Ray} ray
                 * @param {number} length
                 * @param {org.dyn4j.dynamics.Body} body
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture
                 * @return {boolean}
                 */
                isAllowed(ray, length, body, fixture) {
                    if (((ray != null && ray instanceof org.dyn4j.geometry.Ray) || ray === null) && ((typeof length === 'number') || length === null) && ((body != null && body instanceof org.dyn4j.dynamics.Body) || body === null) && ((fixture != null && fixture instanceof org.dyn4j.dynamics.BodyFixture) || fixture === null)) {
                        return this.isAllowed$org_dyn4j_geometry_Ray$double$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(ray, length, body, fixture);
                    }
                    else if (((ray != null) || ray === null) && ((length != null) || length === null) && ((body != null) || body === null) && ((fixture != null) || fixture === null)) {
                        return super.isAllowed(ray, length, body, fixture);
                    }
                    else if (((ray != null && ray instanceof org.dyn4j.geometry.Ray) || ray === null) && ((typeof length === 'number') || length === null) && ((body != null) || body === null) && ((fixture != null) || fixture === null)) {
                        return this.isAllowed$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(ray, length, body, fixture);
                    }
                    else if (((ray != null && ray instanceof org.dyn4j.geometry.AABB) || ray === null) && ((length != null) || length === null) && ((body != null) || body === null) && fixture === undefined) {
                        return this.isAllowed$org_dyn4j_geometry_AABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(ray, length, body);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns true if inactive bodies should be ignored.
                 * @return {boolean} boolean
                 */
                isIgnoreInactive() {
                    return this.ignoreInactive;
                }
                /**
                 * Returns true if sensor fixtures should be ignored.
                 * @return {boolean} boolean
                 */
                isIgnoreSensors() {
                    return this.ignoreSensors;
                }
                /**
                 * Returns the filter used to filter fixtures.
                 * @return {*} {@link Filter}
                 */
                getFilter() {
                    return this.filter;
                }
            }
            dynamics.RaycastBroadphaseFilter = RaycastBroadphaseFilter;
            RaycastBroadphaseFilter["__class"] = "org.dyn4j.dynamics.RaycastBroadphaseFilter";
            RaycastBroadphaseFilter["__interfaces"] = ["org.dyn4j.collision.broadphase.BroadphaseFilter"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Full constructor.
             * @param {boolean} ignoreInactive true to ignore inactive bodies
             * @param {boolean} ignoreSensors true to ignore sensor fixtures
             * @param {*} filter the fixture filter
             * @class
             * @extends org.dyn4j.collision.broadphase.BroadphaseFilterAdapter
             * @author William Bittle
             */
            class AABBBroadphaseFilter extends org.dyn4j.collision.broadphase.BroadphaseFilterAdapter {
                constructor(ignoreInactive, ignoreSensors, filter) {
                    super();
                    if (this.ignoreInactive === undefined) {
                        this.ignoreInactive = false;
                    }
                    if (this.ignoreSensors === undefined) {
                        this.ignoreSensors = false;
                    }
                    if (this.filter === undefined) {
                        this.filter = null;
                    }
                    this.ignoreInactive = ignoreInactive;
                    this.ignoreSensors = ignoreSensors;
                    this.filter = filter;
                }
                /**
                 *
                 * @param {*} collidable1
                 * @param {org.dyn4j.collision.Fixture} fixture1
                 * @param {*} collidable2
                 * @param {org.dyn4j.collision.Fixture} fixture2
                 * @return {boolean}
                 */
                isAllowed(collidable1, fixture1, collidable2, fixture2) {
                    if (((collidable1 != null) || collidable1 === null) && ((fixture1 != null) || fixture1 === null) && ((collidable2 != null) || collidable2 === null) && ((fixture2 != null) || fixture2 === null)) {
                        return super.isAllowed(collidable1, fixture1, collidable2, fixture2);
                    }
                    else if (((collidable1 != null && collidable1 instanceof org.dyn4j.geometry.Ray) || collidable1 === null) && ((typeof fixture1 === 'number') || fixture1 === null) && ((collidable2 != null) || collidable2 === null) && ((fixture2 != null) || fixture2 === null)) {
                        return this.isAllowed$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable1, fixture1, collidable2, fixture2);
                    }
                    else if (((collidable1 != null && collidable1 instanceof org.dyn4j.geometry.AABB) || collidable1 === null) && ((fixture1 != null && fixture1 instanceof org.dyn4j.dynamics.Body) || fixture1 === null) && ((collidable2 != null && collidable2 instanceof org.dyn4j.dynamics.BodyFixture) || collidable2 === null) && fixture2 === undefined) {
                        return this.isAllowed$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(collidable1, fixture1, collidable2);
                    }
                    else if (((collidable1 != null && collidable1 instanceof org.dyn4j.geometry.AABB) || collidable1 === null) && ((fixture1 != null) || fixture1 === null) && ((collidable2 != null) || collidable2 === null) && fixture2 === undefined) {
                        return this.isAllowed$org_dyn4j_geometry_AABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable1, fixture1, collidable2);
                    }
                    else
                        throw new Error('invalid overload');
                }
                isAllowed$org_dyn4j_geometry_AABB$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(aabb, body, fixture) {
                    if (this.ignoreInactive && !body.isActive())
                        return false;
                    if (this.ignoreSensors && fixture.isSensor()) {
                        return false;
                    }
                    if (this.filter != null && !this.filter.isAllowed(fixture.getFilter())) {
                        return false;
                    }
                    return super.isAllowed(aabb, body, fixture);
                }
                /**
                 * Returns true if inactive bodies are ignored.
                 * @return {boolean} boolean
                 */
                isIgnoreInactive() {
                    return this.ignoreInactive;
                }
                /**
                 * Returns true if sensor fixtures are ignored.
                 * @return {boolean} boolean
                 */
                isIgnoreSensors() {
                    return this.ignoreSensors;
                }
                /**
                 * Returns the filter used in filtering {@link Fixture}s.
                 * @return {*} {@link Filter}
                 */
                getFilter() {
                    return this.filter;
                }
            }
            dynamics.AABBBroadphaseFilter = AABBBroadphaseFilter;
            AABBBroadphaseFilter["__class"] = "org.dyn4j.dynamics.AABBBroadphaseFilter";
            AABBBroadphaseFilter["__interfaces"] = ["org.dyn4j.collision.broadphase.BroadphaseFilter"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * A default filter for the {@link BroadphaseDetector#detect(BroadphaseFilter)} method that
                 * filters {@link Fixture}s by their {@link Filter}s.
                 * <p>
                 * This is the default {@link BroadphaseFilter} used in the {@link BroadphaseDetector}s.  Use the methods
                 * in the {@link BroadphaseDetector} that accept {@link BroadphaseFilter}a to override the filter.
                 * <p>
                 * It's recommended that this class be extended when creating custom {@link BroadphaseFilter}s to ensure
                 * the default functionality is retained.
                 * @author William Bittle
                 * @param <E> the {@link Collidable} type
                 * @param <T> the {@link Fixture} type
                 * @version 3.2.0
                 * @since 3.2.0
                 * @class
                 * @extends org.dyn4j.collision.broadphase.BroadphaseFilterAdapter
                 */
                class DefaultBroadphaseFilter extends org.dyn4j.collision.broadphase.BroadphaseFilterAdapter {
                    isAllowed$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable1, fixture1, collidable2, fixture2) {
                        const filter1 = fixture1.getFilter();
                        const filter2 = fixture2.getFilter();
                        return filter1.isAllowed(filter2);
                    }
                    /**
                     *
                     * @param {*} collidable1
                     * @param {org.dyn4j.collision.Fixture} fixture1
                     * @param {*} collidable2
                     * @param {org.dyn4j.collision.Fixture} fixture2
                     * @return {boolean}
                     */
                    isAllowed(collidable1, fixture1, collidable2, fixture2) {
                        if (((collidable1 != null) || collidable1 === null) && ((fixture1 != null) || fixture1 === null) && ((collidable2 != null) || collidable2 === null) && ((fixture2 != null) || fixture2 === null)) {
                            return this.isAllowed$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable1, fixture1, collidable2, fixture2);
                        }
                        else if (((collidable1 != null && collidable1 instanceof org.dyn4j.geometry.Ray) || collidable1 === null) && ((typeof fixture1 === 'number') || fixture1 === null) && ((collidable2 != null) || collidable2 === null) && ((fixture2 != null) || fixture2 === null)) {
                            return this.isAllowed$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable1, fixture1, collidable2, fixture2);
                        }
                        else if (((collidable1 != null && collidable1 instanceof org.dyn4j.geometry.AABB) || collidable1 === null) && ((fixture1 != null) || fixture1 === null) && ((collidable2 != null) || collidable2 === null) && fixture2 === undefined) {
                            return this.isAllowed$org_dyn4j_geometry_AABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable1, fixture1, collidable2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    constructor() {
                        super();
                    }
                }
                broadphase.DefaultBroadphaseFilter = DefaultBroadphaseFilter;
                DefaultBroadphaseFilter["__class"] = "org.dyn4j.collision.broadphase.DefaultBroadphaseFilter";
                DefaultBroadphaseFilter["__interfaces"] = ["org.dyn4j.collision.broadphase.BroadphaseFilter"];
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Full constructor.
                 * <p>
                 * Allows fine tuning of the initial capacity of local storage for faster running times.
                 * @param {number} initialCapacity the initial capacity of local storage
                 * @throws IllegalArgumentException if initialCapacity is less than zero
                 * @since 3.1.1
                 * @class
                 * @extends org.dyn4j.collision.broadphase.AbstractBroadphaseDetector
                 * @author William Bittle
                 */
                class Sap extends org.dyn4j.collision.broadphase.AbstractBroadphaseDetector {
                    constructor(initialCapacity) {
                        if (((typeof initialCapacity === 'number') || initialCapacity === null)) {
                            let __args = arguments;
                            super();
                            if (this.tree === undefined) {
                                this.tree = null;
                            }
                            if (this.map === undefined) {
                                this.map = null;
                            }
                            this.tree = (new org.dyn4j.BinarySearchTree(true));
                            this.map = (new java.util.HashMap((initialCapacity * 4 / 3 | 0) + 1, 0.75));
                        }
                        else if (initialCapacity === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let initialCapacity = org.dyn4j.collision.broadphase.BroadphaseDetector.DEFAULT_INITIAL_CAPACITY;
                                super();
                                if (this.tree === undefined) {
                                    this.tree = null;
                                }
                                if (this.map === undefined) {
                                    this.map = null;
                                }
                                this.tree = (new org.dyn4j.BinarySearchTree(true));
                                this.map = (new java.util.HashMap((initialCapacity * 4 / 3 | 0) + 1, 0.75));
                            }
                            if (this.tree === undefined) {
                                this.tree = null;
                            }
                            if (this.map === undefined) {
                                this.map = null;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    add$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const proxy = this.map.get(key);
                        if (proxy == null) {
                            this.add(key, collidable, fixture);
                        }
                        else {
                            this.update(key, proxy, collidable, fixture);
                        }
                    }
                    add$org_dyn4j_collision_broadphase_BroadphaseKey$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, collidable, fixture) {
                        const tx = collidable.getTransform();
                        const aabb = fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](tx);
                        aabb.expand(this.expansion);
                        const proxy = (new org.dyn4j.collision.broadphase.SapProxy(collidable, fixture, aabb));
                        this.map.put(key, proxy);
                        this.tree.insert(proxy);
                    }
                    /**
                     * Internal add method.
                     * <p>
                     * This method assumes the given arguments are all non-null and that the
                     * {@link Collidable} {@link Fixture} is not currently in this broad-phase.
                     * @param {org.dyn4j.collision.broadphase.BroadphaseKey} key the key for the collidable-fixture pair
                     * @param {*} collidable the collidable
                     * @param {org.dyn4j.collision.Fixture} fixture the fixture
                     */
                    add(key, collidable, fixture) {
                        if (((key != null && key instanceof org.dyn4j.collision.broadphase.BroadphaseKey) || key === null) && ((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.add$org_dyn4j_collision_broadphase_BroadphaseKey$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, collidable, fixture);
                        }
                        else if (((key != null) || key === null) && ((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.add$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, collidable);
                        }
                        else if (((key != null) || key === null) && collidable === undefined && fixture === undefined) {
                            return this.add$org_dyn4j_collision_Collidable(key);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    remove$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const proxy = this.map.remove(key);
                        if (proxy != null) {
                            this.tree.remove(proxy);
                            return true;
                        }
                        return false;
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {boolean}
                     */
                    remove(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.remove$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.remove$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    update$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const proxy = this.map.get(key);
                        if (proxy != null) {
                            this.update(key, proxy, collidable, fixture);
                        }
                        else {
                            this.add(key, collidable, fixture);
                        }
                    }
                    update$org_dyn4j_collision_broadphase_BroadphaseKey$org_dyn4j_collision_broadphase_SapProxy$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, proxy, collidable, fixture) {
                        const tx = collidable.getTransform();
                        const aabb = fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](tx);
                        if (proxy.aabb.contains$org_dyn4j_geometry_AABB(aabb)) {
                            return;
                        }
                        aabb.expand(this.expansion);
                        this.tree.remove(proxy);
                        proxy.aabb = aabb;
                        this.tree.insert(proxy);
                    }
                    /**
                     * Internal update method.
                     * <p>
                     * This method assumes the given arguments are all non-null.
                     * @param {org.dyn4j.collision.broadphase.BroadphaseKey} key the key for the collidable-fixture pair
                     * @param {org.dyn4j.collision.broadphase.SapProxy} proxy the current node in the tree
                     * @param {*} collidable the collidable
                     * @param {org.dyn4j.collision.Fixture} fixture the fixture
                     */
                    update(key, proxy, collidable, fixture) {
                        if (((key != null && key instanceof org.dyn4j.collision.broadphase.BroadphaseKey) || key === null) && ((proxy != null && proxy instanceof org.dyn4j.collision.broadphase.SapProxy) || proxy === null) && ((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.update$org_dyn4j_collision_broadphase_BroadphaseKey$org_dyn4j_collision_broadphase_SapProxy$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, proxy, collidable, fixture);
                        }
                        else if (((key != null) || key === null) && ((proxy != null) || proxy === null) && collidable === undefined && fixture === undefined) {
                            return this.update$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, proxy);
                        }
                        else if (((key != null) || key === null) && proxy === undefined && collidable === undefined && fixture === undefined) {
                            return this.update$org_dyn4j_collision_Collidable(key);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getAABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const proxy = this.map.get(key);
                        if (proxy != null) {
                            return proxy.aabb;
                        }
                        return fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](collidable.getTransform());
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {org.dyn4j.geometry.AABB}
                     */
                    getAABB(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.getAABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.getAABB$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    contains$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        return this.map.containsKey(key);
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {boolean}
                     */
                    contains(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.contains$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.contains$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     */
                    clear() {
                        this.map.clear();
                        this.tree.clear();
                    }
                    /**
                     *
                     * @return {number}
                     */
                    size() {
                        return this.map.size();
                    }
                    /**
                     *
                     * @param {*} convex1
                     * @param {org.dyn4j.geometry.Transform} transform1
                     * @param {*} convex2
                     * @param {org.dyn4j.geometry.Transform} transform2
                     * @return {boolean}
                     */
                    detect(convex1, transform1, convex2, transform2) {
                        if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null)) {
                            return super.detect(convex1, transform1, convex2, transform2);
                        }
                        else if (((convex1 != null && convex1 instanceof org.dyn4j.geometry.AABB) || convex1 === null) && ((transform1 != null && (transform1.constructor != null && transform1.constructor["__interfaces"] != null && transform1.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || transform1 === null) && convex2 === undefined && transform2 === undefined) {
                            return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter(convex1, transform1);
                        }
                        else if (((convex1 != null) || convex1 === null) && ((transform1 != null) || transform1 === null) && convex2 === undefined && transform2 === undefined) {
                            return this.detect$org_dyn4j_collision_Collidable$org_dyn4j_collision_Collidable(convex1, transform1);
                        }
                        else if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || convex1 === null) && transform1 === undefined && convex2 === undefined && transform2 === undefined) {
                            return this.detect$org_dyn4j_collision_broadphase_BroadphaseFilter(convex1);
                        }
                        else if (((convex1 != null && convex1 instanceof org.dyn4j.geometry.AABB) || convex1 === null) && transform1 === undefined && convex2 === undefined && transform2 === undefined) {
                            return this.detect$org_dyn4j_geometry_AABB(convex1);
                        }
                        else if (convex1 === undefined && transform1 === undefined && convex2 === undefined && transform2 === undefined) {
                            return this.detect$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    detect$org_dyn4j_collision_broadphase_BroadphaseFilter(filter) {
                        const size = this.tree.size$();
                        if (size === 0) {
                            return java.util.Collections.emptyList();
                        }
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionPairs(size);
                        const pairs = (new java.util.ArrayList(eSize));
                        const itp = this.tree.iterator();
                        while ((itp.hasNext())) {
                            {
                                const p = itp.next();
                                p.tested = false;
                            }
                        }
                        ;
                        const ito = this.tree.iterator();
                        while ((ito.hasNext())) {
                            {
                                const current = ito.next();
                                const iti = this.tree.tailIterator(current);
                                while ((iti.hasNext())) {
                                    {
                                        const test = iti.next();
                                        if (test.collidable === current.collidable)
                                            continue;
                                        if (test.tested)
                                            continue;
                                        if (current.aabb.getMaxX() >= test.aabb.getMinX()) {
                                            if (current.aabb.overlaps(test.aabb)) {
                                                if (filter.isAllowed(current.collidable, current.fixture, test.collidable, test.fixture)) {
                                                    pairs.add((new org.dyn4j.collision.broadphase.BroadphasePair(current.collidable, current.fixture, test.collidable, test.fixture)));
                                                }
                                            }
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                                ;
                                current.tested = true;
                            }
                        }
                        ;
                        return pairs;
                    }
                    detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter(aabb, filter) {
                        const size = this.tree.size$();
                        if (size === 0) {
                            return java.util.Collections.emptyList();
                        }
                        const list = (new java.util.ArrayList(org.dyn4j.collision.Collisions.getEstimatedCollisionsPerObject()));
                        const it = this.tree.inOrderIterator();
                        while ((it.hasNext())) {
                            {
                                const proxy = it.next();
                                if (proxy.aabb.getMaxX() > aabb.getMinX()) {
                                    if (proxy.aabb.overlaps(aabb)) {
                                        if (filter.isAllowed(aabb, proxy.collidable, proxy.fixture)) {
                                            list.add((new org.dyn4j.collision.broadphase.BroadphaseItem(proxy.collidable, proxy.fixture)));
                                        }
                                    }
                                }
                                else if (aabb.getMaxX() < proxy.aabb.getMinX()) {
                                    break;
                                }
                            }
                        }
                        ;
                        return list;
                    }
                    /**
                     * Returns true if the ray and AABB intersect.
                     * <p>
                     * This method is ideally called for a number of AABBs where the invDx and invDy can
                     * be computed once.
                     * @param {org.dyn4j.geometry.Vector2} start the start position of the ray
                     * @param {number} length the length of the ray
                     * @param {number} invDx the inverse of the x component of the ray direction
                     * @param {number} invDy the inverse of the y component of the ray direction
                     * @param {org.dyn4j.geometry.AABB} aabb the AABB to test
                     * @return {boolean} true if the AABB and ray intersect
                     */
                    raycast(start, length, invDx, invDy, aabb) {
                        if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((typeof length === 'number') || length === null) && ((typeof invDx === 'number') || invDx === null) && ((typeof invDy === 'number') || invDy === null) && ((aabb != null && aabb instanceof org.dyn4j.geometry.AABB) || aabb === null)) {
                            return super.raycast(start, length, invDx, invDy, aabb);
                        }
                        else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof length === 'number') || length === null) && ((invDx != null && (invDx.constructor != null && invDx.constructor["__interfaces"] != null && invDx.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || invDx === null) && invDy === undefined && aabb === undefined) {
                            return this.raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_broadphase_BroadphaseFilter(start, length, invDx);
                        }
                        else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof length === 'number') || length === null) && invDx === undefined && invDy === undefined && aabb === undefined) {
                            return this.raycast$org_dyn4j_geometry_Ray$double(start, length);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_broadphase_BroadphaseFilter(ray, length, filter) {
                        if (this.tree.size$() === 0) {
                            return java.util.Collections.emptyList();
                        }
                        const s = ray.getStart();
                        const d = ray.getDirectionVector();
                        let l = length;
                        if (length <= 0.0)
                            l = javaemul.internal.DoubleHelper.MAX_VALUE;
                        const x1 = s.x;
                        const x2 = s.x + d.x * l;
                        const y1 = s.y;
                        const y2 = s.y + d.y * l;
                        const aabb = org.dyn4j.geometry.AABB.createAABBFromPoints$double$double$double$double(x1, y1, x2, y2);
                        const invDx = 1.0 / d.x;
                        const invDy = 1.0 / d.y;
                        const size = this.tree.size$();
                        if (size === 0) {
                            return java.util.Collections.emptyList();
                        }
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedRaycastCollisions(this.map.size());
                        const list = (new java.util.ArrayList(eSize));
                        const it = this.tree.inOrderIterator();
                        while ((it.hasNext())) {
                            {
                                const proxy = it.next();
                                if (proxy.aabb.getMaxX() > aabb.getMinX()) {
                                    if (proxy.aabb.overlaps(aabb)) {
                                        if (this.raycast$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_geometry_AABB(s, l, invDx, invDy, proxy.aabb)) {
                                            if (filter.isAllowed(ray, length, proxy.collidable, proxy.fixture)) {
                                                list.add((new org.dyn4j.collision.broadphase.BroadphaseItem(proxy.collidable, proxy.fixture)));
                                            }
                                        }
                                    }
                                }
                                else if (aabb.getMaxX() < proxy.aabb.getMinX()) {
                                    break;
                                }
                            }
                        }
                        ;
                        return list;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                        const it = this.tree.iterator();
                        while ((it.hasNext())) {
                            {
                                const proxy = it.next();
                                proxy.aabb.translate$org_dyn4j_geometry_Vector2(shift);
                            }
                        }
                        ;
                    }
                }
                broadphase.Sap = Sap;
                Sap["__class"] = "org.dyn4j.collision.broadphase.Sap";
                Sap["__interfaces"] = ["org.dyn4j.collision.broadphase.BroadphaseDetector", "org.dyn4j.geometry.Shiftable"];
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Optional constructor.
                 * <p>
                 * Allows fine tuning of the initial capacity of local storage for faster running times.
                 *
                 * @param {number} initialCapacity the initial capacity of local storage
                 * @throws IllegalArgumentException if initialCapacity is less than zero
                 * @class
                 * @extends org.dyn4j.collision.broadphase.AbstractBroadphaseDetector
                 * @author Manolis Tsamis
                 */
                class LazyAABBTree extends org.dyn4j.collision.broadphase.AbstractBroadphaseDetector {
                    constructor(initialCapacity) {
                        if (((typeof initialCapacity === 'number') || initialCapacity === null)) {
                            let __args = arguments;
                            super();
                            if (this.root === undefined) {
                                this.root = null;
                            }
                            if (this.elementMap === undefined) {
                                this.elementMap = null;
                            }
                            if (this.elements === undefined) {
                                this.elements = null;
                            }
                            this.sorted = true;
                            this.pendingRemoves = false;
                            this.pendingInserts = false;
                            this.elements = (new java.util.ArrayList(initialCapacity));
                            this.elementMap = (new java.util.HashMap(initialCapacity));
                        }
                        else if (initialCapacity === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let initialCapacity = org.dyn4j.collision.broadphase.BroadphaseDetector.DEFAULT_INITIAL_CAPACITY;
                                super();
                                if (this.root === undefined) {
                                    this.root = null;
                                }
                                if (this.elementMap === undefined) {
                                    this.elementMap = null;
                                }
                                if (this.elements === undefined) {
                                    this.elements = null;
                                }
                                this.sorted = true;
                                this.pendingRemoves = false;
                                this.pendingInserts = false;
                                this.elements = (new java.util.ArrayList(initialCapacity));
                                this.elementMap = (new java.util.HashMap(initialCapacity));
                            }
                            if (this.root === undefined) {
                                this.root = null;
                            }
                            if (this.elementMap === undefined) {
                                this.elementMap = null;
                            }
                            if (this.elements === undefined) {
                                this.elements = null;
                            }
                            this.sorted = true;
                            this.pendingRemoves = false;
                            this.pendingInserts = false;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Destroys the existing tree in O(n) time and prepares for batch-detection,
                     * but does not update the AABBs of elements.
                     */
                    batchRebuild() {
                        for (let index = this.elements.iterator(); index.hasNext();) {
                            let node = index.next();
                            {
                                node.setOnTree(false);
                            }
                        }
                        this.root = null;
                        this.pendingInserts = true;
                    }
                    /**
                     * Destroys the existing tree in O(n) time and prepares for batch-detection while
                     * also updating all AABBs. Called by {@link World} in each step before detection.
                     */
                    batchUpdate() {
                        for (let index = this.elements.iterator(); index.hasNext();) {
                            let node = index.next();
                            {
                                node.setOnTree(false);
                                node.updateAABB();
                            }
                        }
                        this.root = null;
                        this.pendingInserts = true;
                    }
                    add$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const existing = this.elementMap.get(key);
                        if (existing != null) {
                            if (existing.isOnTree()) {
                                this.remove$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf(existing);
                                existing.setOnTree(false);
                            }
                            existing.updateAABB();
                        }
                        else {
                            const node = (new org.dyn4j.collision.broadphase.LazyAABBTreeLeaf(collidable, fixture));
                            this.elementMap.put(key, node);
                            this.elements.add(node);
                            this.sorted = false;
                        }
                        this.pendingInserts = true;
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     */
                    add(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.add$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.add$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    remove$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const node = this.elementMap.remove(key);
                        if (node != null) {
                            if (node.isOnTree()) {
                                this.remove$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf(node);
                            }
                            node.markForRemoval();
                            this.pendingRemoves = true;
                            return true;
                        }
                        return false;
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {boolean}
                     */
                    remove(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.remove$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null && collidable instanceof org.dyn4j.collision.broadphase.LazyAABBTreeLeaf) || collidable === null) && fixture === undefined) {
                            return this.remove$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf(collidable);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.remove$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    remove$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf(leaf) {
                        if (leaf === this.root) {
                            this.root = null;
                            return;
                        }
                        const parent = leaf.parent;
                        const grandparent = parent.parent;
                        const other = leaf.getSibling();
                        if (grandparent != null) {
                            grandparent.replaceChild(parent, other);
                            other.parent = grandparent;
                            this.balanceAll(grandparent);
                        }
                        else {
                            this.root = other;
                            other.parent = null;
                        }
                    }
                    update$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        this.add(collidable, fixture);
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     */
                    update(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.update$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.update$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getAABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const node = this.elementMap.get(key);
                        if (node != null && !node.mustRemove()) {
                            return node.aabb;
                        }
                        return fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](collidable.getTransform());
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {org.dyn4j.geometry.AABB}
                     */
                    getAABB(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.getAABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.getAABB$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    contains$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        return this.elementMap.containsKey(key);
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {boolean}
                     */
                    contains(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.contains$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.contains$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     */
                    clear() {
                        this.elementMap.clear();
                        this.elements.clear();
                        this.root = null;
                        this.sorted = true;
                        this.pendingRemoves = false;
                        this.pendingInserts = false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    size() {
                        return this.elements.size();
                    }
                    detect$org_dyn4j_collision_broadphase_BroadphaseFilter(filter) {
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionPairs(this.size());
                        const pairs = (new java.util.ArrayList(eSize));
                        if (this.root != null) {
                            this.batchRebuild();
                        }
                        this.buildAndDetect(filter, pairs);
                        return pairs;
                    }
                    /**
                     * Internal method to actually remove all leafs marked for removal.
                     * If there are any (see pendingRemoves) performs all deletions in O(n) time, else no work is done.
                     * This mechanism is used to solve the O(n) time for removing an element from the elements ArrayList.
                     * Although worst case is the same, in various scenarios this will perform better.
                     * Assumes all leafs marked for removal are <b>not</b> on the tree.
                     */
                    doPendingRemoves() {
                        if (this.pendingRemoves) {
                            for (let i = 0; i < this.elements.size(); i++) {
                                {
                                    const node = this.elements.get(i);
                                    if (node.mustRemove()) {
                                        const lastIndex = this.elements.size() - 1;
                                        this.elements.set(i, this.elements.get(lastIndex));
                                        this.elements.remove(lastIndex);
                                        i--;
                                    }
                                }
                                ;
                            }
                            this.pendingRemoves = false;
                            this.sorted = false;
                        }
                    }
                    /**
                     * Internal method that sorts the elements if needed.
                     * Note that the sorting routines in array list are optimized for partially sorted data
                     * and we can expect the sorting to happen very fast if just a few changes did happen from the last sorting.
                     */
                    ensureSorted() {
                        if (!this.sorted) {
                            java.util.Collections.sort(this.elements, (o1, o2) => {
                                return /* compare */ (o1.fixture.getShape()['getRadius$']() - o2.fixture.getShape()['getRadius$']());
                            });
                            this.sorted = true;
                        }
                    }
                    /**
                     * Internal method to ensure that all nodes are on the tree.
                     */
                    ensureOnTree() {
                        if (this.pendingInserts) {
                            const size = this.elements.size();
                            for (let i = 0; i < size; i++) {
                                {
                                    const node = this.elements.get(i);
                                    if (!node.isOnTree()) {
                                        this.insert$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf(node);
                                    }
                                }
                                ;
                            }
                            this.pendingInserts = false;
                        }
                    }
                    /**
                     * Internal method that ensures the whole tree is built. This just creates the tree and performs no detection.
                     * This is used to support raycasting and single AABB queries.
                     */
                    build() {
                        this.doPendingRemoves();
                        this.ensureSorted();
                        this.ensureOnTree();
                    }
                    /**
                     * The heart of the LazyAABBTree batch detection.
                     * Assumes no tree exists and in performs all the broad-phase detection while building the tree from scratch.
                     *
                     * @param {*} filter the broadphase filter
                     * @param {*} pairs List a list containing the results
                     */
                    buildAndDetect(filter, pairs) {
                        this.doPendingRemoves();
                        this.ensureSorted();
                        const size = this.elements.size();
                        for (let i = 0; i < size; i++) {
                            {
                                const node = this.elements.get(i);
                                this.insertAndDetect(node, filter, pairs);
                            }
                            ;
                        }
                    }
                    /**
                     * Cost function for descending to a particular node.
                     * The cost equals the enlargement caused in the {@link AABB} of the node.
                     * More specifically, descendCost(node, aabb) = (perimeter(union(node.aabb, aabb)) - perimeter(node.aabb)) / 2
                     *
                     * @param {org.dyn4j.collision.broadphase.LazyAABBTreeNode} node the node to descend
                     * @param {org.dyn4j.geometry.AABB} itemAABB the AABB of the item being inserted
                     * @return {number} the cost of descending to node
                     */
                    descendCost(node, itemAABB) {
                        const nodeAABB = node.aabb;
                        let enlargement = 0;
                        const enlargementMinX = nodeAABB.getMinX() - itemAABB.getMinX();
                        const enlargementMaxX = itemAABB.getMaxX() - nodeAABB.getMaxX();
                        if (enlargementMinX > 0)
                            enlargement += enlargementMinX;
                        if (enlargementMaxX > 0)
                            enlargement += enlargementMaxX;
                        const enlargementMinY = nodeAABB.getMinY() - itemAABB.getMinY();
                        const enlargementMaxY = itemAABB.getMaxY() - nodeAABB.getMaxY();
                        if (enlargementMinY > 0)
                            enlargement += enlargementMinY;
                        if (enlargementMaxY > 0)
                            enlargement += enlargementMaxY;
                        return enlargement;
                    }
                    insert$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf(item) {
                        this.insert$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf$boolean$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(item, false, null, null);
                    }
                    /**
                     * Internal method to insert a leaf in the tree and also perform all the collision detection required for that tree
                     *
                     * @param {org.dyn4j.collision.broadphase.LazyAABBTreeLeaf} item the leaf to insert
                     * @param {*} filter the broadphase filter
                     * @param {*} pairs a list containing the results
                     */
                    insertAndDetect(item, filter, pairs) {
                        this.insert$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf$boolean$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(item, true, filter, pairs);
                    }
                    insert$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf$boolean$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(item, detect, filter, pairs) {
                        item.setOnTree(true);
                        if (this.root == null) {
                            this.root = item;
                            return;
                        }
                        const itemAABB = item.aabb;
                        let node = this.root;
                        while ((!node.isLeaf())) {
                            {
                                let other;
                                const costLeft = this.descendCost(node.left, itemAABB);
                                if (costLeft === 0) {
                                    other = node.right;
                                    node = node.left;
                                }
                                else {
                                    const costRight = this.descendCost(node.right, itemAABB);
                                    node.aabb.union(itemAABB);
                                    if (costLeft < costRight) {
                                        other = node.right;
                                        node = node.left;
                                    }
                                    else {
                                        other = node.left;
                                        node = node.right;
                                    }
                                }
                                if (detect && other.aabb.overlaps(itemAABB)) {
                                    this.detectWhileBuilding(item, other, filter, pairs);
                                }
                            }
                        }
                        ;
                        if (detect && node.aabb.overlaps(itemAABB)) {
                            this.detectWhileBuilding(item, node, filter, pairs);
                        }
                        const parent = node.parent;
                        const newParent = new org.dyn4j.collision.broadphase.LazyAABBTreeNode();
                        newParent.parent = parent;
                        newParent.aabb = node.aabb.getUnion(itemAABB);
                        newParent.height = 1;
                        if (parent != null) {
                            parent.replaceChild(node, newParent);
                        }
                        else {
                            this.root = newParent;
                        }
                        newParent.left = node;
                        newParent.right = item;
                        node.parent = newParent;
                        item.parent = newParent;
                        this.balanceAll(newParent.parent);
                    }
                    /**
                     * The implementation routine for the tree. In order to avoid code duplication this method performs either insertion with detection
                     * or just insertion, as requested by the 'detect' parameter. The actual insertion algorithm is the same with that in {@link DynamicAABBTree}
                     * but with a variety of optimizations and clean-ups.
                     *
                     * @param {org.dyn4j.collision.broadphase.LazyAABBTreeLeaf} item The leaf to insert
                     * @param {boolean} detect Whether to also perform collision detection
                     * @param {*} filter the broadphase filter
                     * @param {*} pairs List a list containing the results
                     */
                    insert(item, detect, filter, pairs) {
                        if (((item != null && item instanceof org.dyn4j.collision.broadphase.LazyAABBTreeLeaf) || item === null) && ((typeof detect === 'boolean') || detect === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || filter === null) && ((pairs != null && (pairs.constructor != null && pairs.constructor["__interfaces"] != null && pairs.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || pairs === null)) {
                            return this.insert$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf$boolean$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(item, detect, filter, pairs);
                        }
                        else if (((item != null && item instanceof org.dyn4j.collision.broadphase.LazyAABBTreeLeaf) || item === null) && detect === undefined && filter === undefined && pairs === undefined) {
                            return this.insert$org_dyn4j_collision_broadphase_LazyAABBTreeLeaf(item);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Internal recursive method to detect broad-phase collisions while building the tree. Only used from insertAndDetect.
                     * Caution: Assumes that node collides with root.aabb when called (In order to reduce recursion height).
                     * Note that in contrast to {@link DynamicAABBTree} we don't need to check if one node was tested for collision.
                     * Because the nodes are tested while being inserted each pair will only be tested once, so we skip those tests.
                     * @param {org.dyn4j.collision.broadphase.LazyAABBTreeLeaf} node
                     * @param {org.dyn4j.collision.broadphase.LazyAABBTreeNode} root
                     * @param {*} filter
                     * @param {*} pairs
                     * @private
                     */
                    /*private*/ detectWhileBuilding(node, root, filter, pairs) {
                        if (root.isLeaf()) {
                            const leaf = root;
                            if (filter.isAllowed(node.collidable, node.fixture, leaf.collidable, leaf.fixture)) {
                                const pair = (new org.dyn4j.collision.broadphase.BroadphasePair(node.collidable, node.fixture, leaf.collidable, leaf.fixture));
                                pairs.add(pair);
                            }
                        }
                        else {
                            if (node.aabb.overlaps(root.left.aabb))
                                this.detectWhileBuilding(node, root.left, filter, pairs);
                            if (node.aabb.overlaps(root.right.aabb))
                                this.detectWhileBuilding(node, root.right, filter, pairs);
                        }
                    }
                    detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter(aabb, filter) {
                        this.build();
                        if (this.root == null) {
                            return java.util.Collections.emptyList();
                        }
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionsPerObject();
                        const list = (new java.util.ArrayList(eSize));
                        if (aabb.overlaps(this.root.aabb)) {
                            this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_LazyAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(aabb, this.root, filter, list);
                        }
                        return list;
                    }
                    detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_LazyAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(aabb, node, filter, list) {
                        if (node.isLeaf()) {
                            const leaf = node;
                            if (filter.isAllowed(aabb, leaf.collidable, leaf.fixture)) {
                                list.add((new org.dyn4j.collision.broadphase.BroadphaseItem(leaf.collidable, leaf.fixture)));
                            }
                        }
                        else {
                            if (aabb.overlaps(node.left.aabb))
                                this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_LazyAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(aabb, node.left, filter, list);
                            if (aabb.overlaps(node.right.aabb))
                                this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_LazyAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(aabb, node.right, filter, list);
                        }
                    }
                    /**
                     * Internal recursive method used to implement BroadphaseDetector#detect.
                     * @param {org.dyn4j.geometry.AABB} aabb the aabb to test with
                     * @param {org.dyn4j.collision.broadphase.LazyAABBTreeNode} node the node to begin at
                     * @param {*} filter the filter
                     * @param {*} list the results list
                     * @private
                     */
                    detect(aabb, node, filter, list) {
                        if (((aabb != null && aabb instanceof org.dyn4j.geometry.AABB) || aabb === null) && ((node != null && node instanceof org.dyn4j.collision.broadphase.LazyAABBTreeNode) || node === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || filter === null) && ((list != null && (list.constructor != null && list.constructor["__interfaces"] != null && list.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || list === null)) {
                            return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_LazyAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(aabb, node, filter, list);
                        }
                        else if (((aabb != null && (aabb.constructor != null && aabb.constructor["__interfaces"] != null && aabb.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || aabb === null) && ((node != null && node instanceof org.dyn4j.geometry.Transform) || node === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || filter === null) && ((list != null && list instanceof org.dyn4j.geometry.Transform) || list === null)) {
                            return super.detect(aabb, node, filter, list);
                        }
                        else if (((aabb != null && aabb instanceof org.dyn4j.geometry.AABB) || aabb === null) && ((node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || node === null) && filter === undefined && list === undefined) {
                            return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter(aabb, node);
                        }
                        else if (((aabb != null) || aabb === null) && ((node != null) || node === null) && filter === undefined && list === undefined) {
                            return this.detect$org_dyn4j_collision_Collidable$org_dyn4j_collision_Collidable(aabb, node);
                        }
                        else if (((aabb != null && (aabb.constructor != null && aabb.constructor["__interfaces"] != null && aabb.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || aabb === null) && node === undefined && filter === undefined && list === undefined) {
                            return this.detect$org_dyn4j_collision_broadphase_BroadphaseFilter(aabb);
                        }
                        else if (((aabb != null && aabb instanceof org.dyn4j.geometry.AABB) || aabb === null) && node === undefined && filter === undefined && list === undefined) {
                            return this.detect$org_dyn4j_geometry_AABB(aabb);
                        }
                        else if (aabb === undefined && node === undefined && filter === undefined && list === undefined) {
                            return this.detect$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Returns true if the ray and AABB intersect.
                     * <p>
                     * This method is ideally called for a number of AABBs where the invDx and invDy can
                     * be computed once.
                     * @param {org.dyn4j.geometry.Vector2} start the start position of the ray
                     * @param {number} length the length of the ray
                     * @param {number} invDx the inverse of the x component of the ray direction
                     * @param {number} invDy the inverse of the y component of the ray direction
                     * @param {org.dyn4j.geometry.AABB} aabb the AABB to test
                     * @return {boolean} true if the AABB and ray intersect
                     */
                    raycast(start, length, invDx, invDy, aabb) {
                        if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((typeof length === 'number') || length === null) && ((typeof invDx === 'number') || invDx === null) && ((typeof invDy === 'number') || invDy === null) && ((aabb != null && aabb instanceof org.dyn4j.geometry.AABB) || aabb === null)) {
                            return super.raycast(start, length, invDx, invDy, aabb);
                        }
                        else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof length === 'number') || length === null) && ((invDx != null && (invDx.constructor != null && invDx.constructor["__interfaces"] != null && invDx.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || invDx === null) && invDy === undefined && aabb === undefined) {
                            return this.raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_broadphase_BroadphaseFilter(start, length, invDx);
                        }
                        else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof length === 'number') || length === null) && invDx === undefined && invDy === undefined && aabb === undefined) {
                            return this.raycast$org_dyn4j_geometry_Ray$double(start, length);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_broadphase_BroadphaseFilter(ray, length, filter) {
                        this.build();
                        if (this.root == null) {
                            return java.util.Collections.emptyList();
                        }
                        const s = ray.getStart();
                        const d = ray.getDirectionVector();
                        if (length <= 0.0) {
                            length = javaemul.internal.DoubleHelper.MAX_VALUE;
                        }
                        const w = d.x * length;
                        const h = d.y * length;
                        const aabb = org.dyn4j.geometry.AABB.createAABBFromPoints$double$double$double$double(s.x, s.y, s.x + w, s.y + h);
                        if (!this.root.aabb.overlaps(aabb)) {
                            return java.util.Collections.emptyList();
                        }
                        const invDx = 1.0 / d.x;
                        const invDy = 1.0 / d.y;
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedRaycastCollisions(this.elementMap.size());
                        const items = (new java.util.ArrayList(eSize));
                        let node = this.root;
                        while ((node != null)) {
                            {
                                if (aabb.overlaps(node.aabb)) {
                                    if (node.isLeaf()) {
                                        if (this.raycast$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_geometry_AABB(s, length, invDx, invDy, node.aabb)) {
                                            const leaf = node;
                                            if (filter.isAllowed(ray, length, leaf.collidable, leaf.fixture)) {
                                                items.add((new org.dyn4j.collision.broadphase.BroadphaseItem(leaf.collidable, leaf.fixture)));
                                            }
                                        }
                                    }
                                    else {
                                        node = node.left;
                                        continue;
                                    }
                                }
                                let nextNodeFound = false;
                                while ((node.parent != null)) {
                                    {
                                        if (node === node.parent.left) {
                                            node = node.parent.right;
                                            nextNodeFound = true;
                                            break;
                                        }
                                        node = node.parent;
                                    }
                                }
                                ;
                                if (!nextNodeFound)
                                    break;
                            }
                        }
                        ;
                        return items;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                        this.build();
                        let node = this.root;
                        while ((node != null)) {
                            {
                                if (node.left != null) {
                                    node = node.left;
                                }
                                else if (node.right != null) {
                                    node.aabb.translate$org_dyn4j_geometry_Vector2(shift);
                                    node = node.right;
                                }
                                else {
                                    node.aabb.translate$org_dyn4j_geometry_Vector2(shift);
                                    let nextNodeFound = false;
                                    while ((node.parent != null)) {
                                        {
                                            if (node === node.parent.left) {
                                                if (node.parent.right != null) {
                                                    node.parent.aabb.translate$org_dyn4j_geometry_Vector2(shift);
                                                    node = node.parent.right;
                                                    nextNodeFound = true;
                                                    break;
                                                }
                                            }
                                            node = node.parent;
                                        }
                                    }
                                    ;
                                    if (!nextNodeFound)
                                        break;
                                }
                            }
                        }
                        ;
                    }
                    /**
                     * Balances the tree starting from node and going up to the root
                     *
                     * @param {org.dyn4j.collision.broadphase.LazyAABBTreeNode} node The starting node
                     */
                    balanceAll(node) {
                        while ((node != null)) {
                            {
                                this.balance(node);
                                node = node.parent;
                            }
                        }
                        ;
                    }
                    /**
                     * Balances the subtree using node as the root.
                     * Note that this is the exact same balancing routine as in {@link DynamicAABBTree} but greatly reduced in size and optimized
                     *
                     * @param {org.dyn4j.collision.broadphase.LazyAABBTreeNode} a the root node of the subtree to balance
                     */
                    balance(a) {
                        if (a.height < 2) {
                            a.height = 1 + Math.max(a.left.height, a.right.height);
                            return;
                        }
                        let b;
                        let c;
                        const balance = a.right.height - a.left.height;
                        if (balance > 1) {
                            b = a.left;
                            c = a.right;
                        }
                        else if (balance < -1) {
                            b = a.right;
                            c = a.left;
                        }
                        else {
                            a.height = 1 + Math.max(a.left.height, a.right.height);
                            return;
                        }
                        let d = c.left;
                        let e = c.right;
                        c.left = a;
                        c.parent = a.parent;
                        a.parent = c;
                        if (c.parent != null) {
                            c.parent.replaceChild(a, c);
                        }
                        else {
                            this.root = c;
                        }
                        if (d.height <= e.height) {
                            const temp = d;
                            d = e;
                            e = temp;
                        }
                        if (balance > 1) {
                            a.right = e;
                        }
                        else {
                            a.left = e;
                        }
                        c.right = d;
                        e.parent = a;
                        a.aabb.set$org_dyn4j_geometry_AABB(b.aabb).union(e.aabb);
                        c.aabb.set$org_dyn4j_geometry_AABB(a.aabb).union(d.aabb);
                        a.height = 1 + Math.max(b.height, e.height);
                        c.height = 1 + Math.max(a.height, d.height);
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getAABBExpansion() {
                        return 0;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    supportsAABBExpansion() {
                        return false;
                    }
                }
                broadphase.LazyAABBTree = LazyAABBTree;
                LazyAABBTree["__class"] = "org.dyn4j.collision.broadphase.LazyAABBTree";
                LazyAABBTree["__interfaces"] = ["org.dyn4j.collision.broadphase.BroadphaseDetector", "org.dyn4j.collision.broadphase.BatchBroadphaseDetector", "org.dyn4j.geometry.Shiftable"];
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Default constructor.
                 * @class
                 * @extends org.dyn4j.collision.broadphase.AbstractBroadphaseDetector
                 * @author Manolis Tsamis
                 */
                class BruteForceBroadphase extends org.dyn4j.collision.broadphase.AbstractBroadphaseDetector {
                    constructor() {
                        super();
                        if (this.map === undefined) {
                            this.map = null;
                        }
                        this.map = (new java.util.LinkedHashMap());
                    }
                    add$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const node = this.map.get(key);
                        if (node != null) {
                            node.updateAABB();
                        }
                        else {
                            this.map.put(key, (new org.dyn4j.collision.broadphase.BruteForceBroadphaseNode(collidable, fixture)));
                        }
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     */
                    add(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.add$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.add$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    remove$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const node = this.map.remove(key);
                        return node != null;
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {boolean}
                     */
                    remove(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.remove$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.remove$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    update$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        this.add(collidable, fixture);
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     */
                    update(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.update$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.update$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getAABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const node = this.map.get(key);
                        if (node != null) {
                            return node.aabb;
                        }
                        return fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](collidable.getTransform());
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {org.dyn4j.geometry.AABB}
                     */
                    getAABB(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.getAABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.getAABB$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    contains$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        return this.map.containsKey(key);
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {boolean}
                     */
                    contains(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.contains$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.contains$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     */
                    clear() {
                        this.map.clear();
                    }
                    /**
                     *
                     * @return {number}
                     */
                    size() {
                        return this.map.size();
                    }
                    /**
                     *
                     * @param {*} convex1
                     * @param {org.dyn4j.geometry.Transform} transform1
                     * @param {*} convex2
                     * @param {org.dyn4j.geometry.Transform} transform2
                     * @return {boolean}
                     */
                    detect(convex1, transform1, convex2, transform2) {
                        if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((transform1 != null && transform1 instanceof org.dyn4j.geometry.Transform) || transform1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null) && ((transform2 != null && transform2 instanceof org.dyn4j.geometry.Transform) || transform2 === null)) {
                            return super.detect(convex1, transform1, convex2, transform2);
                        }
                        else if (((convex1 != null && convex1 instanceof org.dyn4j.geometry.AABB) || convex1 === null) && ((transform1 != null && (transform1.constructor != null && transform1.constructor["__interfaces"] != null && transform1.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || transform1 === null) && convex2 === undefined && transform2 === undefined) {
                            return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter(convex1, transform1);
                        }
                        else if (((convex1 != null) || convex1 === null) && ((transform1 != null) || transform1 === null) && convex2 === undefined && transform2 === undefined) {
                            return this.detect$org_dyn4j_collision_Collidable$org_dyn4j_collision_Collidable(convex1, transform1);
                        }
                        else if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || convex1 === null) && transform1 === undefined && convex2 === undefined && transform2 === undefined) {
                            return this.detect$org_dyn4j_collision_broadphase_BroadphaseFilter(convex1);
                        }
                        else if (((convex1 != null && convex1 instanceof org.dyn4j.geometry.AABB) || convex1 === null) && transform1 === undefined && convex2 === undefined && transform2 === undefined) {
                            return this.detect$org_dyn4j_geometry_AABB(convex1);
                        }
                        else if (convex1 === undefined && transform1 === undefined && convex2 === undefined && transform2 === undefined) {
                            return this.detect$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    detect$org_dyn4j_collision_broadphase_BroadphaseFilter(filter) {
                        const size = this.map.size();
                        const nodes = this.map.values();
                        for (let index = nodes.iterator(); index.hasNext();) {
                            let node = index.next();
                            {
                                node.tested = false;
                            }
                        }
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionPairs(size);
                        const pairs = (new java.util.ArrayList(eSize));
                        for (let index = nodes.iterator(); index.hasNext();) {
                            let node = index.next();
                            {
                                for (let index = nodes.iterator(); index.hasNext();) {
                                    let other = index.next();
                                    {
                                        if (node.aabb.overlaps(other.aabb) && !other.tested && other.collidable !== node.collidable) {
                                            if (filter.isAllowed(node.collidable, node.fixture, other.collidable, other.fixture)) {
                                                const pair = (new org.dyn4j.collision.broadphase.BroadphasePair(node.collidable, node.fixture, other.collidable, other.fixture));
                                                pairs.add(pair);
                                            }
                                        }
                                    }
                                }
                                node.tested = true;
                            }
                        }
                        return pairs;
                    }
                    detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter(aabb, filter) {
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionsPerObject();
                        const list = (new java.util.ArrayList(eSize));
                        const nodes = this.map.values();
                        for (let index = nodes.iterator(); index.hasNext();) {
                            let node = index.next();
                            {
                                if (aabb.overlaps(node.aabb)) {
                                    if (filter.isAllowed(aabb, node.collidable, node.fixture)) {
                                        list.add((new org.dyn4j.collision.broadphase.BroadphaseItem(node.collidable, node.fixture)));
                                    }
                                }
                            }
                        }
                        return list;
                    }
                    /**
                     * Returns true if the ray and AABB intersect.
                     * <p>
                     * This method is ideally called for a number of AABBs where the invDx and invDy can
                     * be computed once.
                     * @param {org.dyn4j.geometry.Vector2} start the start position of the ray
                     * @param {number} length the length of the ray
                     * @param {number} invDx the inverse of the x component of the ray direction
                     * @param {number} invDy the inverse of the y component of the ray direction
                     * @param {org.dyn4j.geometry.AABB} aabb the AABB to test
                     * @return {boolean} true if the AABB and ray intersect
                     */
                    raycast(start, length, invDx, invDy, aabb) {
                        if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((typeof length === 'number') || length === null) && ((typeof invDx === 'number') || invDx === null) && ((typeof invDy === 'number') || invDy === null) && ((aabb != null && aabb instanceof org.dyn4j.geometry.AABB) || aabb === null)) {
                            return super.raycast(start, length, invDx, invDy, aabb);
                        }
                        else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof length === 'number') || length === null) && ((invDx != null && (invDx.constructor != null && invDx.constructor["__interfaces"] != null && invDx.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || invDx === null) && invDy === undefined && aabb === undefined) {
                            return this.raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_broadphase_BroadphaseFilter(start, length, invDx);
                        }
                        else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof length === 'number') || length === null) && invDx === undefined && invDy === undefined && aabb === undefined) {
                            return this.raycast$org_dyn4j_geometry_Ray$double(start, length);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_broadphase_BroadphaseFilter(ray, length, filter) {
                        if (this.map.size() === 0) {
                            return java.util.Collections.emptyList();
                        }
                        const s = ray.getStart();
                        const d = ray.getDirectionVector();
                        let l = length;
                        if (length <= 0.0)
                            l = javaemul.internal.DoubleHelper.MAX_VALUE;
                        const x1 = s.x;
                        const x2 = s.x + d.x * l;
                        const y1 = s.y;
                        const y2 = s.y + d.y * l;
                        const aabb = org.dyn4j.geometry.AABB.createAABBFromPoints$double$double$double$double(x1, y1, x2, y2);
                        const invDx = 1.0 / d.x;
                        const invDy = 1.0 / d.y;
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedRaycastCollisions(this.map.size());
                        const list = (new java.util.ArrayList(eSize));
                        const nodes = this.map.values();
                        for (let index = nodes.iterator(); index.hasNext();) {
                            let node = index.next();
                            {
                                if (aabb.overlaps(node.aabb) && this.raycast$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_geometry_AABB(s, l, invDx, invDy, node.aabb)) {
                                    if (filter.isAllowed(ray, length, node.collidable, node.fixture)) {
                                        list.add((new org.dyn4j.collision.broadphase.BroadphaseItem(node.collidable, node.fixture)));
                                    }
                                }
                            }
                        }
                        return list;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                        const nodes = this.map.values();
                        for (let index = nodes.iterator(); index.hasNext();) {
                            let node = index.next();
                            {
                                node.aabb.translate$org_dyn4j_geometry_Vector2(shift);
                            }
                        }
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getAABBExpansion() {
                        return 0;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    supportsAABBExpansion() {
                        return false;
                    }
                }
                broadphase.BruteForceBroadphase = BruteForceBroadphase;
                BruteForceBroadphase["__class"] = "org.dyn4j.collision.broadphase.BruteForceBroadphase";
                BruteForceBroadphase["__interfaces"] = ["org.dyn4j.collision.broadphase.BroadphaseDetector", "org.dyn4j.geometry.Shiftable"];
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Optional constructor.
                 * <p>
                 * Allows fine tuning of the initial capacity of local storage for faster running times.
                 * @param {number} initialCapacity the initial capacity of local storage
                 * @throws IllegalArgumentException if initialCapacity is less than zero
                 * @since 3.1.1
                 * @class
                 * @extends org.dyn4j.collision.broadphase.AbstractBroadphaseDetector
                 * @author William Bittle
                 */
                class DynamicAABBTree extends org.dyn4j.collision.broadphase.AbstractBroadphaseDetector {
                    constructor(initialCapacity) {
                        if (((typeof initialCapacity === 'number') || initialCapacity === null)) {
                            let __args = arguments;
                            super();
                            if (this.root === undefined) {
                                this.root = null;
                            }
                            if (this.map === undefined) {
                                this.map = null;
                            }
                            this.map = (new java.util.LinkedHashMap((initialCapacity * 4 / 3 | 0) + 1, 0.75));
                        }
                        else if (initialCapacity === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let initialCapacity = org.dyn4j.collision.broadphase.BroadphaseDetector.DEFAULT_INITIAL_CAPACITY;
                                super();
                                if (this.root === undefined) {
                                    this.root = null;
                                }
                                if (this.map === undefined) {
                                    this.map = null;
                                }
                                this.map = (new java.util.LinkedHashMap((initialCapacity * 4 / 3 | 0) + 1, 0.75));
                            }
                            if (this.root === undefined) {
                                this.root = null;
                            }
                            if (this.map === undefined) {
                                this.map = null;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    add$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const node = this.map.get(key);
                        if (node != null) {
                            this.update(key, node, collidable, fixture);
                        }
                        else {
                            this.add(key, collidable, fixture);
                        }
                    }
                    add$org_dyn4j_collision_broadphase_BroadphaseKey$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, collidable, fixture) {
                        const tx = collidable.getTransform();
                        const aabb = fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](tx);
                        aabb.expand(this.expansion);
                        const node = (new org.dyn4j.collision.broadphase.DynamicAABBTreeLeaf(collidable, fixture));
                        node.aabb = aabb;
                        this.map.put(key, node);
                        this.insert(node);
                    }
                    /**
                     * Internal add method.
                     * <p>
                     * This method assumes the given arguments are all non-null and that the
                     * {@link Collidable} {@link Fixture} is not currently in this broad-phase.
                     * @param {org.dyn4j.collision.broadphase.BroadphaseKey} key the key for the collidable-fixture pair
                     * @param {*} collidable the collidable
                     * @param {org.dyn4j.collision.Fixture} fixture the fixture
                     */
                    add(key, collidable, fixture) {
                        if (((key != null && key instanceof org.dyn4j.collision.broadphase.BroadphaseKey) || key === null) && ((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.add$org_dyn4j_collision_broadphase_BroadphaseKey$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, collidable, fixture);
                        }
                        else if (((key != null) || key === null) && ((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.add$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, collidable);
                        }
                        else if (((key != null) || key === null) && collidable === undefined && fixture === undefined) {
                            return this.add$org_dyn4j_collision_Collidable(key);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    remove$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const node = this.map.remove(key);
                        if (node != null) {
                            this.remove$org_dyn4j_collision_broadphase_DynamicAABBTreeNode(node);
                            return true;
                        }
                        return false;
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {boolean}
                     */
                    remove(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.remove$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null && collidable instanceof org.dyn4j.collision.broadphase.DynamicAABBTreeNode) || collidable === null) && fixture === undefined) {
                            return this.remove$org_dyn4j_collision_broadphase_DynamicAABBTreeNode(collidable);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.remove$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    update$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const node = this.map.get(key);
                        if (node != null) {
                            this.update(key, node, collidable, fixture);
                        }
                        else {
                            this.add(key, collidable, fixture);
                        }
                    }
                    update$org_dyn4j_collision_broadphase_BroadphaseKey$org_dyn4j_collision_broadphase_DynamicAABBTreeLeaf$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, node, collidable, fixture) {
                        const tx = collidable.getTransform();
                        const aabb = fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](tx);
                        if (node.aabb.contains$org_dyn4j_geometry_AABB(aabb)) {
                            return;
                        }
                        aabb.expand(this.expansion);
                        this.remove$org_dyn4j_collision_broadphase_DynamicAABBTreeNode(node);
                        node.aabb = aabb;
                        this.insert(node);
                    }
                    /**
                     * Internal update method.
                     * <p>
                     * This method assumes the given arguments are all non-null.
                     * @param {org.dyn4j.collision.broadphase.BroadphaseKey} key the key for the collidable-fixture pair
                     * @param {org.dyn4j.collision.broadphase.DynamicAABBTreeLeaf} node the current node in the tree
                     * @param {*} collidable the collidable
                     * @param {org.dyn4j.collision.Fixture} fixture the fixture
                     */
                    update(key, node, collidable, fixture) {
                        if (((key != null && key instanceof org.dyn4j.collision.broadphase.BroadphaseKey) || key === null) && ((node != null && node instanceof org.dyn4j.collision.broadphase.DynamicAABBTreeLeaf) || node === null) && ((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.update$org_dyn4j_collision_broadphase_BroadphaseKey$org_dyn4j_collision_broadphase_DynamicAABBTreeLeaf$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, node, collidable, fixture);
                        }
                        else if (((key != null) || key === null) && ((node != null) || node === null) && collidable === undefined && fixture === undefined) {
                            return this.update$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(key, node);
                        }
                        else if (((key != null) || key === null) && node === undefined && collidable === undefined && fixture === undefined) {
                            return this.update$org_dyn4j_collision_Collidable(key);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getAABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        const node = this.map.get(key);
                        if (node != null) {
                            return node.aabb;
                        }
                        return fixture.getShape()['createAABB$org_dyn4j_geometry_Transform'](collidable.getTransform());
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {org.dyn4j.geometry.AABB}
                     */
                    getAABB(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.getAABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.getAABB$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    contains$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture) {
                        const key = org.dyn4j.collision.broadphase.BroadphaseKey.get(collidable, fixture);
                        return this.map.containsKey(key);
                    }
                    /**
                     *
                     * @param {*} collidable
                     * @param {org.dyn4j.collision.Fixture} fixture
                     * @return {boolean}
                     */
                    contains(collidable, fixture) {
                        if (((collidable != null) || collidable === null) && ((fixture != null) || fixture === null)) {
                            return this.contains$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(collidable, fixture);
                        }
                        else if (((collidable != null) || collidable === null) && fixture === undefined) {
                            return this.contains$org_dyn4j_collision_Collidable(collidable);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     */
                    clear() {
                        this.map.clear();
                        this.root = null;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    size() {
                        return this.map.size();
                    }
                    detect$org_dyn4j_collision_broadphase_BroadphaseFilter(filter) {
                        const size = this.map.size();
                        const nodes = this.map.values();
                        for (let index = nodes.iterator(); index.hasNext();) {
                            let node = index.next();
                            {
                                node.tested = false;
                            }
                        }
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionPairs(size);
                        const pairs = (new java.util.ArrayList(eSize));
                        for (let index = nodes.iterator(); index.hasNext();) {
                            let node = index.next();
                            {
                                this.detectNonRecursive$org_dyn4j_collision_broadphase_DynamicAABBTreeLeaf$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(node, this.root, filter, pairs);
                                node.tested = true;
                            }
                        }
                        return pairs;
                    }
                    detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter(aabb, filter) {
                        return this.detectNonRecursive$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter(aabb, this.root, filter);
                    }
                    /**
                     * Returns true if the ray and AABB intersect.
                     * <p>
                     * This method is ideally called for a number of AABBs where the invDx and invDy can
                     * be computed once.
                     * @param {org.dyn4j.geometry.Vector2} start the start position of the ray
                     * @param {number} length the length of the ray
                     * @param {number} invDx the inverse of the x component of the ray direction
                     * @param {number} invDy the inverse of the y component of the ray direction
                     * @param {org.dyn4j.geometry.AABB} aabb the AABB to test
                     * @return {boolean} true if the AABB and ray intersect
                     */
                    raycast(start, length, invDx, invDy, aabb) {
                        if (((start != null && start instanceof org.dyn4j.geometry.Vector2) || start === null) && ((typeof length === 'number') || length === null) && ((typeof invDx === 'number') || invDx === null) && ((typeof invDy === 'number') || invDy === null) && ((aabb != null && aabb instanceof org.dyn4j.geometry.AABB) || aabb === null)) {
                            return super.raycast(start, length, invDx, invDy, aabb);
                        }
                        else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof length === 'number') || length === null) && ((invDx != null && (invDx.constructor != null && invDx.constructor["__interfaces"] != null && invDx.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || invDx === null) && invDy === undefined && aabb === undefined) {
                            return this.raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_broadphase_BroadphaseFilter(start, length, invDx);
                        }
                        else if (((start != null && start instanceof org.dyn4j.geometry.Ray) || start === null) && ((typeof length === 'number') || length === null) && invDx === undefined && invDy === undefined && aabb === undefined) {
                            return this.raycast$org_dyn4j_geometry_Ray$double(start, length);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    raycast$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_broadphase_BroadphaseFilter(ray, length, filter) {
                        if (this.map.size() === 0) {
                            return java.util.Collections.emptyList();
                        }
                        const s = ray.getStart();
                        const d = ray.getDirectionVector();
                        let l = length;
                        if (length <= 0.0)
                            l = javaemul.internal.DoubleHelper.MAX_VALUE;
                        const x1 = s.x;
                        const x2 = s.x + d.x * l;
                        const y1 = s.y;
                        const y2 = s.y + d.y * l;
                        const aabb = org.dyn4j.geometry.AABB.createAABBFromPoints$double$double$double$double(x1, y1, x2, y2);
                        const invDx = 1.0 / d.x;
                        const invDy = 1.0 / d.y;
                        let node = this.root;
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedRaycastCollisions(this.map.size());
                        const list = (new java.util.ArrayList(eSize));
                        while ((node != null)) {
                            {
                                if (aabb.overlaps(node.aabb)) {
                                    if (node.left != null) {
                                        node = node.left;
                                        continue;
                                    }
                                    else if (this.raycast$org_dyn4j_geometry_Vector2$double$double$double$org_dyn4j_geometry_AABB(s, l, invDx, invDy, node.aabb)) {
                                        const leaf = node;
                                        if (filter.isAllowed(ray, length, leaf.collidable, leaf.fixture)) {
                                            list.add((new org.dyn4j.collision.broadphase.BroadphaseItem(leaf.collidable, leaf.fixture)));
                                        }
                                    }
                                }
                                let nextNodeFound = false;
                                while ((node.parent != null)) {
                                    {
                                        if (node === node.parent.left) {
                                            node = node.parent.right;
                                            nextNodeFound = true;
                                            break;
                                        }
                                        node = node.parent;
                                    }
                                }
                                ;
                                if (!nextNodeFound)
                                    break;
                            }
                        }
                        ;
                        return list;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                        let node = this.root;
                        while ((node != null)) {
                            {
                                if (node.left != null) {
                                    node = node.left;
                                }
                                else if (node.right != null) {
                                    node.aabb.translate$org_dyn4j_geometry_Vector2(shift);
                                    node = node.right;
                                }
                                else {
                                    node.aabb.translate$org_dyn4j_geometry_Vector2(shift);
                                    let nextNodeFound = false;
                                    while ((node.parent != null)) {
                                        {
                                            if (node === node.parent.left) {
                                                if (node.parent.right != null) {
                                                    node.parent.aabb.translate$org_dyn4j_geometry_Vector2(shift);
                                                    node = node.parent.right;
                                                    nextNodeFound = true;
                                                    break;
                                                }
                                            }
                                            node = node.parent;
                                        }
                                    }
                                    ;
                                    if (!nextNodeFound)
                                        break;
                                }
                            }
                        }
                        ;
                    }
                    detect$org_dyn4j_collision_broadphase_DynamicAABBTreeLeaf$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(node, root, filter, pairs) {
                        if (node.aabb.overlaps(root.aabb)) {
                            if (root.left == null) {
                                const leaf = root;
                                if (!leaf.tested && leaf.collidable !== node.collidable) {
                                    if (filter.isAllowed(node.collidable, node.fixture, leaf.collidable, leaf.fixture)) {
                                        const pair = (new org.dyn4j.collision.broadphase.BroadphasePair(node.collidable, node.fixture, leaf.collidable, leaf.fixture));
                                        pairs.add(pair);
                                    }
                                }
                                return;
                            }
                            if (root.left != null)
                                this.detect$org_dyn4j_collision_broadphase_DynamicAABBTreeLeaf$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(node, root.left, filter, pairs);
                            if (root.right != null)
                                this.detect$org_dyn4j_collision_broadphase_DynamicAABBTreeLeaf$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(node, root.right, filter, pairs);
                        }
                    }
                    /**
                     * Internal recursive detection method.
                     * @param {org.dyn4j.collision.broadphase.DynamicAABBTreeLeaf} node the node to test
                     * @param {org.dyn4j.collision.broadphase.DynamicAABBTreeNode} root the root node of the subtree
                     * @param {*} filter the broadphase filter
                     * @param {*} pairs the list of pairs to add to
                     */
                    detect(node, root, filter, pairs) {
                        if (((node != null && node instanceof org.dyn4j.collision.broadphase.DynamicAABBTreeLeaf) || node === null) && ((root != null && root instanceof org.dyn4j.collision.broadphase.DynamicAABBTreeNode) || root === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || filter === null) && ((pairs != null && (pairs.constructor != null && pairs.constructor["__interfaces"] != null && pairs.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || pairs === null)) {
                            return this.detect$org_dyn4j_collision_broadphase_DynamicAABBTreeLeaf$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(node, root, filter, pairs);
                        }
                        else if (((node != null && node instanceof org.dyn4j.geometry.AABB) || node === null) && ((root != null && root instanceof org.dyn4j.collision.broadphase.DynamicAABBTreeNode) || root === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || filter === null) && ((pairs != null && (pairs.constructor != null && pairs.constructor["__interfaces"] != null && pairs.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || pairs === null)) {
                            return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(node, root, filter, pairs);
                        }
                        else if (((node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || node === null) && ((root != null && root instanceof org.dyn4j.geometry.Transform) || root === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || filter === null) && ((pairs != null && pairs instanceof org.dyn4j.geometry.Transform) || pairs === null)) {
                            return super.detect(node, root, filter, pairs);
                        }
                        else if (((node != null && node instanceof org.dyn4j.geometry.AABB) || node === null) && ((root != null && (root.constructor != null && root.constructor["__interfaces"] != null && root.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || root === null) && filter === undefined && pairs === undefined) {
                            return this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_BroadphaseFilter(node, root);
                        }
                        else if (((node != null) || node === null) && ((root != null) || root === null) && filter === undefined && pairs === undefined) {
                            return this.detect$org_dyn4j_collision_Collidable$org_dyn4j_collision_Collidable(node, root);
                        }
                        else if (((node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || node === null) && root === undefined && filter === undefined && pairs === undefined) {
                            return this.detect$org_dyn4j_collision_broadphase_BroadphaseFilter(node);
                        }
                        else if (((node != null && node instanceof org.dyn4j.geometry.AABB) || node === null) && root === undefined && filter === undefined && pairs === undefined) {
                            return this.detect$org_dyn4j_geometry_AABB(node);
                        }
                        else if (node === undefined && root === undefined && filter === undefined && pairs === undefined) {
                            return this.detect$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    detectNonRecursive$org_dyn4j_collision_broadphase_DynamicAABBTreeLeaf$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(node, root, filter, pairs) {
                        let test = root;
                        while ((test != null)) {
                            {
                                if (test.aabb.overlaps(node.aabb)) {
                                    if (test.left != null) {
                                        test = test.left;
                                        continue;
                                    }
                                    else {
                                        const leaf = test;
                                        if (!leaf.tested && leaf.collidable !== node.collidable) {
                                            if (filter.isAllowed(node.collidable, node.fixture, leaf.collidable, leaf.fixture)) {
                                                const pair = (new org.dyn4j.collision.broadphase.BroadphasePair(node.collidable, node.fixture, leaf.collidable, leaf.fixture));
                                                pairs.add(pair);
                                            }
                                        }
                                    }
                                }
                                let nextNodeFound = false;
                                while ((test.parent != null)) {
                                    {
                                        if (test === test.parent.left) {
                                            test = test.parent.right;
                                            nextNodeFound = true;
                                            break;
                                        }
                                        test = test.parent;
                                    }
                                }
                                ;
                                if (!nextNodeFound)
                                    break;
                            }
                        }
                        ;
                    }
                    /**
                     * Internal non-recursive detection method.
                     * @param {org.dyn4j.collision.broadphase.DynamicAABBTreeLeaf} node the node to test
                     * @param {org.dyn4j.collision.broadphase.DynamicAABBTreeNode} root the root node of the subtree
                     * @param {*} filter the broadphase filter
                     * @param {*} pairs the list of pairs to add to
                     */
                    detectNonRecursive(node, root, filter, pairs) {
                        if (((node != null && node instanceof org.dyn4j.collision.broadphase.DynamicAABBTreeLeaf) || node === null) && ((root != null && root instanceof org.dyn4j.collision.broadphase.DynamicAABBTreeNode) || root === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || filter === null) && ((pairs != null && (pairs.constructor != null && pairs.constructor["__interfaces"] != null && pairs.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || pairs === null)) {
                            return this.detectNonRecursive$org_dyn4j_collision_broadphase_DynamicAABBTreeLeaf$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(node, root, filter, pairs);
                        }
                        else if (((node != null && node instanceof org.dyn4j.geometry.AABB) || node === null) && ((root != null && root instanceof org.dyn4j.collision.broadphase.DynamicAABBTreeNode) || root === null) && ((filter != null && (filter.constructor != null && filter.constructor["__interfaces"] != null && filter.constructor["__interfaces"].indexOf("org.dyn4j.collision.broadphase.BroadphaseFilter") >= 0)) || filter === null) && pairs === undefined) {
                            return this.detectNonRecursive$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter(node, root, filter);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(aabb, node, filter, list) {
                        if (aabb.overlaps(node.aabb)) {
                            if (node.left == null) {
                                const leaf = node;
                                if (filter.isAllowed(aabb, leaf.collidable, leaf.fixture)) {
                                    list.add((new org.dyn4j.collision.broadphase.BroadphaseItem(leaf.collidable, leaf.fixture)));
                                }
                                return;
                            }
                            if (node.left != null)
                                this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(aabb, node.left, filter, list);
                            if (node.right != null)
                                this.detect$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter$java_util_List(aabb, node.right, filter, list);
                        }
                    }
                    detectNonRecursive$org_dyn4j_geometry_AABB$org_dyn4j_collision_broadphase_DynamicAABBTreeNode$org_dyn4j_collision_broadphase_BroadphaseFilter(aabb, node, filter) {
                        const eSize = org.dyn4j.collision.Collisions.getEstimatedCollisionsPerObject();
                        const list = (new java.util.ArrayList(eSize));
                        while ((node != null)) {
                            {
                                if (aabb.overlaps(node.aabb)) {
                                    if (node.left != null) {
                                        node = node.left;
                                        continue;
                                    }
                                    else {
                                        const leaf = node;
                                        if (filter.isAllowed(aabb, leaf.collidable, leaf.fixture)) {
                                            list.add((new org.dyn4j.collision.broadphase.BroadphaseItem(leaf.collidable, leaf.fixture)));
                                        }
                                    }
                                }
                                let nextNodeFound = false;
                                while ((node.parent != null)) {
                                    {
                                        if (node === node.parent.left) {
                                            node = node.parent.right;
                                            nextNodeFound = true;
                                            break;
                                        }
                                        node = node.parent;
                                    }
                                }
                                ;
                                if (!nextNodeFound)
                                    break;
                            }
                        }
                        ;
                        return list;
                    }
                    /**
                     * Internal method to insert a node into the tree.
                     * @param {org.dyn4j.collision.broadphase.DynamicAABBTreeNode} item the node to insert
                     */
                    insert(item) {
                        if (this.root == null) {
                            this.root = item;
                            return;
                        }
                        const temp = new org.dyn4j.geometry.AABB(0, 0, 0, 0);
                        const itemAABB = item.aabb;
                        let node = this.root;
                        while ((!node.isLeaf())) {
                            {
                                const aabb = node.aabb;
                                const perimeter = aabb.getPerimeter();
                                const unionPerimeter = temp.set$org_dyn4j_geometry_AABB(aabb).union(itemAABB).getPerimeter();
                                const cost = 2 * unionPerimeter;
                                const descendCost = 2 * (unionPerimeter - perimeter);
                                const left = node.left;
                                const right = node.right;
                                let costl = 0.0;
                                if (left.isLeaf()) {
                                    costl = temp.set$org_dyn4j_geometry_AABB(left.aabb).union(itemAABB).getPerimeter() + descendCost;
                                }
                                else {
                                    const oldPerimeter = left.aabb.getPerimeter();
                                    const newPerimeter = temp.set$org_dyn4j_geometry_AABB(left.aabb).union(itemAABB).getPerimeter();
                                    costl = newPerimeter - oldPerimeter + descendCost;
                                }
                                let costr = 0.0;
                                if (right.isLeaf()) {
                                    costr = temp.set$org_dyn4j_geometry_AABB(right.aabb).union(itemAABB).getPerimeter() + descendCost;
                                }
                                else {
                                    const oldPerimeter = right.aabb.getPerimeter();
                                    const newPerimeter = temp.set$org_dyn4j_geometry_AABB(right.aabb).union(itemAABB).getPerimeter();
                                    costr = newPerimeter - oldPerimeter + descendCost;
                                }
                                if (cost < costl && cost < costr) {
                                    break;
                                }
                                if (costl < costr) {
                                    node = left;
                                }
                                else {
                                    node = right;
                                }
                            }
                        }
                        ;
                        const parent = node.parent;
                        const newParent = new org.dyn4j.collision.broadphase.DynamicAABBTreeNode();
                        newParent.parent = node.parent;
                        newParent.aabb = node.aabb.getUnion(itemAABB);
                        newParent.height = node.height + 1;
                        if (parent != null) {
                            if (parent.left === node) {
                                parent.left = newParent;
                            }
                            else {
                                parent.right = newParent;
                            }
                            newParent.left = node;
                            newParent.right = item;
                            node.parent = newParent;
                            item.parent = newParent;
                        }
                        else {
                            newParent.left = node;
                            newParent.right = item;
                            node.parent = newParent;
                            item.parent = newParent;
                            this.root = newParent;
                        }
                        node = item.parent;
                        while ((node != null)) {
                            {
                                node = this.balance(node);
                                const left = node.left;
                                const right = node.right;
                                node.height = 1 + Math.max(left.height, right.height);
                                node.aabb.set$org_dyn4j_geometry_AABB(left.aabb).union(right.aabb);
                                node = node.parent;
                            }
                        }
                        ;
                    }
                    remove$org_dyn4j_collision_broadphase_DynamicAABBTreeNode(node) {
                        if (this.root == null)
                            return;
                        if (node === this.root) {
                            this.root = null;
                            return;
                        }
                        const parent = node.parent;
                        const grandparent = parent.parent;
                        let other;
                        if (parent.left === node) {
                            other = parent.right;
                        }
                        else {
                            other = parent.left;
                        }
                        if (grandparent != null) {
                            if (grandparent.left === parent) {
                                grandparent.left = other;
                            }
                            else {
                                grandparent.right = other;
                            }
                            other.parent = grandparent;
                            let n = grandparent;
                            while ((n != null)) {
                                {
                                    n = this.balance(n);
                                    const left = n.left;
                                    const right = n.right;
                                    n.height = 1 + Math.max(left.height, right.height);
                                    n.aabb.set$org_dyn4j_geometry_AABB(left.aabb).union(right.aabb);
                                    n = n.parent;
                                }
                            }
                            ;
                        }
                        else {
                            this.root = other;
                            other.parent = null;
                        }
                    }
                    /**
                     * Balances the subtree using node as the root.
                     * @param {org.dyn4j.collision.broadphase.DynamicAABBTreeNode} node the root node of the subtree to balance
                     * @return {org.dyn4j.collision.broadphase.DynamicAABBTreeNode} {@link DynamicAABBTreeNode} the new root of the subtree
                     */
                    balance(node) {
                        const a = node;
                        if (a.isLeaf() || a.height < 2) {
                            return a;
                        }
                        const b = a.left;
                        const c = a.right;
                        const balance = c.height - b.height;
                        if (balance > 1) {
                            const f = c.left;
                            const g = c.right;
                            c.left = a;
                            c.parent = a.parent;
                            a.parent = c;
                            if (c.parent != null) {
                                if (c.parent.left === a) {
                                    c.parent.left = c;
                                }
                                else {
                                    c.parent.right = c;
                                }
                            }
                            else {
                                this.root = c;
                            }
                            if (f.height > g.height) {
                                c.right = f;
                                a.right = g;
                                g.parent = a;
                                a.aabb.set$org_dyn4j_geometry_AABB(b.aabb).union(g.aabb);
                                c.aabb.set$org_dyn4j_geometry_AABB(a.aabb).union(f.aabb);
                                a.height = 1 + Math.max(b.height, g.height);
                                c.height = 1 + Math.max(a.height, f.height);
                            }
                            else {
                                c.right = g;
                                a.right = f;
                                f.parent = a;
                                a.aabb.set$org_dyn4j_geometry_AABB(b.aabb).union(f.aabb);
                                c.aabb.set$org_dyn4j_geometry_AABB(a.aabb).union(g.aabb);
                                a.height = 1 + Math.max(b.height, f.height);
                                c.height = 1 + Math.max(a.height, g.height);
                            }
                            return c;
                        }
                        if (balance < -1) {
                            const d = b.left;
                            const e = b.right;
                            b.left = a;
                            b.parent = a.parent;
                            a.parent = b;
                            if (b.parent != null) {
                                if (b.parent.left === a) {
                                    b.parent.left = b;
                                }
                                else {
                                    b.parent.right = b;
                                }
                            }
                            else {
                                this.root = b;
                            }
                            if (d.height > e.height) {
                                b.right = d;
                                a.left = e;
                                e.parent = a;
                                a.aabb.set$org_dyn4j_geometry_AABB(c.aabb).union(e.aabb);
                                b.aabb.set$org_dyn4j_geometry_AABB(a.aabb).union(d.aabb);
                                a.height = 1 + Math.max(c.height, e.height);
                                b.height = 1 + Math.max(a.height, d.height);
                            }
                            else {
                                b.right = e;
                                a.left = d;
                                d.parent = a;
                                a.aabb.set$org_dyn4j_geometry_AABB(c.aabb).union(d.aabb);
                                b.aabb.set$org_dyn4j_geometry_AABB(a.aabb).union(e.aabb);
                                a.height = 1 + Math.max(c.height, d.height);
                                b.height = 1 + Math.max(a.height, e.height);
                            }
                            return b;
                        }
                        return a;
                    }
                    /**
                     * Internal recursive method used to validate the state of the
                     * subtree with the given node as the root.
                     * <p>
                     * Used for testing only.  Test using the -ea flag on the command line.
                     * @param {org.dyn4j.collision.broadphase.DynamicAABBTreeNode} node the root of the subtree to validate
                     */
                    validate(node) {
                        if (node == null) {
                            return;
                        }
                        if (node === this.root) {
                        }
                        const left = node.left;
                        const right = node.right;
                        if (node.isLeaf()) {
                            const leaf = node;
                            return;
                        }
                        this.validate(left);
                        this.validate(right);
                    }
                }
                broadphase.DynamicAABBTree = DynamicAABBTree;
                DynamicAABBTree["__class"] = "org.dyn4j.collision.broadphase.DynamicAABBTree";
                DynamicAABBTree["__interfaces"] = ["org.dyn4j.collision.broadphase.BroadphaseDetector", "org.dyn4j.geometry.Shiftable"];
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var broadphase;
            (function (broadphase) {
                /**
                 * Minimal constructor.
                 * @param {*} collidable the collidable
                 * @param {org.dyn4j.collision.Fixture} fixture the fixture
                 * @class
                 * @extends org.dyn4j.collision.broadphase.DynamicAABBTreeNode
                 * @author William Bittle
                 */
                class DynamicAABBTreeLeaf extends org.dyn4j.collision.broadphase.DynamicAABBTreeNode {
                    constructor(collidable, fixture) {
                        super();
                        if (this.collidable === undefined) {
                            this.collidable = null;
                        }
                        if (this.fixture === undefined) {
                            this.fixture = null;
                        }
                        this.tested = false;
                        this.collidable = collidable;
                        this.fixture = fixture;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (obj == null)
                            return false;
                        if (obj === this)
                            return true;
                        if (obj != null && obj instanceof org.dyn4j.collision.broadphase.DynamicAABBTreeLeaf) {
                            const leaf = obj;
                            if (leaf.collidable === this.collidable && leaf.fixture === this.fixture) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let hash = 17;
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable);
                        hash = hash * 31 + /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture);
                        return hash;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("DynamicAABBTreeLeaf[Collidable=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.collidable)).append("|Fixture=").append(/* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.fixture)).append("|AABB=").append(this.aabb.toString()).append("|Height=").append(this.height).append("|Tested=").append(this.tested).append("]");
                        return sb.toString();
                    }
                }
                broadphase.DynamicAABBTreeLeaf = DynamicAABBTreeLeaf;
                DynamicAABBTreeLeaf["__class"] = "org.dyn4j.collision.broadphase.DynamicAABBTreeLeaf";
            })(broadphase = collision.broadphase || (collision.broadphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Optional constructor.
                 * @param {number} sortIndex the sort index of this condition
                 * @class
                 * @extends org.dyn4j.collision.narrowphase.AbstractFallbackCondition
                 * @author William Bittle
                 */
                class TypedFallbackCondition extends org.dyn4j.collision.narrowphase.AbstractFallbackCondition {
                    constructor(sortIndex = 0) {
                        super(sortIndex);
                    }
                    isMatch$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Convex(convex1, convex2) {
                        return this.isMatch$java_lang_Class$java_lang_Class(convex1.constructor, convex2.constructor);
                    }
                    /**
                     *
                     * @param {*} convex1
                     * @param {*} convex2
                     * @return {boolean}
                     */
                    isMatch(convex1, convex2) {
                        if (((convex1 != null && (convex1.constructor != null && convex1.constructor["__interfaces"] != null && convex1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex1 === null) && ((convex2 != null && (convex2.constructor != null && convex2.constructor["__interfaces"] != null && convex2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || convex2 === null)) {
                            return this.isMatch$org_dyn4j_geometry_Convex$org_dyn4j_geometry_Convex(convex1, convex2);
                        }
                        else if (((convex1 != null && (convex1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(convex1))) || convex1 === null) && ((convex2 != null && (convex2["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(convex2))) || convex2 === null)) {
                            return this.isMatch$java_lang_Class$java_lang_Class(convex1, convex2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    isMatch$java_lang_Class$java_lang_Class(type1, type2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
                }
                narrowphase.TypedFallbackCondition = TypedFallbackCondition;
                TypedFallbackCondition["__class"] = "org.dyn4j.collision.narrowphase.TypedFallbackCondition";
                TypedFallbackCondition["__interfaces"] = ["java.lang.Comparable", "org.dyn4j.collision.narrowphase.FallbackCondition"];
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            /**
             * Minimal constructor.
             * @param {number} width the width of the bounds; must be greater than zero
             * @param {number} height the height of the bounds; must be greater than zero
             * @throws IllegalArgumentException if either width or height are less than or equal to zero
             * @class
             * @extends org.dyn4j.collision.AbstractBounds
             * @author William Bittle
             */
            class AxisAlignedBounds extends org.dyn4j.collision.AbstractBounds {
                constructor(width, height) {
                    super();
                    if (this.aabb === undefined) {
                        this.aabb = null;
                    }
                    if (width <= 0.0 || height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("collision.bounds.axisAligned.invalidArgument"));
                    const w2 = width * 0.5;
                    const h2 = height * 0.5;
                    this.aabb = new org.dyn4j.geometry.AABB(-w2, -h2, w2, h2);
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("AxisAlignedBounds[Width=").append(this.aabb.getWidth()).append("|Height=").append(this.aabb.getHeight()).append("|Translation=").append(this.getTranslation()).append("]");
                    return sb.toString();
                }
                /**
                 *
                 * @param {*} collidable
                 * @return {boolean}
                 */
                isOutside(collidable) {
                    const tx = this.transform.getTranslation();
                    const aabbBounds = this.aabb.getTranslated(tx);
                    const aabbBody = collidable['createAABB$']();
                    return !aabbBounds.overlaps(aabbBody);
                }
                /**
                 * Returns the world space Axis-Aligned bounding box for this
                 * bounds object.
                 * @return {org.dyn4j.geometry.AABB} {@link AABB}
                 */
                getBounds() {
                    return this.aabb.getTranslated(this.transform.getTranslation());
                }
                /**
                 * Returns the width of the bounds.
                 * @return {number} double
                 */
                getWidth() {
                    return this.aabb.getWidth();
                }
                /**
                 * Returns the height of the bounds.
                 * @return {number} double
                 */
                getHeight() {
                    return this.aabb.getHeight();
                }
            }
            collision.AxisAlignedBounds = AxisAlignedBounds;
            AxisAlignedBounds["__class"] = "org.dyn4j.collision.AxisAlignedBounds";
            AxisAlignedBounds["__interfaces"] = ["org.dyn4j.collision.Bounds", "org.dyn4j.geometry.Shiftable", "org.dyn4j.geometry.Translatable"];
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Minimal constructor.
             * @param {*} shape the {@link Convex} {@link Shape} for this fixture
             * @class
             * @extends org.dyn4j.collision.Fixture
             * @author William Bittle
             */
            class BodyFixture extends org.dyn4j.collision.Fixture {
                constructor(shape) {
                    super(shape);
                    if (this.density === undefined) {
                        this.density = 0;
                    }
                    if (this.friction === undefined) {
                        this.friction = 0;
                    }
                    if (this.restitution === undefined) {
                        this.restitution = 0;
                    }
                    this.sticky = false;
                    this.density = BodyFixture.DEFAULT_DENSITY;
                    this.friction = BodyFixture.DEFAULT_FRICTION;
                    this.restitution = BodyFixture.DEFAULT_RESTITUTION;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("BodyFixture[Id=").append(this.id).append("|Shape=").append(this.shape).append("|Filter=").append(this.filter).append("|IsSensor=").append(this.sensor).append("|Density=").append(this.density).append("|Friction=").append(this.friction).append("|Restitution=").append(this.restitution).append("]");
                    return sb.toString();
                }
                /**
                 * Sets the density of this shape in kg/m<sup>2</sup>.
                 * <p>
                 * The density of an object is a number that represent how much matter is contained
                 * in a given space.  Larger density values indicate a more massive object.  Larger
                 * density objects resist changes in motion more than smaller objects.
                 * @param {number} density the density in kg/m<sup>2</sup>
                 * @throws IllegalArgumentException if density is less than or equal to zero
                 */
                setDensity(density) {
                    if (density <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.body.fixture.invalidDensity"));
                    this.density = density;
                }
                /**
                 * Returns the density of this shape in kg/m<sup>2</sup>.
                 * @return {number} double the density in kg/m<sup>2</sup>
                 * @see #setDensity(double)
                 */
                getDensity() {
                    return this.density;
                }
                /**
                 * Returns the coefficient of friction.
                 * @return {number} double
                 * @see #setFriction(double)
                 */
                getFriction() {
                    return this.friction;
                }
                /**
                 * Sets the coefficient of friction.
                 * <p>
                 * The coefficient of friction is a number that represents how rough a material is.
                 * Friction between surfaces converts the kinetic (motion) energy into heat, thereby
                 * slowing the objects in contact down.
                 * <p>
                 * A higher value of friction will slow the object down faster.  A friction value of
                 * zero represents no friction.
                 * <p>
                 * Since two {@link BodyFixture}s participate in a collision, their coefficients will
                 * be mixed by a {@link CoefficientMixer} to product a single value for the collision.
                 * @param {number} friction the coefficient of friction; must be greater than zero
                 * @throws IllegalArgumentException if friction is less than zero
                 */
                setFriction(friction) {
                    if (friction < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.body.fixture.invalidFriction"));
                    this.friction = friction;
                }
                /**
                 * Returns the coefficient of restitution.
                 * @return {number} double
                 * @see #setRestitution(double)
                 */
                getRestitution() {
                    return this.restitution;
                }
                /**
                 * Sets the coefficient of restitution.
                 * <p>
                 * The coefficient of restitution is a number that represents the bounciness of a material.
                 * Larger values produce more bounce and smaller values produce less bounce.  A value of 1.0
                 * indicates that an object would retain all of its velocity after bouncing.  The value can
                 * be higher than 1 to increase the velocity after bouncing.
                 * <p>
                 * Due to floating point precision and accuracy, a value of 1.0 may not produce a fully
                 * ellastic bounce (all the velocity is retained).
                 * <p>
                 * Since two {@link BodyFixture}s participate in a collision, their coefficients will
                 * be mixed by a {@link CoefficientMixer} to product a single value for the collision.
                 * @param {number} restitution the coefficient of restitution; must be greater than zero
                 * @throws IllegalArgumentException if restitution is less than zero
                 */
                setRestitution(restitution) {
                    if (restitution < 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.body.fixture.invalidRestitution"));
                    this.restitution = restitution;
                }
                /**
                 * Creates a new {@link Mass} object using the set density and shape.
                 * @return {org.dyn4j.geometry.Mass} {@link Mass}
                 */
                createMass() {
                    return this.shape.createMass(this.density);
                }
                /**
                 * Returns true if fixture is sticky (two fixtures stick if both are sticky).
                 * @return {boolean} true if fixture is sticky
                 */
                isSticky() {
                    return this.sticky;
                }
                /**
                 * Sets fixture sticky (two fixtures stick if both are sticky).
                 * @param {boolean} sticky
                 */
                setSticky(sticky) {
                    this.sticky = sticky;
                }
            }
            /**
             * The default coefficient of friction; value = {@link #DEFAULT_FRICTION}
             */
            BodyFixture.DEFAULT_FRICTION = 0.2;
            /**
             * The default coefficient of restitution; value = {@link #DEFAULT_RESTITUTION}
             */
            BodyFixture.DEFAULT_RESTITUTION = 0.0;
            /**
             * The default density in kg/m<sup>2</sup>; value = {@link #DEFAULT_DENSITY}
             */
            BodyFixture.DEFAULT_DENSITY = 1.0;
            dynamics.BodyFixture = BodyFixture;
            BodyFixture["__class"] = "org.dyn4j.dynamics.BodyFixture";
            BodyFixture["__interfaces"] = ["org.dyn4j.DataContainer"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * <p>
                 * Creates a fixed distance {@link Joint} where the joined
                 * {@link Body}s do not participate in collision detection and
                 * resolution.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} anchor1 in world coordinates
                 * @param {org.dyn4j.geometry.Vector2} anchor2 in world coordinates
                 * @throws NullPointerException if body1, body2, anchor1, or anchor2 is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class DistanceJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2, anchor1, anchor2) {
                        super(body1, body2, false);
                        if (this.localAnchor1 === undefined) {
                            this.localAnchor1 = null;
                        }
                        if (this.localAnchor2 === undefined) {
                            this.localAnchor2 = null;
                        }
                        if (this.frequency === undefined) {
                            this.frequency = 0;
                        }
                        if (this.dampingRatio === undefined) {
                            this.dampingRatio = 0;
                        }
                        if (this.distance === undefined) {
                            this.distance = 0;
                        }
                        if (this.invK === undefined) {
                            this.invK = 0;
                        }
                        if (this.n === undefined) {
                            this.n = null;
                        }
                        if (this.bias === undefined) {
                            this.bias = 0;
                        }
                        if (this.gamma === undefined) {
                            this.gamma = 0;
                        }
                        if (this.impulse === undefined) {
                            this.impulse = 0;
                        }
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        if (anchor1 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor1"));
                        if (anchor2 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor2"));
                        this.localAnchor1 = body1.getLocalPoint(anchor1);
                        this.localAnchor2 = body2.getLocalPoint(anchor2);
                        this.distance = anchor1.distance$org_dyn4j_geometry_Vector2(anchor2);
                        this.n = new org.dyn4j.geometry.Vector2();
                    }
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("DistanceJoint[").append(super.toString()).append("|Anchor1=").append(this.getAnchor1()).append("|Anchor2=").append(this.getAnchor2()).append("|Frequency=").append(this.frequency).append("|DampingRatio=").append(this.dampingRatio).append("|Distance=").append(this.distance).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        const length = this.n.getMagnitude();
                        if (length < linearTolerance) {
                            this.n.zero();
                        }
                        else {
                            this.n.multiply(1.0 / length);
                        }
                        const cr1n = r1.cross$org_dyn4j_geometry_Vector2(this.n);
                        const cr2n = r2.cross$org_dyn4j_geometry_Vector2(this.n);
                        let invMass = invM1 + invI1 * cr1n * cr1n;
                        invMass += invM2 + invI2 * cr2n * cr2n;
                        this.invK = invMass <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / invMass;
                        if (this.frequency > 0.0) {
                            const dt = step.getDeltaTime();
                            const x = length - this.distance;
                            const w = org.dyn4j.geometry.Geometry.TWO_PI_$LI$() * this.frequency;
                            const d = 2.0 * this.invK * this.dampingRatio * w;
                            const k = this.invK * w * w;
                            this.gamma = dt * (d + dt * k);
                            this.gamma = this.gamma <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / this.gamma;
                            this.bias = x * dt * k * this.gamma;
                            invMass += this.gamma;
                            this.invK = invMass <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / invMass;
                        }
                        else {
                            this.gamma = 0.0;
                            this.bias = 0.0;
                        }
                        this.impulse *= step.getDeltaTimeRatio();
                        const J = this.n.product(this.impulse);
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(J));
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(J.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(J));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                        const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                        const Jv = this.n.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2));
                        const j = -this.invK * (Jv + this.bias + this.gamma * this.impulse);
                        this.impulse += j;
                        const J = this.n.product(j);
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(J));
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(J.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(J));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        if (this.frequency > 0.0) {
                            return true;
                        }
                        const linearTolerance = settings.getLinearTolerance();
                        const maxLinearCorrection = settings.getMaximumLinearCorrection();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const c1 = this.body1.getWorldCenter();
                        const c2 = this.body2.getWorldCenter();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        const l = this.n.normalize();
                        let C = l - this.distance;
                        C = org.dyn4j.geometry.Interval.clamp(C, -maxLinearCorrection, maxLinearCorrection);
                        const impulse = -this.invK * C;
                        const J = this.n.product(impulse);
                        this.body1.translate$double$double(this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J.x * invM1, this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J.y * invM1);
                        this.body1.rotate$double$org_dyn4j_geometry_Vector2(invI1 * r1.cross$org_dyn4j_geometry_Vector2(J), c1);
                        this.body2.translate$double$double(this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : -J.x * invM2, this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : -J.y * invM2);
                        this.body2.rotate$double$org_dyn4j_geometry_Vector2(-invI2 * r2.cross$org_dyn4j_geometry_Vector2(J), c2);
                        return Math.abs(C) < linearTolerance;
                    }
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        return this.n.product(this.impulse * invdt);
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Not applicable to this joint. Always returns zero.
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return 0.0;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     * Returns true if this distance joint is a spring distance joint.
                     * @return {boolean} boolean
                     */
                    isSpring() {
                        return this.frequency > 0.0;
                    }
                    /**
                     * Returns true if this distance joint is a spring distance joint
                     * with damping.
                     * @return {boolean} boolean
                     */
                    isSpringDamper() {
                        return this.frequency > 0.0 && this.dampingRatio > 0.0;
                    }
                    /**
                     * Returns the rest distance between the two constrained {@link Body}s in meters.
                     * @return {number} double
                     */
                    getDistance() {
                        return this.distance;
                    }
                    /**
                     * Sets the rest distance between the two constrained {@link Body}s in meters.
                     * @param {number} distance the distance in meters
                     * @throws IllegalArgumentException if distance is less than zero
                     */
                    setDistance(distance) {
                        if (distance < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.distance.invalidDistance"));
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.distance = distance;
                    }
                    /**
                     * Returns the damping ratio.
                     * @return {number} double
                     */
                    getDampingRatio() {
                        return this.dampingRatio;
                    }
                    /**
                     * Sets the damping ratio.
                     * <p>
                     * Larger values reduce the oscillation of the spring.
                     * @param {number} dampingRatio the damping ratio; in the range [0, 1]
                     * @throws IllegalArgumentException if damping ration is less than zero or greater than 1
                     */
                    setDampingRatio(dampingRatio) {
                        if (dampingRatio < 0 || dampingRatio > 1)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidDampingRatio"));
                        this.dampingRatio = dampingRatio;
                    }
                    /**
                     * Returns the spring frequency.
                     * @return {number} double
                     */
                    getFrequency() {
                        return this.frequency;
                    }
                    /**
                     * Sets the spring frequency.
                     * <p>
                     * Larger values increase the stiffness of the spring.
                     * @param {number} frequency the spring frequency in hz; must be greater than or equal to zero
                     * @throws IllegalArgumentException if frequency is less than zero
                     */
                    setFrequency(frequency) {
                        if (frequency < 0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidFrequency"));
                        this.frequency = frequency;
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                        this.localAnchor1.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.localAnchor2.add$org_dyn4j_geometry_Vector2(vt);
                    }
                }
                joint.DistanceJoint = DistanceJoint;
                DistanceJoint["__class"] = "org.dyn4j.dynamics.joint.DistanceJoint";
                DistanceJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.dynamics.Body} body the body to attach the joint to
                 * @param {org.dyn4j.geometry.Vector2} anchor the anchor point on the body
                 * @param {number} frequency the oscillation frequency in hz
                 * @param {number} dampingRatio the damping ratio
                 * @param {number} maximumForce the maximum force this constraint can apply in newtons
                 * @throws NullPointerException if body or anchor is null
                 * @throws IllegalArgumentException if frequency is less than or equal to zero, or if dampingRatio is less than zero or greater than one, or if maxForce is less than zero
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class PinJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body, anchor, frequency, dampingRatio, maximumForce) {
                        super(body, body, false);
                        if (this.target === undefined) {
                            this.target = null;
                        }
                        if (this.anchor === undefined) {
                            this.anchor = null;
                        }
                        if (this.frequency === undefined) {
                            this.frequency = 0;
                        }
                        if (this.dampingRatio === undefined) {
                            this.dampingRatio = 0;
                        }
                        if (this.maximumForce === undefined) {
                            this.maximumForce = 0;
                        }
                        if (this.K === undefined) {
                            this.K = null;
                        }
                        if (this.bias === undefined) {
                            this.bias = null;
                        }
                        if (this.gamma === undefined) {
                            this.gamma = 0;
                        }
                        if (this.impulse === undefined) {
                            this.impulse = null;
                        }
                        if (anchor == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.pin.nullAnchor"));
                        if (frequency <= 0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidFrequencyZero"));
                        if (dampingRatio < 0 || dampingRatio > 1)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidDampingRatio"));
                        if (maximumForce < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.pin.invalidMaximumForce"));
                        this.target = anchor;
                        this.anchor = body.getLocalPoint(anchor);
                        this.frequency = frequency;
                        this.dampingRatio = dampingRatio;
                        this.maximumForce = maximumForce;
                        this.K = new org.dyn4j.geometry.Matrix22();
                        this.impulse = new org.dyn4j.geometry.Vector2();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("PinJoint[").append(super.toString()).append("|Target=").append(this.target).append("|Anchor=").append(this.anchor).append("|Frequency=").append(this.frequency).append("|DampingRatio=").append(this.dampingRatio).append("|MaximumForce=").append(this.maximumForce).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const body = this.body2;
                        const transform = body.getTransform();
                        const mass = this.body2.getMassData();
                        let m = mass.getMass();
                        const invM = mass.getInverseMass();
                        const invI = mass.getInverseInertia();
                        if (m <= org.dyn4j.Epsilon.E_$LI$()) {
                            m = mass.getInertia();
                        }
                        const w = org.dyn4j.geometry.Geometry.TWO_PI_$LI$() * this.frequency;
                        const d = 2.0 * m * this.dampingRatio * w;
                        const k = m * w * w;
                        const dt = step.getDeltaTime();
                        this.gamma = dt * (d + dt * k);
                        if (this.gamma > org.dyn4j.Epsilon.E_$LI$()) {
                            this.gamma = 1.0 / this.gamma;
                        }
                        const r = transform.getTransformedR$org_dyn4j_geometry_Vector2(body.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.anchor));
                        this.bias = body.getWorldCenter().add$org_dyn4j_geometry_Vector2(r).difference$org_dyn4j_geometry_Vector2(this.target);
                        this.bias.multiply(dt * k * this.gamma);
                        this.K.m00 = invM + r.y * r.y * invI;
                        this.K.m01 = -invI * r.x * r.y;
                        this.K.m10 = this.K.m01;
                        this.K.m11 = invM + r.x * r.x * invI;
                        this.K.m00 += this.gamma;
                        this.K.m11 += this.gamma;
                        this.impulse.multiply(step.getDeltaTimeRatio());
                        body.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(this.impulse.product(invM));
                        body.setAngularVelocity(body.getAngularVelocity() + invI * r.cross$org_dyn4j_geometry_Vector2(this.impulse));
                        body.setLinearVelocity$org_dyn4j_geometry_Vector2(body.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        const body = this.body2;
                        const transform = body.getTransform();
                        const mass = this.body2.getMassData();
                        const invM = mass.getInverseMass();
                        const invI = mass.getInverseInertia();
                        const r = transform.getTransformedR$org_dyn4j_geometry_Vector2(body.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.anchor));
                        const C = r.cross$double(body.getAngularVelocity()).add$org_dyn4j_geometry_Vector2(body.getLinearVelocity$());
                        const jvb = C;
                        jvb.add$org_dyn4j_geometry_Vector2(this.bias);
                        jvb.add$org_dyn4j_geometry_Vector2(this.impulse.product(this.gamma));
                        jvb.negate();
                        let J = this.K.solve(jvb);
                        const oldImpulse = this.impulse.copy();
                        this.impulse.add$org_dyn4j_geometry_Vector2(J);
                        const maxImpulse = step.getDeltaTime() * this.maximumForce;
                        if (this.impulse.getMagnitudeSquared() > maxImpulse * maxImpulse) {
                            this.impulse.normalize();
                            this.impulse.multiply(maxImpulse);
                        }
                        J = this.impulse.difference$org_dyn4j_geometry_Vector2(oldImpulse);
                        body.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J.product(invM));
                        body.setAngularVelocity(body.getAngularVelocity() + invI * r.cross$org_dyn4j_geometry_Vector2(J));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        return true;
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Returns the target point in world space.
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor1() {
                        return this.target;
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Returns the anchor point on the body in world space.
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.anchor);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        return this.impulse.product(invdt);
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Not applicable to this joint.
                     * Always returns zero.
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return 0.0;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isCollisionAllowed() {
                        return false;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                        this.target.add$org_dyn4j_geometry_Vector2(shift);
                    }
                    /**
                     * Returns the target point in world coordinates.
                     * @param {org.dyn4j.geometry.Vector2} target the target point
                     * @throws NullPointerException if target is null
                     */
                    setTarget(target) {
                        if (target == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.pin.nullTarget"));
                        this.body2.setAsleep(false);
                        this.target = target;
                    }
                    /**
                     * Returns the target point in world coordinates
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getTarget() {
                        return this.target;
                    }
                    /**
                     * Returns the maximum force this constraint will apply in newtons.
                     * @return {number} double
                     */
                    getMaximumForce() {
                        return this.maximumForce;
                    }
                    /**
                     * Sets the maximum force this constraint will apply in newtons.
                     * @param {number} maximumForce the maximum force in newtons; in the range [0, &infin;]
                     * @throws IllegalArgumentException if maxForce less than zero
                     */
                    setMaximumForce(maximumForce) {
                        if (maximumForce < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.pin.invalidMaximumForce"));
                        this.maximumForce = maximumForce;
                    }
                    /**
                     * Returns the damping ratio.
                     * @return {number} double
                     */
                    getDampingRatio() {
                        return this.dampingRatio;
                    }
                    /**
                     * Sets the damping ratio.
                     * @param {number} dampingRatio the damping ratio; in the range [0, 1]
                     * @throws IllegalArgumentException if dampingRation is less than zero or greater than one
                     */
                    setDampingRatio(dampingRatio) {
                        if (dampingRatio < 0 || dampingRatio > 1)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidDampingRatio"));
                        this.dampingRatio = dampingRatio;
                    }
                    /**
                     * Returns the spring frequency.
                     * @return {number} double
                     */
                    getFrequency() {
                        return this.frequency;
                    }
                    /**
                     * Sets the spring frequency.
                     * @param {number} frequency the spring frequency in hz; must be greater than zero
                     * @throws IllegalArgumentException if frequency is less than or equal to zero
                     */
                    setFrequency(frequency) {
                        if (frequency <= 0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidFrequencyZero"));
                        this.frequency = frequency;
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.anchor.add$org_dyn4j_geometry_Vector2(vt);
                    }
                }
                joint.PinJoint = PinJoint;
                PinJoint["__class"] = "org.dyn4j.dynamics.joint.PinJoint";
                PinJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Full constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} anchor1 the anchor point on body 1 in local coordinates of body1
                 * @param {org.dyn4j.geometry.Vector2} anchor2 the anchor point on body 2 in local coordinates of body2
                 * @param {org.dyn4j.geometry.Vector2} axis the axis of allowed motion in local coordinates of body1 coordinates
                 * @param {number} referenceAngle The initial angle between the two Bodies in degrees
                 * @throws NullPointerException if body1, body2, anchor or axis is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class PrismaticJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2, anchor1, anchor2, axis, referenceAngle) {
                        if (((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((anchor1 != null && anchor1 instanceof org.dyn4j.geometry.Vector2) || anchor1 === null) && ((anchor2 != null && anchor2 instanceof org.dyn4j.geometry.Vector2) || anchor2 === null) && ((axis != null && axis instanceof org.dyn4j.geometry.Vector2) || axis === null) && ((typeof referenceAngle === 'number') || referenceAngle === null)) {
                            let __args = arguments;
                            super(body1, body2, false);
                            if (this.localAnchor1 === undefined) {
                                this.localAnchor1 = null;
                            }
                            if (this.localAnchor2 === undefined) {
                                this.localAnchor2 = null;
                            }
                            if (this.motorEnabled === undefined) {
                                this.motorEnabled = false;
                            }
                            if (this.motorSpeed === undefined) {
                                this.motorSpeed = 0;
                            }
                            if (this.maximumMotorForce === undefined) {
                                this.maximumMotorForce = 0;
                            }
                            if (this.limitEnabled === undefined) {
                                this.limitEnabled = false;
                            }
                            if (this.upperLimit === undefined) {
                                this.upperLimit = 0;
                            }
                            if (this.lowerLimit === undefined) {
                                this.lowerLimit = 0;
                            }
                            if (this.referenceAngle === undefined) {
                                this.referenceAngle = 0;
                            }
                            if (this.xAxis === undefined) {
                                this.xAxis = null;
                            }
                            if (this.yAxis === undefined) {
                                this.yAxis = null;
                            }
                            if (this.limitState === undefined) {
                                this.limitState = null;
                            }
                            if (this.K === undefined) {
                                this.K = null;
                            }
                            if (this.motorMass === undefined) {
                                this.motorMass = 0;
                            }
                            if (this.perp === undefined) {
                                this.perp = null;
                            }
                            if (this.axis === undefined) {
                                this.axis = null;
                            }
                            if (this.s1 === undefined) {
                                this.s1 = 0;
                            }
                            if (this.s2 === undefined) {
                                this.s2 = 0;
                            }
                            if (this.a1 === undefined) {
                                this.a1 = 0;
                            }
                            if (this.a2 === undefined) {
                                this.a2 = 0;
                            }
                            if (this.impulse === undefined) {
                                this.impulse = null;
                            }
                            if (this.motorImpulse === undefined) {
                                this.motorImpulse = 0;
                            }
                            if (body1 === body2)
                                throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                            if (anchor1 == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor"));
                            if (anchor2 == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor"));
                            if (axis == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAxis"));
                            this.localAnchor1 = body1.getLocalPoint(anchor1);
                            this.localAnchor2 = body2.getLocalPoint(anchor2);
                            const n = axis.getNormalized();
                            this.xAxis = n;
                            this.yAxis = this.xAxis.cross$double(1.0);
                            this.referenceAngle = referenceAngle;
                            this.K = new org.dyn4j.geometry.Matrix33();
                            this.impulse = new org.dyn4j.geometry.Vector3();
                            this.limitEnabled = false;
                            this.motorEnabled = false;
                            this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                        }
                        else if (((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((anchor1 != null && anchor1 instanceof org.dyn4j.geometry.Vector2) || anchor1 === null) && ((anchor2 != null && anchor2 instanceof org.dyn4j.geometry.Vector2) || anchor2 === null) && ((axis != null && axis instanceof org.dyn4j.geometry.Vector2) || axis === null) && referenceAngle === undefined) {
                            let __args = arguments;
                            super(body1, body2, false);
                            if (this.localAnchor1 === undefined) {
                                this.localAnchor1 = null;
                            }
                            if (this.localAnchor2 === undefined) {
                                this.localAnchor2 = null;
                            }
                            if (this.motorEnabled === undefined) {
                                this.motorEnabled = false;
                            }
                            if (this.motorSpeed === undefined) {
                                this.motorSpeed = 0;
                            }
                            if (this.maximumMotorForce === undefined) {
                                this.maximumMotorForce = 0;
                            }
                            if (this.limitEnabled === undefined) {
                                this.limitEnabled = false;
                            }
                            if (this.upperLimit === undefined) {
                                this.upperLimit = 0;
                            }
                            if (this.lowerLimit === undefined) {
                                this.lowerLimit = 0;
                            }
                            if (this.referenceAngle === undefined) {
                                this.referenceAngle = 0;
                            }
                            if (this.xAxis === undefined) {
                                this.xAxis = null;
                            }
                            if (this.yAxis === undefined) {
                                this.yAxis = null;
                            }
                            if (this.limitState === undefined) {
                                this.limitState = null;
                            }
                            if (this.K === undefined) {
                                this.K = null;
                            }
                            if (this.motorMass === undefined) {
                                this.motorMass = 0;
                            }
                            if (this.perp === undefined) {
                                this.perp = null;
                            }
                            if (this.axis === undefined) {
                                this.axis = null;
                            }
                            if (this.s1 === undefined) {
                                this.s1 = 0;
                            }
                            if (this.s2 === undefined) {
                                this.s2 = 0;
                            }
                            if (this.a1 === undefined) {
                                this.a1 = 0;
                            }
                            if (this.a2 === undefined) {
                                this.a2 = 0;
                            }
                            if (this.impulse === undefined) {
                                this.impulse = null;
                            }
                            if (this.motorImpulse === undefined) {
                                this.motorImpulse = 0;
                            }
                            if (body1 === body2)
                                throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                            if (anchor1 == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor"));
                            if (anchor2 == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor"));
                            if (axis == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAxis"));
                            this.localAnchor1 = body1.getLocalPoint(anchor1);
                            this.localAnchor2 = body2.getLocalPoint(anchor2);
                            const n = axis.getNormalized();
                            this.xAxis = body2.getLocalVector(n);
                            this.yAxis = this.xAxis.cross$double(1.0);
                            this.referenceAngle = body1.getTransform().getRotationAngle() - body2.getTransform().getRotationAngle();
                            this.K = new org.dyn4j.geometry.Matrix33();
                            this.impulse = new org.dyn4j.geometry.Vector3();
                            this.limitEnabled = false;
                            this.motorEnabled = false;
                            this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                        }
                        else if (((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((anchor1 != null && anchor1 instanceof org.dyn4j.geometry.Vector2) || anchor1 === null) && ((anchor2 != null && anchor2 instanceof org.dyn4j.geometry.Vector2) || anchor2 === null) && axis === undefined && referenceAngle === undefined) {
                            let __args = arguments;
                            let anchor = __args[2];
                            let axis = __args[3];
                            super(body1, body2, false);
                            if (this.localAnchor1 === undefined) {
                                this.localAnchor1 = null;
                            }
                            if (this.localAnchor2 === undefined) {
                                this.localAnchor2 = null;
                            }
                            if (this.motorEnabled === undefined) {
                                this.motorEnabled = false;
                            }
                            if (this.motorSpeed === undefined) {
                                this.motorSpeed = 0;
                            }
                            if (this.maximumMotorForce === undefined) {
                                this.maximumMotorForce = 0;
                            }
                            if (this.limitEnabled === undefined) {
                                this.limitEnabled = false;
                            }
                            if (this.upperLimit === undefined) {
                                this.upperLimit = 0;
                            }
                            if (this.lowerLimit === undefined) {
                                this.lowerLimit = 0;
                            }
                            if (this.referenceAngle === undefined) {
                                this.referenceAngle = 0;
                            }
                            if (this.xAxis === undefined) {
                                this.xAxis = null;
                            }
                            if (this.yAxis === undefined) {
                                this.yAxis = null;
                            }
                            if (this.limitState === undefined) {
                                this.limitState = null;
                            }
                            if (this.K === undefined) {
                                this.K = null;
                            }
                            if (this.motorMass === undefined) {
                                this.motorMass = 0;
                            }
                            if (this.perp === undefined) {
                                this.perp = null;
                            }
                            if (this.axis === undefined) {
                                this.axis = null;
                            }
                            if (this.s1 === undefined) {
                                this.s1 = 0;
                            }
                            if (this.s2 === undefined) {
                                this.s2 = 0;
                            }
                            if (this.a1 === undefined) {
                                this.a1 = 0;
                            }
                            if (this.a2 === undefined) {
                                this.a2 = 0;
                            }
                            if (this.impulse === undefined) {
                                this.impulse = null;
                            }
                            if (this.motorImpulse === undefined) {
                                this.motorImpulse = 0;
                            }
                            if (body1 === body2)
                                throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                            if (anchor == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor"));
                            if (axis == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAxis"));
                            this.localAnchor1 = body1.getLocalPoint(anchor);
                            this.localAnchor2 = body2.getLocalPoint(anchor);
                            const n = axis.getNormalized();
                            this.xAxis = body2.getLocalVector(n);
                            this.yAxis = this.xAxis.getRightHandOrthogonalVector();
                            this.referenceAngle = body1.getTransform().getRotationAngle() - body2.getTransform().getRotationAngle();
                            this.K = new org.dyn4j.geometry.Matrix33();
                            this.impulse = new org.dyn4j.geometry.Vector3();
                            this.limitEnabled = false;
                            this.motorEnabled = false;
                            this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("PrismaticJoint[").append(super.toString()).append("|Anchor=").append(this.getAnchor1()).append("|Axis=").append(this.getAxis()).append("|IsMotorEnabled=").append(this.motorEnabled).append("|MotorSpeed=").append(this.motorSpeed).append("|MaximumMotorForce=").append(this.maximumMotorForce).append("|ReferenceAngle=").append(this.referenceAngle).append("|IsLimitEnabled=").append(this.limitEnabled).append("|LowerLimit=").append(this.lowerLimit).append("|UpperLimit=").append(this.upperLimit).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const d = this.body1.getWorldCenter().sum$org_dyn4j_geometry_Vector2(r1).subtract$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter().sum$org_dyn4j_geometry_Vector2(r2));
                        this.axis = this.body2.getWorldVector(this.xAxis);
                        this.perp = this.body2.getWorldVector(this.yAxis);
                        this.s1 = r1.cross$org_dyn4j_geometry_Vector2(this.perp);
                        this.s2 = r2.sum$org_dyn4j_geometry_Vector2(d).cross$org_dyn4j_geometry_Vector2(this.perp);
                        this.a1 = r1.cross$org_dyn4j_geometry_Vector2(this.axis);
                        this.a2 = r2.sum$org_dyn4j_geometry_Vector2(d).cross$org_dyn4j_geometry_Vector2(this.axis);
                        this.K.m00 = invM1 + invM2 + this.s1 * this.s1 * invI1 + this.s2 * this.s2 * invI2;
                        this.K.m01 = this.s1 * invI1 + this.s2 * invI2;
                        this.K.m02 = this.s1 * this.a1 * invI1 + this.s2 * this.a2 * invI2;
                        this.K.m10 = this.K.m01;
                        this.K.m11 = invI1 + invI2;
                        if (this.K.m11 <= org.dyn4j.Epsilon.E_$LI$())
                            this.K.m11 = 1.0;
                        this.K.m12 = this.a1 * invI1 + this.a2 * invI2;
                        this.K.m20 = this.K.m02;
                        this.K.m21 = this.K.m12;
                        this.K.m22 = invM1 + invM2 + this.a1 * this.a1 * invI1 + this.a2 * this.a2 * invI2;
                        this.motorMass = this.K.m22;
                        if (Math.abs(this.motorMass) > org.dyn4j.Epsilon.E_$LI$()) {
                            this.motorMass = 1.0 / this.motorMass;
                        }
                        if (!this.motorEnabled) {
                            this.motorImpulse = 0.0;
                        }
                        if (this.limitEnabled) {
                            const dist = this.axis.dot$org_dyn4j_geometry_Vector2(d);
                            if (Math.abs(this.upperLimit - this.lowerLimit) < 2.0 * linearTolerance) {
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.EQUAL;
                            }
                            else if (dist <= this.lowerLimit) {
                                if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                    this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_LOWER;
                                    this.impulse.z = 0.0;
                                }
                            }
                            else if (dist >= this.upperLimit) {
                                if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                    this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_UPPER;
                                    this.impulse.z = 0.0;
                                }
                            }
                            else {
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                                this.impulse.z = 0.0;
                            }
                        }
                        else {
                            this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                            this.impulse.z = 0.0;
                        }
                        this.impulse.multiply(step.getDeltaTimeRatio());
                        this.motorImpulse *= step.getDeltaTimeRatio();
                        const P = new org.dyn4j.geometry.Vector2();
                        P.x = this.perp.x * this.impulse.x + (this.motorImpulse + this.impulse.z) * this.axis.x;
                        P.y = this.perp.y * this.impulse.x + (this.motorImpulse + this.impulse.z) * this.axis.y;
                        const l1 = this.impulse.x * this.s1 + this.impulse.y + (this.motorImpulse + this.impulse.z) * this.a1;
                        const l2 = this.impulse.x * this.s2 + this.impulse.y + (this.motorImpulse + this.impulse.z) * this.a2;
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(P.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * l1);
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(P.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * l2);
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const v1 = this.body1.getLinearVelocity$();
                        const v2 = this.body2.getLinearVelocity$();
                        let w1 = this.body1.getAngularVelocity();
                        let w2 = this.body2.getAngularVelocity();
                        if (this.motorEnabled && this.limitState !== org.dyn4j.dynamics.joint.LimitState.EQUAL) {
                            const Cdt = this.axis.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2)) + this.a1 * w1 - this.a2 * w2;
                            let impulse = this.motorMass * (this.motorSpeed - Cdt);
                            const oldImpulse = this.motorImpulse;
                            const maxImpulse = this.maximumMotorForce * step.getDeltaTime();
                            this.motorImpulse = org.dyn4j.geometry.Interval.clamp(this.motorImpulse + impulse, -maxImpulse, maxImpulse);
                            impulse = this.motorImpulse - oldImpulse;
                            const P = this.axis.product(impulse);
                            const l1 = impulse * this.a1;
                            const l2 = impulse * this.a2;
                            v1.add$org_dyn4j_geometry_Vector2(P.product(invM1));
                            w1 += l1 * invI1;
                            v2.subtract$org_dyn4j_geometry_Vector2(P.product(invM2));
                            w2 -= l2 * invI2;
                        }
                        const Cdt = new org.dyn4j.geometry.Vector2();
                        Cdt.x = this.perp.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2)) + this.s1 * w1 - this.s2 * w2;
                        Cdt.y = w1 - w2;
                        if (this.limitEnabled && this.limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const Cdtl = this.axis.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2)) + this.a1 * w1 - this.a2 * w2;
                            const b = new org.dyn4j.geometry.Vector3(Cdt.x, Cdt.y, Cdtl);
                            let impulse = this.K.solve33(b.negate());
                            const f1 = this.impulse.copy();
                            this.impulse.add$org_dyn4j_geometry_Vector3(impulse);
                            if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                this.impulse.z = Math.max(this.impulse.z, 0.0);
                            }
                            else if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                this.impulse.z = Math.min(this.impulse.z, 0.0);
                            }
                            const f2_1 = Cdt.negate().difference$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(this.K.m02, this.K.m12).multiply(this.impulse.z - f1.z));
                            const f2r = this.K.solve22(f2_1).add$double$double(f1.x, f1.y);
                            this.impulse.x = f2r.x;
                            this.impulse.y = f2r.y;
                            impulse = this.impulse.difference$org_dyn4j_geometry_Vector3(f1);
                            const P = new org.dyn4j.geometry.Vector2();
                            P.x = this.perp.x * impulse.x + impulse.z * this.axis.x;
                            P.y = this.perp.y * impulse.x + impulse.z * this.axis.y;
                            const l1 = impulse.x * this.s1 + impulse.y + impulse.z * this.a1;
                            const l2 = impulse.x * this.s2 + impulse.y + impulse.z * this.a2;
                            v1.add$org_dyn4j_geometry_Vector2(P.product(invM1));
                            w1 += l1 * invI1;
                            v2.subtract$org_dyn4j_geometry_Vector2(P.product(invM2));
                            w2 -= l2 * invI2;
                        }
                        else {
                            const f2r = this.K.solve22(Cdt.negate());
                            this.impulse.x += f2r.x;
                            this.impulse.y += f2r.y;
                            const P = this.perp.product(f2r.x);
                            const l1 = f2r.x * this.s1 + f2r.y;
                            const l2 = f2r.x * this.s2 + f2r.y;
                            v1.add$org_dyn4j_geometry_Vector2(P.product(invM1));
                            w1 += l1 * invI1;
                            v2.subtract$org_dyn4j_geometry_Vector2(P.product(invM2));
                            w2 -= l2 * invI2;
                        }
                        this.body1.setAngularVelocity(w1);
                        this.body2.setAngularVelocity(w2);
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        const maxLinearCorrection = settings.getMaximumLinearCorrection();
                        const linearTolerance = settings.getLinearTolerance();
                        const angularTolerance = settings.getAngularTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const c1 = this.body1.getWorldCenter();
                        const c2 = this.body2.getWorldCenter();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const d = c1.sum$org_dyn4j_geometry_Vector2(r1).subtract$org_dyn4j_geometry_Vector2(c2.sum$org_dyn4j_geometry_Vector2(r2));
                        this.axis = this.body2.getWorldVector(this.xAxis);
                        this.perp = this.body2.getWorldVector(this.yAxis);
                        const C = new org.dyn4j.geometry.Vector2();
                        C.x = this.perp.dot$org_dyn4j_geometry_Vector2(d);
                        C.y = t1.getRotationAngle() - t2.getRotationAngle() - this.referenceAngle;
                        let Cz = 0.0;
                        let linearError = 0.0;
                        let angularError = 0.0;
                        let limitActive = false;
                        if (this.limitEnabled) {
                            this.a1 = r1.cross$org_dyn4j_geometry_Vector2(this.axis);
                            this.a2 = r2.sum$org_dyn4j_geometry_Vector2(d).cross$org_dyn4j_geometry_Vector2(this.axis);
                            const dist = this.axis.dot$org_dyn4j_geometry_Vector2(d);
                            if (Math.abs(this.upperLimit - this.lowerLimit) < 2.0 * linearTolerance) {
                                Cz = org.dyn4j.geometry.Interval.clamp(dist, -maxLinearCorrection, maxLinearCorrection);
                                linearError = Math.abs(dist);
                                limitActive = true;
                            }
                            else if (dist <= this.lowerLimit) {
                                Cz = org.dyn4j.geometry.Interval.clamp(dist - this.lowerLimit + linearTolerance, -maxLinearCorrection, 0.0);
                                linearError = this.lowerLimit - dist;
                                limitActive = true;
                            }
                            else if (dist >= this.upperLimit) {
                                Cz = org.dyn4j.geometry.Interval.clamp(dist - this.upperLimit - linearTolerance, 0.0, maxLinearCorrection);
                                linearError = dist - this.upperLimit;
                                limitActive = true;
                            }
                        }
                        this.s1 = r1.cross$org_dyn4j_geometry_Vector2(this.perp);
                        this.s2 = r2.sum$org_dyn4j_geometry_Vector2(d).cross$org_dyn4j_geometry_Vector2(this.perp);
                        linearError = Math.max(linearError, Math.abs(C.x));
                        angularError = Math.abs(C.y);
                        let impulse;
                        if (limitActive) {
                            this.K.m00 = invM1 + invM2 + this.s1 * this.s1 * invI1 + this.s2 * this.s2 * invI2;
                            this.K.m01 = this.s1 * invI1 + this.s2 * invI2;
                            this.K.m02 = this.s1 * this.a1 * invI1 + this.s2 * this.a2 * invI2;
                            this.K.m10 = this.K.m01;
                            this.K.m11 = invI1 + invI2;
                            if (this.K.m11 <= org.dyn4j.Epsilon.E_$LI$())
                                this.K.m11 = 1.0;
                            this.K.m12 = this.a1 * invI1 + this.a2 * invI2;
                            this.K.m20 = this.K.m02;
                            this.K.m21 = this.K.m12;
                            this.K.m22 = invM1 + invM2 + this.a1 * this.a1 * invI1 + this.a2 * this.a2 * invI2;
                            const Clim = new org.dyn4j.geometry.Vector3(C.x, C.y, Cz);
                            impulse = this.K.solve33(Clim.negate());
                        }
                        else {
                            this.K.m00 = invM1 + invM2 + this.s1 * this.s1 * invI1 + this.s2 * this.s2 * invI2;
                            this.K.m01 = this.s1 * invI1 + this.s2 * invI2;
                            this.K.m02 = 0.0;
                            this.K.m10 = this.K.m01;
                            this.K.m11 = invI1 + invI2;
                            if (this.K.m11 <= org.dyn4j.Epsilon.E_$LI$())
                                this.K.m11 = 1.0;
                            this.K.m12 = 0.0;
                            this.K.m20 = 0.0;
                            this.K.m21 = 0.0;
                            this.K.m22 = 0.0;
                            const impulsec = this.K.solve22(C.negate());
                            impulse = new org.dyn4j.geometry.Vector3(impulsec.x, impulsec.y, 0.0);
                        }
                        const P = new org.dyn4j.geometry.Vector2();
                        P.x = this.perp.x * impulse.x + impulse.z * this.axis.x;
                        P.y = this.perp.y * impulse.x + impulse.z * this.axis.y;
                        const l1 = impulse.x * this.s1 + impulse.y + impulse.z * this.a1;
                        const l2 = impulse.x * this.s2 + impulse.y + impulse.z * this.a2;
                        this.body1.translate$double$double(this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : P.x * invM1, this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : P.y * invM1);
                        this.body1.rotateAboutCenter(l1 * invI1);
                        this.body2.translate$double$double(this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : -P.x * invM2, this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : -P.y * invM2);
                        this.body2.rotateAboutCenter(-l2 * invI2);
                        return linearError <= linearTolerance && angularError <= angularTolerance;
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        const force = new org.dyn4j.geometry.Vector2();
                        force.x = this.impulse.x * this.perp.x + (this.motorImpulse + this.impulse.z) * this.axis.x;
                        force.y = this.impulse.x * this.perp.y + (this.motorImpulse + this.impulse.z) * this.axis.y;
                        force.multiply(invdt);
                        return force;
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return invdt * this.impulse.y;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     * Returns the current joint speed.
                     * @return {number} double
                     */
                    getJointSpeed() {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const c1 = this.body1.getWorldCenter();
                        const c2 = this.body2.getWorldCenter();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const d = c1.sum$org_dyn4j_geometry_Vector2(r1).subtract$org_dyn4j_geometry_Vector2(c2.sum$org_dyn4j_geometry_Vector2(r2));
                        const axis = this.body2.getWorldVector(this.xAxis);
                        const v1 = this.body1.getLinearVelocity$();
                        const v2 = this.body2.getLinearVelocity$();
                        const w1 = this.body1.getAngularVelocity();
                        const w2 = this.body2.getAngularVelocity();
                        const speed = d.dot$org_dyn4j_geometry_Vector2(axis.cross$double(w2)) + axis.dot$org_dyn4j_geometry_Vector2(v1.sum$org_dyn4j_geometry_Vector2(r1.cross$double(w1)).subtract$org_dyn4j_geometry_Vector2(v2.sum$org_dyn4j_geometry_Vector2(r2.cross$double(w2))));
                        return speed;
                    }
                    /**
                     * Returns the current joint translation.
                     * @return {number} double
                     */
                    getJointTranslation() {
                        const p1 = this.body1.getWorldPoint(this.localAnchor1);
                        const p2 = this.body2.getWorldPoint(this.localAnchor2);
                        const d = p2.difference$org_dyn4j_geometry_Vector2(p1);
                        const axis = this.body2.getWorldVector(this.xAxis);
                        return d.dot$org_dyn4j_geometry_Vector2(axis);
                    }
                    /**
                     * Returns true if the motor is enabled.
                     * @return {boolean} boolean
                     */
                    isMotorEnabled() {
                        return this.motorEnabled;
                    }
                    /**
                     * Enables or disables the motor.
                     * @param {boolean} motorEnabled true if the motor should be enabled
                     */
                    setMotorEnabled(motorEnabled) {
                        if (this.motorEnabled !== motorEnabled) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                            this.motorEnabled = motorEnabled;
                        }
                    }
                    /**
                     * Returns the target motor speed in meters / second.
                     * @return {number} double
                     */
                    getMotorSpeed() {
                        return this.motorSpeed;
                    }
                    /**
                     * Sets the target motor speed.
                     * @param {number} motorSpeed the target motor speed in meters / second
                     * @see #setMaximumMotorForce(double)
                     */
                    setMotorSpeed(motorSpeed) {
                        if (this.motorSpeed !== motorSpeed) {
                            if (this.motorEnabled) {
                                this.body1.setAsleep(false);
                                this.body2.setAsleep(false);
                            }
                            this.motorSpeed = motorSpeed;
                        }
                    }
                    /**
                     * Returns the maximum force the motor can apply to the joint
                     * to achieve the target speed.
                     * @return {number} double
                     */
                    getMaximumMotorForce() {
                        return this.maximumMotorForce;
                    }
                    /**
                     * Sets the maximum force the motor can apply to the joint
                     * to achieve the target speed.
                     * @param {number} maximumMotorForce the maximum force in newtons; must be greater than zero
                     * @throws IllegalArgumentException if maxMotorForce is less than zero
                     * @see #setMotorSpeed(double)
                     */
                    setMaximumMotorForce(maximumMotorForce) {
                        if (maximumMotorForce < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidMaximumMotorForce"));
                        if (this.maximumMotorForce !== maximumMotorForce) {
                            if (this.motorEnabled) {
                                this.body1.setAsleep(false);
                                this.body2.setAsleep(false);
                            }
                            this.maximumMotorForce = maximumMotorForce;
                        }
                    }
                    /**
                     * Returns the applied motor force.
                     * @param {number} invdt the inverse delta time
                     * @return {number} double
                     */
                    getMotorForce(invdt) {
                        return this.motorImpulse * invdt;
                    }
                    /**
                     * Returns true if the limit is enabled.
                     * @return {boolean} boolean
                     */
                    isLimitEnabled() {
                        return this.limitEnabled;
                    }
                    /**
                     * Enables or disables the limits.
                     * @param {boolean} limitEnabled true if the limit should be enabled.
                     */
                    setLimitEnabled(limitEnabled) {
                        if (this.limitEnabled !== limitEnabled) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                            this.limitEnabled = limitEnabled;
                        }
                    }
                    /**
                     * Returns the lower limit in meters.
                     * @return {number} double
                     */
                    getLowerLimit() {
                        return this.lowerLimit;
                    }
                    /**
                     * Sets the lower limit.
                     * @param {number} lowerLimit the lower limit in meters
                     * @throws IllegalArgumentException if lowerLimit is greater than the current upper limit
                     */
                    setLowerLimit(lowerLimit) {
                        if (lowerLimit > this.upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLowerLimit"));
                        if (this.lowerLimit !== lowerLimit) {
                            if (this.limitEnabled) {
                                this.body1.setAsleep(false);
                                this.body2.setAsleep(false);
                                this.impulse.z = 0.0;
                            }
                            this.lowerLimit = lowerLimit;
                        }
                    }
                    /**
                     * Returns the upper limit in meters.
                     * @return {number} double
                     */
                    getUpperLimit() {
                        return this.upperLimit;
                    }
                    /**
                     * Sets the upper limit.
                     * @param {number} upperLimit the upper limit in meters
                     * @throws IllegalArgumentException if upperLimit is less than the current lower limit
                     */
                    setUpperLimit(upperLimit) {
                        if (upperLimit < this.lowerLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidUpperLimit"));
                        if (this.upperLimit !== upperLimit) {
                            if (this.limitEnabled) {
                                this.body1.setAsleep(false);
                                this.body2.setAsleep(false);
                                this.impulse.z = 0.0;
                            }
                            this.upperLimit = upperLimit;
                        }
                    }
                    /**
                     * Sets the upper and lower limits.
                     * <p>
                     * The lower limit must be less than or equal to the upper limit.
                     * @param {number} lowerLimit the lower limit in meters
                     * @param {number} upperLimit the upper limit in meters
                     * @throws IllegalArgumentException if lowerLimit is greater than upperLimit
                     */
                    setLimits(lowerLimit, upperLimit) {
                        if (lowerLimit > upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLimits"));
                        if (this.lowerLimit !== lowerLimit || this.upperLimit !== upperLimit) {
                            if (this.limitEnabled) {
                                this.body1.setAsleep(false);
                                this.body2.setAsleep(false);
                            }
                            this.impulse.z = 0.0;
                            this.lowerLimit = lowerLimit;
                            this.upperLimit = upperLimit;
                        }
                    }
                    /**
                     * Sets the upper and lower limits and enables the limits.
                     * <p>
                     * The lower limit must be less than or equal to the upper limit.
                     * @param {number} lowerLimit the lower limit in meters
                     * @param {number} upperLimit the upper limit in meters
                     * @throws IllegalArgumentException if lowerLimit is greater than upperLimit
                     * @since 2.2.2
                     */
                    setLimitsEnabled(lowerLimit, upperLimit) {
                        if (lowerLimit > upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLimits"));
                        this.setLimitEnabled(true);
                        this.setLimits(lowerLimit, upperLimit);
                    }
                    /**
                     * Returns the axis in which the joint is allowed move along in world coordinates.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     * @since 3.0.0
                     */
                    getAxis() {
                        return this.body2.getWorldVector(this.xAxis);
                    }
                    /**
                     * Returns the reference angle.
                     * <p>
                     * The reference angle is the angle calculated when the joint was created from the
                     * two joined bodies.  The reference angle is the angular difference between the
                     * bodies.
                     * @return {number} double
                     * @since 3.0.1
                     */
                    getReferenceAngle() {
                        return this.referenceAngle;
                    }
                    /**
                     * Sets the reference angle.
                     * <p>
                     * This method can be used to set the reference angle to override the computed
                     * reference angle from the constructor.  This is useful in recreating the joint
                     * from a current state.
                     * <p>
                     * This can also be used to override the initial angle between the bodies.
                     * @param {number} angle the reference angle
                     * @see #getReferenceAngle()
                     * @since 3.0.1
                     */
                    setReferenceAngle(angle) {
                        this.referenceAngle = angle;
                    }
                    /**
                     * Returns the current state of the limit.
                     * @return {org.dyn4j.dynamics.joint.LimitState} {@link LimitState}
                     * @since 3.2.0
                     */
                    getLimitState() {
                        return this.limitState;
                    }
                }
                joint.PrismaticJoint = PrismaticJoint;
                PrismaticJoint["__class"] = "org.dyn4j.dynamics.joint.PrismaticJoint";
                PrismaticJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @throws NullPointerException if body1 or body2
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class MotorJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2) {
                        super(body1, body2, false);
                        if (this.linearTarget === undefined) {
                            this.linearTarget = null;
                        }
                        if (this.angularTarget === undefined) {
                            this.angularTarget = 0;
                        }
                        if (this.correctionFactor === undefined) {
                            this.correctionFactor = 0;
                        }
                        if (this.maximumForce === undefined) {
                            this.maximumForce = 0;
                        }
                        if (this.maximumTorque === undefined) {
                            this.maximumTorque = 0;
                        }
                        if (this.K === undefined) {
                            this.K = null;
                        }
                        if (this.angularMass === undefined) {
                            this.angularMass = 0;
                        }
                        if (this.linearError === undefined) {
                            this.linearError = null;
                        }
                        if (this.angularError === undefined) {
                            this.angularError = 0;
                        }
                        if (this.linearImpulse === undefined) {
                            this.linearImpulse = null;
                        }
                        if (this.angularImpulse === undefined) {
                            this.angularImpulse = 0;
                        }
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        this.linearTarget = body1.getLocalPoint(body2.getWorldCenter());
                        this.angularTarget = body2.getTransform().getRotationAngle() - body1.getTransform().getRotationAngle();
                        this.correctionFactor = 0.3;
                        this.K = new org.dyn4j.geometry.Matrix22();
                        this.linearImpulse = new org.dyn4j.geometry.Vector2();
                        this.angularImpulse = 0.0;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("MotorJoint[").append(super.toString()).append("|LinearTarget=").append(this.linearTarget).append("|AngularTarget=").append(this.angularTarget).append("|CorrectionFactor=").append(this.correctionFactor).append("|MaximumForce=").append(this.maximumForce).append("|MaximumTorque=").append(this.maximumTorque).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().getNegative());
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().getNegative());
                        this.K.m00 = invM1 + invM2 + r1.y * r1.y * invI1 + r2.y * r2.y * invI2;
                        this.K.m01 = -invI1 * r1.x * r1.y - invI2 * r2.x * r2.y;
                        this.K.m10 = this.K.m01;
                        this.K.m11 = invM1 + invM2 + r1.x * r1.x * invI1 + r2.x * r2.x * invI2;
                        this.K.invert();
                        this.angularMass = invI1 + invI2;
                        if (this.angularMass > org.dyn4j.Epsilon.E_$LI$()) {
                            this.angularMass = 1.0 / this.angularMass;
                        }
                        const d1 = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter());
                        const d2 = r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter());
                        const d0 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.linearTarget);
                        this.linearError = d2.subtract$org_dyn4j_geometry_Vector2(d1).subtract$org_dyn4j_geometry_Vector2(d0);
                        this.angularError = this.getAngularError();
                        this.linearImpulse.multiply(step.getDeltaTimeRatio());
                        this.angularImpulse *= step.getDeltaTimeRatio();
                        this.body1.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(this.linearImpulse.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() - invI1 * (r1.cross$org_dyn4j_geometry_Vector2(this.linearImpulse) + this.angularImpulse));
                        this.body2.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(this.linearImpulse.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() + invI2 * (r2.cross$org_dyn4j_geometry_Vector2(this.linearImpulse) + this.angularImpulse));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        const dt = step.getDeltaTime();
                        const invdt = step.getInverseDeltaTime();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        {
                            const C = this.body2.getAngularVelocity() - this.body1.getAngularVelocity() + invdt * this.correctionFactor * this.angularError;
                            let impulse = this.angularMass * -C;
                            const oldImpulse = this.angularImpulse;
                            const maxImpulse = this.maximumTorque * dt;
                            this.angularImpulse = org.dyn4j.geometry.Interval.clamp(this.angularImpulse + impulse, -maxImpulse, maxImpulse);
                            impulse = this.angularImpulse - oldImpulse;
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() - invI1 * impulse);
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() + invI2 * impulse);
                        }
                        ;
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().getNegative());
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().getNegative());
                        const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                        const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                        const pivotV = v2.subtract$org_dyn4j_geometry_Vector2(v1);
                        pivotV.add$org_dyn4j_geometry_Vector2(this.linearError.product(this.correctionFactor * invdt));
                        let impulse = this.K.multiply$org_dyn4j_geometry_Vector2(pivotV);
                        impulse.negate();
                        const oldImpulse = this.linearImpulse.copy();
                        this.linearImpulse.add$org_dyn4j_geometry_Vector2(impulse);
                        const maxImpulse = this.maximumForce * dt;
                        if (this.linearImpulse.getMagnitudeSquared() > maxImpulse * maxImpulse) {
                            this.linearImpulse.normalize();
                            this.linearImpulse.multiply(maxImpulse);
                        }
                        impulse = this.linearImpulse.difference$org_dyn4j_geometry_Vector2(oldImpulse);
                        this.body1.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(impulse.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() - invI1 * r1.cross$org_dyn4j_geometry_Vector2(impulse));
                        this.body2.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(impulse.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() + invI2 * r2.cross$org_dyn4j_geometry_Vector2(impulse));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        return true;
                    }
                    /**
                     * Returns error in the angle between the joined bodies given the target
                     * angle.
                     * @return {number} double
                     * @private
                     */
                    /*private*/ getAngularError() {
                        let rr = this.body2.getTransform().getRotationAngle() - this.body1.getTransform().getRotationAngle() - this.angularTarget;
                        if (rr < -Math.PI)
                            rr += org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                        if (rr > Math.PI)
                            rr -= org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                        return rr;
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Not applicable to this joint.
                     * Returns the first body's world center.
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor1() {
                        return this.body1.getWorldCenter();
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Not applicable to this joint.
                     * Returns the second body's world center.
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor2() {
                        return this.body2.getWorldCenter();
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        return this.linearImpulse.product(invdt);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return this.angularImpulse * invdt;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     * Returns the desired linear distance along the x and y coordinates from
                     * body1's world center.
                     * <p>
                     * To get the world linear target:
                     * <pre>
                     * joint.getBody1().getWorldVector(joint.getLinearTarget());
                     * </pre>
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getLinearTarget() {
                        return this.linearTarget;
                    }
                    /**
                     * Sets the desired linear distance along the x and y coordinates from
                     * body1's world center.
                     * @param {org.dyn4j.geometry.Vector2} target the desired distance along the x and y coordinates
                     */
                    setLinearTarget(target) {
                        if (!target.equals$org_dyn4j_geometry_Vector2(this.linearTarget)) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                            this.linearTarget = target;
                        }
                    }
                    /**
                     * Returns the desired angle between the bodies.
                     * @return {number} double
                     */
                    getAngularTarget() {
                        return this.angularTarget;
                    }
                    /**
                     * Sets the desired angle between the bodies.
                     * @param {number} target the desired angle between the bodies
                     */
                    setAngularTarget(target) {
                        if (target !== this.angularTarget) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                            this.angularTarget = target;
                        }
                    }
                    /**
                     * Returns the correction factor.
                     * @return {number} double
                     */
                    getCorrectionFactor() {
                        return this.correctionFactor;
                    }
                    /**
                     * Sets the correction factor.
                     * <p>
                     * The correction factor controls the rate at which the bodies perform the
                     * desired actions.  The default is 0.3.
                     * <p>
                     * A value of zero means that the bodies do not perform any action.
                     * @param {number} correctionFactor the correction factor in the range [0, 1]
                     */
                    setCorrectionFactor(correctionFactor) {
                        if (correctionFactor < 0.0 || correctionFactor > 1.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.motor.invalidCorrectionFactor"));
                        this.correctionFactor = correctionFactor;
                    }
                    /**
                     * Returns the maximum torque this constraint will apply in newton-meters.
                     * @return {number} double
                     */
                    getMaximumTorque() {
                        return this.maximumTorque;
                    }
                    /**
                     * Sets the maximum torque this constraint will apply in newton-meters.
                     * @param {number} maximumTorque the maximum torque in newton-meters; in the range [0, &infin;]
                     * @throws IllegalArgumentException if maxTorque is less than zero
                     */
                    setMaximumTorque(maximumTorque) {
                        if (maximumTorque < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.friction.invalidMaximumTorque"));
                        this.maximumTorque = maximumTorque;
                    }
                    /**
                     * Returns the maximum force this constraint will apply in newtons.
                     * @return {number} double
                     */
                    getMaximumForce() {
                        return this.maximumForce;
                    }
                    /**
                     * Sets the maximum force this constraint will apply in newtons.
                     * @param {number} maximumForce the maximum force in newtons; in the range [0, &infin;]
                     * @throws IllegalArgumentException if maxForce is less than zero
                     */
                    setMaximumForce(maximumForce) {
                        if (maximumForce < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.friction.invalidMaximumForce"));
                        this.maximumForce = maximumForce;
                    }
                }
                joint.MotorJoint = MotorJoint;
                MotorJoint["__class"] = "org.dyn4j.dynamics.joint.MotorJoint";
                MotorJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} anchor the anchor point in world coordinates
                 * @throws NullPointerException if body1, body2, or anchor is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class WeldJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2, anchor) {
                        super(body1, body2, false);
                        if (this.localAnchor1 === undefined) {
                            this.localAnchor1 = null;
                        }
                        if (this.localAnchor2 === undefined) {
                            this.localAnchor2 = null;
                        }
                        if (this.referenceAngle === undefined) {
                            this.referenceAngle = 0;
                        }
                        if (this.frequency === undefined) {
                            this.frequency = 0;
                        }
                        if (this.dampingRatio === undefined) {
                            this.dampingRatio = 0;
                        }
                        if (this.K === undefined) {
                            this.K = null;
                        }
                        if (this.bias === undefined) {
                            this.bias = 0;
                        }
                        if (this.gamma === undefined) {
                            this.gamma = 0;
                        }
                        if (this.impulse === undefined) {
                            this.impulse = null;
                        }
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        if (anchor == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor"));
                        this.localAnchor1 = body1.getLocalPoint(anchor);
                        this.localAnchor2 = body2.getLocalPoint(anchor);
                        this.referenceAngle = body1.getTransform().getRotationAngle() - body2.getTransform().getRotationAngle();
                        this.K = new org.dyn4j.geometry.Matrix33();
                        this.impulse = new org.dyn4j.geometry.Vector3();
                        this.frequency = 0.0;
                        this.dampingRatio = 0.0;
                        this.gamma = 0.0;
                        this.bias = 0.0;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("WeldJoint[").append(super.toString()).append("|Anchor=").append(this.getAnchor1()).append("|ReferenceAngle=").append(this.referenceAngle).append("|Frequency=").append(this.frequency).append("|DampingRatio=").append(this.dampingRatio).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.K.m00 = invM1 + invM2 + r1.y * r1.y * invI1 + r2.y * r2.y * invI2;
                        this.K.m01 = -r1.y * r1.x * invI1 - r2.y * r2.x * invI2;
                        this.K.m02 = -r1.y * invI1 - r2.y * invI2;
                        this.K.m10 = this.K.m01;
                        this.K.m11 = invM1 + invM2 + r1.x * r1.x * invI1 + r2.x * r2.x * invI2;
                        this.K.m12 = r1.x * invI1 + r2.x * invI2;
                        this.K.m20 = this.K.m02;
                        this.K.m21 = this.K.m12;
                        this.K.m22 = invI1 + invI2;
                        if (this.frequency > 0.0 && this.K.m22 > 0.0) {
                            let invI = invI1 + invI2;
                            const i = invI <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / invI;
                            const r = this.getRelativeRotation();
                            const dt = step.getDeltaTime();
                            const w = org.dyn4j.geometry.Geometry.TWO_PI_$LI$() * this.frequency;
                            const d = 2.0 * i * this.dampingRatio * w;
                            const k = i * w * w;
                            this.gamma = dt * (d + dt * k);
                            this.gamma = this.gamma <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / this.gamma;
                            this.bias = r * dt * k * this.gamma;
                            invI += this.gamma;
                            this.K.m22 = invI <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / invI;
                        }
                        else {
                            this.gamma = 0.0;
                            this.bias = 0.0;
                        }
                        this.impulse.multiply(step.getDeltaTimeRatio());
                        const impulse = new org.dyn4j.geometry.Vector2(this.impulse.x, this.impulse.y);
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(impulse.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * (r1.cross$org_dyn4j_geometry_Vector2(impulse) + this.impulse.z));
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(impulse.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * (r2.cross$org_dyn4j_geometry_Vector2(impulse) + this.impulse.z));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        if (this.frequency > 0.0) {
                            const rav = this.body1.getAngularVelocity() - this.body2.getAngularVelocity();
                            const j2 = -this.K.m22 * (rav + this.bias + this.gamma * this.impulse.z);
                            this.impulse.z += j2;
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * j2);
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * j2);
                            const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                            const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                            const anchorV = v1.subtract$org_dyn4j_geometry_Vector2(v2);
                            const j1 = this.K.solve22(anchorV).negate();
                            this.impulse.x += j1.x;
                            this.impulse.y += j1.y;
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(j1.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(j1));
                            this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(j1.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(j1));
                        }
                        else {
                            const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                            const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                            const anchorV = v1.subtract$org_dyn4j_geometry_Vector2(v2);
                            const C = new org.dyn4j.geometry.Vector3(anchorV.x, anchorV.y, this.body1.getAngularVelocity() - this.body2.getAngularVelocity());
                            let impulse = null;
                            if (this.K.m22 > 0.0) {
                                impulse = this.K.solve33(C.negate());
                            }
                            else {
                                const impulse2 = this.K.solve22(anchorV).negate();
                                impulse = new org.dyn4j.geometry.Vector3(impulse2.x, impulse2.y, 0.0);
                            }
                            this.impulse.add$org_dyn4j_geometry_Vector3(impulse);
                            const imp = new org.dyn4j.geometry.Vector2(impulse.x, impulse.y);
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(imp.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * (r1.cross$org_dyn4j_geometry_Vector2(imp) + impulse.z));
                            this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(imp.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * (r2.cross$org_dyn4j_geometry_Vector2(imp) + impulse.z));
                            this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                            this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                        }
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const angularTolerance = settings.getAngularTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const p1 = this.body1.getWorldCenter().add$org_dyn4j_geometry_Vector2(r1);
                        const p2 = this.body2.getWorldCenter().add$org_dyn4j_geometry_Vector2(r2);
                        const C1 = p1.difference$org_dyn4j_geometry_Vector2(p2);
                        const C2 = this.getRelativeRotation();
                        const C = new org.dyn4j.geometry.Vector3(C1.x, C1.y, C2);
                        const linearError = C1.getMagnitude();
                        let angularError = Math.abs(C2);
                        this.K.m00 = invM1 + invM2 + r1.y * r1.y * invI1 + r2.y * r2.y * invI2;
                        this.K.m01 = -r1.y * r1.x * invI1 - r2.y * r2.x * invI2;
                        this.K.m02 = -r1.y * invI1 - r2.y * invI2;
                        this.K.m10 = this.K.m01;
                        this.K.m11 = invM1 + invM2 + r1.x * r1.x * invI1 + r2.x * r2.x * invI2;
                        this.K.m12 = r1.x * invI1 + r2.x * invI2;
                        this.K.m20 = this.K.m02;
                        this.K.m21 = this.K.m12;
                        this.K.m22 = invI1 + invI2;
                        if (this.frequency > 0.0) {
                            angularError = 0.0;
                            const j = this.K.solve22(C1).negate();
                            this.body1.translate$org_dyn4j_geometry_Vector2(j.product(invM1));
                            this.body1.rotateAboutCenter(invI1 * r1.cross$org_dyn4j_geometry_Vector2(j));
                            this.body2.translate$org_dyn4j_geometry_Vector2(j.product(-invM2));
                            this.body2.rotateAboutCenter(-invI2 * r2.cross$org_dyn4j_geometry_Vector2(j));
                        }
                        else {
                            let impulse = null;
                            if (this.K.m22 > 0.0) {
                                impulse = this.K.solve33(C.negate());
                            }
                            else {
                                const impulse2 = this.K.solve22(C1).negate();
                                impulse = new org.dyn4j.geometry.Vector3(impulse2.x, impulse2.y, 0.0);
                            }
                            const imp = new org.dyn4j.geometry.Vector2(impulse.x, impulse.y);
                            this.body1.translate$double$double(this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : imp.x * invM1, this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : imp.y * invM1);
                            this.body1.rotateAboutCenter(invI1 * (r1.cross$org_dyn4j_geometry_Vector2(imp) + impulse.z));
                            this.body2.translate$double$double(this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : -imp.x * invM2, this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : -imp.y * invM2);
                            this.body2.rotateAboutCenter(-invI2 * (r2.cross$org_dyn4j_geometry_Vector2(imp) + impulse.z));
                        }
                        return linearError <= linearTolerance && angularError <= angularTolerance;
                    }
                    /**
                     * Returns the relative angle between the two bodies given the reference angle.
                     * @return {number} double
                     * @private
                     */
                    /*private*/ getRelativeRotation() {
                        let rr = this.body1.getTransform().getRotationAngle() - this.body2.getTransform().getRotationAngle() - this.referenceAngle;
                        if (rr < -Math.PI)
                            rr += org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                        if (rr > Math.PI)
                            rr -= org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                        return rr;
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                        this.localAnchor1.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.localAnchor2.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        const impulse = new org.dyn4j.geometry.Vector2(this.impulse.x, this.impulse.y);
                        return impulse.multiply(invdt);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return this.impulse.z * invdt;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     * Returns true if this distance joint is a spring distance joint.
                     * @return {boolean} boolean
                     * @since 3.0.1
                     */
                    isSpring() {
                        return this.frequency > 0.0;
                    }
                    /**
                     * Returns true if this distance joint is a spring distance joint
                     * with damping.
                     * @return {boolean} boolean
                     * @since 3.0.1
                     */
                    isSpringDamper() {
                        return this.frequency > 0.0 && this.dampingRatio > 0.0;
                    }
                    /**
                     * Returns the damping ratio.
                     * @return {number} double
                     * @since 3.0.1
                     */
                    getDampingRatio() {
                        return this.dampingRatio;
                    }
                    /**
                     * Sets the damping ratio.
                     * <p>
                     * Larger values reduce the oscillation of the spring.
                     * @param {number} dampingRatio the damping ratio; in the range [0, 1]
                     * @throws IllegalArgumentException if damping ration is less than zero or greater than 1
                     * @since 3.0.1
                     */
                    setDampingRatio(dampingRatio) {
                        if (dampingRatio < 0 || dampingRatio > 1)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidDampingRatio"));
                        this.dampingRatio = dampingRatio;
                    }
                    /**
                     * Returns the spring frequency.
                     * @return {number} double
                     * @since 3.0.1
                     */
                    getFrequency() {
                        return this.frequency;
                    }
                    /**
                     * Sets the spring frequency.
                     * <p>
                     * Larger values increase the stiffness of the spring.
                     * @param {number} frequency the spring frequency in hz; must be greater than or equal to zero
                     * @throws IllegalArgumentException if frequency is less than zero
                     * @since 3.0.1
                     */
                    setFrequency(frequency) {
                        if (frequency < 0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidFrequency"));
                        this.frequency = frequency;
                    }
                    /**
                     * Returns the reference angle.
                     * <p>
                     * The reference angle is the angle calculated when the joint was created from the
                     * two joined bodies.  The reference angle is the angular difference between the
                     * bodies.
                     * @return {number} double
                     * @since 3.0.1
                     */
                    getReferenceAngle() {
                        return this.referenceAngle;
                    }
                    /**
                     * Sets the reference angle.
                     * <p>
                     * This method can be used to set the reference angle to override the computed
                     * reference angle from the constructor.  This is useful in recreating the joint
                     * from a current state.
                     * @param {number} angle the reference angle in radians
                     * @see #getReferenceAngle()
                     * @since 3.0.1
                     */
                    setReferenceAngle(angle) {
                        this.referenceAngle = angle;
                    }
                }
                joint.WeldJoint = WeldJoint;
                WeldJoint["__class"] = "org.dyn4j.dynamics.joint.WeldJoint";
                WeldJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} anchor the anchor point in world coordinates
                 * @throws NullPointerException if body1, body2 or anchor is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class RevoluteJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2, anchor) {
                        super(body1, body2, false);
                        if (this.localAnchor1 === undefined) {
                            this.localAnchor1 = null;
                        }
                        if (this.localAnchor2 === undefined) {
                            this.localAnchor2 = null;
                        }
                        if (this.motorEnabled === undefined) {
                            this.motorEnabled = false;
                        }
                        if (this.motorSpeed === undefined) {
                            this.motorSpeed = 0;
                        }
                        if (this.maximumMotorTorque === undefined) {
                            this.maximumMotorTorque = 0;
                        }
                        if (this.limitEnabled === undefined) {
                            this.limitEnabled = false;
                        }
                        if (this.upperLimit === undefined) {
                            this.upperLimit = 0;
                        }
                        if (this.lowerLimit === undefined) {
                            this.lowerLimit = 0;
                        }
                        if (this.referenceAngle === undefined) {
                            this.referenceAngle = 0;
                        }
                        if (this.limitState === undefined) {
                            this.limitState = null;
                        }
                        if (this.K === undefined) {
                            this.K = null;
                        }
                        if (this.motorMass === undefined) {
                            this.motorMass = 0;
                        }
                        if (this.impulse === undefined) {
                            this.impulse = null;
                        }
                        if (this.motorImpulse === undefined) {
                            this.motorImpulse = 0;
                        }
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        if (anchor == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor"));
                        this.localAnchor1 = body1.getLocalPoint(anchor);
                        this.localAnchor2 = body2.getLocalPoint(anchor);
                        this.referenceAngle = body1.getTransform().getRotationAngle() - body2.getTransform().getRotationAngle();
                        this.lowerLimit = this.referenceAngle;
                        this.upperLimit = this.referenceAngle;
                        this.limitEnabled = false;
                        this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                        this.impulse = new org.dyn4j.geometry.Vector3();
                        this.K = new org.dyn4j.geometry.Matrix33();
                        this.motorEnabled = false;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("RevoluteJoint[").append(super.toString()).append("|Anchor=").append(this.getAnchor1()).append("|IsMotorEnabled=").append(this.motorEnabled).append("|MotorSpeed=").append(this.motorSpeed).append("|MaximumMotorTorque=").append(this.maximumMotorTorque).append("|IsLimitEnabled=").append(this.limitEnabled).append("|LowerLimit=").append(this.lowerLimit).append("|UpperLimit=").append(this.upperLimit).append("|ReferenceAngle=").append(this.referenceAngle).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const angularTolerance = settings.getAngularTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        if (this.motorEnabled) {
                            if (invI1 <= 0.0 && invI2 <= 0.0) {
                                throw new java.lang.IllegalStateException(org.dyn4j.resources.Messages.getString("dynamics.joint.revolute.twoAngularFixedBodies"));
                            }
                        }
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.K.m00 = invM1 + invM2 + r1.y * r1.y * invI1 + r2.y * r2.y * invI2;
                        this.K.m01 = -r1.y * r1.x * invI1 - r2.y * r2.x * invI2;
                        this.K.m02 = -r1.y * invI1 - r2.y * invI2;
                        this.K.m10 = this.K.m01;
                        this.K.m11 = invM1 + invM2 + r1.x * r1.x * invI1 + r2.x * r2.x * invI2;
                        this.K.m12 = r1.x * invI1 + r2.x * invI2;
                        this.K.m20 = this.K.m02;
                        this.K.m21 = this.K.m12;
                        this.K.m22 = invI1 + invI2;
                        this.motorMass = invI1 + invI2;
                        if (this.motorMass > org.dyn4j.Epsilon.E_$LI$()) {
                            this.motorMass = 1.0 / this.motorMass;
                        }
                        if (!this.motorEnabled) {
                            this.motorImpulse = 0.0;
                        }
                        if (this.limitEnabled) {
                            const angle = this.getRelativeRotation();
                            if (Math.abs(this.upperLimit - this.lowerLimit) < 2.0 * angularTolerance) {
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.EQUAL;
                            }
                            else if (angle <= this.lowerLimit) {
                                if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                    this.impulse.z = 0.0;
                                }
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_LOWER;
                            }
                            else if (angle >= this.upperLimit) {
                                if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                    this.impulse.z = 0.0;
                                }
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_UPPER;
                            }
                            else {
                                this.impulse.z = 0.0;
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                            }
                        }
                        else {
                            this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                        }
                        this.impulse.multiply(step.getDeltaTimeRatio());
                        this.motorImpulse *= step.getDeltaTimeRatio();
                        const impulse = new org.dyn4j.geometry.Vector2(this.impulse.x, this.impulse.y);
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(impulse.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * (r1.cross$org_dyn4j_geometry_Vector2(impulse) + this.motorImpulse + this.impulse.z));
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(impulse.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * (r2.cross$org_dyn4j_geometry_Vector2(impulse) + this.motorImpulse + this.impulse.z));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        if (this.motorEnabled && this.limitState !== org.dyn4j.dynamics.joint.LimitState.EQUAL) {
                            const C = this.body1.getAngularVelocity() - this.body2.getAngularVelocity() - this.motorSpeed;
                            let impulse = this.motorMass * -C;
                            const oldImpulse = this.motorImpulse;
                            const maxImpulse = this.maximumMotorTorque * step.getDeltaTime();
                            this.motorImpulse = org.dyn4j.geometry.Interval.clamp(this.motorImpulse + impulse, -maxImpulse, maxImpulse);
                            impulse = this.motorImpulse - oldImpulse;
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * impulse);
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * impulse);
                        }
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                        const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                        const Jvb2 = v1.subtract$org_dyn4j_geometry_Vector2(v2);
                        if (this.limitEnabled && this.limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const pivotW = this.body1.getAngularVelocity() - this.body2.getAngularVelocity();
                            const Jvb3 = new org.dyn4j.geometry.Vector3(Jvb2.x, Jvb2.y, pivotW);
                            const impulse3 = this.K.solve33(Jvb3.negate());
                            if (this.limitState === org.dyn4j.dynamics.joint.LimitState.EQUAL) {
                                this.impulse.add$org_dyn4j_geometry_Vector3(impulse3);
                            }
                            else if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                const newImpulse = this.impulse.z + impulse3.z;
                                if (newImpulse < 0.0) {
                                    const reduced = this.K.solve22(Jvb2.negate());
                                    impulse3.x = reduced.x;
                                    impulse3.y = reduced.y;
                                    impulse3.z = -this.impulse.z;
                                    this.impulse.x += reduced.x;
                                    this.impulse.y += reduced.y;
                                    this.impulse.z = 0.0;
                                }
                            }
                            else if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                const newImpulse = this.impulse.z + impulse3.z;
                                if (newImpulse > 0.0) {
                                    const reduced = this.K.solve22(Jvb2.negate());
                                    impulse3.x = reduced.x;
                                    impulse3.y = reduced.y;
                                    impulse3.z = -this.impulse.z;
                                    this.impulse.x += reduced.x;
                                    this.impulse.y += reduced.y;
                                    this.impulse.z = 0.0;
                                }
                            }
                            const impulse = new org.dyn4j.geometry.Vector2(impulse3.x, impulse3.y);
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(impulse.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * (r1.cross$org_dyn4j_geometry_Vector2(impulse) + impulse3.z));
                            this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(impulse.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * (r2.cross$org_dyn4j_geometry_Vector2(impulse) + impulse3.z));
                        }
                        else {
                            const impulse = this.K.solve22(Jvb2.negate());
                            this.impulse.x += impulse.x;
                            this.impulse.y += impulse.y;
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(impulse.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(impulse));
                            this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(impulse.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(impulse));
                        }
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const angularTolerance = settings.getAngularTolerance();
                        const maxAngularCorrection = settings.getMaximumAngularCorrection();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        let linearError = 0.0;
                        let angularError = 0.0;
                        if (this.limitEnabled && this.limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const angle = this.getRelativeRotation();
                            let impulse = 0.0;
                            if (this.limitState === org.dyn4j.dynamics.joint.LimitState.EQUAL) {
                                const j = org.dyn4j.geometry.Interval.clamp(angle - this.lowerLimit, -maxAngularCorrection, maxAngularCorrection);
                                impulse = -j * this.motorMass;
                                angularError = Math.abs(j);
                            }
                            else if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                let j = angle - this.lowerLimit;
                                angularError = -j;
                                j = org.dyn4j.geometry.Interval.clamp(j + angularTolerance, -maxAngularCorrection, 0.0);
                                impulse = -j * this.motorMass;
                            }
                            else if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                let j = angle - this.upperLimit;
                                angularError = j;
                                j = org.dyn4j.geometry.Interval.clamp(j - angularTolerance, 0.0, maxAngularCorrection);
                                impulse = -j * this.motorMass;
                            }
                            this.body1.rotateAboutCenter(invI1 * impulse);
                            this.body2.rotateAboutCenter(-invI2 * impulse);
                        }
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        let p1 = this.body1.getWorldCenter().add$org_dyn4j_geometry_Vector2(r1);
                        let p2 = this.body2.getWorldCenter().add$org_dyn4j_geometry_Vector2(r2);
                        let p = p1.difference$org_dyn4j_geometry_Vector2(p2);
                        linearError = p.getMagnitude();
                        const large = 10.0 * linearTolerance;
                        if (p.getMagnitudeSquared() > large * large) {
                            let m = invM1 + invM2;
                            if (m > org.dyn4j.Epsilon.E_$LI$()) {
                                m = 1.0 / m;
                            }
                            const impulse = p.multiply(-m);
                            const scale = 0.5;
                            this.body1.translate$org_dyn4j_geometry_Vector2(impulse.product(invM1 * scale));
                            this.body2.translate$org_dyn4j_geometry_Vector2(impulse.product(-invM2 * scale));
                            p1 = this.body1.getWorldCenter().add$org_dyn4j_geometry_Vector2(r1);
                            p2 = this.body2.getWorldCenter().add$org_dyn4j_geometry_Vector2(r2);
                            p = p1.difference$org_dyn4j_geometry_Vector2(p2);
                        }
                        const K = new org.dyn4j.geometry.Matrix22();
                        K.m00 = invM1 + invM2 + r1.y * r1.y * invI1 + r2.y * r2.y * invI2;
                        K.m01 = -invI1 * r1.x * r1.y - invI2 * r2.x * r2.y;
                        K.m10 = this.K.m01;
                        K.m11 = invM1 + invM2 + r1.x * r1.x * invI1 + r2.x * r2.x * invI2;
                        const J = K.solve(p.negate());
                        this.body1.translate$double$double(this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J.x * invM1, this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J.y * invM1);
                        this.body1.rotateAboutCenter(invI1 * r1.cross$org_dyn4j_geometry_Vector2(J));
                        this.body2.translate$double$double(this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : -J.x * invM2, this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : -J.y * invM2);
                        this.body2.rotateAboutCenter(-invI2 * r2.cross$org_dyn4j_geometry_Vector2(J));
                        return linearError <= linearTolerance && angularError <= angularTolerance;
                    }
                    /**
                     * Returns the relative angle between the two bodies given the reference angle.
                     * @return {number} double
                     * @private
                     */
                    /*private*/ getRelativeRotation() {
                        let rr = this.body1.getTransform().getRotationAngle() - this.body2.getTransform().getRotationAngle() - this.referenceAngle;
                        if (rr < -Math.PI)
                            rr += org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                        if (rr > Math.PI)
                            rr -= org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                        return rr;
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                        this.localAnchor1.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.localAnchor2.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        return new org.dyn4j.geometry.Vector2(this.impulse.x * invdt, this.impulse.y * invdt);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return this.impulse.z * invdt;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     * Returns the relative speed at which the {@link Body}s
                     * are rotating in radians/second.
                     * @return {number} double
                     */
                    getJointSpeed() {
                        return this.body2.getAngularVelocity() - this.body1.getAngularVelocity();
                    }
                    /**
                     * Returns the relative angle between the two {@link Body}s in radians in the range [-&pi;, &pi;].
                     * @return {number} double
                     */
                    getJointAngle() {
                        return this.getRelativeRotation();
                    }
                    /**
                     * Returns true if this motor is enabled.
                     * @return {boolean} boolean
                     */
                    isMotorEnabled() {
                        return this.motorEnabled;
                    }
                    /**
                     * Sets whether the motor for this joint is enabled or not.
                     * @param {boolean} flag true if the motor should be enabled
                     */
                    setMotorEnabled(flag) {
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.motorEnabled = flag;
                    }
                    /**
                     * Returns the maximum torque this motor will apply in newton-meters.
                     * @return {number} double
                     */
                    getMaximumMotorTorque() {
                        return this.maximumMotorTorque;
                    }
                    /**
                     * Sets the maximum torque this motor will apply in newton-meters.
                     * @param {number} maximumMotorTorque the maximum motor torque in newton-meters; must be greater than or equal to zero
                     * @throws IllegalArgumentException if maxMotorTorque is less than zero
                     * @see #setMotorSpeed(double)
                     */
                    setMaximumMotorTorque(maximumMotorTorque) {
                        if (maximumMotorTorque < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidMaximumMotorTorque"));
                        this.maximumMotorTorque = maximumMotorTorque;
                    }
                    /**
                     * Returns the desired motor speed in radians/second.
                     * @return {number} double
                     */
                    getMotorSpeed() {
                        return this.motorSpeed;
                    }
                    /**
                     * Sets the target motor speed in radians/second.
                     * @param {number} motorSpeed the motor speed desired in radians/second
                     * @see #setMaximumMotorTorque(double)
                     */
                    setMotorSpeed(motorSpeed) {
                        if (this.motorEnabled) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.motorSpeed = motorSpeed;
                    }
                    /**
                     * Returns the motor torque in newton-meters.
                     * @return {number} double
                     */
                    getMotorTorque() {
                        return this.motorImpulse;
                    }
                    /**
                     * Returns true if the rotational limit is enabled.
                     * @return {boolean} boolean
                     */
                    isLimitEnabled() {
                        return this.limitEnabled;
                    }
                    /**
                     * Enables or disables the rotational limit.
                     * @param {boolean} flag true if the limit should be enabled
                     */
                    setLimitEnabled(flag) {
                        if (this.limitEnabled !== flag) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                            this.limitEnabled = flag;
                            this.impulse.z = 0.0;
                        }
                    }
                    /**
                     * Returns the upper rotational limit in radians.
                     * @return {number} double
                     */
                    getUpperLimit() {
                        return this.upperLimit;
                    }
                    /**
                     * Sets the upper rotational limit.
                     * <p>
                     * Must be greater than or equal to the lower rotational limit.
                     * <p>
                     * See the class documentation for more details on the limit ranges.
                     * @param {number} upperLimit the upper rotational limit in radians
                     * @throws IllegalArgumentException if upperLimit is less than the current lower limit
                     */
                    setUpperLimit(upperLimit) {
                        if (upperLimit < this.lowerLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidUpperLimit"));
                        if (this.limitEnabled && upperLimit !== this.upperLimit) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.upperLimit = upperLimit;
                    }
                    /**
                     * Returns the lower rotational limit in radians.
                     * @return {number} double
                     */
                    getLowerLimit() {
                        return this.lowerLimit;
                    }
                    /**
                     * Sets the lower rotational limit.
                     * <p>
                     * Must be less than or equal to the upper rotational limit.
                     * <p>
                     * See the class documentation for more details on the limit ranges.
                     * @param {number} lowerLimit the lower rotational limit in radians
                     * @throws IllegalArgumentException if lowerLimit is greater than the current upper limit
                     */
                    setLowerLimit(lowerLimit) {
                        if (lowerLimit > this.upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLowerLimit"));
                        if (this.limitEnabled && lowerLimit !== this.lowerLimit) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.lowerLimit = lowerLimit;
                    }
                    /**
                     * Sets the upper and lower rotational limits.
                     * <p>
                     * The lower limit must be less than or equal to the upper limit.
                     * <p>
                     * See the class documentation for more details on the limit ranges.
                     * @param {number} lowerLimit the lower limit in radians
                     * @param {number} upperLimit the upper limit in radians
                     * @throws IllegalArgumentException if the lowerLimit is greater than upperLimit
                     */
                    setLimits(lowerLimit, upperLimit) {
                        if (lowerLimit > upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLimits"));
                        if (this.limitEnabled && (lowerLimit !== this.lowerLimit || upperLimit !== this.upperLimit)) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.lowerLimit = lowerLimit;
                        this.upperLimit = upperLimit;
                    }
                    /**
                     * Returns the reference angle.
                     * <p>
                     * The reference angle is the angle calculated when the joint was created from the
                     * two joined bodies.  The reference angle is the angular difference between the
                     * bodies.
                     * @return {number} double
                     * @since 3.0.1
                     */
                    getReferenceAngle() {
                        return this.referenceAngle;
                    }
                    /**
                     * Sets the reference angle.
                     * <p>
                     * This method can be used to set the reference angle to override the computed
                     * reference angle from the constructor.  This is useful in recreating the joint
                     * from a current state.
                     * @param {number} angle the reference angle in radians
                     * @see #getReferenceAngle()
                     * @since 3.0.1
                     */
                    setReferenceAngle(angle) {
                        this.referenceAngle = angle;
                    }
                    /**
                     * Returns the current state of the limit.
                     * @return {org.dyn4j.dynamics.joint.LimitState} {@link LimitState}
                     * @since 3.2.0
                     */
                    getLimitState() {
                        return this.limitState;
                    }
                }
                joint.RevoluteJoint = RevoluteJoint;
                RevoluteJoint["__class"] = "org.dyn4j.dynamics.joint.RevoluteJoint";
                RevoluteJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} anchor the anchor point in world coordinates
                 * @param {org.dyn4j.geometry.Vector2} axis the axis of allowed motion
                 * @throws NullPointerException if body1, body2, anchor, or axis is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class WheelJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2, anchor, axis) {
                        super(body1, body2, false);
                        if (this.localAnchor1 === undefined) {
                            this.localAnchor1 = null;
                        }
                        if (this.localAnchor2 === undefined) {
                            this.localAnchor2 = null;
                        }
                        if (this.motorEnabled === undefined) {
                            this.motorEnabled = false;
                        }
                        if (this.motorSpeed === undefined) {
                            this.motorSpeed = 0;
                        }
                        if (this.maximumMotorTorque === undefined) {
                            this.maximumMotorTorque = 0;
                        }
                        if (this.frequency === undefined) {
                            this.frequency = 0;
                        }
                        if (this.dampingRatio === undefined) {
                            this.dampingRatio = 0;
                        }
                        if (this.xAxis === undefined) {
                            this.xAxis = null;
                        }
                        if (this.yAxis === undefined) {
                            this.yAxis = null;
                        }
                        if (this.bias === undefined) {
                            this.bias = 0;
                        }
                        if (this.gamma === undefined) {
                            this.gamma = 0;
                        }
                        if (this.invK === undefined) {
                            this.invK = 0;
                        }
                        if (this.springMass === undefined) {
                            this.springMass = 0;
                        }
                        if (this.motorMass === undefined) {
                            this.motorMass = 0;
                        }
                        if (this.perp === undefined) {
                            this.perp = null;
                        }
                        if (this.axis === undefined) {
                            this.axis = null;
                        }
                        if (this.s1 === undefined) {
                            this.s1 = 0;
                        }
                        if (this.s2 === undefined) {
                            this.s2 = 0;
                        }
                        if (this.a1 === undefined) {
                            this.a1 = 0;
                        }
                        if (this.a2 === undefined) {
                            this.a2 = 0;
                        }
                        if (this.impulse === undefined) {
                            this.impulse = 0;
                        }
                        if (this.springImpulse === undefined) {
                            this.springImpulse = 0;
                        }
                        if (this.motorImpulse === undefined) {
                            this.motorImpulse = 0;
                        }
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        if (anchor == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor"));
                        if (axis == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAxis"));
                        this.localAnchor1 = body1.getLocalPoint(anchor);
                        this.localAnchor2 = body2.getLocalPoint(anchor);
                        const n = axis.getNormalized();
                        this.xAxis = body2.getLocalVector(n);
                        this.yAxis = this.xAxis.cross$double(1.0);
                        this.invK = 0.0;
                        this.impulse = 0.0;
                        this.motorMass = 0.0;
                        this.motorImpulse = 0.0;
                        this.springMass = 0.0;
                        this.springImpulse = 0.0;
                        this.frequency = 8.0;
                        this.dampingRatio = 0.0;
                        this.gamma = 0.0;
                        this.bias = 0.0;
                        this.motorEnabled = false;
                        this.maximumMotorTorque = 0.0;
                        this.motorSpeed = 0.0;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("WheelJoint[").append(super.toString()).append("|WorldAnchor=").append(this.getAnchor1()).append("|Axis=").append(this.getAxis()).append("|IsMotorEnabled=").append(this.motorEnabled).append("|MotorSpeed=").append(this.motorSpeed).append("|MaximumMotorTorque=").append(this.maximumMotorTorque).append("|Frequency=").append(this.frequency).append("|DampingRatio=").append(this.dampingRatio).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const d = this.body1.getWorldCenter().sum$org_dyn4j_geometry_Vector2(r1).subtract$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter().sum$org_dyn4j_geometry_Vector2(r2));
                        this.axis = this.body2.getWorldVector(this.xAxis);
                        this.perp = this.body2.getWorldVector(this.yAxis);
                        {
                            this.s1 = r1.cross$org_dyn4j_geometry_Vector2(this.perp);
                            this.s2 = r2.sum$org_dyn4j_geometry_Vector2(d).cross$org_dyn4j_geometry_Vector2(this.perp);
                            this.invK = invM1 + invM2 + this.s1 * this.s1 * invI1 + this.s2 * this.s2 * invI2;
                            if (this.invK > org.dyn4j.Epsilon.E_$LI$()) {
                                this.invK = 1.0 / this.invK;
                            }
                        }
                        ;
                        if (this.frequency > 0.0) {
                            this.a1 = r1.cross$org_dyn4j_geometry_Vector2(this.axis);
                            this.a2 = r2.sum$org_dyn4j_geometry_Vector2(d).cross$org_dyn4j_geometry_Vector2(this.axis);
                            const invMass = invM1 + invM2 + this.a1 * this.a1 * invI1 + this.a2 * this.a2 * invI2;
                            if (invMass > org.dyn4j.Epsilon.E_$LI$()) {
                                this.springMass = 1.0 / invMass;
                                const c = d.dot$org_dyn4j_geometry_Vector2(this.axis);
                                const dt = step.getDeltaTime();
                                const w = org.dyn4j.geometry.Geometry.TWO_PI_$LI$() * this.frequency;
                                const dc = 2.0 * this.springMass * this.dampingRatio * w;
                                const k = this.springMass * w * w;
                                this.gamma = dt * (dc + dt * k);
                                this.gamma = Math.abs(this.gamma) <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / this.gamma;
                                this.bias = c * dt * k * this.gamma;
                                this.springMass = invMass + this.gamma;
                                this.springMass = Math.abs(this.springMass) <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / this.springMass;
                            }
                        }
                        else {
                            this.springMass = 0.0;
                            this.springImpulse = 0.0;
                        }
                        if (this.motorEnabled) {
                            this.motorMass = invI1 + invI2;
                            if (Math.abs(this.motorMass) > org.dyn4j.Epsilon.E_$LI$()) {
                                this.motorMass = 1.0 / this.motorMass;
                            }
                        }
                        else {
                            this.motorMass = 0.0;
                            this.motorImpulse = 0.0;
                        }
                        this.impulse *= step.getDeltaTimeRatio();
                        this.springImpulse *= step.getDeltaTimeRatio();
                        this.motorImpulse *= step.getDeltaTimeRatio();
                        const P = new org.dyn4j.geometry.Vector2();
                        P.x = this.perp.x * this.impulse + this.springImpulse * this.axis.x;
                        P.y = this.perp.y * this.impulse + this.springImpulse * this.axis.y;
                        const l1 = this.impulse * this.s1 + this.springImpulse * this.a1 + this.motorImpulse;
                        const l2 = this.impulse * this.s2 + this.springImpulse * this.a2 + this.motorImpulse;
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(P.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * l1);
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(P.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * l2);
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const v1 = this.body1.getLinearVelocity$();
                        const v2 = this.body2.getLinearVelocity$();
                        let w1 = this.body1.getAngularVelocity();
                        let w2 = this.body2.getAngularVelocity();
                        {
                            const Cdt = this.axis.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2)) + this.a1 * w1 - this.a2 * w2;
                            const impulse = -this.springMass * (Cdt + this.bias + this.gamma * this.springImpulse);
                            this.springImpulse += impulse;
                            const P = this.axis.product(impulse);
                            const l1 = impulse * this.a1;
                            const l2 = impulse * this.a2;
                            v1.add$org_dyn4j_geometry_Vector2(P.product(invM1));
                            w1 += l1 * invI1;
                            v2.subtract$org_dyn4j_geometry_Vector2(P.product(invM2));
                            w2 -= l2 * invI2;
                        }
                        ;
                        if (this.motorEnabled) {
                            const Cdt = w1 - w2 - this.motorSpeed;
                            let impulse = this.motorMass * (-Cdt);
                            const oldImpulse = this.motorImpulse;
                            const maxImpulse = this.maximumMotorTorque * step.getDeltaTime();
                            this.motorImpulse = org.dyn4j.geometry.Interval.clamp(this.motorImpulse + impulse, -maxImpulse, maxImpulse);
                            impulse = this.motorImpulse - oldImpulse;
                            w1 += impulse * invI1;
                            w2 -= impulse * invI2;
                        }
                        {
                            const Cdt = this.perp.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2)) + this.s1 * w1 - this.s2 * w2;
                            const impulse = this.invK * -Cdt;
                            this.impulse += impulse;
                            const P = this.perp.product(impulse);
                            const l1 = impulse * this.s1;
                            const l2 = impulse * this.s2;
                            v1.add$org_dyn4j_geometry_Vector2(P.product(invM1));
                            w1 += l1 * invI1;
                            v2.subtract$org_dyn4j_geometry_Vector2(P.product(invM2));
                            w2 -= l2 * invI2;
                        }
                        ;
                        this.body1.setAngularVelocity(w1);
                        this.body2.setAngularVelocity(w2);
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const c1 = this.body1.getWorldCenter();
                        const c2 = this.body2.getWorldCenter();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const d = c1.sum$org_dyn4j_geometry_Vector2(r1).subtract$org_dyn4j_geometry_Vector2(c2.sum$org_dyn4j_geometry_Vector2(r2));
                        this.axis = this.body2.getWorldVector(this.xAxis);
                        this.perp = this.body2.getWorldVector(this.yAxis);
                        const Cx = this.perp.dot$org_dyn4j_geometry_Vector2(d);
                        const k = invM1 + invM2 + this.s1 * this.s1 * invI1 + this.s2 * this.s2 * invI2;
                        let impulse = 0.0;
                        if (k > org.dyn4j.Epsilon.E_$LI$()) {
                            impulse = -Cx / k;
                        }
                        else {
                            impulse = 0.0;
                        }
                        const P = new org.dyn4j.geometry.Vector2();
                        P.x = this.perp.x * impulse;
                        P.y = this.perp.y * impulse;
                        const l1 = this.s1 * impulse;
                        const l2 = this.s2 * impulse;
                        this.body1.translate$double$double(this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : P.x * invM1, this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : P.y * invM1);
                        this.body1.rotateAboutCenter(l1 * invI1);
                        this.body2.translate$double$double(this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : -P.x * invM2, this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : -P.y * invM2);
                        this.body2.rotateAboutCenter(-l2 * invI2);
                        return Math.abs(Cx) <= linearTolerance;
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        const force = new org.dyn4j.geometry.Vector2();
                        force.x = this.impulse * this.perp.x + this.springImpulse * this.axis.x;
                        force.y = this.impulse * this.perp.y + this.springImpulse * this.axis.y;
                        force.multiply(invdt);
                        return force;
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return this.motorImpulse * invdt;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     * Returns the current joint speed.
                     * @return {number} double
                     * @deprecated Replaced by {@link #getAngularSpeed()} in 3.2.1
                     */
                    getJointSpeed() {
                        return this.getAngularSpeed();
                    }
                    /**
                     * Returns the linear speed along the axis between the two joined bodies
                     * @return {number} double
                     * @since 3.2.1
                     */
                    getLinearSpeed() {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const axis = this.body2.getWorldVector(this.xAxis);
                        const v1 = r1.cross$double(this.body1.getAngularVelocity()).add$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        const v2 = r2.cross$double(this.body2.getAngularVelocity()).add$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                        return v2.dot$org_dyn4j_geometry_Vector2(axis) - v1.dot$org_dyn4j_geometry_Vector2(axis);
                    }
                    /**
                     * Returns the current angular speed between the two joined bodies.
                     * @return {number} double
                     * @since 3.2.1
                     */
                    getAngularSpeed() {
                        const a1 = this.body1.getAngularVelocity();
                        const a2 = this.body2.getAngularVelocity();
                        return a2 - a1;
                    }
                    /**
                     * Returns the current joint translation.
                     * @return {number} double
                     * @deprecated Replaced by {@link #getLinearTranslation()} in 3.2.1
                     */
                    getJointTranslation() {
                        return this.getLinearTranslation();
                    }
                    /**
                     * Returns the current linear translation along the joint axis.
                     * @return {number} double
                     * @since 3.2.1
                     */
                    getLinearTranslation() {
                        const p1 = this.body1.getWorldPoint(this.localAnchor1);
                        const p2 = this.body2.getWorldPoint(this.localAnchor2);
                        const d = p2.difference$org_dyn4j_geometry_Vector2(p1);
                        const axis = this.body2.getWorldVector(this.xAxis);
                        return d.dot$org_dyn4j_geometry_Vector2(axis);
                    }
                    /**
                     * Returns the current angular translation between the joined bodies.
                     * @return {number} double
                     * @since 3.2.1
                     */
                    getAngularTranslation() {
                        const a1 = this.body1.getTransform().getRotationAngle();
                        const a2 = this.body2.getTransform().getRotationAngle();
                        return a2 - a1;
                    }
                    /**
                     * Returns true if this wheel joint is a spring wheel joint.
                     * @return {boolean} boolean
                     */
                    isSpring() {
                        return this.frequency > 0.0;
                    }
                    /**
                     * Returns true if this wheel joint is a spring wheel joint
                     * with damping.
                     * @return {boolean} boolean
                     */
                    isSpringDamper() {
                        return this.frequency > 0.0 && this.dampingRatio > 0.0;
                    }
                    /**
                     * Returns the damping ratio.
                     * @return {number} double
                     */
                    getDampingRatio() {
                        return this.dampingRatio;
                    }
                    /**
                     * Sets the damping ratio.
                     * <p>
                     * Larger values reduce the oscillation of the spring.
                     * @param {number} dampingRatio the damping ratio; in the range [0, 1]
                     * @throws IllegalArgumentException if damping ration is less than zero or greater than 1
                     */
                    setDampingRatio(dampingRatio) {
                        if (dampingRatio < 0 || dampingRatio > 1)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidDampingRatio"));
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.dampingRatio = dampingRatio;
                    }
                    /**
                     * Returns the spring frequency.
                     * @return {number} double
                     */
                    getFrequency() {
                        return this.frequency;
                    }
                    /**
                     * Sets the spring frequency.
                     * <p>
                     * Larger values increase the stiffness of the spring.
                     * @param {number} frequency the spring frequency in hz; must be greater than zero
                     * @throws IllegalArgumentException if frequency is less than or equal to zero
                     */
                    setFrequency(frequency) {
                        if (frequency <= 0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidFrequencyZero"));
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.frequency = frequency;
                    }
                    /**
                     * Returns true if the motor is enabled.
                     * @return {boolean} boolean
                     */
                    isMotorEnabled() {
                        return this.motorEnabled;
                    }
                    /**
                     * Enables or disables the motor.
                     * @param {boolean} motorEnabled true if the motor should be enabled
                     */
                    setMotorEnabled(motorEnabled) {
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.motorEnabled = motorEnabled;
                    }
                    /**
                     * Returns the target motor speed in radians / second.
                     * @return {number} double
                     */
                    getMotorSpeed() {
                        return this.motorSpeed;
                    }
                    /**
                     * Sets the target motor speed.
                     * @param {number} motorSpeed the target motor speed in radians / second
                     * @see #setMaximumMotorTorque(double)
                     */
                    setMotorSpeed(motorSpeed) {
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.motorSpeed = motorSpeed;
                    }
                    /**
                     * Returns the maximum torque the motor can apply to the joint
                     * to achieve the target speed.
                     * @return {number} double
                     */
                    getMaximumMotorTorque() {
                        return this.maximumMotorTorque;
                    }
                    /**
                     * Sets the maximum torque the motor can apply to the joint
                     * to achieve the target speed.
                     * @param {number} maximumMotorTorque the maximum torque in newtons-meters; in the range [0, &infin;]
                     * @throws IllegalArgumentException if maxMotorTorque is less than zero
                     * @see #setMotorSpeed(double)
                     */
                    setMaximumMotorTorque(maximumMotorTorque) {
                        if (maximumMotorTorque < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidMaximumMotorTorque"));
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.maximumMotorTorque = maximumMotorTorque;
                    }
                    /**
                     * Returns the applied motor torque.
                     * @param {number} invdt the inverse delta time from the time step
                     * @return {number} double
                     */
                    getMotorTorque(invdt) {
                        return this.motorImpulse * invdt;
                    }
                    /**
                     * Returns the axis in which the joint is allowed move along in world coordinates.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getAxis() {
                        return this.body2.getWorldVector(this.xAxis);
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                        this.localAnchor1.add$org_dyn4j_geometry_Vector2(vt);
                        const anchor1 = this.body1.getWorldPoint(this.localAnchor1);
                        const anchor2 = this.body2.getWorldPoint(this.localAnchor2);
                        const axis = anchor1.difference$org_dyn4j_geometry_Vector2(anchor2);
                        const n = axis.getNormalized();
                        this.xAxis = this.body2.getLocalVector(n);
                        this.yAxis = this.xAxis.cross$double(1.0);
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.localAnchor2.add$org_dyn4j_geometry_Vector2(vt);
                        const anchor1 = this.body1.getWorldPoint(this.localAnchor1);
                        const anchor2 = this.body2.getWorldPoint(this.localAnchor2);
                        const axis = anchor1.difference$org_dyn4j_geometry_Vector2(anchor2);
                        const n = axis.getNormalized();
                        this.xAxis = this.body2.getLocalVector(n);
                        this.yAxis = this.xAxis.cross$double(1.0);
                    }
                }
                joint.WheelJoint = WheelJoint;
                WheelJoint["__class"] = "org.dyn4j.dynamics.joint.WheelJoint";
                WheelJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * <p>
                 * Creates a pulley joint between the two given {@link Body}s using the given anchor points.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} pulleyAnchor1 the first pulley anchor point
                 * @param {org.dyn4j.geometry.Vector2} pulleyAnchor2 the second pulley anchor point
                 * @param {org.dyn4j.geometry.Vector2} bodyAnchor1 the first {@link Body}'s anchor point
                 * @param {org.dyn4j.geometry.Vector2} bodyAnchor2 the second {@link Body}'s anchor point
                 * @throws NullPointerException if body1, body2, pulleyAnchor1, pulleyAnchor2, bodyAnchor1, or bodyAnchor2 is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class PulleyJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2, pulleyAnchor1, pulleyAnchor2, bodyAnchor1, bodyAnchor2) {
                        super(body1, body2, false);
                        if (this.pulleyAnchor1 === undefined) {
                            this.pulleyAnchor1 = null;
                        }
                        if (this.pulleyAnchor2 === undefined) {
                            this.pulleyAnchor2 = null;
                        }
                        if (this.localAnchor1 === undefined) {
                            this.localAnchor1 = null;
                        }
                        if (this.localAnchor2 === undefined) {
                            this.localAnchor2 = null;
                        }
                        if (this.ratio === undefined) {
                            this.ratio = 0;
                        }
                        if (this.slackEnabled === undefined) {
                            this.slackEnabled = false;
                        }
                        if (this.limitState === undefined) {
                            this.limitState = null;
                        }
                        if (this.length1 === undefined) {
                            this.length1 = 0;
                        }
                        if (this.length2 === undefined) {
                            this.length2 = 0;
                        }
                        if (this.length === undefined) {
                            this.length = 0;
                        }
                        if (this.n1 === undefined) {
                            this.n1 = null;
                        }
                        if (this.n2 === undefined) {
                            this.n2 = null;
                        }
                        if (this.invK === undefined) {
                            this.invK = 0;
                        }
                        if (this.impulse === undefined) {
                            this.impulse = 0;
                        }
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        if (pulleyAnchor1 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.pulley.nullPulleyAnchor1"));
                        if (pulleyAnchor2 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.pulley.nullPulleyAnchor2"));
                        if (bodyAnchor1 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.pulley.nullBodyAnchor1"));
                        if (bodyAnchor2 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.pulley.nullBodyAnchor2"));
                        this.pulleyAnchor1 = pulleyAnchor1;
                        this.pulleyAnchor2 = pulleyAnchor2;
                        this.localAnchor1 = body1.getLocalPoint(bodyAnchor1);
                        this.localAnchor2 = body2.getLocalPoint(bodyAnchor2);
                        this.ratio = 1.0;
                        this.length1 = bodyAnchor1.distance$org_dyn4j_geometry_Vector2(pulleyAnchor1);
                        this.length2 = bodyAnchor2.distance$org_dyn4j_geometry_Vector2(pulleyAnchor2);
                        this.length = this.length1 + this.length2;
                        this.impulse = 0.0;
                        this.slackEnabled = false;
                        this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_UPPER;
                    }
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("PulleyJoint[").append(super.toString()).append("|PulleyAnchor1=").append(this.pulleyAnchor1).append("|PulleyAnchor2=").append(this.pulleyAnchor2).append("|Anchor1=").append(this.getAnchor1()).append("|Anchor2=").append(this.getAnchor2()).append("|Ratio=").append(this.ratio).append("|Length=").append(this.length).append("|SlackEnabled=").append(this.slackEnabled).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const p1 = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter());
                        const p2 = r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter());
                        const s1 = this.pulleyAnchor1;
                        const s2 = this.pulleyAnchor2;
                        this.n1 = s1.to$org_dyn4j_geometry_Vector2(p1);
                        this.n2 = s2.to$org_dyn4j_geometry_Vector2(p2);
                        const l1 = this.n1.normalize();
                        const l2 = this.n2.normalize();
                        const l = l1 + this.ratio * l2;
                        if (l > this.length || !this.slackEnabled) {
                            this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_UPPER;
                            if (l1 <= 10.0 * linearTolerance) {
                                this.n1.zero();
                            }
                            if (l2 <= 10.0 * linearTolerance) {
                                this.n2.zero();
                            }
                            const r1CrossN1 = r1.cross$org_dyn4j_geometry_Vector2(this.n1);
                            const r2CrossN2 = r2.cross$org_dyn4j_geometry_Vector2(this.n2);
                            const pm1 = invM1 + invI1 * r1CrossN1 * r1CrossN1;
                            const pm2 = invM2 + invI2 * r2CrossN2 * r2CrossN2;
                            this.invK = pm1 + this.ratio * this.ratio * pm2;
                            if (this.invK > org.dyn4j.Epsilon.E_$LI$()) {
                                this.invK = 1.0 / this.invK;
                            }
                            else {
                                this.invK = 0.0;
                            }
                            const dtRatio = step.getDeltaTimeRatio();
                            this.impulse *= dtRatio;
                            const J1 = this.n1.product(-this.impulse);
                            const J2 = this.n2.product(-this.ratio * this.impulse);
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J1.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(J1));
                            this.body2.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J2.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() + invI2 * r2.cross$org_dyn4j_geometry_Vector2(J2));
                        }
                        else {
                            this.impulse = 0;
                            this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                        }
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const t1 = this.body1.getTransform();
                            const t2 = this.body2.getTransform();
                            const m1 = this.body1.getMassData();
                            const m2 = this.body2.getMassData();
                            const invM1 = m1.getInverseMass();
                            const invM2 = m2.getInverseMass();
                            const invI1 = m1.getInverseInertia();
                            const invI2 = m2.getInverseInertia();
                            const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                            const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                            const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                            const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                            const C = -this.n1.dot$org_dyn4j_geometry_Vector2(v1) - this.ratio * this.n2.dot$org_dyn4j_geometry_Vector2(v2);
                            const impulse = this.invK * (-C);
                            this.impulse += impulse;
                            const J1 = this.n1.product(-impulse);
                            const J2 = this.n2.product(-impulse * this.ratio);
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J1.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(J1));
                            this.body2.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J2.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() + invI2 * r2.cross$org_dyn4j_geometry_Vector2(J2));
                            this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                            this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                        }
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const linearTolerance = settings.getLinearTolerance();
                            const t1 = this.body1.getTransform();
                            const t2 = this.body2.getTransform();
                            const m1 = this.body1.getMassData();
                            const m2 = this.body2.getMassData();
                            const invM1 = m1.getInverseMass();
                            const invM2 = m2.getInverseMass();
                            const invI1 = m1.getInverseInertia();
                            const invI2 = m2.getInverseInertia();
                            const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                            const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                            const p1 = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter());
                            const p2 = r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter());
                            const s1 = this.pulleyAnchor1;
                            const s2 = this.pulleyAnchor2;
                            this.n1 = s1.to$org_dyn4j_geometry_Vector2(p1);
                            this.n2 = s2.to$org_dyn4j_geometry_Vector2(p2);
                            const l1 = this.n1.normalize();
                            const l2 = this.n2.normalize();
                            if (l1 <= 10.0 * linearTolerance) {
                                this.n1.zero();
                            }
                            if (l2 <= 10.0 * linearTolerance) {
                                this.n2.zero();
                            }
                            let linearError = 0.0;
                            const r1CrossN1 = r1.cross$org_dyn4j_geometry_Vector2(this.n1);
                            const r2CrossN2 = r2.cross$org_dyn4j_geometry_Vector2(this.n2);
                            const pm1 = invM1 + invI1 * r1CrossN1 * r1CrossN1;
                            const pm2 = invM2 + invI2 * r2CrossN2 * r2CrossN2;
                            this.invK = pm1 + this.ratio * this.ratio * pm2;
                            if (this.invK > org.dyn4j.Epsilon.E_$LI$()) {
                                this.invK = 1.0 / this.invK;
                            }
                            else {
                                this.invK = 0.0;
                            }
                            const C = this.length - l1 - this.ratio * l2;
                            linearError = Math.abs(C);
                            const impulse = -this.invK * C;
                            const J1 = this.n1.product(-impulse);
                            const J2 = this.n2.product(-this.ratio * impulse);
                            this.body1.translate$double$double(this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J1.x * invM1, this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J1.y * invM1);
                            this.body1.rotateAboutCenter(r1.cross$org_dyn4j_geometry_Vector2(J1) * invI1);
                            this.body2.translate$double$double(this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J2.x * invM2, this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J2.y * invM2);
                            this.body2.rotateAboutCenter(r2.cross$org_dyn4j_geometry_Vector2(J2) * invI2);
                            return linearError < linearTolerance;
                        }
                        else {
                            return true;
                        }
                    }
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                        this.localAnchor1.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.localAnchor2.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        return this.n2.product(this.impulse * invdt);
                    }
                    getReactionForce2(invdt) {
                        return this.n1.product(-this.impulse * invdt);
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Not applicable to this joint.
                     * Always returns zero.
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return 0.0;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                        this.pulleyAnchor1.add$org_dyn4j_geometry_Vector2(shift);
                        this.pulleyAnchor2.add$org_dyn4j_geometry_Vector2(shift);
                    }
                    /**
                     * Returns the pulley anchor point for the first {@link Body}
                     * in world coordinates.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getPulleyAnchor1() {
                        return this.pulleyAnchor1;
                    }
                    /**
                     * Returns the pulley anchor point for the second {@link Body}
                     * in world coordinates.
                     * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                     */
                    getPulleyAnchor2() {
                        return this.pulleyAnchor2;
                    }
                    /**
                     * Returns the total length of the pulley "rope."
                     * @since 3.0.1
                     * @return {number} double
                     * @see #setLength(double)
                     */
                    getLength() {
                        return this.length;
                    }
                    /**
                     * Sets the total length of the pulley "rope."
                     * <p>
                     * Typically this is computed when the joint is created by adding the distance from the
                     * first body anchor to the first pulley anchor with the distance from the second body anchor
                     * to the second pulley anchor.
                     * @param {number} length the length
                     * @since 3.2.1
                     */
                    setLength(length) {
                        this.length = length;
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                    }
                    /**
                     * Returns the current length from the first pulley anchor point to the
                     * anchor point on the first {@link Body}.
                     * <p>
                     * This is used, in conjunction with length2, to compute the total length
                     * when the ratio is changed.
                     * @return {number} double
                     */
                    getLength1() {
                        const ba = this.body1.getWorldPoint(this.localAnchor1);
                        return this.pulleyAnchor1.distance$org_dyn4j_geometry_Vector2(ba);
                    }
                    /**
                     * Returns the current length from the second pulley anchor point to the
                     * anchor point on the second {@link Body}.
                     * <p>
                     * This is used, in conjunction with length1, to compute the total length
                     * when the ratio is changed.
                     * @return {number} double
                     */
                    getLength2() {
                        const ba = this.body2.getWorldPoint(this.localAnchor2);
                        return this.pulleyAnchor2.distance$org_dyn4j_geometry_Vector2(ba);
                    }
                    /**
                     * Returns the pulley ratio.
                     * @return {number} double
                     */
                    getRatio() {
                        return this.ratio;
                    }
                    /**
                     * Sets the pulley ratio.
                     * <p>
                     * The ratio value is used to simulate a block-and-tackle.  A ratio of 1.0 is the default
                     * and indicates that the pulley is not a block-and-tackle.
                     * <p>
                     * This method recomputes the total length of the pulley system.
                     * @param {number} ratio the ratio; must be greater than zero
                     * @throws IllegalArgumentException if ratio is less than or equal to zero
                     */
                    setRatio(ratio) {
                        if (ratio <= 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.pulley.invalidRatio"));
                        if (ratio !== this.ratio) {
                            this.ratio = ratio;
                            this.length = this.length1 + this.ratio * this.length2;
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                    }
                    /**
                     * Returns true if slack in the rope is enabled.
                     * @return {boolean} boolean
                     * @since 3.1.6
                     */
                    isSlackEnabled() {
                        return this.slackEnabled;
                    }
                    /**
                     * Toggles the slack in the rope.
                     * <p>
                     * If slack is not enabled the rope length is fixed to the total length of the rope, acting like the {@link DistanceJoint}.
                     * @param {boolean} flag true to enable slack
                     * @since 3.1.6
                     */
                    setSlackEnabled(flag) {
                        this.slackEnabled = flag;
                    }
                    /**
                     * Returns the current state of the limit.
                     * @return {org.dyn4j.dynamics.joint.LimitState} {@link LimitState}
                     * @since 3.2.0
                     */
                    getLimitState() {
                        return this.limitState;
                    }
                }
                joint.PulleyJoint = PulleyJoint;
                PulleyJoint["__class"] = "org.dyn4j.dynamics.joint.PulleyJoint";
                PulleyJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @throws NullPointerException if body1 or body2 is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class AngleJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2) {
                        super(body1, body2, false);
                        if (this.ratio === undefined) {
                            this.ratio = 0;
                        }
                        if (this.lowerLimit === undefined) {
                            this.lowerLimit = 0;
                        }
                        if (this.upperLimit === undefined) {
                            this.upperLimit = 0;
                        }
                        if (this.limitEnabled === undefined) {
                            this.limitEnabled = false;
                        }
                        if (this.referenceAngle === undefined) {
                            this.referenceAngle = 0;
                        }
                        if (this.limitState === undefined) {
                            this.limitState = null;
                        }
                        if (this.invK === undefined) {
                            this.invK = 0;
                        }
                        if (this.impulse === undefined) {
                            this.impulse = 0;
                        }
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        this.ratio = 1.0;
                        this.impulse = 0.0;
                        this.referenceAngle = body1.getTransform().getRotationAngle() - body2.getTransform().getRotationAngle();
                        this.upperLimit = this.referenceAngle;
                        this.lowerLimit = this.referenceAngle;
                        this.limitEnabled = true;
                        this.limitState = org.dyn4j.dynamics.joint.LimitState.EQUAL;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("AngleJoint[").append(super.toString()).append("|Ratio=").append(this.ratio).append("|LowerLimit=").append(this.lowerLimit).append("|UpperLimit=").append(this.upperLimit).append("|IsLimitEnabled=").append(this.limitEnabled).append("|ReferenceAngle=").append(this.referenceAngle).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const angularTolerance = settings.getAngularTolerance();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        if (this.limitEnabled) {
                            const angle = this.getRelativeRotation();
                            if (Math.abs(this.upperLimit - this.lowerLimit) < 2.0 * angularTolerance) {
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.EQUAL;
                            }
                            else {
                                if (this.upperLimit > this.lowerLimit) {
                                    if (angle >= this.upperLimit) {
                                        if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                            this.impulse = 0;
                                        }
                                        this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_UPPER;
                                    }
                                    else if (angle <= this.lowerLimit) {
                                        if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                            this.impulse = 0;
                                        }
                                        this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_LOWER;
                                    }
                                    else {
                                        this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                                        this.impulse = 0;
                                    }
                                }
                            }
                        }
                        else {
                            this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                            this.impulse = 0;
                        }
                        if (this.limitState === org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            this.invK = invI1 + this.ratio * this.ratio * invI2;
                        }
                        else {
                            this.invK = invI1 + invI2;
                        }
                        if (this.invK > org.dyn4j.Epsilon.E_$LI$()) {
                            this.invK = 1.0 / this.invK;
                        }
                        this.impulse *= step.getDeltaTimeRatio();
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * this.impulse);
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * this.impulse * (this.limitState === org.dyn4j.dynamics.joint.LimitState.INACTIVE ? this.ratio : 1.0));
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const C = this.body1.getAngularVelocity() - this.body2.getAngularVelocity();
                            let impulse = this.invK * -C;
                            if (this.limitState === org.dyn4j.dynamics.joint.LimitState.EQUAL) {
                                this.impulse += impulse;
                            }
                            else if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                const newImpulse = this.impulse + impulse;
                                if (newImpulse < 0.0) {
                                    impulse = -this.impulse;
                                    this.impulse = 0.0;
                                }
                            }
                            else if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                const newImpulse = this.impulse + impulse;
                                if (newImpulse > 0.0) {
                                    impulse = -this.impulse;
                                    this.impulse = 0.0;
                                }
                            }
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * impulse);
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * impulse);
                        }
                        else if (this.ratio !== 1.0) {
                            const C = this.body1.getAngularVelocity() - this.ratio * this.body2.getAngularVelocity();
                            const impulse = this.invK * -C;
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * impulse);
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * impulse * this.ratio);
                        }
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const angularTolerance = settings.getAngularTolerance();
                            const maxAngularCorrection = settings.getMaximumAngularCorrection();
                            const m1 = this.body1.getMassData();
                            const m2 = this.body2.getMassData();
                            const invI1 = m1.getInverseInertia();
                            const invI2 = m2.getInverseInertia();
                            const angle = this.getRelativeRotation();
                            let impulse = 0.0;
                            let angularError = 0.0;
                            if (this.limitState === org.dyn4j.dynamics.joint.LimitState.EQUAL) {
                                const j = org.dyn4j.geometry.Interval.clamp(angle - this.lowerLimit, -maxAngularCorrection, maxAngularCorrection);
                                impulse = -j * this.invK;
                                angularError = Math.abs(j);
                            }
                            else if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                let j = angle - this.lowerLimit;
                                angularError = -j;
                                j = org.dyn4j.geometry.Interval.clamp(j + angularTolerance, -maxAngularCorrection, 0.0);
                                impulse = -j * this.invK;
                            }
                            else if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                let j = angle - this.upperLimit;
                                angularError = j;
                                j = org.dyn4j.geometry.Interval.clamp(j - angularTolerance, 0.0, maxAngularCorrection);
                                impulse = -j * this.invK;
                            }
                            this.body1.rotateAboutCenter(invI1 * impulse);
                            this.body2.rotateAboutCenter(-invI2 * impulse);
                            return angularError <= angularTolerance;
                        }
                        else {
                            return true;
                        }
                    }
                    /**
                     * Returns the relative angle between the two bodies given the reference angle.
                     * @return {number} double
                     * @private
                     */
                    /*private*/ getRelativeRotation() {
                        let rr = this.body1.getTransform().getRotationAngle() - this.body2.getTransform().getRotationAngle() - this.referenceAngle;
                        if (rr < -Math.PI)
                            rr += org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                        if (rr > Math.PI)
                            rr -= org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                        return rr;
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Not applicable to this joint.
                     * This method returns the first body's world center.
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor1() {
                        return this.body1.getWorldCenter();
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Not applicable to this joint.
                     * This method returns the second body's world center.
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor2() {
                        return this.body2.getWorldCenter();
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Not applicable to this joint. Returns a new zero {@link Vector2}.
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        return new org.dyn4j.geometry.Vector2();
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return this.impulse * invdt;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     * Returns the relative angle between the two {@link Body}s in radians in the range [-&pi;, &pi;].
                     * @return {number} double
                     * @since 3.1.0
                     */
                    getJointAngle() {
                        return this.getRelativeRotation();
                    }
                    /**
                     * Returns the angular velocity ratio between the two bodies.
                     * @return {number} double
                     * @since 3.1.0
                     */
                    getRatio() {
                        return this.ratio;
                    }
                    /**
                     * Sets the angular velocity ratio between the two bodies.
                     * <p>
                     * To disable the ratio and fix their velocities set the ratio to 1.0.
                     * <p>
                     * The ratio can be negative to reverse the direction of the velocity
                     * of the other body.
                     * @param {number} ratio the ratio
                     * @since 3.1.0
                     */
                    setRatio(ratio) {
                        this.ratio = ratio;
                    }
                    /**
                     * Sets whether the angle limits are enabled.
                     * @param {boolean} flag true if the angle limits should be enforced
                     */
                    setLimitEnabled(flag) {
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.limitEnabled = flag;
                    }
                    /**
                     * Returns true if the limit is enabled.
                     * @return {boolean} boolean true if the limit is enabled
                     * @since 3.0.1
                     */
                    isLimitEnabled() {
                        return this.limitEnabled;
                    }
                    /**
                     * Returns the upper limit in radians.
                     * @return {number} double
                     */
                    getUpperLimit() {
                        return this.upperLimit;
                    }
                    /**
                     * Sets the upper limit in radians.
                     * <p>
                     * See the class documentation for more details on the limit ranges.
                     * @param {number} upperLimit the upper limit in radians
                     * @throws IllegalArgumentException if upperLimit is less than the current lower limit
                     */
                    setUpperLimit(upperLimit) {
                        if (upperLimit < this.lowerLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidUpperLimit"));
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.upperLimit = upperLimit;
                    }
                    /**
                     * Returns the lower limit in radians.
                     * @return {number} double
                     */
                    getLowerLimit() {
                        return this.lowerLimit;
                    }
                    /**
                     * Sets the lower limit in radians.
                     * <p>
                     * See the class documentation for more details on the limit ranges.
                     * @param {number} lowerLimit the lower limit in radians
                     * @throws IllegalArgumentException if lowerLimit is greater than the current upper limit
                     */
                    setLowerLimit(lowerLimit) {
                        if (lowerLimit > this.upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLowerLimit"));
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.lowerLimit = lowerLimit;
                    }
                    setLimits$double$double(lowerLimit, upperLimit) {
                        if (lowerLimit > upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLimits"));
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.upperLimit = upperLimit;
                        this.lowerLimit = lowerLimit;
                    }
                    /**
                     * Sets both the lower and upper limits.
                     * <p>
                     * See the class documentation for more details on the limit ranges.
                     * @param {number} lowerLimit the lower limit in radians
                     * @param {number} upperLimit the upper limit in radians
                     * @throws IllegalArgumentException if lowerLimit is greater than upperLimit
                     */
                    setLimits(lowerLimit, upperLimit) {
                        if (((typeof lowerLimit === 'number') || lowerLimit === null) && ((typeof upperLimit === 'number') || upperLimit === null)) {
                            return this.setLimits$double$double(lowerLimit, upperLimit);
                        }
                        else if (((typeof lowerLimit === 'number') || lowerLimit === null) && upperLimit === undefined) {
                            return this.setLimits$double(lowerLimit);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    setLimitsEnabled$double$double(lowerLimit, upperLimit) {
                        this.setLimits$double$double(lowerLimit, upperLimit);
                        this.limitEnabled = true;
                    }
                    /**
                     * Sets both the lower and upper limits and enables them.
                     * <p>
                     * See the class documentation for more details on the limit ranges.
                     * @param {number} lowerLimit the lower limit in radians
                     * @param {number} upperLimit the upper limit in radians
                     * @throws IllegalArgumentException if lowerLimit is greater than upperLimit
                     */
                    setLimitsEnabled(lowerLimit, upperLimit) {
                        if (((typeof lowerLimit === 'number') || lowerLimit === null) && ((typeof upperLimit === 'number') || upperLimit === null)) {
                            return this.setLimitsEnabled$double$double(lowerLimit, upperLimit);
                        }
                        else if (((typeof lowerLimit === 'number') || lowerLimit === null) && upperLimit === undefined) {
                            return this.setLimitsEnabled$double(lowerLimit);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    setLimits$double(limit) {
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.upperLimit = limit;
                        this.lowerLimit = limit;
                    }
                    setLimitsEnabled$double(limit) {
                        this.setLimits$double(limit);
                        this.limitEnabled = true;
                    }
                    /**
                     * Returns the reference angle.
                     * <p>
                     * The reference angle is the angle calculated when the joint was created from the
                     * two joined bodies.  The reference angle is the angular difference between the
                     * bodies.
                     * @return {number} double
                     * @since 3.0.1
                     */
                    getReferenceAngle() {
                        return this.referenceAngle;
                    }
                    /**
                     * Sets the reference angle.
                     * <p>
                     * This method can be used to set the reference angle to override the computed
                     * reference angle from the constructor.  This is useful in recreating the joint
                     * from a current state.
                     * <p>
                     * See the class documentation for more details.
                     * @param {number} angle the reference angle in radians
                     * @see #getReferenceAngle()
                     * @since 3.0.1
                     */
                    setReferenceAngle(angle) {
                        this.referenceAngle = angle;
                    }
                    /**
                     * Returns the current state of the limit.
                     * @return {org.dyn4j.dynamics.joint.LimitState} {@link LimitState}
                     * @since 3.2.0
                     */
                    getLimitState() {
                        return this.limitState;
                    }
                }
                joint.AngleJoint = AngleJoint;
                AngleJoint["__class"] = "org.dyn4j.dynamics.joint.AngleJoint";
                AngleJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * <p>
                 * Creates a rope joint between the two bodies that acts like a distance joint.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} anchor1 in world coordinates
                 * @param {org.dyn4j.geometry.Vector2} anchor2 in world coordinates
                 * @throws NullPointerException if body1, body2, anchor1, or anchor2 is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author mahesh Kurmi
                 */
                class SpindleJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2, anchor1, anchor2) {
                        super(body1, body2, false);
                        if (this.localAnchor1 === undefined) {
                            this.localAnchor1 = null;
                        }
                        if (this.radius1 === undefined) {
                            this.radius1 = 0;
                        }
                        if (this.radius2 === undefined) {
                            this.radius2 = 0;
                        }
                        if (this.localAnchor2 === undefined) {
                            this.localAnchor2 = null;
                        }
                        if (this.invK === undefined) {
                            this.invK = 0;
                        }
                        if (this.n === undefined) {
                            this.n = null;
                        }
                        if (this.limitState === undefined) {
                            this.limitState = null;
                        }
                        if (this.impulse === undefined) {
                            this.impulse = 0;
                        }
                        this.springConstant = 0;
                        this.dampingCoeff = 0;
                        if (this.naturalLength === undefined) {
                            this.naturalLength = 0;
                        }
                        this.linkedJoint = null;
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        if (anchor1 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor1"));
                        if (anchor2 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor2"));
                        this.localAnchor1 = body1.getLocalPoint(anchor1);
                        this.localAnchor2 = body2.getLocalPoint(anchor2);
                        this.radius1 = -anchor1.difference$org_dyn4j_geometry_Vector2(anchor2).getRightHandOrthogonalVector().getNormalized().dot$org_dyn4j_geometry_Vector2(anchor1.difference$org_dyn4j_geometry_Vector2(body1.getWorldCenter()));
                        this.radius2 = -anchor2.difference$org_dyn4j_geometry_Vector2(anchor1).getRightHandOrthogonalVector().getNormalized().dot$org_dyn4j_geometry_Vector2(anchor2.difference$org_dyn4j_geometry_Vector2(body2.getWorldCenter()));
                        if (body1.getFixture$org_dyn4j_geometry_Vector2(anchor1) != null && !(body1.getFixture$org_dyn4j_geometry_Vector2(anchor1).getShape() != null && body1.getFixture$org_dyn4j_geometry_Vector2(anchor1).getShape() instanceof org.dyn4j.geometry.Circle)) {
                            this.radius1 = 0;
                        }
                        if (body2.getFixture$org_dyn4j_geometry_Vector2(anchor2) != null && !(body2.getFixture$org_dyn4j_geometry_Vector2(anchor2).getShape() != null && body2.getFixture$org_dyn4j_geometry_Vector2(anchor2).getShape() instanceof org.dyn4j.geometry.Circle)) {
                            this.radius2 = 0;
                        }
                        this.n = anchor1.subtract$org_dyn4j_geometry_Vector2(anchor2);
                        const length = this.n.getMagnitude();
                        if (length === 0) {
                            this.n.zero();
                        }
                        else {
                            this.n.multiply(1.0 / length);
                        }
                        const distance = anchor1.distance$org_dyn4j_geometry_Vector2(anchor2);
                        this.naturalLength = distance;
                        this.collisionAllowed = true;
                    }
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("RopeJoint[").append(super.toString()).append("|LocalAnchor1=").append(this.localAnchor1).append("|LocalAnchor2=").append(this.localAnchor2).append("|WorldAnchor1=").append(this.getAnchor1()).append("|WorldAnchor2=").append(this.getAnchor2()).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        let length = this.n.getMagnitude();
                        if (length < linearTolerance) {
                            this.n.zero();
                        }
                        else {
                            this.n.multiply(1.0 / length);
                        }
                        let v1;
                        let v2;
                        if (this.body1.isActive() && this.body2.isActive()) {
                            const cr1n = r1.cross$org_dyn4j_geometry_Vector2(this.n);
                            const cr2n = r2.cross$org_dyn4j_geometry_Vector2(this.n);
                            let invMass = invM1 + invI1 * cr1n * cr1n;
                            invMass += invM2 + invI2 * cr2n * cr2n;
                            this.invK = invMass <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / invMass;
                            this.impulse *= step.getDeltaTimeRatio();
                            if (this.springConstant > 0 || this.linkedJoint != null && this.linkedJoint.springConstant > 0) {
                                const dt = step.getDeltaTime();
                                let k = this.springConstant > 0 ? 1 / this.springConstant : 0;
                                if (this.linkedJoint != null) {
                                    const r21 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                                    const r22 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                                    length += r21.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r22.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter())).getMagnitude();
                                    k += this.linkedJoint.springConstant > 0 ? 1 / this.linkedJoint.springConstant : 0;
                                }
                                k = 1 / k;
                                const x = length - this.naturalLength;
                                v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                                v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                                const rv = this.n.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2));
                                this.impulse = -k * x * dt - this.dampingCoeff * rv * dt;
                            }
                            const J = this.n.product(this.impulse);
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(J));
                            this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(J.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(J));
                        }
                        v1 = this.body1.getWorldPoint(this.localAnchor1);
                        v2 = this.body2.getWorldPoint(this.localAnchor2);
                        if (this.radius1 !== 0) {
                            v1 = r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()).difference$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter());
                            const l = v1.getMagnitude();
                            let th = this.radius1 / l;
                            if (th > 1)
                                th = 1;
                            if (th < -1)
                                th = -1;
                            if (l > 0) {
                                v1.rotate$double(Math.acos(th));
                                v1.divide(l);
                                v1.multiply(this.radius1);
                                v1.add$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter());
                                this.localAnchor1 = this.body1.getLocalPoint(v1);
                            }
                        }
                        if (this.radius2 !== 0) {
                            v2 = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).difference$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter());
                            const l = v2.getMagnitude();
                            let th = this.radius2 / l;
                            if (th > 1)
                                th = 1;
                            if (th < -1)
                                th = -1;
                            if (l > 0) {
                                v2.rotate$double(Math.acos(th));
                                if (!((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(v2.x) || !((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(v2.y)) {
                                    console.info(" Detected nan");
                                }
                                v2.divide(l);
                                v2.multiply(this.radius2);
                                v2.add$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter());
                                this.localAnchor2 = this.body2.getLocalPoint(v2);
                            }
                        }
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        if (this.springConstant > 0 || this.linkedJoint != null && this.linkedJoint.springConstant > 0)
                            return;
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const length = r1.distance$org_dyn4j_geometry_Vector2(r2);
                        const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                        const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                        const Jv = this.n.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2));
                        const j = -this.invK * (Jv);
                        this.impulse += j;
                        const J = this.n.product(j);
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(J));
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(J.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(J));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        if (this.springConstant > 0 || this.linkedJoint != null && this.linkedJoint.springConstant > 0)
                            return true;
                        let v1 = this.body1.getWorldPoint(this.localAnchor1);
                        let v2 = this.body2.getWorldPoint(this.localAnchor2);
                        const targetDistance = v1.distance$org_dyn4j_geometry_Vector2(v2);
                        const linearTolerance = settings.getLinearTolerance();
                        const maxLinearCorrection = settings.getMaximumLinearCorrection();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const c1 = this.body1.getWorldCenter();
                        const c2 = this.body2.getWorldCenter();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        const l = this.n.normalize();
                        let C = l - targetDistance;
                        let impulse;
                        if (this.springConstant === 0) {
                            C = org.dyn4j.geometry.Interval.clamp(C, -maxLinearCorrection, maxLinearCorrection);
                            impulse = -this.invK * C;
                        }
                        else {
                            const dt = step.getDeltaTime();
                            C = l - this.naturalLength;
                            v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                            v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                            const rv = this.n.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2));
                            impulse = -this.springConstant * C * dt - this.dampingCoeff * rv * dt;
                            return true;
                        }
                        const J = this.n.product(impulse);
                        this.body1.translate$double$double(this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J.x * invM1, this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J.y * invM1);
                        this.body1.rotate$double$org_dyn4j_geometry_Vector2(invI1 * r1.cross$org_dyn4j_geometry_Vector2(J), c1);
                        this.body2.translate$double$double(this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : -J.x * invM2, this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : -J.y * invM2);
                        this.body2.rotate$double$org_dyn4j_geometry_Vector2(-invI2 * r2.cross$org_dyn4j_geometry_Vector2(J), c2);
                        return Math.abs(C) < linearTolerance;
                    }
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                        this.localAnchor1.add$org_dyn4j_geometry_Vector2(vt);
                        const anchor1 = this.body1.getWorldPoint(this.localAnchor1);
                        const anchor2 = this.body2.getWorldPoint(this.localAnchor2);
                        this.radius1 = -anchor1.difference$org_dyn4j_geometry_Vector2(anchor2).getRightHandOrthogonalVector().getNormalized().dot$org_dyn4j_geometry_Vector2(anchor1.difference$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()));
                        this.radius2 = -anchor2.difference$org_dyn4j_geometry_Vector2(anchor1).getRightHandOrthogonalVector().getNormalized().dot$org_dyn4j_geometry_Vector2(anchor2.difference$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        const distance = anchor1.distance$org_dyn4j_geometry_Vector2(anchor2);
                        this.naturalLength = distance;
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.localAnchor2.add$org_dyn4j_geometry_Vector2(vt);
                        const anchor1 = this.body1.getWorldPoint(this.localAnchor1);
                        const anchor2 = this.body2.getWorldPoint(this.localAnchor2);
                        this.radius1 = -anchor1.difference$org_dyn4j_geometry_Vector2(anchor2).getRightHandOrthogonalVector().getNormalized().dot$org_dyn4j_geometry_Vector2(anchor1.difference$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()));
                        this.radius2 = -anchor2.difference$org_dyn4j_geometry_Vector2(anchor1).getRightHandOrthogonalVector().getNormalized().dot$org_dyn4j_geometry_Vector2(anchor2.difference$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        const distance = anchor1.distance$org_dyn4j_geometry_Vector2(anchor2);
                        this.naturalLength = distance;
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        return this.n.product(this.impulse * invdt);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return 0.0;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.joint.SpindleJoint} jt
                     */
                    setLinkedJoint(jt) {
                        let t1 = this.body1.getTransform();
                        let t2 = this.body2.getTransform();
                        let r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        let r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        let length = this.n.getMagnitude();
                        let v1;
                        let v2;
                        v1 = this.body1.getWorldPoint(this.localAnchor1);
                        v2 = this.body2.getWorldPoint(this.localAnchor2);
                        if (this.radius1 !== 0) {
                            v1 = r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()).difference$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter());
                            v1.rotate$double(Math.acos(this.radius1 / v1.getMagnitude()));
                            v1.normalize();
                            v1.multiply(this.radius1);
                            v1.add$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter());
                            this.localAnchor1 = this.body1.getLocalPoint(v1);
                        }
                        if (this.radius2 !== 0) {
                            v2 = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).difference$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter());
                            v2.rotate$double(Math.acos(this.radius2 / v2.getMagnitude()));
                            v2.normalize();
                            v2.multiply(this.radius2);
                            v2.add$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter());
                            this.localAnchor2 = this.body2.getLocalPoint(v2);
                        }
                        this.naturalLength = length;
                        if (jt == null) {
                            if (this.linkedJoint != null) {
                                this.linkedJoint.linkedJoint = null;
                                this.linkedJoint.setLinkedJoint(null);
                            }
                            return;
                        }
                        t1 = jt.body1.getTransform();
                        t2 = jt.body2.getTransform();
                        r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(jt.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(jt.localAnchor1));
                        r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(jt.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(jt.localAnchor2));
                        length = r1.sum$org_dyn4j_geometry_Vector2(jt.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(jt.body2.getWorldCenter())).getMagnitude();
                        v1 = jt.body1.getWorldPoint(this.localAnchor1);
                        v2 = jt.body2.getWorldPoint(this.localAnchor2);
                        if (jt.radius1 !== 0) {
                            v1 = r2.sum$org_dyn4j_geometry_Vector2(jt.body2.getWorldCenter()).difference$org_dyn4j_geometry_Vector2(jt.body1.getWorldCenter());
                            v1.rotate$double(Math.acos(jt.radius1 / v1.getMagnitude()));
                            v1.normalize();
                            v1.multiply(jt.radius1);
                            v1.add$org_dyn4j_geometry_Vector2(jt.body1.getWorldCenter());
                            jt.localAnchor1 = jt.body1.getLocalPoint(v1);
                        }
                        if (jt.radius2 !== 0) {
                            v2 = r1.sum$org_dyn4j_geometry_Vector2(jt.body1.getWorldCenter()).difference$org_dyn4j_geometry_Vector2(jt.body2.getWorldCenter());
                            v2.rotate$double(Math.acos(jt.radius2 / v2.getMagnitude()));
                            v2.normalize();
                            v2.multiply(jt.radius2);
                            v2.add$org_dyn4j_geometry_Vector2(jt.body2.getWorldCenter());
                            jt.localAnchor2 = jt.body2.getLocalPoint(v2);
                        }
                        this.naturalLength += length;
                    }
                    /**
                     * Returns the radius of spindle of first body in meters.
                     * @return {number} double
                     */
                    getRadius1() {
                        return this.radius1;
                    }
                    /**
                     * Returns the radius of spindle of second body in meters.
                     * @return {number} double
                     */
                    getRadius2() {
                        return this.radius2;
                    }
                    /**
                     * Sets Spring Constant of the spring
                     * @param {number} springConstant
                     */
                    setSpringConstant(springConstant) {
                        if (springConstant < 0.0)
                            throw new java.lang.IllegalArgumentException("ForceConstant can not be less than or equal to zero");
                        this.springConstant = springConstant;
                    }
                    /**
                     * returns Spring Constant of the Spring
                     * @return {number} Spring Constant of the Spring
                     */
                    getSpringConstant() {
                        return this.springConstant;
                    }
                    /**
                     * Returns the rest distance between the two constrained {@link Body}s in meters.
                     * @return {number} double
                     */
                    getNaturalLength() {
                        return this.naturalLength;
                    }
                    /**
                     * Sets the rest distance between the two constrained {@link Body}s in meters.
                     * @param {number} naturalLength the naturalLength in meters
                     * @throws IllegalArgumentException if distance is less than zero
                     */
                    setNaturalLength(naturalLength) {
                        if (naturalLength < 0.0)
                            throw new java.lang.IllegalArgumentException("Natural Length can not be less than zero");
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.naturalLength = naturalLength;
                    }
                    /**
                     * Returns the damping ratio.
                     * @return {number} double
                     */
                    getDampingcoeff() {
                        return this.dampingCoeff;
                    }
                    /**
                     * Sets the damping ratio.
                     * @param dampingRatio the damping ratio; in the range [0, 1]
                     * @throws IllegalArgumentException if damping ration is less than zero or greater than 1
                     * @param {number} dampingCoeff
                     */
                    setDampingCoeff(dampingCoeff) {
                        if (dampingCoeff < 0)
                            throw new java.lang.IllegalArgumentException("DampingCoeff can not be less than to zero");
                        this.dampingCoeff = dampingCoeff;
                    }
                }
                joint.SpindleJoint = SpindleJoint;
                SpindleJoint["__class"] = "org.dyn4j.dynamics.joint.SpindleJoint";
                SpindleJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * <p>
                 * Creates a fixed distance {@link Joint} where the joined
                 * {@link Body}s do not participate in collision detection and
                 * resolution.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} anchor1 in world coordinates
                 * @param {org.dyn4j.geometry.Vector2} anchor2 in world coordinates
                 * @param {number} k spring constant
                 * @param damping Coefficient
                 * @throws NullPointerException if body1, body2, anchor1, or anchor2 is null
                 * @throws IllegalArgumentException if body1 == body2, k<=0, dampingCoeff<0;
                 * @param {number} dampingCoeff
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 */
                class SpringJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2, anchor1, anchor2, k, dampingCoeff) {
                        super(body1, body2, false);
                        if (this.localAnchor1 === undefined) {
                            this.localAnchor1 = null;
                        }
                        if (this.localAnchor2 === undefined) {
                            this.localAnchor2 = null;
                        }
                        this.springConstant = 500;
                        if (this.dampingCoeff === undefined) {
                            this.dampingCoeff = 0;
                        }
                        if (this.naturalLength === undefined) {
                            this.naturalLength = 0;
                        }
                        if (this.n === undefined) {
                            this.n = null;
                        }
                        if (this.impulse === undefined) {
                            this.impulse = 0;
                        }
                        if (this.invEqMass === undefined) {
                            this.invEqMass = 0;
                        }
                        if (this.frequency === undefined) {
                            this.frequency = 0;
                        }
                        this.oscillator = false;
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        if (anchor1 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor1"));
                        if (anchor2 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor2"));
                        this.localAnchor1 = body1.getLocalPoint(anchor1);
                        this.localAnchor2 = body2.getLocalPoint(anchor2);
                        if (k <= 0)
                            throw new java.lang.IllegalArgumentException("ForceConstant can not be less than or equal to zero");
                        if (dampingCoeff < 0)
                            throw new java.lang.IllegalArgumentException("DampingCoeff can not be less than zero");
                        this.springConstant = k;
                        this.dampingCoeff = dampingCoeff;
                        this.naturalLength = anchor1.distance$org_dyn4j_geometry_Vector2(anchor2);
                        this.n = new org.dyn4j.geometry.Vector2();
                        const t1 = body1.getTransform();
                        const t2 = body2.getTransform();
                        const m1 = body1.getMassData();
                        const m2 = body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        const cr1n = r1.cross$org_dyn4j_geometry_Vector2(this.n);
                        const cr2n = r2.cross$org_dyn4j_geometry_Vector2(this.n);
                        let invMass = invM1 + invI1 * cr1n * cr1n;
                        invMass += invM2 + invI2 * cr2n * cr2n;
                        this.invEqMass = invMass <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / invMass;
                    }
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("SpringJoint[").append(super.toString()).append("|LocalAnchor1=").append(this.localAnchor1).append("|LocalAnchor2=").append(this.localAnchor2).append("|WorldAnchor1=").append(this.getAnchor1()).append("|WorldAnchor2=").append(this.getAnchor2()).append("|springConstant=").append(this.springConstant).append("|DampingRatio=").append(this.dampingCoeff).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        const cr1n = r1.cross$org_dyn4j_geometry_Vector2(this.n);
                        const cr2n = r2.cross$org_dyn4j_geometry_Vector2(this.n);
                        let invMass = invM1 + invI1 * cr1n * cr1n;
                        invMass += invM2 + invI2 * cr2n * cr2n;
                        this.invEqMass = invMass <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / invMass;
                        let k;
                        if (this.oscillator) {
                            const w = org.dyn4j.geometry.Geometry.TWO_PI_$LI$() * this.frequency;
                            const massEff = invMass <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / invMass;
                            k = massEff * w * w;
                        }
                        else {
                            k = this.springConstant;
                            this.frequency = Math.sqrt(this.springConstant * this.invEqMass) / (2 * Math.PI);
                        }
                        const length = this.n.getMagnitude();
                        if (length < linearTolerance) {
                            this.n.zero();
                        }
                        else {
                            this.n.multiply(1.0 / length);
                        }
                        const dt = step.getDeltaTime();
                        const x = length - this.naturalLength;
                        const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                        const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                        const rv = this.n.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2));
                        this.impulse = -k * x * dt - this.dampingCoeff * rv * dt;
                        let J = this.n.product(this.impulse);
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(J));
                        J = this.n.product(this.impulse);
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(J.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(J));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        const length = this.n.getMagnitude();
                        if (length < linearTolerance) {
                            this.n.zero();
                        }
                        else {
                            this.n.multiply(1.0 / length);
                        }
                        const dt = step.getDeltaTime();
                        const x = length - this.naturalLength;
                        const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                        const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                        const rv = this.n.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2));
                        this.impulse = -this.springConstant * x * dt - this.dampingCoeff * rv * dt;
                        return true;
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        return this.n.product(this.impulse * invdt);
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Not applicable to this joint. Always returns zero.
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return 0.0;
                    }
                    /**
                     * Returns true if this distance joint is a spring distance joint
                     * with damping.
                     * @return {boolean} boolean
                     */
                    isSpringDamper() {
                        return this.dampingCoeff > 0.0;
                    }
                    /**
                     * Returns the damping ratio.
                     * @return {number} double
                     */
                    getDampingcoeff() {
                        return this.dampingCoeff;
                    }
                    /**
                     * Sets the damping ratio.
                     * @param dampingRatio the damping ratio; in the range [0, 1]
                     * @throws IllegalArgumentException if damping ration is less than zero or greater than 1
                     * @param {number} dampingCoeff
                     */
                    setDampingCoeff(dampingCoeff) {
                        if (dampingCoeff < 0)
                            throw new java.lang.IllegalArgumentException("DampingCoeff can not be less than to zero");
                        this.dampingCoeff = dampingCoeff;
                    }
                    /**
                     * Returns the spring frequency.
                     * @return {number} double
                     */
                    getFrequency() {
                        if (this.oscillator) {
                            return this.frequency;
                        }
                        else {
                            return Math.sqrt(this.springConstant * this.invEqMass) / (2 * Math.PI);
                        }
                    }
                    /**
                     * Sets the spring frequency.
                     * @param {number} frequency the spring frequency in hz; must be greater than or equal to zero
                     * @throws IllegalArgumentException if frequency is less than zero
                     */
                    setFrequency(frequency) {
                        if (frequency < 0)
                            throw new java.lang.IllegalArgumentException("frequency can not be less than or equal to zero");
                        this.frequency = frequency;
                    }
                    /**
                     * Returns the rest distance between the two constrained {@link Body}s in meters.
                     * @return {number} double
                     */
                    getNaturalLength() {
                        return this.naturalLength;
                    }
                    /**
                     * Sets the rest distance between the two constrained {@link Body}s in meters.
                     * @param {number} naturalLength the naturalLength in meters
                     * @throws IllegalArgumentException if distance is less than zero
                     */
                    setNaturalLength(naturalLength) {
                        if (naturalLength < 0.0)
                            throw new java.lang.IllegalArgumentException("Natural Length can not be less than zero");
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.naturalLength = naturalLength;
                    }
                    /**
                     * Sets Spring Constant of the spring
                     * @param {number} springConstant
                     */
                    setSpringConstant(springConstant) {
                        if (springConstant < 0.0)
                            throw new java.lang.IllegalArgumentException("ForceConstant can not be less than or equal to zero");
                        this.springConstant = springConstant;
                    }
                    /**
                     * returns Spring Constant of the Spring
                     * @return {number} Spring Constant of the Spring
                     */
                    getSpringConstant() {
                        return this.springConstant;
                    }
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                        this.localAnchor1.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.localAnchor2.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                }
                joint.SpringJoint = SpringJoint;
                SpringJoint["__class"] = "org.dyn4j.dynamics.joint.SpringJoint";
                SpringJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * <p>
                 * Creates a rope joint between the two bodies that acts like a distance joint.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} anchor1 in world coordinates
                 * @param {org.dyn4j.geometry.Vector2} anchor2 in world coordinates
                 * @throws NullPointerException if body1, body2, anchor1, or anchor2 is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class RopeJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2, anchor1, anchor2) {
                        super(body1, body2, false);
                        if (this.localAnchor1 === undefined) {
                            this.localAnchor1 = null;
                        }
                        if (this.localAnchor2 === undefined) {
                            this.localAnchor2 = null;
                        }
                        if (this.upperLimit === undefined) {
                            this.upperLimit = 0;
                        }
                        if (this.lowerLimit === undefined) {
                            this.lowerLimit = 0;
                        }
                        if (this.upperLimitEnabled === undefined) {
                            this.upperLimitEnabled = false;
                        }
                        if (this.lowerLimitEnabled === undefined) {
                            this.lowerLimitEnabled = false;
                        }
                        if (this.invK === undefined) {
                            this.invK = 0;
                        }
                        if (this.n === undefined) {
                            this.n = null;
                        }
                        if (this.limitState === undefined) {
                            this.limitState = null;
                        }
                        if (this.impulse === undefined) {
                            this.impulse = 0;
                        }
                        this.prevImpulse = 0;
                        if (this.avImpulse === undefined) {
                            this.avImpulse = 0;
                        }
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        if (anchor1 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor1"));
                        if (anchor2 == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor2"));
                        this.localAnchor1 = body1.getLocalPoint(anchor1);
                        this.localAnchor2 = body2.getLocalPoint(anchor2);
                        this.upperLimitEnabled = true;
                        this.lowerLimitEnabled = true;
                        const distance = anchor1.distance$org_dyn4j_geometry_Vector2(anchor2);
                        this.upperLimit = distance;
                        this.lowerLimit = 0;
                    }
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("RopeJoint[").append(super.toString()).append("|Anchor1=").append(this.getAnchor1()).append("|Anchor2=").append(this.getAnchor2()).append("|IsLowerLimitEnabled=").append(this.lowerLimitEnabled).append("|LowerLimit").append(this.lowerLimit).append("|IsUpperLimitEnabled=").append(this.upperLimitEnabled).append("|UpperLimit=").append(this.upperLimit).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        const length = this.n.getMagnitude();
                        if (length < linearTolerance) {
                            this.n.zero();
                        }
                        else {
                            this.n.multiply(1.0 / length);
                        }
                        if (this.upperLimitEnabled && this.lowerLimitEnabled) {
                            if (Math.abs(this.upperLimit - this.lowerLimit) < 2.0 * linearTolerance) {
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.EQUAL;
                            }
                            else {
                                if (this.upperLimit > this.lowerLimit) {
                                    if (length > this.upperLimit) {
                                        this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_UPPER;
                                    }
                                    else if (length < this.lowerLimit) {
                                        this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_LOWER;
                                    }
                                    else {
                                        this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                                    }
                                }
                            }
                        }
                        else if (this.upperLimitEnabled) {
                            if (length > this.upperLimit) {
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_UPPER;
                            }
                            else {
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                            }
                        }
                        else if (this.lowerLimitEnabled) {
                            if (length < this.lowerLimit) {
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.AT_LOWER;
                            }
                            else {
                                this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                            }
                        }
                        else {
                            this.limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                        }
                        if (this.prevImpulse === 0 && this.impulse === 0) {
                            this.avImpulse = 0;
                        }
                        else if ((Math.abs(this.impulse) - Math.abs(this.prevImpulse)) / Math.abs(this.impulse) > 0.3) {
                            this.avImpulse = (this.impulse + this.prevImpulse) / 2;
                        }
                        else if ((Math.abs(this.impulse) - Math.abs(this.prevImpulse)) / Math.abs(this.impulse) < -0.3) {
                            this.avImpulse = (this.impulse + this.prevImpulse) / 2;
                        }
                        else if (this.impulse !== 0) {
                            this.avImpulse = this.impulse;
                        }
                        this.prevImpulse = this.impulse;
                        if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const cr1n = r1.cross$org_dyn4j_geometry_Vector2(this.n);
                            const cr2n = r2.cross$org_dyn4j_geometry_Vector2(this.n);
                            let invMass = invM1 + invI1 * cr1n * cr1n;
                            invMass += invM2 + invI2 * cr2n * cr2n;
                            this.invK = invMass <= org.dyn4j.Epsilon.E_$LI$() ? 0.0 : 1.0 / invMass;
                            this.impulse *= step.getDeltaTimeRatio();
                            const J = this.n.product(this.impulse);
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(J));
                            this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(J.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(J));
                        }
                        else {
                            this.impulse = 0.0;
                        }
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const t1 = this.body1.getTransform();
                            const t2 = this.body2.getTransform();
                            const m1 = this.body1.getMassData();
                            const m2 = this.body2.getMassData();
                            const invM1 = m1.getInverseMass();
                            const invM2 = m2.getInverseMass();
                            const invI1 = m1.getInverseInertia();
                            const invI2 = m2.getInverseInertia();
                            const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                            const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                            const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                            const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                            const Jv = this.n.dot$org_dyn4j_geometry_Vector2(v1.difference$org_dyn4j_geometry_Vector2(v2));
                            const j = -this.invK * (Jv);
                            this.impulse += j;
                            const J = this.n.product(j);
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(J.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(J));
                            this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(J.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(J));
                            this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                            this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                        }
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        if (this.limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            let targetDistance = this.upperLimit;
                            if (this.limitState === org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                targetDistance = this.lowerLimit;
                            }
                            const linearTolerance = settings.getLinearTolerance();
                            const maxLinearCorrection = settings.getMaximumLinearCorrection();
                            const t1 = this.body1.getTransform();
                            const t2 = this.body2.getTransform();
                            const m1 = this.body1.getMassData();
                            const m2 = this.body2.getMassData();
                            const invM1 = m1.getInverseMass();
                            const invM2 = m2.getInverseMass();
                            const invI1 = m1.getInverseInertia();
                            const invI2 = m2.getInverseInertia();
                            const c1 = this.body1.getWorldCenter();
                            const c2 = this.body2.getWorldCenter();
                            const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                            const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                            this.n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                            const l = this.n.normalize();
                            let C = l - targetDistance;
                            C = org.dyn4j.geometry.Interval.clamp(C, -maxLinearCorrection, maxLinearCorrection);
                            const impulse = -this.invK * C;
                            const J = this.n.product(impulse);
                            this.body1.translate$double$double(this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J.x * invM1, this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J.y * invM1);
                            this.body1.rotate$double$org_dyn4j_geometry_Vector2(invI1 * r1.cross$org_dyn4j_geometry_Vector2(J), c1);
                            this.body2.translate$double$double(this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : -J.x * invM2, this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : -J.y * invM2);
                            this.body2.rotate$double$org_dyn4j_geometry_Vector2(-invI2 * r2.cross$org_dyn4j_geometry_Vector2(J), c2);
                            return Math.abs(C) < linearTolerance;
                        }
                        else {
                            return true;
                        }
                    }
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        if (this.avImpulse === 0)
                            return new org.dyn4j.geometry.Vector2();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const n = r1.sum$org_dyn4j_geometry_Vector2(this.body1.getWorldCenter()).subtract$org_dyn4j_geometry_Vector2(r2.sum$org_dyn4j_geometry_Vector2(this.body2.getWorldCenter()));
                        n.normalize();
                        return n.product(this.avImpulse * invdt);
                    }
                    /**
                     * {@inheritDoc}
                     * <p>
                     * Not applicable to this joint.
                     * Always returns zero.
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return 0.0;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     * Returns the upper limit in meters.
                     * @return {number} double
                     */
                    getUpperLimit() {
                        return this.upperLimit;
                    }
                    /**
                     * Sets the upper limit in meters.
                     * @param {number} upperLimit the upper limit in meters; must be greater than or equal to zero
                     * @throws IllegalArgumentException if upperLimit is less than zero or less than the current lower limit
                     */
                    setUpperLimit(upperLimit) {
                        if (upperLimit < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.rope.lessThanZeroUpperLimit"));
                        if (upperLimit < this.lowerLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidUpperLimit"));
                        if (this.upperLimitEnabled && upperLimit !== this.upperLimit) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.upperLimit = upperLimit;
                    }
                    /**
                     * Sets whether the upper limit is enabled.
                     * @param {boolean} flag true if the upper limit should be enabled
                     */
                    setUpperLimitEnabled(flag) {
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.upperLimitEnabled = flag;
                    }
                    /**
                     * Returns true if the upper limit is enabled.
                     * @return {boolean} boolean true if the upper limit is enabled
                     */
                    isUpperLimitEnabled() {
                        return this.upperLimitEnabled;
                    }
                    /**
                     * Returns the lower limit in meters.
                     * @return {number} double
                     */
                    getLowerLimit() {
                        return this.lowerLimit;
                    }
                    /**
                     * Sets the lower limit in meters.
                     * @param {number} lowerLimit the lower limit in meters; must be greater than or equal to zero
                     * @throws IllegalArgumentException if lowerLimit is less than zero or greater than the current upper limit
                     */
                    setLowerLimit(lowerLimit) {
                        if (lowerLimit < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.rope.lessThanZeroLowerLimit"));
                        if (lowerLimit > this.upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLowerLimit"));
                        if (this.lowerLimitEnabled && lowerLimit !== this.lowerLimit) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.lowerLimit = lowerLimit;
                    }
                    /**
                     * Sets whether the lower limit is enabled.
                     * @param {boolean} flag true if the lower limit should be enabled
                     */
                    setLowerLimitEnabled(flag) {
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.lowerLimitEnabled = flag;
                    }
                    /**
                     * Returns true if the lower limit is enabled.
                     * @return {boolean} boolean true if the lower limit is enabled
                     */
                    isLowerLimitEnabled() {
                        return this.lowerLimitEnabled;
                    }
                    setLimits$double$double(lowerLimit, upperLimit) {
                        if (lowerLimit < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.rope.lessThanZeroLowerLimit"));
                        if (upperLimit < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.rope.lessThanZeroUpperLimit"));
                        if (lowerLimit > upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLimits"));
                        if ((this.lowerLimitEnabled && lowerLimit !== this.lowerLimit) || (this.upperLimitEnabled && upperLimit !== this.upperLimit)) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.upperLimit = upperLimit;
                        this.lowerLimit = lowerLimit;
                    }
                    /**
                     * Sets both the lower and upper limits.
                     * @param {number} lowerLimit the lower limit in meters; must be greater than or equal to zero
                     * @param {number} upperLimit the upper limit in meters; must be greater than or equal to zero
                     * @throws IllegalArgumentException if lowerLimit is less than zero, upperLimit is less than zero, or lowerLimit is greater than upperLimit
                     */
                    setLimits(lowerLimit, upperLimit) {
                        if (((typeof lowerLimit === 'number') || lowerLimit === null) && ((typeof upperLimit === 'number') || upperLimit === null)) {
                            return this.setLimits$double$double(lowerLimit, upperLimit);
                        }
                        else if (((typeof lowerLimit === 'number') || lowerLimit === null) && upperLimit === undefined) {
                            return this.setLimits$double(lowerLimit);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    setLimitsEnabled$double$double(lowerLimit, upperLimit) {
                        this.upperLimitEnabled = true;
                        this.lowerLimitEnabled = true;
                        this.setLimits$double$double(lowerLimit, upperLimit);
                    }
                    /**
                     * Sets both the lower and upper limits and enables both.
                     * @param {number} lowerLimit the lower limit in meters; must be greater than or equal to zero
                     * @param {number} upperLimit the upper limit in meters; must be greater than or equal to zero
                     * @throws IllegalArgumentException if lowerLimit is less than zero, upperLimit is less than zero, or lowerLimit is greater than upperLimit
                     */
                    setLimitsEnabled(lowerLimit, upperLimit) {
                        if (((typeof lowerLimit === 'number') || lowerLimit === null) && ((typeof upperLimit === 'number') || upperLimit === null)) {
                            return this.setLimitsEnabled$double$double(lowerLimit, upperLimit);
                        }
                        else if (((typeof lowerLimit === 'boolean') || lowerLimit === null) && upperLimit === undefined) {
                            return this.setLimitsEnabled$boolean(lowerLimit);
                        }
                        else if (((typeof lowerLimit === 'number') || lowerLimit === null) && upperLimit === undefined) {
                            return this.setLimitsEnabled$double(lowerLimit);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    setLimitsEnabled$boolean(flag) {
                        this.upperLimitEnabled = flag;
                        this.lowerLimitEnabled = flag;
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                    }
                    setLimits$double(limit) {
                        if (limit < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.rope.invalidLimit"));
                        if ((this.lowerLimitEnabled && limit !== this.lowerLimit) || (this.upperLimitEnabled && limit !== this.upperLimit)) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.upperLimit = limit;
                        this.lowerLimit = limit;
                    }
                    setLimitsEnabled$double(limit) {
                        this.upperLimitEnabled = true;
                        this.lowerLimitEnabled = true;
                        this.setLimits$double(limit);
                    }
                    /**
                     * Returns the current state of the limit.
                     * @return {org.dyn4j.dynamics.joint.LimitState} {@link LimitState}
                     * @since 3.2.0
                     */
                    getLimitState() {
                        return this.limitState;
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                        this.localAnchor1.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.localAnchor2.add$org_dyn4j_geometry_Vector2(vt);
                    }
                }
                joint.RopeJoint = RopeJoint;
                RopeJoint["__class"] = "org.dyn4j.dynamics.joint.RopeJoint";
                RopeJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} anchor the anchor point in world coordinates
                 * @throws NullPointerException if body1, body2, or anchor is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.Joint
                 * @author William Bittle
                 */
                class FrictionJoint extends org.dyn4j.dynamics.joint.Joint {
                    constructor(body1, body2, anchor) {
                        super(body1, body2, false);
                        if (this.localAnchor1 === undefined) {
                            this.localAnchor1 = null;
                        }
                        if (this.localAnchor2 === undefined) {
                            this.localAnchor2 = null;
                        }
                        if (this.maximumForce === undefined) {
                            this.maximumForce = 0;
                        }
                        if (this.maximumTorque === undefined) {
                            this.maximumTorque = 0;
                        }
                        if (this.K === undefined) {
                            this.K = null;
                        }
                        if (this.angularMass === undefined) {
                            this.angularMass = 0;
                        }
                        if (this.linearImpulse === undefined) {
                            this.linearImpulse = null;
                        }
                        if (this.angularImpulse === undefined) {
                            this.angularImpulse = 0;
                        }
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        if (anchor == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor"));
                        this.localAnchor1 = body1.getLocalPoint(anchor);
                        this.localAnchor2 = body2.getLocalPoint(anchor);
                        this.K = new org.dyn4j.geometry.Matrix22();
                        this.linearImpulse = new org.dyn4j.geometry.Vector2();
                        this.angularImpulse = 0.0;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("FrictionJoint[").append(super.toString()).append("|Anchor=").append(this.getAnchor1()).append("|MaximumForce=").append(this.maximumForce).append("|MaximumTorque=").append(this.maximumTorque).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.K.m00 = invM1 + invM2 + r1.y * r1.y * invI1 + r2.y * r2.y * invI2;
                        this.K.m01 = -invI1 * r1.x * r1.y - invI2 * r2.x * r2.y;
                        this.K.m10 = this.K.m01;
                        this.K.m11 = invM1 + invM2 + r1.x * r1.x * invI1 + r2.x * r2.x * invI2;
                        this.angularMass = invI1 + invI2;
                        if (this.angularMass > org.dyn4j.Epsilon.E_$LI$()) {
                            this.angularMass = 1.0 / this.angularMass;
                        }
                        this.linearImpulse.multiply(step.getDeltaTimeRatio());
                        this.angularImpulse *= step.getDeltaTimeRatio();
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(this.linearImpulse.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * (r1.cross$org_dyn4j_geometry_Vector2(this.linearImpulse) + this.angularImpulse));
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(this.linearImpulse.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * (r2.cross$org_dyn4j_geometry_Vector2(this.linearImpulse) + this.angularImpulse));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        {
                            const C = this.body1.getAngularVelocity() - this.body2.getAngularVelocity();
                            let impulse = this.angularMass * -C;
                            const oldImpulse = this.angularImpulse;
                            const maxImpulse = this.maximumTorque * step.getDeltaTime();
                            this.angularImpulse = org.dyn4j.geometry.Interval.clamp(this.angularImpulse + impulse, -maxImpulse, maxImpulse);
                            impulse = this.angularImpulse - oldImpulse;
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * impulse);
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * impulse);
                        }
                        ;
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                        const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                        const pivotV = v1.subtract$org_dyn4j_geometry_Vector2(v2);
                        let impulse = this.K.solve(pivotV.negate());
                        const oldImpulse = this.linearImpulse.copy();
                        this.linearImpulse.add$org_dyn4j_geometry_Vector2(impulse);
                        const maxImpulse = this.maximumForce * step.getDeltaTime();
                        if (this.linearImpulse.getMagnitudeSquared() > maxImpulse * maxImpulse) {
                            this.linearImpulse.normalize();
                            this.linearImpulse.multiply(maxImpulse);
                        }
                        impulse = this.linearImpulse.difference$org_dyn4j_geometry_Vector2(oldImpulse);
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(impulse.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(impulse));
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(impulse.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(impulse));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        return true;
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        return this.linearImpulse.product(invdt);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return this.angularImpulse * invdt;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     * Returns the maximum torque this constraint will apply in newton-meters.
                     * @return {number} double
                     */
                    getMaximumTorque() {
                        return this.maximumTorque;
                    }
                    /**
                     * Sets the maximum torque this constraint will apply in newton-meters.
                     * @param {number} maximumTorque the maximum torque in newton-meters; in the range [0, &infin;]
                     * @throws IllegalArgumentException if maxTorque is less than zero
                     */
                    setMaximumTorque(maximumTorque) {
                        if (maximumTorque < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.friction.invalidMaximumTorque"));
                        this.maximumTorque = maximumTorque;
                    }
                    /**
                     * Returns the maximum force this constraint will apply in newtons.
                     * @return {number} double
                     */
                    getMaximumForce() {
                        return this.maximumForce;
                    }
                    /**
                     * Sets the maximum force this constraint will apply in newtons.
                     * @param {number} maximumForce the maximum force in newtons; in the range [0, &infin;]
                     * @throws IllegalArgumentException if maxForce is less than zero
                     */
                    setMaximumForce(maximumForce) {
                        if (maximumForce < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.friction.invalidMaximumForce"));
                        this.maximumForce = maximumForce;
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                        this.localAnchor1.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.localAnchor2.add$org_dyn4j_geometry_Vector2(vt);
                    }
                }
                joint.FrictionJoint = FrictionJoint;
                FrictionJoint["__class"] = "org.dyn4j.dynamics.joint.FrictionJoint";
                FrictionJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                var input;
                (function (input) {
                    class KeyBoardControlsHandler extends org.dyn4j.samples.framework.input.AbstractKeyboardInputHandler {
                        constructor(component, frame, camera) {
                            super(component);
                            if (this.frame === undefined) {
                                this.frame = null;
                            }
                            if (this.camera === undefined) {
                                this.camera = null;
                            }
                            this.frame = frame;
                            this.camera = camera;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isActive() {
                            return true;
                        }
                        onKeyPressed(keyCode, key) {
                            switch ((key)) {
                                case "a":
                                    this.frame.setBodyAABBDrawingEnabled(!this.frame.isBodyAABBDrawingEnabled());
                                    break;
                                case "s":
                                    this.frame.setBodyRotationRadiusDrawingEnabled(!this.frame.isBodyRotationRadiusDrawingEnabled());
                                    break;
                                case "d":
                                    this.frame.setFixtureAABBDrawingEnabled(!this.frame.isFixtureAABBDrawingEnabled());
                                    ;
                                    break;
                                case "f":
                                    this.frame.setFixtureRotationRadiusDrawingEnabled(!this.frame.isFixtureRotationRadiusDrawingEnabled());
                                    break;
                                case "g":
                                    this.frame.setContactDrawingEnabled(!this.frame.isContactDrawingEnabled());
                                case "q":
                                    this.frame.step();
                                    break;
                            }
                            if (keyCode === 32) {
                                if (this.frame.isPaused()) {
                                    this.frame.resume();
                                }
                                else {
                                    this.frame.pause();
                                }
                            }
                        }
                        onKeyReleased(keyCode, key) {
                        }
                    }
                    input.KeyBoardControlsHandler = KeyBoardControlsHandler;
                    KeyBoardControlsHandler["__class"] = "org.dyn4j.samples.framework.input.KeyBoardControlsHandler";
                    KeyBoardControlsHandler["__interfaces"] = ["org.dyn4j.samples.framework.input.InputHandler"];
                })(input = framework.input || (framework.input = {}));
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                var input;
                (function (input) {
                    class KeyBoardCameraHandler extends org.dyn4j.samples.framework.input.AbstractKeyboardInputHandler {
                        constructor(component, camera) {
                            super(component);
                            if (this.camera === undefined) {
                                this.camera = null;
                            }
                            this.delta = 1;
                            this.camera = camera;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isActive() {
                            return true;
                        }
                        onKeyPressed(keyCode, key) {
                            switch ((key)) {
                                case "ArrowLeft":
                                    this.camera.offsetX -= this.delta;
                                    break;
                                case "ArrowRight":
                                    this.camera.offsetX += this.delta;
                                    break;
                                case "ArrowUp":
                                    this.camera.offsetY += this.delta;
                                    break;
                                case "ArrowDown":
                                    this.camera.offsetY -= this.delta;
                                    break;
                                case "Space":
                                    this.camera.offsetY = 0;
                                    this.camera.offsetY = 0;
                                case "q":
                                    this.camera.scale *= 1.04;
                                    break;
                                case "w":
                                    this.camera.scale *= 0.95;
                                    break;
                            }
                        }
                        onKeyReleased(keyCode, key) {
                        }
                    }
                    input.KeyBoardCameraHandler = KeyBoardCameraHandler;
                    KeyBoardCameraHandler["__class"] = "org.dyn4j.samples.framework.input.KeyBoardCameraHandler";
                    KeyBoardCameraHandler["__interfaces"] = ["org.dyn4j.samples.framework.input.InputHandler"];
                })(input = framework.input || (framework.input = {}));
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                var input;
                (function (input) {
                    class MouseZoomInputHandler extends org.dyn4j.samples.framework.input.AbstractMouseInputHandler {
                        constructor(component, camera, button) {
                            super(component, camera, button);
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isActive() {
                            return false;
                        }
                        /**
                         *
                         * @param {number} rotation
                         */
                        onMouseWheel(rotation) {
                            super.onMouseWheel(rotation);
                            if (rotation > 0) {
                                this.camera.scale /= 0.96;
                            }
                            else {
                                this.camera.scale *= 0.96;
                            }
                        }
                    }
                    input.MouseZoomInputHandler = MouseZoomInputHandler;
                    MouseZoomInputHandler["__class"] = "org.dyn4j.samples.framework.input.MouseZoomInputHandler";
                    MouseZoomInputHandler["__interfaces"] = ["org.dyn4j.samples.framework.input.InputHandler"];
                })(input = framework.input || (framework.input = {}));
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                var input;
                (function (input) {
                    class MousePickingInputHandler extends org.dyn4j.samples.framework.input.AbstractMouseInputHandler {
                        constructor(component, camera, world) {
                            super(component, camera, 1);
                            if (this.world === undefined) {
                                this.world = null;
                            }
                            if (this.mouseHandle === undefined) {
                                this.mouseHandle = null;
                            }
                            this.world = world;
                        }
                        /**
                         *
                         * @param {org.dyn4j.geometry.Vector2} point
                         */
                        onMousePressed(point) {
                            super.onMousePressed(point);
                            this.handleMouseStartOrDrag(point);
                        }
                        /**
                         *
                         * @param {org.dyn4j.geometry.Vector2} start
                         * @param {org.dyn4j.geometry.Vector2} current
                         */
                        onMouseDrag(start, current) {
                            super.onMouseDrag(start, current);
                            this.handleMouseStartOrDrag(current);
                        }
                        /**
                         *
                         */
                        onMouseRelease() {
                            this.removeMouseHandleJoint();
                            super.onMouseRelease();
                        }
                        /**
                         *
                         * @param {boolean} flag
                         */
                        setEnabled(flag) {
                            super.setEnabled(flag);
                            if (!flag) {
                                this.removeMouseHandleJoint();
                            }
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isActive() {
                            return this.mouseHandle != null;
                        }
                        /**
                         *
                         */
                        uninstall() {
                            super.uninstall();
                            this.removeMouseHandleJoint();
                        }
                        /*private*/ handleMouseStartOrDrag(point) {
                            const p = this.toWorldCoordinates(point);
                            if (!this.isActive()) {
                                let body = null;
                                const aabb = new org.dyn4j.geometry.AABB(new org.dyn4j.geometry.Vector2(p.x, p.y), 1.0E-4);
                                const it = (new java.util.ArrayList());
                                this.world.detect$org_dyn4j_geometry_AABB$java_util_List(aabb, it);
                                for (let index = it.iterator(); index.hasNext();) {
                                    let result = index.next();
                                    {
                                        const b = result.getBody();
                                        if (b.isStatic()) {
                                            continue;
                                        }
                                        if (b.contains(p)) {
                                            body = b;
                                            break;
                                        }
                                    }
                                }
                                if (body != null) {
                                    console.log("Body picked " + body);
                                    this.mouseHandle = new org.dyn4j.dynamics.joint.PinJoint(body, new org.dyn4j.geometry.Vector2(p.x, p.y), 8.0, 0.2, 1000);
                                    this.world.addJoint(this.mouseHandle);
                                    return true;
                                }
                            }
                            else {
                                this.mouseHandle.setTarget(new org.dyn4j.geometry.Vector2(p.x, p.y));
                                return true;
                            }
                            return false;
                        }
                        /*private*/ removeMouseHandleJoint() {
                            const joint = this.mouseHandle;
                            this.mouseHandle = null;
                            this.world.removeJoint$org_dyn4j_dynamics_joint_Joint(joint);
                        }
                    }
                    input.MousePickingInputHandler = MousePickingInputHandler;
                    MousePickingInputHandler["__class"] = "org.dyn4j.samples.framework.input.MousePickingInputHandler";
                    MousePickingInputHandler["__interfaces"] = ["org.dyn4j.samples.framework.input.InputHandler"];
                })(input = framework.input || (framework.input = {}));
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                var input;
                (function (input) {
                    class MousePanningInputHandler extends org.dyn4j.samples.framework.input.AbstractMouseInputHandler {
                        constructor(component, camera) {
                            super(component, camera, 1);
                            if (this.panning === undefined) {
                                this.panning = false;
                            }
                            if (this.start === undefined) {
                                this.start = null;
                            }
                            this.panning = false;
                        }
                        /**
                         *
                         * @param {org.dyn4j.geometry.Vector2} point
                         */
                        onMousePressed(point) {
                            super.onMousePressed(point);
                            this.handleMouseStart(point);
                        }
                        /**
                         *
                         * @param {org.dyn4j.geometry.Vector2} start
                         * @param {org.dyn4j.geometry.Vector2} current
                         */
                        onMouseDrag(start, current) {
                            super.onMouseDrag(start, current);
                            this.handleMouseDrag(current);
                        }
                        /**
                         *
                         */
                        onMouseRelease() {
                            this.clearPanningState();
                            super.onMouseRelease();
                        }
                        onMouseWheel(rotation) {
                            if (rotation > 0)
                                this.camera.scale *= 1.002;
                            else if (rotation < 0)
                                this.camera.scale *= 0.998;
                        }
                        /**
                         *
                         * @param {boolean} flag
                         */
                        setEnabled(flag) {
                            super.setEnabled(flag);
                            if (!flag) {
                                this.clearPanningState();
                            }
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isActive() {
                            return this.panning;
                        }
                        /**
                         *
                         */
                        uninstall() {
                            super.uninstall();
                            this.clearPanningState();
                        }
                        /*private*/ handleMouseStart(start) {
                            this.panning = true;
                            this.start = start;
                            return true;
                        }
                        /*private*/ handleMouseDrag(current) {
                            this.panning = true;
                            const x = current.x - this.start.x;
                            const y = current.y - this.start.y;
                            this.camera.offsetX += x;
                            this.camera.offsetY -= y;
                            this.start = current;
                            return true;
                        }
                        /*private*/ clearPanningState() {
                            this.panning = false;
                            this.start = null;
                        }
                    }
                    input.MousePanningInputHandler = MousePanningInputHandler;
                    MousePanningInputHandler["__class"] = "org.dyn4j.samples.framework.input.MousePanningInputHandler";
                    MousePanningInputHandler["__interfaces"] = ["org.dyn4j.samples.framework.input.InputHandler"];
                })(input = framework.input || (framework.input = {}));
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * <p>
             * Creates a new {@link Polygon} using the given vertices.  The center of the polygon
             * is calculated using an area weighted method.
             * <p>
             * A polygon must have 3 or more vertices, of which one is not colinear with the other two.
             * <p>
             * A polygon must also be convex and have counter-clockwise winding.
             * @param {org.dyn4j.geometry.Vector2[]} vertices the array of vertices
             * @throws NullPointerException if vertices is null or contains a null element
             * @throws IllegalArgumentException if vertices contains less than 3 points, contains coincident points, is not convex, or has clockwise winding
             * @class
             * @extends org.dyn4j.geometry.AbstractShape
             * @author William Bittle
             */
            class Polygon extends org.dyn4j.geometry.AbstractShape {
                constructor(vertices) {
                    super(new org.dyn4j.geometry.Vector2(), 1);
                    if (this.vertices === undefined) {
                        this.vertices = null;
                    }
                    if (this.normals === undefined) {
                        this.normals = null;
                    }
                    this.center = org.dyn4j.geometry.Geometry.getAreaWeightedCenter$org_dyn4j_geometry_Vector2_A.apply(null, vertices);
                    this.radius = org.dyn4j.geometry.Geometry.getRotationRadius$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2_A.apply(null, [this.center].concat(vertices));
                    this.vertices = vertices;
                    this.normals = org.dyn4j.geometry.Geometry.getCounterClockwiseEdgeNormals.apply(null, vertices);
                }
                /**
                 * Validates the constructor input returning true if valid or throwing an exception if invalid.
                 * @param {org.dyn4j.geometry.Vector2[]} vertices the array of vertices
                 * @return {boolean} boolean true
                 * @throws NullPointerException if vertices is null or contains a null element
                 * @throws IllegalArgumentException if vertices contains less than 3 points, contains coincident points, is not convex, or has clockwise winding
                 * @private
                 */
                /*private*/ static validate(...vertices) {
                    if (vertices == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.polygon.nullArray"));
                    const size = vertices.length;
                    if (size < 3)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.polygon.lessThan3Vertices"));
                    for (let i = 0; i < size; i++) {
                        {
                            if (vertices[i] == null)
                                throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.polygon.nullVertices"));
                        }
                        ;
                    }
                    let area = 0.0;
                    let sign = 0.0;
                    for (let i = 0; i < size; i++) {
                        {
                            const p0 = (i - 1 < 0) ? vertices[size - 1] : vertices[i - 1];
                            const p1 = vertices[i];
                            const p2 = (i + 1 === size) ? vertices[0] : vertices[i + 1];
                            if (p1.equals$org_dyn4j_geometry_Vector2(p2)) {
                                throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.polygon.coincidentVertices"));
                            }
                            const cross = p0.to$org_dyn4j_geometry_Vector2(p1).cross$org_dyn4j_geometry_Vector2(p1.to$org_dyn4j_geometry_Vector2(p2));
                            const tsign = (f => { if (f > 0) {
                                return 1;
                            }
                            else if (f < 0) {
                                return -1;
                            }
                            else {
                                return 0;
                            } })(cross);
                            area += cross;
                            if (Math.abs(cross) > org.dyn4j.Epsilon.E_$LI$()) {
                                if (sign !== 0.0 && tsign !== sign) {
                                    throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.polygon.nonConvex"));
                                }
                            }
                            sign = tsign;
                        }
                        ;
                    }
                    if (Math.abs(area) <= org.dyn4j.Epsilon.E_$LI$()) {
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.polygon.zeroArea"));
                    }
                    if (area < 0.0) {
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.polygon.invalidWinding"));
                    }
                    return true;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Polygon[").append(super.toString()).append("|Vertices={");
                    for (let i = 0; i < this.vertices.length; i++) {
                        {
                            if (i !== 0)
                                sb.append(",");
                            sb.append(this.vertices[i]);
                        }
                        ;
                    }
                    sb.append("}").append("]");
                    return sb.toString();
                }
                /**
                 *
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getVertices() {
                    return this.vertices;
                }
                /**
                 *
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getNormals() {
                    return this.normals;
                }
                /**
                 *
                 * @return {*}
                 */
                getVertexIterator() {
                    return new org.dyn4j.geometry.WoundIterator(this.vertices);
                }
                /**
                 *
                 * @return {*}
                 */
                getNormalIterator() {
                    return new org.dyn4j.geometry.WoundIterator(this.normals);
                }
                getRadius$org_dyn4j_geometry_Vector2(center) {
                    return org.dyn4j.geometry.Geometry.getRotationRadius$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2_A.apply(null, [center].concat(this.vertices));
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} center
                 * @return {number}
                 */
                getRadius(center) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        return this.getRadius$org_dyn4j_geometry_Vector2(center);
                    }
                    else if (center === undefined) {
                        return this.getRadius$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2[]} foci
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getAxes(foci, transform) {
                    const fociSize = foci != null ? foci.length : 0;
                    const size = this.vertices.length;
                    const axes = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size + fociSize);
                    let n = 0;
                    for (let i = 0; i < size; i++) {
                        {
                            const v = this.normals[i];
                            axes[n++] = transform.getTransformedR$org_dyn4j_geometry_Vector2(v);
                        }
                        ;
                    }
                    for (let i = 0; i < fociSize; i++) {
                        {
                            const f = foci[i];
                            let closest = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                            let d = f.distanceSquared$org_dyn4j_geometry_Vector2(closest);
                            for (let j = 1; j < size; j++) {
                                {
                                    let p = this.vertices[j];
                                    p = transform.getTransformed$org_dyn4j_geometry_Vector2(p);
                                    const dt = f.distanceSquared$org_dyn4j_geometry_Vector2(p);
                                    if (dt < d) {
                                        closest = p;
                                        d = dt;
                                    }
                                }
                                ;
                            }
                            const axis = f.to$org_dyn4j_geometry_Vector2(closest);
                            axis.normalize();
                            axes[n++] = axis;
                        }
                        ;
                    }
                    return axes;
                }
                /**
                 * {@inheritDoc}
                 * <p>
                 * Not applicable to this shape. Always returns null.
                 * @return {org.dyn4j.geometry.Vector2[]} null
                 * @param {org.dyn4j.geometry.Transform} transform
                 */
                getFoci(transform) {
                    return null;
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    const p = transform.getInverseTransformed$org_dyn4j_geometry_Vector2(point);
                    const size = this.vertices.length;
                    let p1 = this.vertices[size - 1];
                    let p2 = this.vertices[0];
                    let last = org.dyn4j.geometry.Segment.getLocation(p, p1, p2);
                    for (let i = 0; i < size - 1; i++) {
                        {
                            p1 = p2;
                            p2 = this.vertices[i + 1];
                            if (p.equals$org_dyn4j_geometry_Vector2(p1) || p.equals$org_dyn4j_geometry_Vector2(p2)) {
                                return true;
                            }
                            const location = org.dyn4j.geometry.Segment.getLocation(p, p1, p2);
                            if (last * location < 0) {
                                return false;
                            }
                            if (Math.abs(location) > org.dyn4j.Epsilon.E_$LI$()) {
                                last = location;
                            }
                        }
                        ;
                    }
                    return true;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} point
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {boolean}
                 */
                contains(point, transform) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    super.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    const size = this.vertices.length;
                    for (let i = 0; i < size; i++) {
                        {
                            this.vertices[i].rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                            this.normals[i].rotate$org_dyn4j_geometry_Rotation(rotation);
                        }
                        ;
                    }
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$double$double(x, y) {
                    super.translate$double$double(x, y);
                    const size = this.vertices.length;
                    for (let i = 0; i < size; i++) {
                        {
                            this.vertices[i].add$double$double(x, y);
                        }
                        ;
                    }
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform) {
                    let v = 0.0;
                    let p = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                    let min = vector.dot$org_dyn4j_geometry_Vector2(p);
                    let max = min;
                    const size = this.vertices.length;
                    for (let i = 1; i < size; i++) {
                        {
                            p = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[i]);
                            v = vector.dot$org_dyn4j_geometry_Vector2(p);
                            if (v < min) {
                                min = v;
                            }
                            else if (v > max) {
                                max = v;
                            }
                        }
                        ;
                    }
                    return new org.dyn4j.geometry.Interval(min, max);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Interval}
                 */
                project(vector, transform) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && transform === undefined) {
                        return this.project$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.EdgeFeature}
                 */
                getFarthestFeature(vector, transform) {
                    const localn = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(vector);
                    const index = this.getFarthestVertexIndex(localn);
                    const count = this.vertices.length;
                    const maximum = new org.dyn4j.geometry.Vector2(this.vertices[index]);
                    const leftN = this.normals[index === 0 ? count - 1 : index - 1];
                    const rightN = this.normals[index];
                    transform.transform(maximum);
                    const vm = new org.dyn4j.geometry.PointFeature(maximum, index);
                    if (leftN.dot$org_dyn4j_geometry_Vector2(localn) < rightN.dot$org_dyn4j_geometry_Vector2(localn)) {
                        const l = (index === count - 1) ? 0 : index + 1;
                        const left = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[l]);
                        const vl = new org.dyn4j.geometry.PointFeature(left, l);
                        return new org.dyn4j.geometry.EdgeFeature(vm, vl, vm, maximum.to$org_dyn4j_geometry_Vector2(left), index + 1);
                    }
                    else {
                        const r = (index === 0) ? count - 1 : index - 1;
                        const right = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[r]);
                        const vr = new org.dyn4j.geometry.PointFeature(right, r);
                        return new org.dyn4j.geometry.EdgeFeature(vr, vm, vm, right.to$org_dyn4j_geometry_Vector2(maximum), index);
                    }
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getFarthestPoint(vector, transform) {
                    const localn = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(vector);
                    const index = this.getFarthestVertexIndex(localn);
                    return transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[index]);
                }
                /**
                 * Internal helper method that returns the index of the point that is
                 * farthest in direction of a vector.
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector the direction
                 * @return {number} the index of the farthest vertex in that direction
                 * @since 3.4.0
                 */
                getFarthestVertexIndex(vector) {
                    let maxIndex = 0;
                    const n = this.vertices.length;
                    let max = vector.dot$org_dyn4j_geometry_Vector2(this.vertices[0]);
                    let candidateMax;
                    if (max < (candidateMax = vector.dot$org_dyn4j_geometry_Vector2(this.vertices[1]))) {
                        do {
                            {
                                max = candidateMax;
                                maxIndex++;
                            }
                        } while (((maxIndex + 1) < n && max < (candidateMax = vector.dot$org_dyn4j_geometry_Vector2(this.vertices[maxIndex + 1]))));
                    }
                    else if (max < (candidateMax = vector.dot$org_dyn4j_geometry_Vector2(this.vertices[n - 1]))) {
                        maxIndex = n;
                        do {
                            {
                                max = candidateMax;
                                maxIndex--;
                            }
                        } while ((maxIndex > 0 && max <= (candidateMax = vector.dot$org_dyn4j_geometry_Vector2(this.vertices[maxIndex - 1]))));
                    }
                    return maxIndex;
                }
                /**
                 * Creates a {@link Mass} object using the geometric properties of
                 * this {@link Polygon} and the given density.
                 * <p>
                 * A {@link Polygon}'s centroid must be computed by the area weighted method since the
                 * average method can be bias to one side if there are more points on that one
                 * side than another.
                 * <p>
                 * Finding the area of a {@link Polygon} can be done by using the following
                 * summation:
                 * <p style="white-space: pre;"> 0.5 * &sum;(x<sub>i</sub> * y<sub>i + 1</sub> - x<sub>i + 1</sub> * y<sub>i</sub>)</p>
                 * Finding the area weighted centroid can be done by using the following
                 * summation:
                 * <p style="white-space: pre;"> 1 / (6 * A) * &sum;(p<sub>i</sub> + p<sub>i + 1</sub>) * (x<sub>i</sub> * y<sub>i + 1</sub> - x<sub>i + 1</sub> * y<sub>i</sub>)</p>
                 * Finding the inertia tensor can by done by using the following equation:
                 * <p style="white-space: pre;">
                 * &sum;(p<sub>i + 1</sub> x p<sub>i</sub>) * (p<sub>i</sub><sup>2</sup> + p<sub>i</sub> &middot; p<sub>i + 1</sub> + p<sub>i + 1</sub><sup>2</sup>)
                 * m / 6 * -------------------------------------------
                 * &sum;(p<sub>i + 1</sub> x p<sub>i</sub>)
                 * </p>
                 * Where the mass is computed by:
                 * <p style="white-space: pre;"> d * area</p>
                 * @param {number} density the density in kg/m<sup>2</sup>
                 * @return {org.dyn4j.geometry.Mass} {@link Mass} the {@link Mass} of this {@link Polygon}
                 */
                createMass(density) {
                    const center = new org.dyn4j.geometry.Vector2();
                    let area = 0.0;
                    let I = 0.0;
                    const n = this.vertices.length;
                    const ac = new org.dyn4j.geometry.Vector2();
                    for (let i = 0; i < n; i++) {
                        {
                            ac.add$org_dyn4j_geometry_Vector2(this.vertices[i]);
                        }
                        ;
                    }
                    ac.divide(n);
                    for (let i1 = n - 1, i2 = 0; i2 < n; i1 = i2++) {
                        {
                            let p1 = this.vertices[i1];
                            let p2 = this.vertices[i2];
                            p1 = p1.difference$org_dyn4j_geometry_Vector2(ac);
                            p2 = p2.difference$org_dyn4j_geometry_Vector2(ac);
                            const D = p1.cross$org_dyn4j_geometry_Vector2(p2);
                            const triangleArea = 0.5 * D;
                            area += triangleArea;
                            center.x += (p1.x + p2.x) * org.dyn4j.geometry.Geometry.INV_3 * triangleArea;
                            center.y += (p1.y + p2.y) * org.dyn4j.geometry.Geometry.INV_3 * triangleArea;
                            I += triangleArea * (p2.dot$org_dyn4j_geometry_Vector2(p2) + p2.dot$org_dyn4j_geometry_Vector2(p1) + p1.dot$org_dyn4j_geometry_Vector2(p1));
                        }
                        ;
                    }
                    const m = density * area;
                    center.divide(area);
                    const c = center.sum$org_dyn4j_geometry_Vector2(ac);
                    I *= (density / 6.0);
                    I -= m * center.getMagnitudeSquared();
                    return new org.dyn4j.geometry.Mass(c, m, I);
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    const p = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                    let minX = p.x;
                    let maxX = p.x;
                    let minY = p.y;
                    let maxY = p.y;
                    const size = this.vertices.length;
                    for (let i = 1; i < size; i++) {
                        {
                            const px = transform.getTransformedX(this.vertices[i]);
                            const py = transform.getTransformedY(this.vertices[i]);
                            if (px < minX) {
                                minX = px;
                            }
                            else if (px > maxX) {
                                maxX = px;
                            }
                            if (py < minY) {
                                minY = py;
                            }
                            else if (py > maxY) {
                                maxY = py;
                            }
                        }
                        ;
                    }
                    return new org.dyn4j.geometry.AABB(minX, minY, maxX, maxY);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.AABB}
                 */
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            geometry.Polygon = Polygon;
            Polygon["__class"] = "org.dyn4j.geometry.Polygon";
            Polygon["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Wound", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Minimal constructor.
             * <p>
             * This creates an axis-aligned Parabola fitting inside a rectangle, with vertex at origin
             * of the given width and height.
             * @param {number} width the width
             * @param {number} height the height of the half
             * @throws IllegalArgumentException if either the width or height is less than or equal to zero
             * @class
             * @extends org.dyn4j.geometry.AbstractShape
             * @author Mahesh Kurmi
             */
            class Parabola extends org.dyn4j.geometry.AbstractShape {
                constructor(width, height) {
                    super(new org.dyn4j.geometry.Vector2(3.0 * width / 5, 0), 4 * width * width / 25 + height * height);
                    if (this.a === undefined) {
                        this.a = 0;
                    }
                    if (this.h === undefined) {
                        this.h = 0;
                    }
                    if (this.b === undefined) {
                        this.b = 0;
                    }
                    if (this.localXAxis === undefined) {
                        this.localXAxis = null;
                    }
                    if (this.vertex === undefined) {
                        this.vertex = null;
                    }
                    if (this.vertices === undefined) {
                        this.vertices = null;
                    }
                    if (width <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.parabola.invalidWidth"));
                    if (height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.parabola.invalidHeight"));
                    this.b = width;
                    this.h = height / 2.0;
                    this.a = this.h * this.h / (4 * this.b);
                    this.vertex = new org.dyn4j.geometry.Vector2();
                    this.localXAxis = new org.dyn4j.geometry.Vector2(1.0, 0.0);
                    this.vertices = [new org.dyn4j.geometry.Vector2(this.b, -this.h), new org.dyn4j.geometry.Vector2(this.b, this.h)];
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Parabola[").append(super.toString()).append("|b=").append(this.b).append("|h=").append(this.h).append("|UserData=").append(this.userData).append("]");
                    return sb.toString();
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2[]} foci
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getAxes(foci, transform) {
                    throw new java.lang.UnsupportedOperationException(org.dyn4j.resources.Messages.getString("geometry.halfEllipse.satNotSupported"));
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getFoci(transform) {
                    throw new java.lang.UnsupportedOperationException(org.dyn4j.resources.Messages.getString("geometry.halfEllipse.satNotSupported"));
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} n
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getFarthestPoint(n, transform) {
                    const localAxis = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(n);
                    const r = this.getRotation();
                    localAxis.rotate$double(-r);
                    let p = null;
                    if (localAxis.y <= 0 && localAxis.x >= 0) {
                        return transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                    }
                    else if (localAxis.y >= 0 && localAxis.x >= 0) {
                        return transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[1]);
                    }
                    else if (localAxis.y >= 0 && localAxis.x <= 0) {
                        let t;
                        if (localAxis.x === 0)
                            t = javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                        else
                            t = -localAxis.y / localAxis.x;
                        if (t >= this.h / (2 * this.a)) {
                            return transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[1]);
                        }
                        p = new org.dyn4j.geometry.Vector2(this.a * t * t, 2 * this.a * t);
                    }
                    else {
                        let t;
                        if (localAxis.x === 0)
                            t = javaemul.internal.DoubleHelper.NEGATIVE_INFINITY;
                        else
                            t = -localAxis.y / localAxis.x;
                        if (t <= -this.h / (2 * this.a)) {
                            return transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                        }
                        p = new org.dyn4j.geometry.Vector2(this.a * t * t, 2 * this.a * t);
                    }
                    p.rotate$double(r);
                    p.add$org_dyn4j_geometry_Vector2(this.vertex);
                    transform.transform(p);
                    return p;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} n
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Feature}
                 */
                getFarthestFeature(n, transform) {
                    const localAxis = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(n);
                    if (Math.abs(localAxis.getAngleBetween$org_dyn4j_geometry_Vector2(this.localXAxis)) > 1.57) {
                        const point = this.getFarthestPoint(n, transform);
                        return new org.dyn4j.geometry.PointFeature(point);
                    }
                    else {
                        return org.dyn4j.geometry.Segment.getFarthestFeature(this.vertices[0], this.vertices[1], n, transform);
                    }
                }
                project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(n, transform) {
                    const p1 = this.getFarthestPoint(n, transform);
                    const p2 = this.getFarthestPoint(n.getNegative(), transform);
                    const d1 = p1.dot$org_dyn4j_geometry_Vector2(n);
                    const d2 = p2.dot$org_dyn4j_geometry_Vector2(n);
                    return new org.dyn4j.geometry.Interval(d2, d1);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} n
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Interval}
                 */
                project(n, transform) {
                    if (((n != null && n instanceof org.dyn4j.geometry.Vector2) || n === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(n, transform);
                    }
                    else if (((n != null && n instanceof org.dyn4j.geometry.Vector2) || n === null) && transform === undefined) {
                        return this.project$org_dyn4j_geometry_Vector2(n);
                    }
                    else
                        throw new Error('invalid overload');
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    const x = this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(org.dyn4j.geometry.Vector2.X_AXIS_$LI$(), transform);
                    const y = this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(org.dyn4j.geometry.Vector2.Y_AXIS_$LI$(), transform);
                    return new org.dyn4j.geometry.AABB(x.getMin(), y.getMin(), x.getMax(), y.getMax());
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.AABB}
                 */
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} density
                 * @return {org.dyn4j.geometry.Mass}
                 */
                createMass(density) {
                    const area = (4 / 3.0) * this.b * this.h;
                    const m = area * density;
                    const I = m * this.b * this.h * (7 * this.h * this.h + 15 * this.b * this.b) * Parabola.INERTIA_CONSTANT;
                    return new org.dyn4j.geometry.Mass(this.center, m, I);
                }
                getRadius$org_dyn4j_geometry_Vector2(center) {
                    return this.radius + center.distance$org_dyn4j_geometry_Vector2(this.center);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} center
                 * @return {number}
                 */
                getRadius(center) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        return this.getRadius$org_dyn4j_geometry_Vector2(center);
                    }
                    else if (center === undefined) {
                        return this.getRadius$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    const localPoint = transform.getInverseTransformed$org_dyn4j_geometry_Vector2(point);
                    const r = this.getRotation();
                    localPoint.rotate$double$double$double(-r, this.vertex.x, this.vertex.y);
                    const x = (localPoint.x - this.vertex.x);
                    const y = (localPoint.y - this.vertex.y);
                    if (x < 0 || x > this.b)
                        return false;
                    if (y < -this.h || y > this.h)
                        return false;
                    const y2 = y * y;
                    const value = y2 - 4 * this.a * x;
                    if (value <= 0.0) {
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} point
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {boolean}
                 */
                contains(point, transform) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        super.rotate(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$double$double$double(theta, x, y) {
                    super.rotate$double$double$double(theta, x, y);
                    this.localXAxis.rotate$double(theta);
                    for (let i = 0; i < this.vertices.length; i++) {
                        {
                            this.vertices[i].rotate$double$double$double(theta, x, y);
                        }
                        ;
                    }
                    this.vertex.rotate$double$double$double(theta, x, y);
                }
                translate$double$double(x, y) {
                    super.translate$double$double(x, y);
                    for (let i = 0; i < this.vertices.length; i++) {
                        {
                            this.vertices[i].add$double$double(x, y);
                        }
                        ;
                    }
                    this.vertex.add$double$double(x, y);
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the rotation about the local center in radians.
                 * @return {number} double the rotation in radians
                 */
                getRotation() {
                    return org.dyn4j.geometry.Vector2.X_AXIS_$LI$().getAngleBetween$org_dyn4j_geometry_Vector2(this.localXAxis);
                }
                /**
                 * Returns the focal distance a {y^2-4*a*x=0}.
                 * @return {number} double
                 */
                getFocalDistance() {
                    return this.a;
                }
                /**
                 * Returns the width.
                 * @return {number} double
                 */
                getWidth() {
                    return this.b;
                }
                /**
                 * Returns the height.
                 * @return {number} double
                 */
                getHeight() {
                    return 2 * this.h;
                }
                /**
                 * Returns the half height.
                 * @return {number} double
                 */
                getHalfHeight() {
                    return this.h;
                }
                /**
                 * Returns the center of the Parabola.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getVertex() {
                    return this.vertex;
                }
            }
            /**
             * The half ellipse inertia constant. See http://www.efunda.com/math/areas/ellipticalhalf.cfm
             */
            Parabola.INERTIA_CONSTANT = 2 / 105.0;
            geometry.Parabola = Parabola;
            Parabola["__class"] = "org.dyn4j.geometry.Parabola";
            Parabola["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * <p>
             * Creates a new segment using the given points.  The center will be the
             * average of the points.
             * <p>
             * A segment's points cannot be null or the same point.
             * @param {org.dyn4j.geometry.Vector2} point1 the first point
             * @param {org.dyn4j.geometry.Vector2} point2 the second point
             * @throws NullPointerException if point1 or point2 is null
             * @throws IllegalArgumentException if point1 == point2
             * @class
             * @extends org.dyn4j.geometry.AbstractShape
             * @author William Bittle
             */
            class Segment extends org.dyn4j.geometry.AbstractShape {
                constructor(valid, vertices, segment, length) {
                    if (((typeof valid === 'boolean') || valid === null) && ((vertices != null && vertices instanceof Array && (vertices.length == 0 || vertices[0] == null || (vertices[0] != null && vertices[0] instanceof org.dyn4j.geometry.Vector2))) || vertices === null) && ((segment != null && segment instanceof org.dyn4j.geometry.Vector2) || segment === null) && ((typeof length === 'number') || length === null)) {
                        let __args = arguments;
                        super(org.dyn4j.geometry.Geometry.getAverageCenter$org_dyn4j_geometry_Vector2_A.apply(null, vertices), length * 0.5);
                        if (this.vertices === undefined) {
                            this.vertices = null;
                        }
                        if (this.normals === undefined) {
                            this.normals = null;
                        }
                        if (this.length === undefined) {
                            this.length = 0;
                        }
                        this.vertices = vertices;
                        this.normals = [null, null];
                        this.normals[0] = segment.copy();
                        this.normals[0].normalize();
                        this.normals[1] = segment.right();
                        this.normals[1].normalize();
                        this.length = length;
                    }
                    else if (((valid != null && valid instanceof org.dyn4j.geometry.Vector2) || valid === null) && ((vertices != null && vertices instanceof org.dyn4j.geometry.Vector2) || vertices === null) && segment === undefined && length === undefined) {
                        let __args = arguments;
                        let point1 = __args[0];
                        let point2 = __args[1];
                        {
                            let __args = arguments;
                            let valid = Segment.validate(point1, point2);
                            let vertices = [point1, point2];
                            let segment = point1.to$org_dyn4j_geometry_Vector2(point2);
                            let length = point1.distance$org_dyn4j_geometry_Vector2(point2);
                            super(org.dyn4j.geometry.Geometry.getAverageCenter$org_dyn4j_geometry_Vector2_A.apply(null, vertices), length * 0.5);
                            if (this.vertices === undefined) {
                                this.vertices = null;
                            }
                            if (this.normals === undefined) {
                                this.normals = null;
                            }
                            if (this.length === undefined) {
                                this.length = 0;
                            }
                            this.vertices = vertices;
                            this.normals = [null, null];
                            this.normals[0] = segment.copy();
                            this.normals[0].normalize();
                            this.normals[1] = segment.right();
                            this.normals[1].normalize();
                            this.length = length;
                        }
                        if (this.vertices === undefined) {
                            this.vertices = null;
                        }
                        if (this.normals === undefined) {
                            this.normals = null;
                        }
                        if (this.length === undefined) {
                            this.length = 0;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Validates the constructor input returning true if valid or throwing an exception if invalid.
                 * @param {org.dyn4j.geometry.Vector2} point1 the first point
                 * @param {org.dyn4j.geometry.Vector2} point2 the second point
                 * @return {boolean} boolean true
                 * @throws NullPointerException if point1 or point2 is null
                 * @throws IllegalArgumentException if point1 == point2
                 * @private
                 */
                /*private*/ static validate(point1, point2) {
                    if (point1 == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.segment.nullPoint1"));
                    if (point2 == null)
                        throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("geometry.segment.nullPoint2"));
                    if (point1.equals$org_dyn4j_geometry_Vector2(point2)) {
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.segment.samePoint"));
                    }
                    return true;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Segment[").append(super.toString()).append("|Length=").append(this.length).append("]");
                    return sb.toString();
                }
                /**
                 *
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getVertices() {
                    return this.vertices;
                }
                /**
                 *
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getNormals() {
                    return this.normals;
                }
                /**
                 *
                 * @return {*}
                 */
                getVertexIterator() {
                    return new org.dyn4j.geometry.WoundIterator(this.vertices);
                }
                /**
                 *
                 * @return {*}
                 */
                getNormalIterator() {
                    return new org.dyn4j.geometry.WoundIterator(this.normals);
                }
                getRadius$org_dyn4j_geometry_Vector2(center) {
                    return org.dyn4j.geometry.Geometry.getRotationRadius$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2_A.apply(null, [center].concat(this.vertices));
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} center
                 * @return {number}
                 */
                getRadius(center) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        return this.getRadius$org_dyn4j_geometry_Vector2(center);
                    }
                    else if (center === undefined) {
                        return this.getRadius$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns point1 in local coordinates.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getPoint1() {
                    return this.vertices[0];
                }
                /**
                 * Returns point2 in local coordinates.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getPoint2() {
                    return this.vertices[1];
                }
                /**
                 * Returns the length of the line {@link Segment}.
                 * @return {number} double
                 */
                getLength() {
                    return this.length;
                }
                /**
                 * Determines where the point is relative to the given line.
                 * <p style="white-space: pre;"> Set L = linePoint2 - linePoint1
                 * Set P = point - linePoint1
                 * location = L.cross(P)</p>
                 * Returns 0 if the point lies on the line created from the line segment.<br>
                 * Assuming a right handed coordinate system:<br>
                 * Returns &lt; 0 if the point lies on the right side of the line<br>
                 * Returns &gt; 0 if the point lies on the left side of the line
                 * <p>
                 * Assumes all points are in world space.
                 * @param {org.dyn4j.geometry.Vector2} point the point
                 * @param {org.dyn4j.geometry.Vector2} linePoint1 the first point of the line
                 * @param {org.dyn4j.geometry.Vector2} linePoint2 the second point of the line
                 * @throws NullPointerException if point, linePoint1, or linePoint2 is null
                 * @return {number} double
                 */
                static getLocation(point, linePoint1, linePoint2) {
                    return (linePoint2.x - linePoint1.x) * (point.y - linePoint1.y) - (point.x - linePoint1.x) * (linePoint2.y - linePoint1.y);
                }
                /**
                 * Returns the point on the given line closest to the given point.
                 * <p>
                 * Project the point onto the line:
                 * <p style="white-space: pre;"> V<sub>line</sub> = P<sub>1</sub> - P<sub>0</sub>
                 * V<sub>point</sub> = P<sub>0</sub> - P
                 * P<sub>closest</sub> = V<sub>point</sub>.project(V<sub>line</sub>)</p>
                 * Assumes all points are in world space.
                 * @see Vector2#project(Vector2)
                 * @param {org.dyn4j.geometry.Vector2} point the point
                 * @param {org.dyn4j.geometry.Vector2} linePoint1 the first point of the line
                 * @param {org.dyn4j.geometry.Vector2} linePoint2 the second point of the line
                 * @throws NullPointerException if point, linePoint1, or linePoint2 is null
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                static getPointOnLineClosestToPoint(point, linePoint1, linePoint2) {
                    const p1ToP = point.difference$org_dyn4j_geometry_Vector2(linePoint1);
                    const line = linePoint2.difference$org_dyn4j_geometry_Vector2(linePoint1);
                    const ab2 = line.dot$org_dyn4j_geometry_Vector2(line);
                    if (ab2 <= org.dyn4j.Epsilon.E_$LI$())
                        return linePoint1.copy();
                    const ap_ab = p1ToP.dot$org_dyn4j_geometry_Vector2(line);
                    const t = ap_ab / ab2;
                    return line.multiply(t).add$org_dyn4j_geometry_Vector2(linePoint1);
                }
                /**
                 * Returns the point on the <b>line</b> that this {@link Segment}
                 * defines closest to the given point.
                 * <p>
                 * This method works in this {@link Segment}'s local space.
                 * @param {org.dyn4j.geometry.Vector2} point the local space point
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @throws NullPointerException if the given point is null
                 * @since 3.1.5
                 * @see #getPointOnLineClosestToPoint(Vector2, Vector2, Vector2)
                 */
                getPointOnLineClosestToPoint(point) {
                    return Segment.getPointOnLineClosestToPoint(point, this.vertices[0], this.vertices[1]);
                }
                /**
                 * Returns the point on the given line segment closest to the given point.
                 * <p>
                 * If the point closest to the given point is on the line created by the
                 * given line segment, but is not on the line segment then either of the segments
                 * end points will be returned.
                 * <p>
                 * Assumes all points are in world space.
                 * @see Segment#getPointOnLineClosestToPoint(Vector2, Vector2, Vector2)
                 * @param {org.dyn4j.geometry.Vector2} point the point
                 * @param {org.dyn4j.geometry.Vector2} linePoint1 the first point of the line
                 * @param {org.dyn4j.geometry.Vector2} linePoint2 the second point of the line
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @throws NullPointerException if point, linePoint1, or linePoint2 is null
                 */
                static getPointOnSegmentClosestToPoint(point, linePoint1, linePoint2) {
                    const p1ToP = point.difference$org_dyn4j_geometry_Vector2(linePoint1);
                    const line = linePoint2.difference$org_dyn4j_geometry_Vector2(linePoint1);
                    const ab2 = line.dot$org_dyn4j_geometry_Vector2(line);
                    const ap_ab = p1ToP.dot$org_dyn4j_geometry_Vector2(line);
                    if (ab2 <= org.dyn4j.Epsilon.E_$LI$())
                        return linePoint1.copy();
                    let t = ap_ab / ab2;
                    t = org.dyn4j.geometry.Interval.clamp(t, 0.0, 1.0);
                    return line.multiply(t).add$org_dyn4j_geometry_Vector2(linePoint1);
                }
                /**
                 * Returns the point on this {@link Segment} closest to the given point.
                 * <p>
                 * This method works in this {@link Segment}'s local space.
                 * @param {org.dyn4j.geometry.Vector2} point the local space point
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @throws NullPointerException if the given point is null
                 * @since 3.1.5
                 * @see #getPointOnSegmentClosestToPoint(Vector2, Vector2, Vector2)
                 */
                getPointOnSegmentClosestToPoint(point) {
                    return Segment.getPointOnSegmentClosestToPoint(point, this.vertices[0], this.vertices[1]);
                }
                /**
                 * Returns the intersection point of the two lines or null if they are parallel or coincident.
                 * <p>
                 * If we let:
                 * <p style="white-space: pre;"> A = A<sub>p2</sub> - A<sub>p1</sub>
                 * B = B<sub>p2</sub> - B<sub>p1</sub></p>
                 * we can create two parametric equations:
                 * <p style="white-space: pre;"> Q = A<sub>p1</sub> + t<sub>a</sub>A
                 * Q = B<sub>p1</sub> + t<sub>b</sub>B</p>
                 * Where Q is the intersection point:
                 * <p style="white-space: pre;"> A<sub>p1</sub> + t<sub>a</sub>A = B<sub>p1</sub> + t<sub>b</sub>B</p>
                 * We can solve for t<sub>b</sub> by applying the cross product with A on both sides:
                 * <p style="white-space: pre;"> (A<sub>p1</sub> + t<sub>a</sub>A) x A = (B<sub>p1</sub> + t<sub>b</sub>B) x A
                 * A<sub>p1</sub> x A = B<sub>p1</sub> x A + t<sub>b</sub>B x A
                 * (A<sub>p1</sub> - B<sub>p1</sub>) x A = t<sub>b</sub>B x A
                 * t<sub>b</sub> = ((A<sub>p1</sub> - B<sub>p1</sub>) x A) / (B x A)</p>
                 * If B x A == 0 then the lines are parallel.  If both the top and bottom are zero
                 * then the lines are coincident.
                 * <p>
                 * If the lines are parallel or coincident, null is returned.
                 * @param {org.dyn4j.geometry.Vector2} ap1 the first point of the first line
                 * @param {org.dyn4j.geometry.Vector2} ap2 the second point of the first line
                 * @param {org.dyn4j.geometry.Vector2} bp1 the first point of the second line
                 * @param {org.dyn4j.geometry.Vector2} bp2 the second point of the second line
                 * @return {org.dyn4j.geometry.Vector2} Vector2 the intersection point; null if the lines are parallel or coincident
                 * @see #getSegmentIntersection(Vector2, Vector2, Vector2, Vector2)
                 * @throws NullPointerException if ap1, ap2, bp1 or bp2 is null
                 * @since 3.1.1
                 */
                static getLineIntersection(ap1, ap2, bp1, bp2) {
                    const A = ap1.to$org_dyn4j_geometry_Vector2(ap2);
                    const B = bp1.to$org_dyn4j_geometry_Vector2(bp2);
                    const BxA = B.cross$org_dyn4j_geometry_Vector2(A);
                    if (Math.abs(BxA) <= org.dyn4j.Epsilon.E_$LI$()) {
                        return null;
                    }
                    const ambxA = ap1.difference$org_dyn4j_geometry_Vector2(bp1).cross$org_dyn4j_geometry_Vector2(A);
                    if (Math.abs(ambxA) <= org.dyn4j.Epsilon.E_$LI$()) {
                        return null;
                    }
                    const tb = ambxA / BxA;
                    return B.product(tb).add$org_dyn4j_geometry_Vector2(bp1);
                }
                /**
                 * Returns the line intersection of the given {@link Segment} and this {@link Segment}.
                 * <p>
                 * This method treats this segment and the given segment as defining <b>lines</b> rather than segments.
                 * <p>
                 * This method assumes that both this and the given segment are in the same space (either
                 * local or world space).
                 * <p>
                 * If the lines are parallel or coincident, null is returned.
                 * @param {org.dyn4j.geometry.Segment} segment the other segment
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @throws NullPointerException if the given segment is null
                 * @since 3.1.5
                 * @see #getLineIntersection(Vector2, Vector2, Vector2, Vector2)
                 */
                getLineIntersection(segment) {
                    return Segment.getLineIntersection(this.vertices[0], this.vertices[1], segment.vertices[0], segment.vertices[1]);
                }
                /**
                 * Returns the intersection point of the two line segments or null if they are parallel, coincident
                 * or don't intersect.
                 * <p>
                 * If we let:
                 * <p style="white-space: pre;"> A = A<sub>p2</sub> - A<sub>p1</sub>
                 * B = B<sub>p2</sub> - B<sub>p1</sub></p>
                 * we can create two parametric equations:
                 * <p style="white-space: pre;"> Q = A<sub>p1</sub> + t<sub>a</sub>A
                 * Q = B<sub>p1</sub> + t<sub>b</sub>B</p>
                 * Where Q is the intersection point:
                 * <p style="white-space: pre;"> A<sub>p1</sub> + t<sub>a</sub>A = B<sub>p1</sub> + t<sub>b</sub>B</p>
                 * We can solve for t<sub>b</sub> by applying the cross product with A on both sides:
                 * <p style="white-space: pre;"> (A<sub>p1</sub> + t<sub>a</sub>A) x A = (B<sub>p1</sub> + t<sub>b</sub>B) x A
                 * A<sub>p1</sub> x A = B<sub>p1</sub> x A + t<sub>b</sub>B x A
                 * (A<sub>p1</sub> - B<sub>p1</sub>) x A = t<sub>b</sub>B x A
                 * t<sub>b</sub> = ((A<sub>p1</sub> - B<sub>p1</sub>) x A) / (B x A)</p>
                 * If B x A == 0 then the segments are parallel.  If the top == 0 then they don't intersect.  If both the
                 * top and bottom are zero then the segments are coincident.
                 * <p>
                 * If t<sub>b</sub> or t<sub>a</sub> less than zero or greater than 1 then the segments do not intersect.
                 * <p>
                 * If the segments do not intersect, are parallel, or are coincident, null is returned.
                 * @param {org.dyn4j.geometry.Vector2} ap1 the first point of the first line segment
                 * @param {org.dyn4j.geometry.Vector2} ap2 the second point of the first line segment
                 * @param {org.dyn4j.geometry.Vector2} bp1 the first point of the second line segment
                 * @param {org.dyn4j.geometry.Vector2} bp2 the second point of the second line segment
                 * @return {org.dyn4j.geometry.Vector2} Vector2 the intersection point; null if the line segments don't intersect, are parallel, or are coincident
                 * @see #getLineIntersection(Vector2, Vector2, Vector2, Vector2)
                 * @throws NullPointerException if ap1, ap2, bp1, or bp2 is null
                 * @since 3.1.1
                 */
                static getSegmentIntersection(ap1, ap2, bp1, bp2) {
                    const A = ap1.to$org_dyn4j_geometry_Vector2(ap2);
                    const B = bp1.to$org_dyn4j_geometry_Vector2(bp2);
                    const BxA = B.cross$org_dyn4j_geometry_Vector2(A);
                    if (Math.abs(BxA) <= org.dyn4j.Epsilon.E_$LI$()) {
                        return null;
                    }
                    const ambxA = ap1.difference$org_dyn4j_geometry_Vector2(bp1).cross$org_dyn4j_geometry_Vector2(A);
                    if (Math.abs(ambxA) <= org.dyn4j.Epsilon.E_$LI$()) {
                        return null;
                    }
                    const tb = ambxA / BxA;
                    if (tb < 0.0 || tb > 1.0) {
                        return null;
                    }
                    const ip = B.product(tb).add$org_dyn4j_geometry_Vector2(bp1);
                    const ta = ip.difference$org_dyn4j_geometry_Vector2(ap1).dot$org_dyn4j_geometry_Vector2(A) / A.dot$org_dyn4j_geometry_Vector2(A);
                    if (ta < 0.0 || ta > 1.0) {
                        return null;
                    }
                    return ip;
                }
                /**
                 * Returns the intersection of the given {@link Segment} and this {@link Segment}.
                 * <p>
                 * This method assumes that both this and the given segment are in the same space (either
                 * local or world space).
                 * <p>
                 * If the segments do not intersect, are parallel, or are coincident, null is returned.
                 * @param {org.dyn4j.geometry.Segment} segment the other segment
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @throws NullPointerException if the given segment is null
                 * @since 3.1.5
                 * @see #getSegmentIntersection(Vector2, Vector2, Vector2, Vector2)
                 */
                getSegmentIntersection(segment) {
                    return Segment.getSegmentIntersection(this.vertices[0], this.vertices[1], segment.vertices[0], segment.vertices[1]);
                }
                /**
                 * Returns the farthest feature on the given segment.
                 * <p>
                 * This will always return the segment itself, but must return it with the correct winding
                 * and the correct maximum.
                 * @param {org.dyn4j.geometry.Vector2} v1 the first segment vertex
                 * @param {org.dyn4j.geometry.Vector2} v2 the second segment vertex
                 * @param {org.dyn4j.geometry.Vector2} vector the direction
                 * @param {org.dyn4j.geometry.Transform} transform the local to world space {@link Transform} of this {@link Convex} {@link Shape}
                 * @return {org.dyn4j.geometry.EdgeFeature} {@link EdgeFeature}
                 * @throws NullPointerException if v1, v2, vector, or transform is null
                 * @since 3.1.5
                 */
                static getFarthestFeature(v1, v2, vector, transform) {
                    let max = null;
                    const p1 = transform.getTransformed$org_dyn4j_geometry_Vector2(v1);
                    const p2 = transform.getTransformed$org_dyn4j_geometry_Vector2(v2);
                    const dot1 = vector.dot$org_dyn4j_geometry_Vector2(p1);
                    const dot2 = vector.dot$org_dyn4j_geometry_Vector2(p2);
                    let index = 0;
                    if (dot1 >= dot2) {
                        max = p1;
                        index = 0;
                    }
                    else {
                        max = p2;
                        index = 1;
                    }
                    const vp1 = new org.dyn4j.geometry.PointFeature(p1, 0);
                    const vp2 = new org.dyn4j.geometry.PointFeature(p2, 1);
                    const vm = new org.dyn4j.geometry.PointFeature(max, index);
                    if (p1.to$org_dyn4j_geometry_Vector2(p2).right().dot$org_dyn4j_geometry_Vector2(vector) > 0) {
                        return new org.dyn4j.geometry.EdgeFeature(vp2, vp1, vm, p2.to$org_dyn4j_geometry_Vector2(p1), 0);
                    }
                    else {
                        return new org.dyn4j.geometry.EdgeFeature(vp1, vp2, vm, p1.to$org_dyn4j_geometry_Vector2(p2), 0);
                    }
                }
                /**
                 * Returns the farthest point on the given segment.
                 * @param {org.dyn4j.geometry.Vector2} v1 the first point of the segment
                 * @param {org.dyn4j.geometry.Vector2} v2 the second point of the segment
                 * @param {org.dyn4j.geometry.Vector2} vector the direction
                 * @param {org.dyn4j.geometry.Transform} transform the local to world space {@link Transform} of this {@link Convex} {@link Shape}
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @throws NullPointerException if v1, v2, vector, or transform is null
                 * @since 3.1.5
                 */
                static getFarthestPoint(v1, v2, vector, transform) {
                    const p1 = transform.getTransformed$org_dyn4j_geometry_Vector2(v1);
                    const p2 = transform.getTransformed$org_dyn4j_geometry_Vector2(v2);
                    const dot1 = vector.dot$org_dyn4j_geometry_Vector2(p1);
                    const dot2 = vector.dot$org_dyn4j_geometry_Vector2(p2);
                    if (dot1 >= dot2) {
                        return p1;
                    }
                    else {
                        return p2;
                    }
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2[]} foci
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getAxes(foci, transform) {
                    const size = foci != null ? foci.length : 0;
                    const axes = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(2 + size);
                    let n = 0;
                    const p1 = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                    const p2 = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[1]);
                    axes[n++] = transform.getTransformedR$org_dyn4j_geometry_Vector2(this.normals[1]);
                    axes[n++] = transform.getTransformedR$org_dyn4j_geometry_Vector2(this.normals[0]);
                    let axis;
                    for (let i = 0; i < size; i++) {
                        {
                            const f = foci[i];
                            if (p1.distanceSquared$org_dyn4j_geometry_Vector2(f) < p2.distanceSquared$org_dyn4j_geometry_Vector2(f)) {
                                axis = p1.to$org_dyn4j_geometry_Vector2(f);
                            }
                            else {
                                axis = p2.to$org_dyn4j_geometry_Vector2(f);
                            }
                            axis.normalize();
                            axes[n++] = axis;
                        }
                        ;
                    }
                    return axes;
                }
                /**
                 * {@inheritDoc}
                 * <p>
                 * Not applicable to this shape.  Always returns null.
                 * @return {org.dyn4j.geometry.Vector2[]} null
                 * @param {org.dyn4j.geometry.Transform} transform
                 */
                getFoci(transform) {
                    return null;
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    const p = transform.getInverseTransformed$org_dyn4j_geometry_Vector2(point);
                    const p1 = this.vertices[0];
                    const p2 = this.vertices[1];
                    const value = Segment.getLocation(p, p1, p2);
                    if (Math.abs(value) <= org.dyn4j.Epsilon.E_$LI$()) {
                        const distSqrd = p1.distanceSquared$org_dyn4j_geometry_Vector2(p2);
                        if (p.distanceSquared$org_dyn4j_geometry_Vector2(p1) <= distSqrd && p.distanceSquared$org_dyn4j_geometry_Vector2(p2) <= distSqrd) {
                            return true;
                        }
                        return false;
                    }
                    return false;
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform$double(point, transform, radius) {
                    if (radius <= 0) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else {
                        const p = transform.getInverseTransformed$org_dyn4j_geometry_Vector2(point);
                        if (this.vertices[0].distanceSquared$org_dyn4j_geometry_Vector2(p) <= radius * radius) {
                            return true;
                        }
                        else if (this.vertices[1].distanceSquared$org_dyn4j_geometry_Vector2(p) <= radius * radius) {
                            return true;
                        }
                        else {
                            const l = this.vertices[0].to$org_dyn4j_geometry_Vector2(this.vertices[1]);
                            const p1 = this.vertices[0].to$org_dyn4j_geometry_Vector2(p);
                            const p2 = this.vertices[1].to$org_dyn4j_geometry_Vector2(p);
                            if (l.dot$org_dyn4j_geometry_Vector2(p1) > 0 && -l.dot$org_dyn4j_geometry_Vector2(p2) > 0) {
                                const dist = p1.project(l.getRightHandOrthogonalVector()).getMagnitudeSquared();
                                if (dist <= radius * radius) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                }
                /**
                 * Returns true if the given point is inside this {@link Shape}.
                 * <p>
                 * If the given point lies on an edge the point is considered
                 * to be inside the {@link Shape}.
                 * <p>
                 * The given point is assumed to be in world space.
                 * <p>
                 * If the radius is greater than zero then the point is tested to be
                 * within the shape expanded radially by the radius.
                 * @param {org.dyn4j.geometry.Vector2} point world space point
                 * @param {org.dyn4j.geometry.Transform} transform {@link Transform} for this {@link Shape}
                 * @param {number} radius the expansion radius; in the range [0, &infin;]
                 * @return {boolean} boolean
                 */
                contains(point, transform, radius) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && ((typeof radius === 'number') || radius === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform$double(point, transform, radius);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null) && radius === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined && radius === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform) {
                    let v = 0.0;
                    const p1 = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                    const p2 = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[1]);
                    let min = vector.dot$org_dyn4j_geometry_Vector2(p1);
                    let max = min;
                    v = vector.dot$org_dyn4j_geometry_Vector2(p2);
                    if (v < min) {
                        min = v;
                    }
                    else if (v > max) {
                        max = v;
                    }
                    return new org.dyn4j.geometry.Interval(min, max);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Interval}
                 */
                project(vector, transform) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && transform === undefined) {
                        return this.project$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getFarthestPoint(vector, transform) {
                    return Segment.getFarthestPoint(this.vertices[0], this.vertices[1], vector, transform);
                }
                /**
                 * Returns the feature farthest in the direction of n.
                 * <p>
                 * For a {@link Segment} it's always the {@link Segment} itself.
                 * @param {org.dyn4j.geometry.Vector2} vector the direction
                 * @param {org.dyn4j.geometry.Transform} transform the local to world space {@link Transform} of this {@link Convex} {@link Shape}
                 * @return {org.dyn4j.geometry.EdgeFeature} {@link EdgeFeature}
                 */
                getFarthestFeature(vector, transform) {
                    return Segment.getFarthestFeature(this.vertices[0], this.vertices[1], vector, transform);
                }
                rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    super.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    this.vertices[0].rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    this.vertices[1].rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    this.normals[0].rotate$org_dyn4j_geometry_Rotation(rotation);
                    this.normals[1].rotate$org_dyn4j_geometry_Rotation(rotation);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$double$double(x, y) {
                    super.translate$double$double(x, y);
                    this.vertices[0].add$double$double(x, y);
                    this.vertices[1].add$double$double(x, y);
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Creates a {@link Mass} object using the geometric properties of
                 * this {@link Segment} and the given density.
                 * <p style="white-space: pre;"> m = d * length
                 * I = l<sup>2</sup> * m / 12</p>
                 * @param {number} density the density in kg/m<sup>2</sup>
                 * @return {org.dyn4j.geometry.Mass} {@link Mass} the {@link Mass} of this {@link Segment}
                 */
                createMass(density) {
                    const length = this.length;
                    const mass = density * length;
                    const inertia = length * length * mass / 12.0;
                    return new org.dyn4j.geometry.Mass(this.center, mass, inertia);
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    const p0 = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                    const p1 = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[1]);
                    return org.dyn4j.geometry.AABB.createAABBFromPoints$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2(p0, p1);
                }
                /**
                 * {@inheritDoc}
                 * <p>
                 * Be aware that this method could produce an infinitely thin
                 * AABB if this segment is aligned to either the x or y-axis.
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.AABB}
                 */
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            geometry.Segment = Segment;
            Segment["__class"] = "org.dyn4j.geometry.Segment";
            Segment["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Wound", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Minimal constructor.
             * <p>
             * This creates an axis-aligned ellipse fitting inside a rectangle of the given width and
             * height centered at the origin.
             * @param {number} width the width
             * @param {number} height the height
             * @throws IllegalArgumentException if either the width or height is less than or equal to zero
             * @class
             * @extends org.dyn4j.geometry.AbstractShape
             * @author William Bittle
             */
            class Ellipse extends org.dyn4j.geometry.AbstractShape {
                constructor(valid, width, height) {
                    if (((typeof valid === 'boolean') || valid === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                        let __args = arguments;
                        super(Math.max(width, height) * 0.5);
                        if (this.halfWidth === undefined) {
                            this.halfWidth = 0;
                        }
                        if (this.halfHeight === undefined) {
                            this.halfHeight = 0;
                        }
                        if (this.rotation === undefined) {
                            this.rotation = null;
                        }
                        this.halfWidth = width * 0.5;
                        this.halfHeight = height * 0.5;
                        this.rotation = new org.dyn4j.geometry.Rotation();
                    }
                    else if (((typeof valid === 'number') || valid === null) && ((typeof width === 'number') || width === null) && height === undefined) {
                        let __args = arguments;
                        let width = __args[0];
                        let height = __args[1];
                        {
                            let __args = arguments;
                            let valid = Ellipse.validate(__args[1], __args[2]);
                            super(Math.max(width, height) * 0.5);
                            if (this.halfWidth === undefined) {
                                this.halfWidth = 0;
                            }
                            if (this.halfHeight === undefined) {
                                this.halfHeight = 0;
                            }
                            if (this.rotation === undefined) {
                                this.rotation = null;
                            }
                            this.halfWidth = width * 0.5;
                            this.halfHeight = height * 0.5;
                            this.rotation = new org.dyn4j.geometry.Rotation();
                        }
                        if (this.halfWidth === undefined) {
                            this.halfWidth = 0;
                        }
                        if (this.halfHeight === undefined) {
                            this.halfHeight = 0;
                        }
                        if (this.rotation === undefined) {
                            this.rotation = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                static INV_GOLDEN_RATIO_$LI$() { if (Ellipse.INV_GOLDEN_RATIO == null) {
                    Ellipse.INV_GOLDEN_RATIO = 1.0 / ((Math.sqrt(5.0) + 1.0) * 0.5);
                } return Ellipse.INV_GOLDEN_RATIO; }
                /**
                 * Validates the constructor input returning true if valid or throwing an exception if invalid.
                 * @param {number} width the bounding rectangle width
                 * @param {number} height the bounding rectangle height
                 * @return {boolean} boolean true
                 * @throws IllegalArgumentException if either the width or height is less than or equal to zero
                 * @private
                 */
                /*private*/ static validate(width, height) {
                    if (width <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.ellipse.invalidWidth"));
                    if (height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.ellipse.invalidHeight"));
                    return true;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Ellipse[").append(super.toString()).append("|Width=").append(this.getWidth()).append("|Height=").append(this.getHeight()).append("]");
                    return sb.toString();
                }
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method is not supported by this shape.
                 * @throws UnsupportedOperationException when called
                 * @param {org.dyn4j.geometry.Vector2[]} foci
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getAxes(foci, transform) {
                    throw new java.lang.UnsupportedOperationException(org.dyn4j.resources.Messages.getString("geometry.ellipse.satNotSupported"));
                }
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method is not supported by this shape.
                 * @throws UnsupportedOperationException when called
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getFoci(transform) {
                    throw new java.lang.UnsupportedOperationException(org.dyn4j.resources.Messages.getString("geometry.ellipse.satNotSupported"));
                }
                getFarthestPoint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform) {
                    let localAxis = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(vector);
                    localAxis = this.getFarthestPoint$org_dyn4j_geometry_Vector2(localAxis);
                    transform.transform(localAxis);
                    return localAxis;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getFarthestPoint(vector, transform) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.getFarthestPoint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && transform === undefined) {
                        return this.getFarthestPoint$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ getFarthestPoint$org_dyn4j_geometry_Vector2(localAxis) {
                    if (this.rotation.isIdentity$()) {
                        this.getFarthestPointOnAlignedEllipse(localAxis);
                    }
                    else {
                        localAxis.inverseRotate$org_dyn4j_geometry_Rotation(this.rotation);
                        this.getFarthestPointOnAlignedEllipse(localAxis);
                        localAxis.rotate$org_dyn4j_geometry_Rotation(this.rotation);
                    }
                    localAxis.add$org_dyn4j_geometry_Vector2(this.center);
                    return localAxis;
                }
                /**
                 * Returns the farthest point along the given local space axis assuming the
                 * ellipse and the given axis are aligned.
                 * <p>
                 * Typically this means that the ellipse is axis-aligned, but it could also
                 * mean that the ellipse is not axis-aligned, but the given local space axis
                 * has been rotated to match the alignment of the ellipse.
                 * @since 3.4.0
                 * @param {org.dyn4j.geometry.Vector2} localAxis
                 * @private
                 */
                /*private*/ getFarthestPointOnAlignedEllipse(localAxis) {
                    localAxis.x *= this.halfWidth;
                    localAxis.y *= this.halfHeight;
                    localAxis.normalize();
                    localAxis.x *= this.halfWidth;
                    localAxis.y *= this.halfHeight;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Feature}
                 */
                getFarthestFeature(vector, transform) {
                    const farthest = this.getFarthestPoint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    return new org.dyn4j.geometry.PointFeature(farthest);
                }
                project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform) {
                    const p1 = this.getFarthestPoint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    const center = transform.getTransformed$org_dyn4j_geometry_Vector2(this.center);
                    const c = center.dot$org_dyn4j_geometry_Vector2(vector);
                    const d = p1.dot$org_dyn4j_geometry_Vector2(vector);
                    return new org.dyn4j.geometry.Interval(2 * c - d, d);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Interval}
                 */
                project(vector, transform) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && transform === undefined) {
                        return this.project$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    const u = this.rotation.toVector$();
                    transform.transformR(u);
                    const x2 = u.x * u.x;
                    const y2 = u.y * u.y;
                    const hw2 = this.halfWidth * this.halfWidth;
                    const hh2 = this.halfHeight * this.halfHeight;
                    const aabbHalfWidth = Math.sqrt(x2 * hw2 + y2 * hh2);
                    const aabbHalfHeight = Math.sqrt(y2 * hw2 + x2 * hh2);
                    const cx = transform.getTransformedX(this.center);
                    const cy = transform.getTransformedY(this.center);
                    const minx = cx - aabbHalfWidth;
                    const miny = cy - aabbHalfHeight;
                    const maxx = cx + aabbHalfWidth;
                    const maxy = cy + aabbHalfHeight;
                    return new org.dyn4j.geometry.AABB(minx, miny, maxx, maxy);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.AABB}
                 */
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} density
                 * @return {org.dyn4j.geometry.Mass}
                 */
                createMass(density) {
                    const area = Math.PI * this.halfWidth * this.halfHeight;
                    const m = area * density;
                    const I = m * (this.halfWidth * this.halfWidth + this.halfHeight * this.halfHeight) / 4.0;
                    return new org.dyn4j.geometry.Mass(this.center, m, I);
                }
                getRadius$org_dyn4j_geometry_Vector2(center) {
                    const p = center.difference$org_dyn4j_geometry_Vector2(this.center).inverseRotate$org_dyn4j_geometry_Rotation(this.rotation);
                    const fp = Ellipse.getFarthestPointOnEllipse(this.halfWidth, this.halfHeight, p);
                    return p.distance$org_dyn4j_geometry_Vector2(fp);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} center
                 * @return {number}
                 */
                getRadius(center) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        return this.getRadius$org_dyn4j_geometry_Vector2(center);
                    }
                    else if (center === undefined) {
                        return this.getRadius$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the point on this ellipse farthest from the given point.
                 * <p>
                 * This method assumes that this ellipse is centered on the origin and
                 * has it's semi-major axis aligned with the x-axis and its semi-minor
                 * axis aligned with the y-axis.
                 * <p>
                 * This method performs a Golden Section Search to find the point of
                 * maximum distance from the given point.
                 * @param {number} a the half width of the ellipse
                 * @param {number} b the half height of the ellipse
                 * @param {org.dyn4j.geometry.Vector2} point the query point
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @since 3.4.0
                 */
                static getFarthestPointOnEllipse(a, b, point) {
                    let px = point.x;
                    let py = point.y;
                    let flipped = false;
                    if (a < b) {
                        let temp = a;
                        a = b;
                        b = temp;
                        temp = px;
                        px = -py;
                        py = temp;
                        flipped = true;
                    }
                    let quadrant = 3;
                    if (px >= 0 && py >= 0) {
                        quadrant = 1;
                        px = -px;
                        py = -py;
                    }
                    else if (px >= 0 && py <= 0) {
                        quadrant = 4;
                        px = -px;
                    }
                    else if (px <= 0 && py >= 0) {
                        quadrant = 2;
                        py = -py;
                    }
                    let p = null;
                    if (py === 0.0) {
                        p = new org.dyn4j.geometry.Vector2(px < 0 ? a : -a, 0);
                    }
                    else {
                        p = Ellipse.getFarthestPointOnBoundedEllipse(0, a, a, b, new org.dyn4j.geometry.Vector2(px, py));
                    }
                    if (quadrant === 1) {
                        p.x *= -1;
                        p.y *= -1;
                    }
                    else if (quadrant === 2) {
                        p.y *= -1;
                    }
                    else if (quadrant === 4) {
                        p.x *= -1;
                    }
                    if (flipped) {
                        const temp = p.x;
                        p.x = p.y;
                        p.y = -temp;
                    }
                    return p;
                }
                /**
                 * Performs a golden section search of the ellipse bounded between the interval [xmin, xmax] for the farthest
                 * point from the given point.
                 * <p>
                 * This method assumes that this ellipse is centered on the origin and
                 * has it's semi-major axis aligned with the x-axis and its semi-minor
                 * axis aligned with the y-axis.
                 * @param {number} xmin the minimum x value
                 * @param {number} xmax the maximum x value
                 * @param {number} a the half width of the ellipse
                 * @param {number} b the half height of the ellipse
                 * @param {org.dyn4j.geometry.Vector2} point the query point
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 * @since 3.4.0
                 */
                static getFarthestPointOnBoundedEllipse(xmin, xmax, a, b, point) {
                    const px = point.x;
                    const py = point.y;
                    let x0 = xmin;
                    let x1 = xmax;
                    const q = new org.dyn4j.geometry.Vector2(px, py);
                    const p = new org.dyn4j.geometry.Vector2();
                    const aa = a * a;
                    const ba = b / a;
                    let x2 = x1 - (x1 - x0) * Ellipse.INV_GOLDEN_RATIO_$LI$();
                    let x3 = x0 + (x1 - x0) * Ellipse.INV_GOLDEN_RATIO_$LI$();
                    let fx2 = Ellipse.getSquaredDistance(aa, ba, x2, q, p);
                    let fx3 = Ellipse.getSquaredDistance(aa, ba, x3, q, p);
                    for (let i = 0; i < Ellipse.FARTHEST_POINT_MAX_ITERATIONS; i++) {
                        {
                            if (fx2 < fx3) {
                                if (Math.abs(x1 - x2) <= Ellipse.FARTHEST_POINT_EPSILON) {
                                    break;
                                }
                                x0 = x2;
                                x2 = x3;
                                fx2 = fx3;
                                x3 = x0 + (x1 - x0) * Ellipse.INV_GOLDEN_RATIO_$LI$();
                                fx3 = Ellipse.getSquaredDistance(aa, ba, x3, q, p);
                            }
                            else {
                                if (Math.abs(x3 - x0) <= Ellipse.FARTHEST_POINT_EPSILON) {
                                    break;
                                }
                                x1 = x3;
                                x3 = x2;
                                fx3 = fx2;
                                x2 = x1 - (x1 - x0) * Ellipse.INV_GOLDEN_RATIO_$LI$();
                                fx2 = Ellipse.getSquaredDistance(aa, ba, x2, q, p);
                            }
                        }
                        ;
                    }
                    return p;
                }
                /**
                 * Returns the distance from the ellipse at the given x to the given point q.
                 * @param {number} a2 the ellipse semi-major axis squared (a * a)
                 * @param {number} ba the ellipse semi-minor axis divided by the semi-major axis (b / a)
                 * @param {number} x the x of the point on the ellipse
                 * @param {org.dyn4j.geometry.Vector2} q the query point
                 * @param {org.dyn4j.geometry.Vector2} p output; the point on the ellipse
                 * @return {number} double
                 * @since 3.4.0
                 * @private
                 */
                /*private*/ static getSquaredDistance(a2, ba, x, q, p) {
                    let a2x2 = a2 - (x * x);
                    if (a2x2 < 0) {
                        a2x2 = 0;
                    }
                    const sa2x2 = Math.sqrt(a2x2);
                    const y = ba * sa2x2;
                    const xx = (q.x - x);
                    const yy = (q.y - y);
                    const d2 = xx * xx + yy * yy;
                    p.x = x;
                    p.y = y;
                    return d2;
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    const localPoint = transform.getInverseTransformed$org_dyn4j_geometry_Vector2(point);
                    localPoint.inverseRotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(this.rotation, this.center);
                    const x = (localPoint.x - this.center.x);
                    const y = (localPoint.y - this.center.y);
                    const x2 = x * x;
                    const y2 = y * y;
                    const a2 = this.halfWidth * this.halfWidth;
                    const b2 = this.halfHeight * this.halfHeight;
                    const value = x2 / a2 + y2 / b2;
                    return value <= 1.0;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} point
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {boolean}
                 */
                contains(point, transform) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    super.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    this.rotation.rotate$org_dyn4j_geometry_Rotation(rotation);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the rotation about the local center in radians.
                 * @return {number} double the rotation in radians
                 */
                getRotationAngle() {
                    return this.rotation.toRadians();
                }
                /**
                 * @return {org.dyn4j.geometry.Rotation} the {@link Rotation} object that represents the local rotation
                 */
                getRotation() {
                    return this.rotation.copy();
                }
                /**
                 * Returns the width.
                 * @return {number} double
                 */
                getWidth() {
                    return this.halfWidth * 2;
                }
                /**
                 * Returns the height.
                 * @return {number} double
                 */
                getHeight() {
                    return this.halfHeight * 2;
                }
                /**
                 * Returns the half width.
                 * @return {number} double
                 */
                getHalfWidth() {
                    return this.halfWidth;
                }
                /**
                 * Returns the half height.
                 * @return {number} double
                 */
                getHalfHeight() {
                    return this.halfHeight;
                }
            }
            /**
             * The maximum number of iterations to perform when finding the farthest point
             */
            Ellipse.FARTHEST_POINT_MAX_ITERATIONS = 50;
            /**
             * The desired accuracy for the farthest point
             */
            Ellipse.FARTHEST_POINT_EPSILON = 1.0E-8;
            geometry.Ellipse = Ellipse;
            Ellipse["__class"] = "org.dyn4j.geometry.Ellipse";
            Ellipse["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Minimal constructor.
             * <p>
             * This creates an axis-aligned half ellipse fitting inside a rectangle
             * of the given width and height.
             * @param {number} width the width
             * @param {number} height the height of the half
             * @throws IllegalArgumentException if either the width or height is less than or equal to zero
             * @class
             * @extends org.dyn4j.geometry.AbstractShape
             * @author William Bittle
             */
            class HalfEllipse extends org.dyn4j.geometry.AbstractShape {
                constructor(valid, width, height, center, vertexLeft, vertexRight) {
                    if (((typeof valid === 'boolean') || valid === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null) && ((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null) && ((vertexLeft != null && vertexLeft instanceof org.dyn4j.geometry.Vector2) || vertexLeft === null) && ((vertexRight != null && vertexRight instanceof org.dyn4j.geometry.Vector2) || vertexRight === null)) {
                        let __args = arguments;
                        super(center, center.distance$org_dyn4j_geometry_Vector2(vertexRight));
                        if (this.height === undefined) {
                            this.height = 0;
                        }
                        if (this.halfWidth === undefined) {
                            this.halfWidth = 0;
                        }
                        if (this.rotation === undefined) {
                            this.rotation = null;
                        }
                        if (this.ellipseCenter === undefined) {
                            this.ellipseCenter = null;
                        }
                        if (this.vertexLeft === undefined) {
                            this.vertexLeft = null;
                        }
                        if (this.vertexRight === undefined) {
                            this.vertexRight = null;
                        }
                        this.height = height;
                        this.halfWidth = width * 0.5;
                        this.ellipseCenter = new org.dyn4j.geometry.Vector2();
                        this.rotation = new org.dyn4j.geometry.Rotation();
                        this.vertexLeft = vertexLeft;
                        this.vertexRight = vertexRight;
                    }
                    else if (((typeof valid === 'number') || valid === null) && ((typeof width === 'number') || width === null) && height === undefined && center === undefined && vertexLeft === undefined && vertexRight === undefined) {
                        let __args = arguments;
                        let width = __args[0];
                        let height = __args[1];
                        {
                            let __args = arguments;
                            let valid = HalfEllipse.validate(__args[1], __args[2]);
                            let center = new org.dyn4j.geometry.Vector2(0, (4.0 * __args[2]) / (3.0 * Math.PI));
                            let vertexLeft = new org.dyn4j.geometry.Vector2(-__args[1] * 0.5, 0);
                            let vertexRight = new org.dyn4j.geometry.Vector2(__args[1] * 0.5, 0);
                            super(center, center.distance$org_dyn4j_geometry_Vector2(vertexRight));
                            if (this.height === undefined) {
                                this.height = 0;
                            }
                            if (this.halfWidth === undefined) {
                                this.halfWidth = 0;
                            }
                            if (this.rotation === undefined) {
                                this.rotation = null;
                            }
                            if (this.ellipseCenter === undefined) {
                                this.ellipseCenter = null;
                            }
                            if (this.vertexLeft === undefined) {
                                this.vertexLeft = null;
                            }
                            if (this.vertexRight === undefined) {
                                this.vertexRight = null;
                            }
                            this.height = height;
                            this.halfWidth = width * 0.5;
                            this.ellipseCenter = new org.dyn4j.geometry.Vector2();
                            this.rotation = new org.dyn4j.geometry.Rotation();
                            this.vertexLeft = vertexLeft;
                            this.vertexRight = vertexRight;
                        }
                        if (this.height === undefined) {
                            this.height = 0;
                        }
                        if (this.halfWidth === undefined) {
                            this.halfWidth = 0;
                        }
                        if (this.rotation === undefined) {
                            this.rotation = null;
                        }
                        if (this.ellipseCenter === undefined) {
                            this.ellipseCenter = null;
                        }
                        if (this.vertexLeft === undefined) {
                            this.vertexLeft = null;
                        }
                        if (this.vertexRight === undefined) {
                            this.vertexRight = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                static INERTIA_CONSTANT_$LI$() { if (HalfEllipse.INERTIA_CONSTANT == null) {
                    HalfEllipse.INERTIA_CONSTANT = Math.PI / 8.0 - 8.0 / (9.0 * Math.PI);
                } return HalfEllipse.INERTIA_CONSTANT; }
                /**
                 * Validates the constructor input returning true if valid or throwing an exception if invalid.
                 * @param {number} width the bounding rectangle width
                 * @param {number} height the bounding rectangle height
                 * @return {boolean} boolean true
                 * @throws IllegalArgumentException if either the width or height is less than or equal to zero
                 * @private
                 */
                /*private*/ static validate(width, height) {
                    if (width <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.halfEllipse.invalidWidth"));
                    if (height <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.halfEllipse.invalidHeight"));
                    return true;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("HalfEllipse[").append(super.toString()).append("|Width=").append(this.getWidth()).append("|Height=").append(this.getHeight()).append("]");
                    return sb.toString();
                }
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method is not supported by this shape.
                 * @throws UnsupportedOperationException when called
                 * @param {org.dyn4j.geometry.Vector2[]} foci
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getAxes(foci, transform) {
                    throw new java.lang.UnsupportedOperationException(org.dyn4j.resources.Messages.getString("geometry.halfEllipse.satNotSupported"));
                }
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method is not supported by this shape.
                 * @throws UnsupportedOperationException when called
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getFoci(transform) {
                    throw new java.lang.UnsupportedOperationException(org.dyn4j.resources.Messages.getString("geometry.halfEllipse.satNotSupported"));
                }
                getFarthestPoint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform) {
                    let localAxis = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(vector);
                    localAxis = this.getFarthestPoint$org_dyn4j_geometry_Vector2(localAxis);
                    transform.transform(localAxis);
                    return localAxis;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getFarthestPoint(vector, transform) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.getFarthestPoint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && transform === undefined) {
                        return this.getFarthestPoint$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ getFarthestPoint$org_dyn4j_geometry_Vector2(localAxis) {
                    localAxis.inverseRotate$org_dyn4j_geometry_Rotation(this.rotation);
                    if (localAxis.y <= 0) {
                        if (localAxis.x >= 0) {
                            localAxis.set$org_dyn4j_geometry_Vector2(this.vertexRight);
                        }
                        else {
                            localAxis.set$org_dyn4j_geometry_Vector2(this.vertexLeft);
                        }
                        return localAxis;
                    }
                    this.getFarthestPointOnAlignedEllipse(localAxis);
                    localAxis.rotate$org_dyn4j_geometry_Rotation(this.rotation);
                    localAxis.add$org_dyn4j_geometry_Vector2(this.ellipseCenter);
                    return localAxis;
                }
                /**
                 * Returns the farthest point along the given local space axis assuming the
                 * ellipse and the given axis are aligned.
                 * <p>
                 * Typically this means that the ellipse is axis-aligned, but it could also
                 * mean that the ellipse is not axis-aligned, but the given local space axis
                 * has been rotated to match the alignment of the ellipse.
                 * @since 3.4.0
                 * @param {org.dyn4j.geometry.Vector2} localAxis
                 * @private
                 */
                /*private*/ getFarthestPointOnAlignedEllipse(localAxis) {
                    localAxis.x *= this.halfWidth;
                    localAxis.y *= this.height;
                    localAxis.normalize();
                    localAxis.x *= this.halfWidth;
                    localAxis.y *= this.height;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Feature}
                 */
                getFarthestFeature(vector, transform) {
                    const localAxis = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(vector);
                    localAxis.inverseRotate$org_dyn4j_geometry_Rotation(this.rotation);
                    if (localAxis.y > 0) {
                        this.getFarthestPointOnAlignedEllipse(localAxis);
                        localAxis.rotate$org_dyn4j_geometry_Rotation(this.rotation);
                        localAxis.add$org_dyn4j_geometry_Vector2(this.ellipseCenter);
                        transform.transform(localAxis);
                        return new org.dyn4j.geometry.PointFeature(localAxis);
                    }
                    else {
                        const p1 = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertexLeft);
                        const p2 = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertexRight);
                        const vp1 = new org.dyn4j.geometry.PointFeature(p1, 0);
                        const vp2 = new org.dyn4j.geometry.PointFeature(p2, 1);
                        const vmax = (localAxis.x <= 0) ? vp1 : vp2;
                        return new org.dyn4j.geometry.EdgeFeature(vp1, vp2, vmax, p1.to$org_dyn4j_geometry_Vector2(p2), 0);
                    }
                }
                project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform) {
                    const p1 = this.getFarthestPoint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    const p2 = this.getFarthestPoint$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector.getNegative(), transform);
                    const d1 = p1.dot$org_dyn4j_geometry_Vector2(vector);
                    const d2 = p2.dot$org_dyn4j_geometry_Vector2(vector);
                    return new org.dyn4j.geometry.Interval(d2, d1);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Interval}
                 */
                project(vector, transform) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && transform === undefined) {
                        return this.project$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    const u = this.rotation.toVector$();
                    transform.transformR(u);
                    const x2 = u.x * u.x;
                    const y2 = u.y * u.y;
                    const hw2 = this.halfWidth * this.halfWidth;
                    const hh2 = this.height * this.height;
                    const aabbHalfWidth = Math.sqrt(x2 * hw2 + y2 * hh2);
                    const aabbHalfHeight = Math.sqrt(y2 * hw2 + x2 * hh2);
                    const cx = transform.getTransformedX(this.ellipseCenter);
                    const cy = transform.getTransformedY(this.ellipseCenter);
                    let minx = cx - aabbHalfWidth;
                    let miny = cy - aabbHalfHeight;
                    let maxx = cx + aabbHalfWidth;
                    let maxy = cy + aabbHalfHeight;
                    if (u.y > 0) {
                        if (u.x > 0) {
                            maxx = transform.getTransformedX(this.vertexRight);
                            miny = transform.getTransformedY(this.vertexLeft);
                        }
                        else {
                            maxx = transform.getTransformedX(this.vertexLeft);
                            maxy = transform.getTransformedY(this.vertexRight);
                        }
                    }
                    else {
                        if (u.x > 0) {
                            minx = transform.getTransformedX(this.vertexLeft);
                            miny = transform.getTransformedY(this.vertexRight);
                        }
                        else {
                            minx = transform.getTransformedX(this.vertexRight);
                            maxy = transform.getTransformedY(this.vertexLeft);
                        }
                    }
                    return new org.dyn4j.geometry.AABB(minx, miny, maxx, maxy);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.AABB}
                 */
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} density
                 * @return {org.dyn4j.geometry.Mass}
                 */
                createMass(density) {
                    const area = Math.PI * this.halfWidth * this.height;
                    const m = area * density * 0.5;
                    const I = m * (this.halfWidth * this.halfWidth + this.height * this.height) * HalfEllipse.INERTIA_CONSTANT_$LI$();
                    return new org.dyn4j.geometry.Mass(this.center, m, I);
                }
                getRadius$org_dyn4j_geometry_Vector2(center) {
                    if (this.halfWidth >= this.height) {
                        if (org.dyn4j.geometry.Segment.getLocation(center, this.vertexLeft, this.vertexRight) <= 0) {
                            return this.getMaxDistanceEllipse(center);
                        }
                        else {
                            return this.getMaxDistanceToVertices(center);
                        }
                    }
                    else {
                        return this.getMaxDistanceHalfEllipse(center);
                    }
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} center
                 * @return {number}
                 */
                getRadius(center) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        return this.getRadius$org_dyn4j_geometry_Vector2(center);
                    }
                    else if (center === undefined) {
                        return this.getRadius$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the maximum distance between the two vertices of the ellipse and the given point.
                 * @param {org.dyn4j.geometry.Vector2} point the point
                 * @return {number} double
                 * @since 3.4.0
                 * @private
                 */
                /*private*/ getMaxDistanceToVertices(point) {
                    const leftR = point.distanceSquared$org_dyn4j_geometry_Vector2(this.vertexLeft);
                    const rightR = point.distanceSquared$org_dyn4j_geometry_Vector2(this.vertexRight);
                    const r2 = Math.max(leftR, rightR);
                    return Math.sqrt(r2);
                }
                /**
                 * Returns the maximum distance from the given point to the ellipse.
                 * @param {org.dyn4j.geometry.Vector2} point the point
                 * @return {number} double
                 * @since 3.4.0
                 * @private
                 */
                /*private*/ getMaxDistanceEllipse(point) {
                    const p = point.difference$org_dyn4j_geometry_Vector2(this.ellipseCenter).inverseRotate$org_dyn4j_geometry_Rotation(this.rotation);
                    const fp = org.dyn4j.geometry.Ellipse.getFarthestPointOnEllipse(this.halfWidth, this.height, p);
                    return p.distance$org_dyn4j_geometry_Vector2(fp);
                }
                /**
                 * Returns the maximum distance between the given point and the half ellipse.
                 * @param {org.dyn4j.geometry.Vector2} point the point
                 * @return {number} double
                 * @since 3.4.0
                 * @private
                 */
                /*private*/ getMaxDistanceHalfEllipse(point) {
                    const a = this.halfWidth;
                    const b = this.height;
                    const p = point.difference$org_dyn4j_geometry_Vector2(this.ellipseCenter).inverseRotate$org_dyn4j_geometry_Rotation(this.rotation);
                    if (p.y < 0) {
                        return this.getMaxDistanceEllipse(point);
                    }
                    if (p.x < 0) {
                        p.x = -p.x;
                    }
                    const ab = (b * b - a * a);
                    const ab2r3 = Math.pow(ab * ab, 1 / 3);
                    const ax = a * p.x;
                    const ax2r3 = Math.pow(ax * ax, 1 / 3);
                    let top = ab2r3 - ax2r3;
                    if (top < 0) {
                        return this.getMaxDistanceToVertices(point);
                    }
                    top = Math.sqrt(top);
                    const ey = (top * top * top) / b;
                    if (p.y > ey) {
                        return this.getMaxDistanceToVertices(point);
                    }
                    if (Math.abs(p.x) < 1.0E-16) {
                        const d1 = this.height - p.y;
                        const d2 = this.getMaxDistanceToVertices(point);
                        return d1 > d2 ? d1 : d2;
                    }
                    const xr3 = Math.pow(p.x, 1 / 3);
                    const a2r3 = Math.pow(a * a, 1 / 3);
                    const m = (-a2r3 * top) / (b * xr3);
                    const a2 = a * a;
                    const b2 = b * b;
                    const m2 = m * m;
                    const x2 = p.x * p.x;
                    const y2 = ey * ey;
                    const qa = a2 * m2 + b2;
                    const qb = 2 * a2 * m * ey - 2 * a2 * m2 * p.x;
                    const qc = a2 * m2 * x2 - 2 * a2 * m * p.x * ey + a2 * y2 - b2 * a2;
                    const b24ac = qb * qb - 4 * qa * qc;
                    if (b24ac < 0) {
                        return this.getMaxDistanceToVertices(point);
                    }
                    const xmin = (-qb - Math.sqrt(b24ac)) / (2 * qa);
                    const xmax = 0;
                    const s = org.dyn4j.geometry.Ellipse.getFarthestPointOnBoundedEllipse(xmin, xmax, a, b, p);
                    const d1 = s.distance$org_dyn4j_geometry_Vector2(p);
                    const d2 = this.getMaxDistanceToVertices(point);
                    return d1 > d2 ? d1 : d2;
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    const localPoint = transform.getInverseTransformed$org_dyn4j_geometry_Vector2(point);
                    localPoint.inverseRotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(this.rotation, this.ellipseCenter);
                    const x = (localPoint.x - this.ellipseCenter.x);
                    const y = (localPoint.y - this.ellipseCenter.y);
                    if (y < 0)
                        return false;
                    const x2 = x * x;
                    const y2 = y * y;
                    const a2 = this.halfWidth * this.halfWidth;
                    const b2 = this.height * this.height;
                    const value = x2 / a2 + y2 / b2;
                    return value <= 1.0;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} point
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {boolean}
                 */
                contains(point, transform) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    super.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    this.rotation.rotate$org_dyn4j_geometry_Rotation(rotation);
                    this.vertexLeft.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    this.vertexRight.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    this.ellipseCenter.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$double$double(x, y) {
                    super.translate$double$double(x, y);
                    this.vertexLeft.add$double$double(x, y);
                    this.vertexRight.add$double$double(x, y);
                    this.ellipseCenter.add$double$double(x, y);
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the rotation about the local center in radians.
                 * @return {number} double the rotation in radians
                 */
                getRotationAngle() {
                    return this.rotation.toRadians();
                }
                /**
                 * @return {org.dyn4j.geometry.Rotation} the {@link Rotation} object that represents the local rotation
                 */
                getRotation() {
                    return this.rotation.copy();
                }
                /**
                 * Returns the width.
                 * @return {number} double
                 */
                getWidth() {
                    return this.halfWidth * 2;
                }
                /**
                 * Returns the height.
                 * @return {number} double
                 */
                getHeight() {
                    return this.height;
                }
                /**
                 * Returns the half width.
                 * @return {number} double
                 */
                getHalfWidth() {
                    return this.halfWidth;
                }
                /**
                 * Returns the center of the ellipse.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getEllipseCenter() {
                    return this.ellipseCenter;
                }
            }
            geometry.HalfEllipse = HalfEllipse;
            HalfEllipse["__class"] = "org.dyn4j.geometry.HalfEllipse";
            HalfEllipse["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Minimal constructor.
             * <p>
             * Creates an axis-aligned capsule centered on the origin with the caps on
             * ends of the larger dimension.
             * @param {number} width the bounding rectangle width
             * @param {number} height the bounding rectangle height
             * @throws IllegalArgumentException thrown if width or height are less than or equal to zero or if the width and height are near equal
             * @class
             * @extends org.dyn4j.geometry.AbstractShape
             * @author William Bittle
             */
            class Capsule extends org.dyn4j.geometry.AbstractShape {
                constructor(valid, width, height) {
                    if (((typeof valid === 'boolean') || valid === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                        let __args = arguments;
                        super(Math.max(width, height) * 0.5);
                        if (this.length === undefined) {
                            this.length = 0;
                        }
                        if (this.capRadius === undefined) {
                            this.capRadius = 0;
                        }
                        if (this.foci === undefined) {
                            this.foci = null;
                        }
                        if (this.localXAxis === undefined) {
                            this.localXAxis = null;
                        }
                        let major = width;
                        let minor = height;
                        let vertical = false;
                        if (width < height) {
                            major = height;
                            minor = width;
                            vertical = true;
                        }
                        this.length = major;
                        this.capRadius = minor * 0.5;
                        const f = (major - minor) * 0.5;
                        this.foci = [null, null];
                        if (vertical) {
                            this.foci[0] = new org.dyn4j.geometry.Vector2(0, -f);
                            this.foci[1] = new org.dyn4j.geometry.Vector2(0, f);
                            this.localXAxis = new org.dyn4j.geometry.Vector2(0.0, 1.0);
                        }
                        else {
                            this.foci[0] = new org.dyn4j.geometry.Vector2(-f, 0);
                            this.foci[1] = new org.dyn4j.geometry.Vector2(f, 0);
                            this.localXAxis = new org.dyn4j.geometry.Vector2(1.0, 0.0);
                        }
                    }
                    else if (((typeof valid === 'number') || valid === null) && ((typeof width === 'number') || width === null) && height === undefined) {
                        let __args = arguments;
                        let width = __args[0];
                        let height = __args[1];
                        {
                            let __args = arguments;
                            let valid = Capsule.validate(__args[1], __args[2]);
                            super(Math.max(width, height) * 0.5);
                            if (this.length === undefined) {
                                this.length = 0;
                            }
                            if (this.capRadius === undefined) {
                                this.capRadius = 0;
                            }
                            if (this.foci === undefined) {
                                this.foci = null;
                            }
                            if (this.localXAxis === undefined) {
                                this.localXAxis = null;
                            }
                            let major = width;
                            let minor = height;
                            let vertical = false;
                            if (width < height) {
                                major = height;
                                minor = width;
                                vertical = true;
                            }
                            this.length = major;
                            this.capRadius = minor * 0.5;
                            const f = (major - minor) * 0.5;
                            this.foci = [null, null];
                            if (vertical) {
                                this.foci[0] = new org.dyn4j.geometry.Vector2(0, -f);
                                this.foci[1] = new org.dyn4j.geometry.Vector2(0, f);
                                this.localXAxis = new org.dyn4j.geometry.Vector2(0.0, 1.0);
                            }
                            else {
                                this.foci[0] = new org.dyn4j.geometry.Vector2(-f, 0);
                                this.foci[1] = new org.dyn4j.geometry.Vector2(f, 0);
                                this.localXAxis = new org.dyn4j.geometry.Vector2(1.0, 0.0);
                            }
                        }
                        if (this.length === undefined) {
                            this.length = 0;
                        }
                        if (this.capRadius === undefined) {
                            this.capRadius = 0;
                        }
                        if (this.foci === undefined) {
                            this.foci = null;
                        }
                        if (this.localXAxis === undefined) {
                            this.localXAxis = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Validates the constructor input returning true if valid or throwing an exception if invalid.
                 * @param {number} width the bounding rectangle width
                 * @param {number} height the bounding rectangle height
                 * @return {boolean} boolean true
                 * @throws IllegalArgumentException thrown if width or height are less than or equal to zero or if the width and height are near equal
                 * @private
                 */
                /*private*/ static validate(width, height) {
                    if (width <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.capsule.invalidWidth"));
                    if (height <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.capsule.invalidHeight"));
                    if (Math.abs(width - height) < org.dyn4j.Epsilon.E_$LI$())
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.capsule.degenerate"));
                    return true;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Capsule[").append(super.toString()).append("|Width=").append(this.length).append("|CapRadius=").append(this.capRadius).append("]");
                    return sb.toString();
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2[]} foci
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getAxes(foci, transform) {
                    if (foci != null) {
                        const axes = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(2 + foci.length);
                        axes[0] = transform.getTransformedR$org_dyn4j_geometry_Vector2(this.localXAxis);
                        axes[1] = transform.getTransformedR$org_dyn4j_geometry_Vector2(this.localXAxis.getRightHandOrthogonalVector());
                        const f1 = transform.getTransformed$org_dyn4j_geometry_Vector2(this.foci[0]);
                        const f2 = transform.getTransformed$org_dyn4j_geometry_Vector2(this.foci[1]);
                        for (let i = 0; i < foci.length; i++) {
                            {
                                const d1 = f1.distanceSquared$org_dyn4j_geometry_Vector2(foci[i]);
                                const d2 = f2.distanceSquared$org_dyn4j_geometry_Vector2(foci[i]);
                                let v = null;
                                if (d1 < d2) {
                                    v = f1.to$org_dyn4j_geometry_Vector2(foci[i]);
                                }
                                else {
                                    v = f2.to$org_dyn4j_geometry_Vector2(foci[i]);
                                }
                                v.normalize();
                                axes[2 + i] = v;
                            }
                            ;
                        }
                        return axes;
                    }
                    return [transform.getTransformedR$org_dyn4j_geometry_Vector2(this.localXAxis), transform.getTransformedR$org_dyn4j_geometry_Vector2(this.localXAxis.getRightHandOrthogonalVector())];
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getFoci(transform) {
                    return [transform.getTransformed$org_dyn4j_geometry_Vector2(this.foci[0]), transform.getTransformed$org_dyn4j_geometry_Vector2(this.foci[1])];
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getFarthestPoint(vector, transform) {
                    vector.normalize();
                    const p = org.dyn4j.geometry.Segment.getFarthestPoint(this.foci[0], this.foci[1], vector, transform);
                    return p.add$org_dyn4j_geometry_Vector2(vector.product(this.capRadius));
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Feature}
                 */
                getFarthestFeature(vector, transform) {
                    const localAxis = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(vector);
                    const n1 = this.localXAxis.getLeftHandOrthogonalVector();
                    const d = localAxis.dot$org_dyn4j_geometry_Vector2(localAxis) * Capsule.EDGE_FEATURE_SELECTION_CRITERIA;
                    const d1 = localAxis.dot$org_dyn4j_geometry_Vector2(n1);
                    if (Math.abs(d1) < d) {
                        const point = this.getFarthestPoint(vector, transform);
                        return new org.dyn4j.geometry.PointFeature(point);
                    }
                    else {
                        const v = n1.multiply(this.capRadius);
                        const e = this.localXAxis.product(this.length * 0.5 * Capsule.EDGE_FEATURE_EXPANSION_FACTOR);
                        if (d1 > 0) {
                            const p1 = this.foci[0].sum$org_dyn4j_geometry_Vector2(v).subtract$org_dyn4j_geometry_Vector2(e);
                            const p2 = this.foci[1].sum$org_dyn4j_geometry_Vector2(v).add$org_dyn4j_geometry_Vector2(e);
                            return org.dyn4j.geometry.Segment.getFarthestFeature(p1, p2, vector, transform);
                        }
                        else {
                            const p1 = this.foci[0].difference$org_dyn4j_geometry_Vector2(v).subtract$org_dyn4j_geometry_Vector2(e);
                            const p2 = this.foci[1].difference$org_dyn4j_geometry_Vector2(v).add$org_dyn4j_geometry_Vector2(e);
                            return org.dyn4j.geometry.Segment.getFarthestFeature(p1, p2, vector, transform);
                        }
                    }
                }
                project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform) {
                    const p1 = this.getFarthestPoint(vector, transform);
                    const center = transform.getTransformed$org_dyn4j_geometry_Vector2(this.center);
                    const c = center.dot$org_dyn4j_geometry_Vector2(vector);
                    const d = p1.dot$org_dyn4j_geometry_Vector2(vector);
                    return new org.dyn4j.geometry.Interval(2 * c - d, d);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Interval}
                 */
                project(vector, transform) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && transform === undefined) {
                        return this.project$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    let p1 = this.getFarthestPoint(org.dyn4j.geometry.Vector2.X_AXIS_$LI$(), transform);
                    let c = transform.getTransformedX(this.center);
                    const minX = 2 * c - p1.x;
                    const maxX = p1.x;
                    p1 = this.getFarthestPoint(org.dyn4j.geometry.Vector2.Y_AXIS_$LI$(), transform);
                    c = transform.getTransformedY(this.center);
                    const minY = 2 * c - p1.y;
                    const maxY = p1.y;
                    return new org.dyn4j.geometry.AABB(minX, minY, maxX, maxY);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.AABB}
                 */
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} density
                 * @return {org.dyn4j.geometry.Mass}
                 */
                createMass(density) {
                    const h = this.capRadius * 2.0;
                    const w = this.length - h;
                    const r2 = this.capRadius * this.capRadius;
                    const ra = w * h;
                    const ca = r2 * Math.PI;
                    const rm = density * ra;
                    const cm = density * ca;
                    const m = rm + cm;
                    const d = w * 0.5;
                    const cI = 0.5 * cm * r2 + cm * d * d;
                    const rI = rm * (h * h + w * w) / 12.0;
                    const I = rI + cI;
                    return new org.dyn4j.geometry.Mass(this.center, m, I);
                }
                getRadius$org_dyn4j_geometry_Vector2(center) {
                    return org.dyn4j.geometry.Geometry.getRotationRadius$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2_A.apply(null, [center].concat(this.foci)) + this.capRadius;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} center
                 * @return {number}
                 */
                getRadius(center) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        return this.getRadius$org_dyn4j_geometry_Vector2(center);
                    }
                    else if (center === undefined) {
                        return this.getRadius$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    const p = org.dyn4j.geometry.Segment.getPointOnSegmentClosestToPoint(point, transform.getTransformed$org_dyn4j_geometry_Vector2(this.foci[0]), transform.getTransformed$org_dyn4j_geometry_Vector2(this.foci[1]));
                    const r2 = this.capRadius * this.capRadius;
                    const d2 = p.distanceSquared$org_dyn4j_geometry_Vector2(point);
                    return d2 <= r2;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} point
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {boolean}
                 */
                contains(point, transform) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    super.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    this.foci[0].rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    this.foci[1].rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    this.localXAxis.rotate$org_dyn4j_geometry_Rotation(rotation);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$double$double(x, y) {
                    super.translate$double$double(x, y);
                    this.foci[0].add$double$double(x, y);
                    this.foci[1].add$double$double(x, y);
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the rotation about the local center in radians in the range [-&pi;, &pi;].
                 * @return {number} double the rotation in radians
                 */
                getRotationAngle() {
                    return Math.atan2(this.localXAxis.y, this.localXAxis.x);
                }
                /**
                 * @return {org.dyn4j.geometry.Rotation} the {@link Rotation} object that represents the local rotation
                 */
                getRotation() {
                    return new org.dyn4j.geometry.Rotation(this.localXAxis.x, this.localXAxis.y);
                }
                /**
                 * Returns the length of the capsule.
                 * <p>
                 * The length is the largest dimension of the capsule's
                 * bounding rectangle.
                 * @return {number} double
                 */
                getLength() {
                    return this.length;
                }
                /**
                 * Returns the end cap radius.
                 * @return {number} double
                 */
                getCapRadius() {
                    return this.capRadius;
                }
            }
            /**
             *
             * The Capsule shape has two edge features which could be returned from the {@link #getFarthestFeature(Vector2, Transform)}
             * method. Under normal floating point conditions the edges will never be selected as the farthest features. Due to this,
             * stacking of capsule shapes is very unstable (or any resting contact that involves the edge). We introduce this factor
             * (% of projected normal) to help select the edge in cases where the collision normal is nearly parallel to the edge normal.
             */
            Capsule.EDGE_FEATURE_SELECTION_CRITERIA = 0.98;
            /**
             * Because we are selecting an edge even when the farthest feature should be a vertex, when the edges are clipped
             * against each other (in the ClippingManifoldSolver) they will not overlap. Due to this, we introduce an expansion
             * value (% of the width) that expands the edge feature so that in these cases a collision manifold is still generated.
             */
            Capsule.EDGE_FEATURE_EXPANSION_FACTOR = 0.1;
            geometry.Capsule = Capsule;
            Capsule["__class"] = "org.dyn4j.geometry.Capsule";
            Capsule["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * <p>
             * Creates a new {@link Circle} centered on the origin with the given radius.
             * @param {number} radius the radius
             * @throws IllegalArgumentException if the given radius is less than or equal to zero
             * @class
             * @extends org.dyn4j.geometry.AbstractShape
             * @author William Bittle
             */
            class Circle extends org.dyn4j.geometry.AbstractShape {
                constructor(valid, radius) {
                    if (((typeof valid === 'boolean') || valid === null) && ((typeof radius === 'number') || radius === null)) {
                        let __args = arguments;
                        super(radius);
                        this.isRuler = false;
                    }
                    else if (((typeof valid === 'number') || valid === null) && radius === undefined) {
                        let __args = arguments;
                        let radius = __args[0];
                        {
                            let __args = arguments;
                            let valid = Circle.validate(__args[1]);
                            super(radius);
                            this.isRuler = false;
                        }
                        this.isRuler = false;
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Validates the constructor input returning true if valid or throwing an exception if invalid.
                 * @param {number} radius the radius
                 * @return {boolean} boolean true
                 * @throws IllegalArgumentException if the given radius is less than or equal to zero
                 * @private
                 */
                /*private*/ static validate(radius) {
                    if (radius <= 0.0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.circle.invalidRadius"));
                    return true;
                }
                getRadius$org_dyn4j_geometry_Vector2(center) {
                    return this.radius + center.distance$org_dyn4j_geometry_Vector2(this.center);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} center
                 * @return {number}
                 */
                getRadius(center) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        return this.getRadius$org_dyn4j_geometry_Vector2(center);
                    }
                    else if (center === undefined) {
                        return this.getRadius$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Circle[").append(super.toString()).append("]");
                    return sb.toString();
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    const v = transform.getTransformed$org_dyn4j_geometry_Vector2(this.center);
                    const radiusSquared = this.radius * this.radius;
                    v.subtract$org_dyn4j_geometry_Vector2(point);
                    if (v.getMagnitudeSquared() <= radiusSquared) {
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} point
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {boolean}
                 */
                contains(point, transform) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform) {
                    const center = transform.getTransformed$org_dyn4j_geometry_Vector2(this.center);
                    const c = center.dot$org_dyn4j_geometry_Vector2(vector);
                    return new org.dyn4j.geometry.Interval(c - this.radius, c + this.radius);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Interval}
                 */
                project(vector, transform) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && transform === undefined) {
                        return this.project$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * {@inheritDoc}
                 * <p>
                 * For a {@link Circle} this will always return a {@link PointFeature}.
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.PointFeature}
                 */
                getFarthestFeature(vector, transform) {
                    const farthest = this.getFarthestPoint(vector, transform);
                    return new org.dyn4j.geometry.PointFeature(farthest);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getFarthestPoint(vector, transform) {
                    const nAxis = vector.getNormalized();
                    const center = transform.getTransformed$org_dyn4j_geometry_Vector2(this.center);
                    center.x += this.radius * nAxis.x;
                    center.y += this.radius * nAxis.y;
                    return center;
                }
                /**
                 * {@inheritDoc}
                 * <p>
                 * Circular shapes are handled specifically in the SAT algorithm since
                 * they have an infinite number of axes. As a result this method returns
                 * null.
                 * @return {org.dyn4j.geometry.Vector2[]} null
                 * @param {org.dyn4j.geometry.Vector2[]} foci
                 * @param {org.dyn4j.geometry.Transform} transform
                 */
                getAxes(foci, transform) {
                    return null;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getFoci(transform) {
                    const foci = [null];
                    foci[0] = transform.getTransformed$org_dyn4j_geometry_Vector2(this.center);
                    return foci;
                }
                /**
                 * {@inheritDoc}
                 * <p style="white-space: pre;"> m = d * &pi; * r<sup>2</sup>
                 * I = m * r<sup>2</sup> / 2</p>
                 * @param {number} density
                 * @return {org.dyn4j.geometry.Mass}
                 */
                createMass(density) {
                    const r2 = this.radius * this.radius;
                    const mass = density * Math.PI * r2;
                    const inertia = mass * r2 * 0.5;
                    return new org.dyn4j.geometry.Mass(this.center, mass, inertia);
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    const center = transform.getTransformed$org_dyn4j_geometry_Vector2(this.center);
                    return new org.dyn4j.geometry.AABB(center, this.radius);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.AABB}
                 */
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            geometry.Circle = Circle;
            Circle["__class"] = "org.dyn4j.geometry.Circle";
            Circle["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * <p>
             * This method creates a slice of a circle with the <b>circle center</b> at the origin
             * and half of theta below the x-axis and half above.
             * @param {number} radius the radius of the circular section
             * @param {number} theta the angular extent in radians; must be greater than zero and less than or equal to &pi;
             * @throws IllegalArgumentException throw if 1) radius is less than or equal to zero or 2) theta is less than or equal to zero or 3) theta is greater than 180 degrees
             * @class
             * @extends org.dyn4j.geometry.AbstractShape
             * @author William Bittle
             */
            class Slice extends org.dyn4j.geometry.AbstractShape {
                constructor(valid, radius, theta, center) {
                    if (((typeof valid === 'boolean') || valid === null) && ((typeof radius === 'number') || radius === null) && ((typeof theta === 'number') || theta === null) && ((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        let __args = arguments;
                        super(center, Math.max(center.x, center.distance$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(radius, 0).rotate$double(0.5 * theta))));
                        if (this.alpha === undefined) {
                            this.alpha = 0;
                        }
                        if (this.cosAlpha === undefined) {
                            this.cosAlpha = 0;
                        }
                        if (this.sliceRadius === undefined) {
                            this.sliceRadius = 0;
                        }
                        if (this.vertices === undefined) {
                            this.vertices = null;
                        }
                        if (this.normals === undefined) {
                            this.normals = null;
                        }
                        if (this.rotation === undefined) {
                            this.rotation = null;
                        }
                        this.sliceRadius = radius;
                        this.alpha = theta * 0.5;
                        const x = radius * (this.cosAlpha = Math.cos(this.alpha));
                        const y = radius * Math.sin(this.alpha);
                        this.vertices = [new org.dyn4j.geometry.Vector2(), new org.dyn4j.geometry.Vector2(x, y), new org.dyn4j.geometry.Vector2(x, -y)];
                        const v1 = this.vertices[1].to$org_dyn4j_geometry_Vector2(this.vertices[0]);
                        const v2 = this.vertices[0].to$org_dyn4j_geometry_Vector2(this.vertices[2]);
                        v1.left().normalize();
                        v2.left().normalize();
                        this.normals = [v1, v2];
                        this.rotation = new org.dyn4j.geometry.Rotation();
                    }
                    else if (((typeof valid === 'number') || valid === null) && ((typeof radius === 'number') || radius === null) && theta === undefined && center === undefined) {
                        let __args = arguments;
                        let radius = __args[0];
                        let theta = __args[1];
                        {
                            let __args = arguments;
                            let valid = Slice.validate(__args[1], __args[2]);
                            let center = new org.dyn4j.geometry.Vector2(2.0 * __args[1] * Math.sin(__args[2] * 0.5) / (1.5 * __args[2]), 0);
                            super(center, Math.max(center.x, center.distance$org_dyn4j_geometry_Vector2(new org.dyn4j.geometry.Vector2(radius, 0).rotate$double(0.5 * theta))));
                            if (this.alpha === undefined) {
                                this.alpha = 0;
                            }
                            if (this.cosAlpha === undefined) {
                                this.cosAlpha = 0;
                            }
                            if (this.sliceRadius === undefined) {
                                this.sliceRadius = 0;
                            }
                            if (this.vertices === undefined) {
                                this.vertices = null;
                            }
                            if (this.normals === undefined) {
                                this.normals = null;
                            }
                            if (this.rotation === undefined) {
                                this.rotation = null;
                            }
                            this.sliceRadius = radius;
                            this.alpha = theta * 0.5;
                            const x = radius * (this.cosAlpha = Math.cos(this.alpha));
                            const y = radius * Math.sin(this.alpha);
                            this.vertices = [new org.dyn4j.geometry.Vector2(), new org.dyn4j.geometry.Vector2(x, y), new org.dyn4j.geometry.Vector2(x, -y)];
                            const v1 = this.vertices[1].to$org_dyn4j_geometry_Vector2(this.vertices[0]);
                            const v2 = this.vertices[0].to$org_dyn4j_geometry_Vector2(this.vertices[2]);
                            v1.left().normalize();
                            v2.left().normalize();
                            this.normals = [v1, v2];
                            this.rotation = new org.dyn4j.geometry.Rotation();
                        }
                        if (this.alpha === undefined) {
                            this.alpha = 0;
                        }
                        if (this.cosAlpha === undefined) {
                            this.cosAlpha = 0;
                        }
                        if (this.sliceRadius === undefined) {
                            this.sliceRadius = 0;
                        }
                        if (this.vertices === undefined) {
                            this.vertices = null;
                        }
                        if (this.normals === undefined) {
                            this.normals = null;
                        }
                        if (this.rotation === undefined) {
                            this.rotation = null;
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Validates the constructor input returning true if valid or throwing an exception if invalid.
                 * @param {number} radius the radius of the circular section
                 * @param {number} theta the angular extent in radians; must be greater than zero and less than or equal to &pi;
                 * return true
                 * @throws IllegalArgumentException throw if 1) radius is less than or equal to zero or 2) theta is less than or equal to zero or 3) theta is greater than 180 degrees
                 * @return {boolean}
                 * @private
                 */
                /*private*/ static validate(radius, theta) {
                    if (radius <= 0)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.slice.invalidRadius"));
                    if (theta <= 0 || theta > Math.PI)
                        throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("geometry.slice.invalidTheta"));
                    return true;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Slice[").append(super.toString()).append("|Radius=").append(this.sliceRadius).append("|Theta=").append(this.getTheta()).append("]");
                    return sb.toString();
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2[]} foci
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getAxes(foci, transform) {
                    const fociSize = foci != null ? foci.length : 0;
                    const size = this.vertices.length;
                    const axes = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(2 + fociSize);
                    let n = 0;
                    axes[n++] = transform.getTransformedR$org_dyn4j_geometry_Vector2(this.normals[0]);
                    axes[n++] = transform.getTransformedR$org_dyn4j_geometry_Vector2(this.normals[1]);
                    const focus = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                    for (let i = 0; i < fociSize; i++) {
                        {
                            const f = foci[i];
                            let closest = focus;
                            let d = f.distanceSquared$org_dyn4j_geometry_Vector2(closest);
                            for (let j = 1; j < size; j++) {
                                {
                                    let p = this.vertices[j];
                                    p = transform.getTransformed$org_dyn4j_geometry_Vector2(p);
                                    const dt = f.distanceSquared$org_dyn4j_geometry_Vector2(p);
                                    if (dt < d) {
                                        closest = p;
                                        d = dt;
                                    }
                                }
                                ;
                            }
                            const axis = f.to$org_dyn4j_geometry_Vector2(closest);
                            axis.normalize();
                            axes[n++] = axis;
                        }
                        ;
                    }
                    return axes;
                }
                /**
                 * {@inheritDoc}
                 * <p>
                 * Returns a single point, the circle center.
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getFoci(transform) {
                    return [transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0])];
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getFarthestPoint(vector, transform) {
                    const localn = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(vector);
                    let localnRotated;
                    localn.normalize();
                    if (!this.rotation.isIdentity$()) {
                        localnRotated = localn.copy().inverseRotate$org_dyn4j_geometry_Rotation(this.rotation);
                    }
                    else {
                        localnRotated = localn;
                    }
                    if (localnRotated.x < this.cosAlpha) {
                        const edge = this.vertices[0].dot$org_dyn4j_geometry_Vector2(localn);
                        let maxIndex = 0;
                        if (localnRotated.y < 0) {
                            if (this.vertices[2].dot$org_dyn4j_geometry_Vector2(localn) > edge) {
                                maxIndex = 2;
                            }
                        }
                        else {
                            if (this.vertices[1].dot$org_dyn4j_geometry_Vector2(localn) > edge) {
                                maxIndex = 1;
                            }
                        }
                        const point = new org.dyn4j.geometry.Vector2(this.vertices[maxIndex]);
                        transform.transform(point);
                        return point;
                    }
                    else {
                        localn.multiply(this.sliceRadius).add$org_dyn4j_geometry_Vector2(this.vertices[0]);
                        transform.transform(localn);
                        return localn;
                    }
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Feature}
                 */
                getFarthestFeature(vector, transform) {
                    const localn = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(vector);
                    let localnRotated;
                    localn.normalize();
                    if (!this.rotation.isIdentity$()) {
                        localnRotated = localn.copy().inverseRotate$org_dyn4j_geometry_Rotation(this.rotation);
                    }
                    else {
                        localnRotated = localn;
                    }
                    if (localnRotated.x < this.cosAlpha) {
                        if (this.cosAlpha <= 1.0E-6) {
                            return org.dyn4j.geometry.Segment.getFarthestFeature(this.vertices[1], this.vertices[2], vector, transform);
                        }
                        if (localnRotated.y > 0) {
                            return org.dyn4j.geometry.Segment.getFarthestFeature(this.vertices[0], this.vertices[1], vector, transform);
                        }
                        else if (localnRotated.y < 0) {
                            return org.dyn4j.geometry.Segment.getFarthestFeature(this.vertices[0], this.vertices[2], vector, transform);
                        }
                        else {
                            return new org.dyn4j.geometry.PointFeature(transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]));
                        }
                    }
                    else {
                        localn.multiply(this.sliceRadius).add$org_dyn4j_geometry_Vector2(this.vertices[0]);
                        transform.transform(localn);
                        return new org.dyn4j.geometry.PointFeature(localn);
                    }
                }
                project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform) {
                    const p1 = this.getFarthestPoint(vector, transform);
                    const p2 = this.getFarthestPoint(vector.getNegative(), transform);
                    const d1 = p1.dot$org_dyn4j_geometry_Vector2(vector);
                    const d2 = p2.dot$org_dyn4j_geometry_Vector2(vector);
                    return new org.dyn4j.geometry.Interval(d2, d1);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Interval}
                 */
                project(vector, transform) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && transform === undefined) {
                        return this.project$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    const minX = this.getFarthestPoint(org.dyn4j.geometry.Vector2.INV_X_AXIS_$LI$(), transform).x;
                    const maxX = this.getFarthestPoint(org.dyn4j.geometry.Vector2.X_AXIS_$LI$(), transform).x;
                    const minY = this.getFarthestPoint(org.dyn4j.geometry.Vector2.INV_Y_AXIS_$LI$(), transform).y;
                    const maxY = this.getFarthestPoint(org.dyn4j.geometry.Vector2.Y_AXIS_$LI$(), transform).y;
                    return new org.dyn4j.geometry.AABB(minX, minY, maxX, maxY);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.AABB}
                 */
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} density
                 * @return {org.dyn4j.geometry.Mass}
                 */
                createMass(density) {
                    const r2 = this.sliceRadius * this.sliceRadius;
                    const m = density * r2 * this.alpha;
                    const sina = Math.sin(this.alpha);
                    const I = 1.0 / 18.0 * r2 * r2 * (9.0 * this.alpha * this.alpha - 8.0 * sina * sina) / this.alpha;
                    return new org.dyn4j.geometry.Mass(this.center, m, I);
                }
                getRadius$org_dyn4j_geometry_Vector2(center) {
                    if (org.dyn4j.geometry.Segment.getLocation(center, this.vertices[1], this.vertices[0]) <= 0 && org.dyn4j.geometry.Segment.getLocation(center, this.vertices[2], this.vertices[0]) >= 0) {
                        return this.sliceRadius + center.distance$org_dyn4j_geometry_Vector2(this.vertices[0]);
                    }
                    else {
                        return org.dyn4j.geometry.Geometry.getRotationRadius$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Vector2_A.apply(null, [center].concat(this.vertices));
                    }
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} center
                 * @return {number}
                 */
                getRadius(center) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        return this.getRadius$org_dyn4j_geometry_Vector2(center);
                    }
                    else if (center === undefined) {
                        return this.getRadius$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    const lp = transform.getInverseTransformed$org_dyn4j_geometry_Vector2(point);
                    const radiusSquared = this.sliceRadius * this.sliceRadius;
                    const v = this.vertices[0].to$org_dyn4j_geometry_Vector2(lp);
                    if (v.getMagnitudeSquared() <= radiusSquared) {
                        if (org.dyn4j.geometry.Segment.getLocation(lp, this.vertices[0], this.vertices[1]) <= 0 && org.dyn4j.geometry.Segment.getLocation(lp, this.vertices[0], this.vertices[2]) >= 0) {
                            return true;
                        }
                    }
                    return false;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} point
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {boolean}
                 */
                contains(point, transform) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y) {
                    super.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    for (let i = 0; i < this.vertices.length; i++) {
                        {
                            this.vertices[i].rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                        }
                        ;
                    }
                    for (let i = 0; i < this.normals.length; i++) {
                        {
                            this.normals[i].rotate$org_dyn4j_geometry_Rotation(rotation);
                        }
                        ;
                    }
                    this.rotation.rotate$org_dyn4j_geometry_Rotation(rotation);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$org_dyn4j_geometry_Rotation$double$double(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                translate$double$double(x, y) {
                    super.translate$double$double(x, y);
                    for (let i = 0; i < this.vertices.length; i++) {
                        {
                            this.vertices[i].add$double$double(x, y);
                        }
                        ;
                    }
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the rotation about the local center in radians.
                 * @return {number} double the rotation in radians
                 */
                getRotationAngle() {
                    return this.rotation.toRadians();
                }
                /**
                 * @return {org.dyn4j.geometry.Rotation} the {@link Rotation} object that represents the local rotation
                 */
                getRotation() {
                    return this.rotation.copy();
                }
                /**
                 * Returns the angular extent of the slice in radians.
                 * @return {number} double
                 */
                getTheta() {
                    return this.alpha * 2;
                }
                /**
                 * Returns the slice radius.
                 * <p>
                 * This is the radius passed in at creation.
                 * @return {number} double
                 */
                getSliceRadius() {
                    return this.sliceRadius;
                }
                /**
                 * Returns the tip of the pie shape.
                 * <p>
                 * This is the center of the circle.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getCircleCenter() {
                    return this.vertices[0];
                }
            }
            geometry.Slice = Slice;
            Slice["__class"] = "org.dyn4j.geometry.Slice";
            Slice["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Minimal constructor.
             * <p>
             * This creates an axis-aligned Parabola fitting inside a rectangle, with vertex at origin
             * of the given width and height.
             * @param width the width
             * @param height the height of the half
             * @throws IllegalArgumentException if either the width or height is less than or equal to zero
             * @class
             * @extends org.dyn4j.geometry.AbstractShape
             * @author Mahesh Kurmi
             */
            class Plane extends org.dyn4j.geometry.AbstractShape {
                constructor() {
                    super(Plane.MAX);
                    if (this.localXAxis === undefined) {
                        this.localXAxis = null;
                    }
                    if (this.vertex === undefined) {
                        this.vertex = null;
                    }
                    if (this.vertices === undefined) {
                        this.vertices = null;
                    }
                    this.vertex = new org.dyn4j.geometry.Vector2();
                    this.localXAxis = new org.dyn4j.geometry.Vector2(1.0, 0.0);
                    this.vertices = [new org.dyn4j.geometry.Vector2(-Plane.MAX, 0), new org.dyn4j.geometry.Vector2(Plane.MAX, 0), new org.dyn4j.geometry.Vector2(Plane.MAX, -Plane.MAX), new org.dyn4j.geometry.Vector2(-Plane.MAX, -Plane.MAX)];
                    this.center.set$double$double(0, 0);
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Planre[").append(super.toString()).append("|UserData=").append(this.userData).append("]");
                    return sb.toString();
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2[]} foci
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getAxes(foci, transform) {
                    throw new java.lang.UnsupportedOperationException(org.dyn4j.resources.Messages.getString("geometry.halfEllipse.satNotSupported"));
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getFoci(transform) {
                    throw new java.lang.UnsupportedOperationException(org.dyn4j.resources.Messages.getString("geometry.halfEllipse.satNotSupported"));
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} n
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2}
                 */
                getFarthestPoint(n, transform) {
                    const localAxis = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(n);
                    const r = this.getRotation();
                    localAxis.rotate$double(-r);
                    let p = null;
                    if (localAxis.y > 0) {
                        if (localAxis.x > 0) {
                            return transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[1]);
                        }
                        else {
                            return transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                        }
                    }
                    else {
                        p = localAxis.product(Plane.MAX);
                    }
                    p.rotate$double(r);
                    p.add$org_dyn4j_geometry_Vector2(this.vertex);
                    transform.transform(p);
                    return p;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} n
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Feature}
                 */
                getFarthestFeature(n, transform) {
                    const localAxis = transform.getInverseTransformedR$org_dyn4j_geometry_Vector2(n);
                    if (localAxis.y < 0) {
                        return org.dyn4j.geometry.Segment.getFarthestFeature(this.vertices[0], this.vertices[1], n, transform);
                    }
                    else {
                        return org.dyn4j.geometry.Segment.getFarthestFeature(this.vertices[0], this.vertices[1], n, transform);
                    }
                }
                project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(n, transform) {
                    const p1 = this.getFarthestPoint(n, transform);
                    const p2 = this.getFarthestPoint(n.getNegative(), transform);
                    const d1 = p1.dot$org_dyn4j_geometry_Vector2(n);
                    const d2 = p2.dot$org_dyn4j_geometry_Vector2(n);
                    return new org.dyn4j.geometry.Interval(d2, d1);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} n
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Interval}
                 */
                project(n, transform) {
                    if (((n != null && n instanceof org.dyn4j.geometry.Vector2) || n === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(n, transform);
                    }
                    else if (((n != null && n instanceof org.dyn4j.geometry.Vector2) || n === null) && transform === undefined) {
                        return this.project$org_dyn4j_geometry_Vector2(n);
                    }
                    else
                        throw new Error('invalid overload');
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    const x = this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(org.dyn4j.geometry.Vector2.X_AXIS_$LI$(), transform);
                    const y = this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(org.dyn4j.geometry.Vector2.Y_AXIS_$LI$(), transform);
                    return new org.dyn4j.geometry.AABB(x.getMin(), y.getMin(), x.getMax(), y.getMax());
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.AABB}
                 */
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} density
                 * @return {org.dyn4j.geometry.Mass}
                 */
                createMass(density) {
                    const area = (4 / 3.0) * 1;
                    const m = area * density;
                    const I = m * Plane.INERTIA_CONSTANT;
                    return new org.dyn4j.geometry.Mass(this.center, m, I);
                }
                getRadius$org_dyn4j_geometry_Vector2(center) {
                    return this.radius + center.distance$org_dyn4j_geometry_Vector2(this.center);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} center
                 * @return {number}
                 */
                getRadius(center) {
                    if (((center != null && center instanceof org.dyn4j.geometry.Vector2) || center === null)) {
                        return this.getRadius$org_dyn4j_geometry_Vector2(center);
                    }
                    else if (center === undefined) {
                        return this.getRadius$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    const localPoint = transform.getInverseTransformed$org_dyn4j_geometry_Vector2(point);
                    const r = this.getRotation();
                    localPoint.rotate$double$double$double(-r, this.vertex.x, this.vertex.y);
                    const y = (localPoint.y - this.vertex.y);
                    if (y <= 0.0) {
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} point
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {boolean}
                 */
                contains(point, transform) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        super.rotate(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$double$double$double(theta, x, y) {
                }
                translate$double$double(x, y) {
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the rotation about the local center in radians.
                 * @return {number} double the rotation in radians
                 */
                getRotation() {
                    return org.dyn4j.geometry.Vector2.X_AXIS_$LI$().getAngleBetween$org_dyn4j_geometry_Vector2(this.localXAxis);
                }
                /**
                 * Returns the center of the Parabola.
                 * @return {org.dyn4j.geometry.Vector2} {@link Vector2}
                 */
                getVertex() {
                    return this.vertex;
                }
                getDirection() {
                    return this.localXAxis;
                }
                /**
                 * Returns the center of the Parabola.
                 * @return {org.dyn4j.geometry.Vector2[]} {@link Vector2}
                 */
                getVertices() {
                    return this.vertices;
                }
            }
            /**
             * The half ellipse inertia constant. See http://www.efunda.com/math/areas/ellipticalhalf.cfm
             */
            Plane.INERTIA_CONSTANT = 2 / 105.0;
            Plane.MAX = 1000000.0;
            geometry.Plane = Plane;
            Plane["__class"] = "org.dyn4j.geometry.Plane";
            Plane["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var samples;
        (function (samples) {
            var framework;
            (function (framework) {
                /**
                 * Constructor.
                 * @param {org.dyn4j.samples.framework.Color} color a set color
                 * @class
                 * @extends org.dyn4j.dynamics.Body
                 * @author William Bittle
                 */
                class SimulationBody extends org.dyn4j.dynamics.Body {
                    constructor(color) {
                        if (((color != null && color instanceof org.dyn4j.samples.framework.Color) || color === null)) {
                            let __args = arguments;
                            super();
                            if (this.color === undefined) {
                                this.color = null;
                            }
                            this.color = color;
                        }
                        else if (color === undefined) {
                            let __args = arguments;
                            super();
                            if (this.color === undefined) {
                                this.color = null;
                            }
                            this.color = org.dyn4j.samples.framework.Graphics2DRenderer.getRandomColor();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Returns this body's color.
                     * @return {org.dyn4j.samples.framework.Color} Color
                     */
                    getColor() {
                        return this.color;
                    }
                    /**
                     * Sets the body's color
                     * @param {org.dyn4j.samples.framework.Color} color the color
                     */
                    setColor(color) {
                        this.color = color;
                    }
                }
                framework.SimulationBody = SimulationBody;
                SimulationBody["__class"] = "org.dyn4j.samples.framework.SimulationBody";
                SimulationBody["__interfaces"] = ["org.dyn4j.collision.Collidable", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
            })(framework = samples.framework || (samples.framework = {}));
        })(samples = dyn4j.samples || (dyn4j.samples = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            /**
             * Represents a {@link BroadphaseFilter} for the {@link BroadphaseDetector#detect(BroadphaseFilter)} method.
             * <p>
             * This filter extends the {@link DefaultBroadphaseFilter} class and adds filtering for the additional information
             * in the {@link Body} class.
             * <p>
             * Extend this class to add additional filtering capabilities to the broad-phase.
             * @author William Bittle
             * @version 3.2.4
             * @since 3.2.0
             * @class
             * @extends org.dyn4j.collision.broadphase.DefaultBroadphaseFilter
             */
            class DetectBroadphaseFilter extends org.dyn4j.collision.broadphase.DefaultBroadphaseFilter {
                isAllowed$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(body1, fixture1, body2, fixture2) {
                    if (!body1.isActive() || !body2.isActive())
                        return false;
                    if (!body1.isDynamic() && !body2.isDynamic() && !fixture1.isSensor() && !fixture2.isSensor())
                        return false;
                    if (body1.isConnected$org_dyn4j_dynamics_Body$boolean(body2, false))
                        return false;
                    return super.isAllowed(body1, fixture1, body2, fixture2);
                }
                /**
                 *
                 * @param {org.dyn4j.dynamics.Body} body1
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture1
                 * @param {org.dyn4j.dynamics.Body} body2
                 * @param {org.dyn4j.dynamics.BodyFixture} fixture2
                 * @return {boolean}
                 */
                isAllowed(body1, fixture1, body2, fixture2) {
                    if (((body1 != null && body1 instanceof org.dyn4j.dynamics.Body) || body1 === null) && ((fixture1 != null && fixture1 instanceof org.dyn4j.dynamics.BodyFixture) || fixture1 === null) && ((body2 != null && body2 instanceof org.dyn4j.dynamics.Body) || body2 === null) && ((fixture2 != null && fixture2 instanceof org.dyn4j.dynamics.BodyFixture) || fixture2 === null)) {
                        return this.isAllowed$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture$org_dyn4j_dynamics_Body$org_dyn4j_dynamics_BodyFixture(body1, fixture1, body2, fixture2);
                    }
                    else if (((body1 != null) || body1 === null) && ((fixture1 != null) || fixture1 === null) && ((body2 != null) || body2 === null) && ((fixture2 != null) || fixture2 === null)) {
                        return super.isAllowed(body1, fixture1, body2, fixture2);
                    }
                    else if (((body1 != null && body1 instanceof org.dyn4j.geometry.Ray) || body1 === null) && ((typeof fixture1 === 'number') || fixture1 === null) && ((body2 != null) || body2 === null) && ((fixture2 != null) || fixture2 === null)) {
                        return this.isAllowed$org_dyn4j_geometry_Ray$double$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(body1, fixture1, body2, fixture2);
                    }
                    else if (((body1 != null && body1 instanceof org.dyn4j.geometry.AABB) || body1 === null) && ((fixture1 != null) || fixture1 === null) && ((body2 != null) || body2 === null) && fixture2 === undefined) {
                        return this.isAllowed$org_dyn4j_geometry_AABB$org_dyn4j_collision_Collidable$org_dyn4j_collision_Fixture(body1, fixture1, body2);
                    }
                    else
                        throw new Error('invalid overload');
                }
                constructor() {
                    super();
                }
            }
            dynamics.DetectBroadphaseFilter = DetectBroadphaseFilter;
            DetectBroadphaseFilter["__class"] = "org.dyn4j.dynamics.DetectBroadphaseFilter";
            DetectBroadphaseFilter["__interfaces"] = ["org.dyn4j.collision.broadphase.BroadphaseFilter"];
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Full constructor.
                 * <p>
                 * The ordering of the types doesn't matter.
                 * @param {java.lang.Class} type1 the first type of the pair
                 * @param {boolean} strict1 true if a strict type comparison should be performed on the first type
                 * @param {java.lang.Class} type2 the second type of the pair
                 * @param {boolean} strict2 true if a strict type comparison should be performed on the second type
                 * @param {number} sortIndex the sort index of this condition
                 * @class
                 * @extends org.dyn4j.collision.narrowphase.TypedFallbackCondition
                 * @author William Bittle
                 */
                class PairwiseTypedFallbackCondition extends org.dyn4j.collision.narrowphase.TypedFallbackCondition {
                    constructor(type1, strict1, type2, strict2, sortIndex) {
                        if (((type1 != null && (type1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type1))) || type1 === null) && ((typeof strict1 === 'boolean') || strict1 === null) && ((type2 != null && (type2["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type2))) || type2 === null) && ((typeof strict2 === 'boolean') || strict2 === null) && ((typeof sortIndex === 'number') || sortIndex === null)) {
                            let __args = arguments;
                            super(sortIndex);
                            if (this.type1 === undefined) {
                                this.type1 = null;
                            }
                            if (this.strict1 === undefined) {
                                this.strict1 = false;
                            }
                            if (this.type2 === undefined) {
                                this.type2 = null;
                            }
                            if (this.strict2 === undefined) {
                                this.strict2 = false;
                            }
                            this.type1 = type1;
                            this.strict1 = strict1;
                            this.type2 = type2;
                            this.strict2 = strict2;
                        }
                        else if (((type1 != null && (type1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type1))) || type1 === null) && ((strict1 != null && (strict1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(strict1))) || strict1 === null) && ((typeof type2 === 'boolean') || type2 === null) && ((typeof strict2 === 'number') || strict2 === null) && sortIndex === undefined) {
                            let __args = arguments;
                            let type2 = __args[1];
                            let strict = __args[2];
                            let sortIndex = __args[3];
                            {
                                let __args = arguments;
                                let strict1 = strict;
                                let strict2 = strict;
                                super(sortIndex);
                                if (this.type1 === undefined) {
                                    this.type1 = null;
                                }
                                if (this.strict1 === undefined) {
                                    this.strict1 = false;
                                }
                                if (this.type2 === undefined) {
                                    this.type2 = null;
                                }
                                if (this.strict2 === undefined) {
                                    this.strict2 = false;
                                }
                                this.type1 = type1;
                                this.strict1 = strict1;
                                this.type2 = type2;
                                this.strict2 = strict2;
                            }
                            if (this.type1 === undefined) {
                                this.type1 = null;
                            }
                            if (this.strict1 === undefined) {
                                this.strict1 = false;
                            }
                            if (this.type2 === undefined) {
                                this.type2 = null;
                            }
                            if (this.strict2 === undefined) {
                                this.strict2 = false;
                            }
                        }
                        else if (((type1 != null && (type1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type1))) || type1 === null) && ((typeof strict1 === 'boolean') || strict1 === null) && ((type2 != null && (type2["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type2))) || type2 === null) && ((typeof strict2 === 'boolean') || strict2 === null) && sortIndex === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let sortIndex = 0;
                                super(sortIndex);
                                if (this.type1 === undefined) {
                                    this.type1 = null;
                                }
                                if (this.strict1 === undefined) {
                                    this.strict1 = false;
                                }
                                if (this.type2 === undefined) {
                                    this.type2 = null;
                                }
                                if (this.strict2 === undefined) {
                                    this.strict2 = false;
                                }
                                this.type1 = type1;
                                this.strict1 = strict1;
                                this.type2 = type2;
                                this.strict2 = strict2;
                            }
                            if (this.type1 === undefined) {
                                this.type1 = null;
                            }
                            if (this.strict1 === undefined) {
                                this.strict1 = false;
                            }
                            if (this.type2 === undefined) {
                                this.type2 = null;
                            }
                            if (this.strict2 === undefined) {
                                this.strict2 = false;
                            }
                        }
                        else if (((type1 != null && (type1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type1))) || type1 === null) && ((strict1 != null && (strict1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(strict1))) || strict1 === null) && ((typeof type2 === 'number') || type2 === null) && strict2 === undefined && sortIndex === undefined) {
                            let __args = arguments;
                            let type2 = __args[1];
                            let sortIndex = __args[2];
                            {
                                let __args = arguments;
                                let strict1 = true;
                                let strict2 = true;
                                super(sortIndex);
                                if (this.type1 === undefined) {
                                    this.type1 = null;
                                }
                                if (this.strict1 === undefined) {
                                    this.strict1 = false;
                                }
                                if (this.type2 === undefined) {
                                    this.type2 = null;
                                }
                                if (this.strict2 === undefined) {
                                    this.strict2 = false;
                                }
                                this.type1 = type1;
                                this.strict1 = strict1;
                                this.type2 = type2;
                                this.strict2 = strict2;
                            }
                            if (this.type1 === undefined) {
                                this.type1 = null;
                            }
                            if (this.strict1 === undefined) {
                                this.strict1 = false;
                            }
                            if (this.type2 === undefined) {
                                this.type2 = null;
                            }
                            if (this.strict2 === undefined) {
                                this.strict2 = false;
                            }
                        }
                        else if (((type1 != null && (type1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type1))) || type1 === null) && ((strict1 != null && (strict1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(strict1))) || strict1 === null) && ((typeof type2 === 'boolean') || type2 === null) && strict2 === undefined && sortIndex === undefined) {
                            let __args = arguments;
                            let type2 = __args[1];
                            let strict = __args[2];
                            {
                                let __args = arguments;
                                let strict1 = strict;
                                let strict2 = strict;
                                let sortIndex = 0;
                                super(sortIndex);
                                if (this.type1 === undefined) {
                                    this.type1 = null;
                                }
                                if (this.strict1 === undefined) {
                                    this.strict1 = false;
                                }
                                if (this.type2 === undefined) {
                                    this.type2 = null;
                                }
                                if (this.strict2 === undefined) {
                                    this.strict2 = false;
                                }
                                this.type1 = type1;
                                this.strict1 = strict1;
                                this.type2 = type2;
                                this.strict2 = strict2;
                            }
                            if (this.type1 === undefined) {
                                this.type1 = null;
                            }
                            if (this.strict1 === undefined) {
                                this.strict1 = false;
                            }
                            if (this.type2 === undefined) {
                                this.type2 = null;
                            }
                            if (this.strict2 === undefined) {
                                this.strict2 = false;
                            }
                        }
                        else if (((type1 != null && (type1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type1))) || type1 === null) && ((strict1 != null && (strict1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(strict1))) || strict1 === null) && type2 === undefined && strict2 === undefined && sortIndex === undefined) {
                            let __args = arguments;
                            let type2 = __args[1];
                            {
                                let __args = arguments;
                                let strict1 = true;
                                let strict2 = true;
                                let sortIndex = 0;
                                super(sortIndex);
                                if (this.type1 === undefined) {
                                    this.type1 = null;
                                }
                                if (this.strict1 === undefined) {
                                    this.strict1 = false;
                                }
                                if (this.type2 === undefined) {
                                    this.type2 = null;
                                }
                                if (this.strict2 === undefined) {
                                    this.strict2 = false;
                                }
                                this.type1 = type1;
                                this.strict1 = strict1;
                                this.type2 = type2;
                                this.strict2 = strict2;
                            }
                            if (this.type1 === undefined) {
                                this.type1 = null;
                            }
                            if (this.strict1 === undefined) {
                                this.strict1 = false;
                            }
                            if (this.type2 === undefined) {
                                this.type2 = null;
                            }
                            if (this.strict2 === undefined) {
                                this.strict2 = false;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        const prime = 31;
                        let result = ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this);
                        result = prime * result + (this.strict1 ? 1231 : 1237);
                        result = prime * result + (this.strict2 ? 1231 : 1237);
                        result = prime * result + ((this.type1 == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.type1));
                        result = prime * result + ((this.type2 == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.type2));
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (obj == null)
                            return false;
                        if (obj === this)
                            return true;
                        if (obj != null && obj instanceof org.dyn4j.collision.narrowphase.PairwiseTypedFallbackCondition) {
                            const pfc = obj;
                            if (((pfc.type1 === this.type1 && pfc.type2 === this.type2) || (pfc.type1 === this.type2 && pfc.type2 === this.type1)) && pfc.strict1 === this.strict1 && pfc.strict2 === this.strict2 && pfc.sortIndex === this.sortIndex) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("PairwiseTypedFallbackCondition[").append("Type1=").append(/* getName */ (c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])(this.type1)).append("|IsStrict1=").append(this.strict1).append("|Type2=").append(/* getName */ (c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])(this.type2)).append("|IsStrict2=").append(this.strict2).append("]");
                        return sb.toString();
                    }
                    isMatch$java_lang_Class$java_lang_Class(type1, type2) {
                        if (this.strict1) {
                            if (this.strict2) {
                                return (this.type1 === type1 && this.type2 === type2) || (this.type1 === type2 && this.type2 === type1);
                            }
                            else {
                                return (this.type1 === type1 && this.type2.isAssignableFrom(type2)) || (this.type1 === type2 && this.type2.isAssignableFrom(type1));
                            }
                        }
                        else {
                            if (this.strict2) {
                                return (this.type1.isAssignableFrom(type1) && this.type2 === type2) || (this.type1.isAssignableFrom(type2) && this.type2 === type1);
                            }
                            else {
                                return (this.type1.isAssignableFrom(type1) && this.type2.isAssignableFrom(type2)) || (this.type1.isAssignableFrom(type2) && this.type2.isAssignableFrom(type1));
                            }
                        }
                    }
                    isMatch(type1, type2) {
                        if (((type1 != null && (type1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type1))) || type1 === null) && ((type2 != null && (type2["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type2))) || type2 === null)) {
                            return this.isMatch$java_lang_Class$java_lang_Class(type1, type2);
                        }
                        else if (((type1 != null && (type1.constructor != null && type1.constructor["__interfaces"] != null && type1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || type1 === null) && ((type2 != null && (type2.constructor != null && type2.constructor["__interfaces"] != null && type2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || type2 === null)) {
                            return super.isMatch(type1, type2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Returns the first type for this fallback condition.
                     * @return {java.lang.Class} Class&lt;? extends {@link Convex}&gt;
                     */
                    getType1() {
                        return this.type1;
                    }
                    /**
                     * Returns the second type for this fallback condition.
                     * @return {java.lang.Class} Class&lt;? extends {@link Convex}&gt;
                     */
                    getType2() {
                        return this.type2;
                    }
                    /**
                     * Returns true if this condition uses a strict type comparison for the first type.
                     * @return {boolean} boolean
                     */
                    isStrict1() {
                        return this.strict1;
                    }
                    /**
                     * Returns true if this condition uses a strict type comparison for the second type.
                     * @return {boolean} boolean
                     */
                    isStrict2() {
                        return this.strict2;
                    }
                }
                narrowphase.PairwiseTypedFallbackCondition = PairwiseTypedFallbackCondition;
                PairwiseTypedFallbackCondition["__class"] = "org.dyn4j.collision.narrowphase.PairwiseTypedFallbackCondition";
                PairwiseTypedFallbackCondition["__interfaces"] = ["java.lang.Comparable", "org.dyn4j.collision.narrowphase.FallbackCondition"];
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var collision;
        (function (collision) {
            var narrowphase;
            (function (narrowphase) {
                /**
                 * Full constructor.
                 * @param {java.lang.Class} type the type
                 * @param {number} sortIndex the sort index of this condition
                 * @param {boolean} strict true if a strict type comparison should be performed
                 * @class
                 * @extends org.dyn4j.collision.narrowphase.TypedFallbackCondition
                 * @author William Bittle
                 */
                class SingleTypedFallbackCondition extends org.dyn4j.collision.narrowphase.TypedFallbackCondition {
                    constructor(type, sortIndex, strict) {
                        if (((type != null && (type["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type))) || type === null) && ((typeof sortIndex === 'number') || sortIndex === null) && ((typeof strict === 'boolean') || strict === null)) {
                            let __args = arguments;
                            super(sortIndex);
                            if (this.type === undefined) {
                                this.type = null;
                            }
                            if (this.strict === undefined) {
                                this.strict = false;
                            }
                            this.type = type;
                            this.strict = strict;
                        }
                        else if (((type != null && (type["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type))) || type === null) && ((typeof sortIndex === 'number') || sortIndex === null) && strict === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let strict = true;
                                super(sortIndex);
                                if (this.type === undefined) {
                                    this.type = null;
                                }
                                if (this.strict === undefined) {
                                    this.strict = false;
                                }
                                this.type = type;
                                this.strict = strict;
                            }
                            if (this.type === undefined) {
                                this.type = null;
                            }
                            if (this.strict === undefined) {
                                this.strict = false;
                            }
                        }
                        else if (((type != null && (type["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type))) || type === null) && ((typeof sortIndex === 'boolean') || sortIndex === null) && strict === undefined) {
                            let __args = arguments;
                            let strict = __args[1];
                            {
                                let __args = arguments;
                                let sortIndex = 0;
                                super(sortIndex);
                                if (this.type === undefined) {
                                    this.type = null;
                                }
                                if (this.strict === undefined) {
                                    this.strict = false;
                                }
                                this.type = type;
                                this.strict = strict;
                            }
                            if (this.type === undefined) {
                                this.type = null;
                            }
                            if (this.strict === undefined) {
                                this.strict = false;
                            }
                        }
                        else if (((type != null && (type["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type))) || type === null) && sortIndex === undefined && strict === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let sortIndex = 0;
                                let strict = true;
                                super(sortIndex);
                                if (this.type === undefined) {
                                    this.type = null;
                                }
                                if (this.strict === undefined) {
                                    this.strict = false;
                                }
                                this.type = type;
                                this.strict = strict;
                            }
                            if (this.type === undefined) {
                                this.type = null;
                            }
                            if (this.strict === undefined) {
                                this.strict = false;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        const prime = 31;
                        let result = ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this);
                        result = prime * result + (this.strict ? 1231 : 1237);
                        result = prime * result + ((this.type == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.type));
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (obj == null)
                            return false;
                        if (this === obj)
                            return true;
                        if (obj != null && obj instanceof org.dyn4j.collision.narrowphase.SingleTypedFallbackCondition) {
                            const other = obj;
                            if (this.strict === other.strict && this.type === other.type && this.sortIndex === other.sortIndex) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("SingleTypedFallbackCondition[").append("Type=").append(/* getName */ (c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])(this.type)).append("|IsStrict=").append(this.strict).append("]");
                        return sb.toString();
                    }
                    isMatch$java_lang_Class$java_lang_Class(type1, type2) {
                        if (this.strict) {
                            return this.type === type1 || this.type === type2;
                        }
                        return this.type.isAssignableFrom(type1) || this.type.isAssignableFrom(type2);
                    }
                    /**
                     *
                     * @param {java.lang.Class} type1
                     * @param {java.lang.Class} type2
                     * @return {boolean}
                     */
                    isMatch(type1, type2) {
                        if (((type1 != null && (type1["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type1))) || type1 === null) && ((type2 != null && (type2["__class"] != null || ((t) => { try {
                            new t;
                            return true;
                        }
                        catch (_a) {
                            return false;
                        } })(type2))) || type2 === null)) {
                            return this.isMatch$java_lang_Class$java_lang_Class(type1, type2);
                        }
                        else if (((type1 != null && (type1.constructor != null && type1.constructor["__interfaces"] != null && type1.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || type1 === null) && ((type2 != null && (type2.constructor != null && type2.constructor["__interfaces"] != null && type2.constructor["__interfaces"].indexOf("org.dyn4j.geometry.Convex") >= 0)) || type2 === null)) {
                            return super.isMatch(type1, type2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Returns the type for this fallback condition.
                     * @return {java.lang.Class} Class&lt;? extends {@link Convex}&gt;
                     */
                    getType() {
                        return this.type;
                    }
                    /**
                     * Returns true if this condition uses a strict type comparison.
                     * @return {boolean} boolean
                     */
                    isStrict() {
                        return this.strict;
                    }
                }
                narrowphase.SingleTypedFallbackCondition = SingleTypedFallbackCondition;
                SingleTypedFallbackCondition["__class"] = "org.dyn4j.collision.narrowphase.SingleTypedFallbackCondition";
                SingleTypedFallbackCondition["__interfaces"] = ["java.lang.Comparable", "org.dyn4j.collision.narrowphase.FallbackCondition"];
            })(narrowphase = collision.narrowphase || (collision.narrowphase = {}));
        })(collision = dyn4j.collision || (dyn4j.collision = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var dynamics;
        (function (dynamics) {
            var joint;
            (function (joint) {
                /**
                 * Minimal constructor.
                 * @param {org.dyn4j.dynamics.Body} body1 the first {@link Body}
                 * @param {org.dyn4j.dynamics.Body} body2 the second {@link Body}
                 * @param {org.dyn4j.geometry.Vector2} anchor the anchor point in world coordinates
                 * @throws NullPointerException if body1, body2 or anchor is null
                 * @throws IllegalArgumentException if body1 == body2
                 * @class
                 * @extends org.dyn4j.dynamics.joint.RevoluteJoint
                 * @author William Bittle
                 */
                class TorsionJoint extends org.dyn4j.dynamics.joint.RevoluteJoint {
                    constructor(body1, body2, anchor) {
                        super(body1, body2, anchor);
                        if (this.localAnchor1 === undefined) {
                            this.localAnchor1 = null;
                        }
                        if (this.localAnchor2 === undefined) {
                            this.localAnchor2 = null;
                        }
                        if (this.motorEnabled === undefined) {
                            this.motorEnabled = false;
                        }
                        if (this.motorSpeed === undefined) {
                            this.motorSpeed = 0;
                        }
                        if (this.maximumMotorTorque === undefined) {
                            this.maximumMotorTorque = 0;
                        }
                        if (this.limitEnabled === undefined) {
                            this.limitEnabled = false;
                        }
                        if (this.upperLimit === undefined) {
                            this.upperLimit = 0;
                        }
                        if (this.lowerLimit === undefined) {
                            this.lowerLimit = 0;
                        }
                        if (this.referenceAngle === undefined) {
                            this.referenceAngle = 0;
                        }
                        this.springConstant = 5;
                        this.dampingCoeff = 0.0;
                        if (this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState === undefined) {
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState = null;
                        }
                        if (this.__org_dyn4j_dynamics_joint_TorsionJoint_K === undefined) {
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_K = null;
                        }
                        if (this.__org_dyn4j_dynamics_joint_TorsionJoint_motorMass === undefined) {
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_motorMass = 0;
                        }
                        if (this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse === undefined) {
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse = null;
                        }
                        if (this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse === undefined) {
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse = 0;
                        }
                        if (this.torsionalTorque === undefined) {
                            this.torsionalTorque = 0;
                        }
                        this.theta = 3 * Math.PI;
                        if (this.currentAngle === undefined) {
                            this.currentAngle = 0;
                        }
                        if (body1 === body2)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.sameBody"));
                        if (anchor == null)
                            throw new java.lang.NullPointerException(org.dyn4j.resources.Messages.getString("dynamics.joint.nullAnchor"));
                        this.localAnchor1 = body1.getLocalPoint(anchor);
                        this.localAnchor2 = body2.getLocalPoint(anchor);
                        this.referenceAngle = body1.getTransform().getRotationAngle() - body2.getTransform().getRotationAngle();
                        this.lowerLimit = this.referenceAngle;
                        this.upperLimit = this.referenceAngle;
                        this.limitEnabled = false;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse = new org.dyn4j.geometry.Vector3();
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_K = new org.dyn4j.geometry.Matrix33();
                        this.motorEnabled = false;
                        this.dampingCoeff = Math.sqrt(4 * this.springConstant * body1.getMassData().getInertia()) / 2;
                        this.currentAngle = body1.getTransform().getRotationAngle();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const sb = new java.lang.StringBuilder();
                        sb.append("RevoluteJoint[").append(super.toString()).append("|Anchor=").append(this.getAnchor1()).append("|IsMotorEnabled=").append(this.motorEnabled).append("|MotorSpeed=").append(this.motorSpeed).append("|MaximumMotorTorque=").append(this.maximumMotorTorque).append("|IsLimitEnabled=").append(this.limitEnabled).append("|LowerLimit=").append(this.lowerLimit).append("|UpperLimit=").append(this.upperLimit).append("|ReferenceAngle=").append(this.referenceAngle).append("]");
                        return sb.toString();
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    initializeConstraints(step, settings) {
                        const angularTolerance = settings.getAngularTolerance();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        if (this.motorEnabled) {
                            if (invI1 <= 0.0 && invI2 <= 0.0) {
                                throw new java.lang.IllegalStateException(org.dyn4j.resources.Messages.getString("dynamics.joint.revolute.twoAngularFixedBodies"));
                            }
                        }
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m00 = invM1 + invM2 + r1.y * r1.y * invI1 + r2.y * r2.y * invI2;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m01 = -r1.y * r1.x * invI1 - r2.y * r2.x * invI2;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m02 = -r1.y * invI1 - r2.y * invI2;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m10 = this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m01;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m11 = invM1 + invM2 + r1.x * r1.x * invI1 + r2.x * r2.x * invI2;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m12 = r1.x * invI1 + r2.x * invI2;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m20 = this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m02;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m21 = this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m12;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m22 = invI1 + invI2;
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_motorMass = invI1 + invI2;
                        if (this.__org_dyn4j_dynamics_joint_TorsionJoint_motorMass > org.dyn4j.Epsilon.E_$LI$()) {
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_motorMass = 1.0 / this.__org_dyn4j_dynamics_joint_TorsionJoint_motorMass;
                        }
                        if (!this.motorEnabled) {
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse = 0.0;
                        }
                        const angle = this.__org_dyn4j_dynamics_joint_TorsionJoint_getRelativeRotation();
                        if (this.limitEnabled) {
                            if (Math.abs(this.upperLimit - this.lowerLimit) < 2.0 * angularTolerance) {
                                this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState = org.dyn4j.dynamics.joint.LimitState.EQUAL;
                            }
                            else if (angle <= this.lowerLimit) {
                                if (this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState !== org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                    this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z = 0.0;
                                }
                                this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState = org.dyn4j.dynamics.joint.LimitState.AT_LOWER;
                            }
                            else if (angle >= this.upperLimit) {
                                if (this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState === org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                    this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z = 0.0;
                                }
                                this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState = org.dyn4j.dynamics.joint.LimitState.AT_UPPER;
                            }
                            else {
                                this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z = 0.0;
                                this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                            }
                        }
                        else {
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState = org.dyn4j.dynamics.joint.LimitState.INACTIVE;
                        }
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.multiply(step.getDeltaTimeRatio());
                        this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse *= step.getDeltaTimeRatio();
                        const C = this.springConstant;
                        this.torsionalTorque = 0;
                        const dTheta = this.body1.getTransform().getRotationAngle();
                        const wRel = this.body1.getAngularVelocity();
                        const b = this.dampingCoeff;
                        const dt = step.getDeltaTime();
                        this.torsionalTorque = -C * this.theta * dt - b * wRel * dt;
                        this.theta += wRel * dt;
                        const impulse = new org.dyn4j.geometry.Vector2(this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.x, this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.y);
                        this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(impulse.product(invM1));
                        this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * (r1.cross$org_dyn4j_geometry_Vector2(impulse) + this.torsionalTorque + this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse + this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z));
                        this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(impulse.product(invM2));
                        this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * (r2.cross$org_dyn4j_geometry_Vector2(impulse) + this.torsionalTorque + this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse + this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z));
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     */
                    solveVelocityConstraints(step, settings) {
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        if (this.motorEnabled && this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState !== org.dyn4j.dynamics.joint.LimitState.EQUAL) {
                            const C = this.body1.getAngularVelocity() - this.body2.getAngularVelocity() - this.motorSpeed;
                            let impulse = this.__org_dyn4j_dynamics_joint_TorsionJoint_motorMass * -C;
                            const oldImpulse = this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse;
                            const maxImpulse = this.maximumMotorTorque * step.getDeltaTime();
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse = org.dyn4j.geometry.Interval.clamp(this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse + impulse, -maxImpulse, maxImpulse);
                            impulse = this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse - oldImpulse;
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * impulse);
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * impulse);
                        }
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        const v1 = this.body1.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r1.cross$double(this.body1.getAngularVelocity()));
                        const v2 = this.body2.getLinearVelocity$().sum$org_dyn4j_geometry_Vector2(r2.cross$double(this.body2.getAngularVelocity()));
                        const Jvb2 = v1.subtract$org_dyn4j_geometry_Vector2(v2);
                        if (this.limitEnabled && this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const pivotW = this.body1.getAngularVelocity() - this.body2.getAngularVelocity();
                            const Jvb3 = new org.dyn4j.geometry.Vector3(Jvb2.x, Jvb2.y, pivotW);
                            const impulse3 = this.__org_dyn4j_dynamics_joint_TorsionJoint_K.solve33(Jvb3.negate());
                            if (this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState === org.dyn4j.dynamics.joint.LimitState.EQUAL) {
                                this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.add$org_dyn4j_geometry_Vector3(impulse3);
                            }
                            else if (this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState === org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                const newImpulse = this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z + impulse3.z;
                                if (newImpulse < 0.0) {
                                    const reduced = this.__org_dyn4j_dynamics_joint_TorsionJoint_K.solve22(Jvb2.negate());
                                    impulse3.x = reduced.x;
                                    impulse3.y = reduced.y;
                                    impulse3.z = -this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z;
                                    this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.x += reduced.x;
                                    this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.y += reduced.y;
                                    this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z = 0.0;
                                }
                            }
                            else if (this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState === org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                const newImpulse = this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z + impulse3.z;
                                if (newImpulse > 0.0) {
                                    const reduced = this.__org_dyn4j_dynamics_joint_TorsionJoint_K.solve22(Jvb2.negate());
                                    impulse3.x = reduced.x;
                                    impulse3.y = reduced.y;
                                    impulse3.z = -this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z;
                                    this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.x += reduced.x;
                                    this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.y += reduced.y;
                                    this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z = 0.0;
                                }
                            }
                            const impulse = new org.dyn4j.geometry.Vector2(impulse3.x, impulse3.y);
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(impulse.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * (r1.cross$org_dyn4j_geometry_Vector2(impulse) + impulse3.z));
                            this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(impulse.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * (r2.cross$org_dyn4j_geometry_Vector2(impulse) + impulse3.z));
                        }
                        else {
                            const impulse = this.__org_dyn4j_dynamics_joint_TorsionJoint_K.solve22(Jvb2.negate());
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.x += impulse.x;
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.y += impulse.y;
                            this.body1.getLinearVelocity$().add$org_dyn4j_geometry_Vector2(impulse.product(invM1));
                            this.body1.setAngularVelocity(this.body1.getAngularVelocity() + invI1 * r1.cross$org_dyn4j_geometry_Vector2(impulse));
                            this.body2.getLinearVelocity$().subtract$org_dyn4j_geometry_Vector2(impulse.product(invM2));
                            this.body2.setAngularVelocity(this.body2.getAngularVelocity() - invI2 * r2.cross$org_dyn4j_geometry_Vector2(impulse));
                        }
                        this.body1.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body1.getLinearVelocity$());
                        this.body2.setLinearVelocity$org_dyn4j_geometry_Vector2(this.body2.getLinearVelocity$());
                    }
                    /**
                     *
                     * @param {org.dyn4j.dynamics.Step} step
                     * @param {org.dyn4j.dynamics.Settings} settings
                     * @return {boolean}
                     */
                    solvePositionConstraints(step, settings) {
                        const linearTolerance = settings.getLinearTolerance();
                        const angularTolerance = settings.getAngularTolerance();
                        const maxAngularCorrection = settings.getMaximumAngularCorrection();
                        const t1 = this.body1.getTransform();
                        const t2 = this.body2.getTransform();
                        const m1 = this.body1.getMassData();
                        const m2 = this.body2.getMassData();
                        const invM1 = m1.getInverseMass();
                        const invM2 = m2.getInverseMass();
                        const invI1 = m1.getInverseInertia();
                        const invI2 = m2.getInverseInertia();
                        let linearError = 0.0;
                        let angularError = 0.0;
                        if (this.limitEnabled && this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState !== org.dyn4j.dynamics.joint.LimitState.INACTIVE) {
                            const angle = this.__org_dyn4j_dynamics_joint_TorsionJoint_getRelativeRotation();
                            let impulse = 0.0;
                            if (this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState === org.dyn4j.dynamics.joint.LimitState.EQUAL) {
                                const j = org.dyn4j.geometry.Interval.clamp(angle - this.lowerLimit, -maxAngularCorrection, maxAngularCorrection);
                                impulse = -j * this.__org_dyn4j_dynamics_joint_TorsionJoint_motorMass;
                                angularError = Math.abs(j);
                            }
                            else if (this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState === org.dyn4j.dynamics.joint.LimitState.AT_LOWER) {
                                let j = angle - this.lowerLimit;
                                angularError = -j;
                                j = org.dyn4j.geometry.Interval.clamp(j + angularTolerance, -maxAngularCorrection, 0.0);
                                impulse = -j * this.__org_dyn4j_dynamics_joint_TorsionJoint_motorMass;
                            }
                            else if (this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState === org.dyn4j.dynamics.joint.LimitState.AT_UPPER) {
                                let j = angle - this.upperLimit;
                                angularError = j;
                                j = org.dyn4j.geometry.Interval.clamp(j - angularTolerance, 0.0, maxAngularCorrection);
                                impulse = -j * this.__org_dyn4j_dynamics_joint_TorsionJoint_motorMass;
                            }
                            this.body1.rotateAboutCenter(invI1 * impulse);
                            this.body2.rotateAboutCenter(-invI2 * impulse);
                        }
                        const r1 = t1.getTransformedR$org_dyn4j_geometry_Vector2(this.body1.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor1));
                        const r2 = t2.getTransformedR$org_dyn4j_geometry_Vector2(this.body2.getLocalCenter().to$org_dyn4j_geometry_Vector2(this.localAnchor2));
                        let p1 = this.body1.getWorldCenter().add$org_dyn4j_geometry_Vector2(r1);
                        let p2 = this.body2.getWorldCenter().add$org_dyn4j_geometry_Vector2(r2);
                        let p = p1.difference$org_dyn4j_geometry_Vector2(p2);
                        linearError = p.getMagnitude();
                        const large = 10.0 * linearTolerance;
                        if (p.getMagnitudeSquared() > large * large) {
                            let m = invM1 + invM2;
                            if (m > org.dyn4j.Epsilon.E_$LI$()) {
                                m = 1.0 / m;
                            }
                            const impulse = p.multiply(-m);
                            const scale = 0.5;
                            this.body1.translate$org_dyn4j_geometry_Vector2(impulse.product(invM1 * scale));
                            this.body2.translate$org_dyn4j_geometry_Vector2(impulse.product(-invM2 * scale));
                            p1 = this.body1.getWorldCenter().add$org_dyn4j_geometry_Vector2(r1);
                            p2 = this.body2.getWorldCenter().add$org_dyn4j_geometry_Vector2(r2);
                            p = p1.difference$org_dyn4j_geometry_Vector2(p2);
                        }
                        const K = new org.dyn4j.geometry.Matrix22();
                        K.m00 = invM1 + invM2 + r1.y * r1.y * invI1 + r2.y * r2.y * invI2;
                        K.m01 = -invI1 * r1.x * r1.y - invI2 * r2.x * r2.y;
                        K.m10 = this.__org_dyn4j_dynamics_joint_TorsionJoint_K.m01;
                        K.m11 = invM1 + invM2 + r1.x * r1.x * invI1 + r2.x * r2.x * invI2;
                        const J = K.solve(p.negate());
                        this.body1.translate$double$double(this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : J.x * invM1, this.body1.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : J.y * invM1);
                        this.body1.rotateAboutCenter(invI1 * r1.cross$org_dyn4j_geometry_Vector2(J));
                        this.body2.translate$double$double(this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.Y_MOTION_ONLY ? 0 : -J.x * invM2, this.body2.getMassData().getType() === org.dyn4j.geometry.MassType.X_MOTION_ONLY ? 0 : -J.y * invM2);
                        this.body2.rotateAboutCenter(-invI2 * r2.cross$org_dyn4j_geometry_Vector2(J));
                        return linearError <= linearTolerance && angularError <= angularTolerance;
                    }
                    /**
                     * Returns the relative angle between the two bodies given the reference angle.
                     * @return {number} double
                     * @private
                     */
                    /*private*/ __org_dyn4j_dynamics_joint_TorsionJoint_getRelativeRotation() {
                        let rr = this.body1.getTransform().getRotationAngle() - this.body2.getTransform().getRotationAngle() - this.referenceAngle;
                        if (rr < -Math.PI)
                            rr += org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                        if (rr > Math.PI)
                            rr -= org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
                        return rr;
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor1() {
                        return this.body1.getWorldPoint(this.localAnchor1);
                    }
                    /**
                     *
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getAnchor2() {
                        return this.body2.getWorldPoint(this.localAnchor2);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {org.dyn4j.geometry.Vector2}
                     */
                    getReactionForce(invdt) {
                        return new org.dyn4j.geometry.Vector2(this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.x * invdt, this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.y * invdt);
                    }
                    /**
                     *
                     * @param {number} invdt
                     * @return {number}
                     */
                    getReactionTorque(invdt) {
                        return this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z * invdt + this.torsionalTorque * invdt;
                    }
                    /**
                     *
                     * @param {org.dyn4j.geometry.Vector2} shift
                     */
                    shift(shift) {
                    }
                    /**
                     * Returns the relative speed at which the {@link Body}s
                     * are rotating in radians/second.
                     * @return {number} double
                     */
                    getJointSpeed() {
                        return this.body2.getAngularVelocity() - this.body1.getAngularVelocity();
                    }
                    /**
                     * Returns the relative angle between the two {@link Body}s in radians in the range [-&pi;, &pi;].
                     * @return {number} double
                     */
                    getJointAngle() {
                        return this.__org_dyn4j_dynamics_joint_TorsionJoint_getRelativeRotation();
                    }
                    /**
                     * Returns true if this motor is enabled.
                     * @return {boolean} boolean
                     */
                    isMotorEnabled() {
                        return this.motorEnabled;
                    }
                    /**
                     * Sets whether the motor for this joint is enabled or not.
                     * @param {boolean} flag true if the motor should be enabled
                     */
                    setMotorEnabled(flag) {
                        this.body1.setAsleep(false);
                        this.body2.setAsleep(false);
                        this.motorEnabled = flag;
                    }
                    /**
                     * Returns the maximum torque this motor will apply in newton-meters.
                     * @return {number} double
                     */
                    getMaximumMotorTorque() {
                        return this.maximumMotorTorque;
                    }
                    /**
                     * Sets the maximum torque this motor will apply in newton-meters.
                     * @param {number} maximumMotorTorque the maximum motor torque in newton-meters; must be greater than or equal to zero
                     * @throws IllegalArgumentException if maxMotorTorque is less than zero
                     * @see #setMotorSpeed(double)
                     */
                    setMaximumMotorTorque(maximumMotorTorque) {
                        if (maximumMotorTorque < 0.0)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidMaximumMotorTorque"));
                        this.maximumMotorTorque = maximumMotorTorque;
                    }
                    /**
                     * Returns the desired motor speed in radians/second.
                     * @return {number} double
                     */
                    getMotorSpeed() {
                        return this.motorSpeed;
                    }
                    /**
                     * Sets the target motor speed in radians/second.
                     * @param {number} motorSpeed the motor speed desired in radians/second
                     * @see #setMaximumMotorTorque(double)
                     */
                    setMotorSpeed(motorSpeed) {
                        if (this.motorEnabled) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.motorSpeed = motorSpeed;
                    }
                    /**
                     * Returns the motor torque in newton-meters.
                     * @return {number} double
                     */
                    getMotorTorque() {
                        return this.__org_dyn4j_dynamics_joint_TorsionJoint_motorImpulse;
                    }
                    /**
                     * Returns true if the rotational limit is enabled.
                     * @return {boolean} boolean
                     */
                    isLimitEnabled() {
                        return this.limitEnabled;
                    }
                    /**
                     * Enables or disables the rotational limit.
                     * @param {boolean} flag true if the limit should be enabled
                     */
                    setLimitEnabled(flag) {
                        if (this.limitEnabled !== flag) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                            this.limitEnabled = flag;
                            this.__org_dyn4j_dynamics_joint_TorsionJoint_impulse.z = 0.0;
                        }
                    }
                    /**
                     * Returns the upper rotational limit in radians.
                     * @return {number} double
                     */
                    getUpperLimit() {
                        return this.upperLimit;
                    }
                    /**
                     * Sets the upper rotational limit.
                     * <p>
                     * Must be greater than or equal to the lower rotational limit.
                     * <p>
                     * See the class documentation for more details on the limit ranges.
                     * @param {number} upperLimit the upper rotational limit in radians
                     * @throws IllegalArgumentException if upperLimit is less than the current lower limit
                     */
                    setUpperLimit(upperLimit) {
                        if (upperLimit < this.lowerLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidUpperLimit"));
                        if (this.limitEnabled && upperLimit !== this.upperLimit) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.upperLimit = upperLimit;
                    }
                    /**
                     * Returns the lower rotational limit in radians.
                     * @return {number} double
                     */
                    getLowerLimit() {
                        return this.lowerLimit;
                    }
                    /**
                     * Sets the lower rotational limit.
                     * <p>
                     * Must be less than or equal to the upper rotational limit.
                     * <p>
                     * See the class documentation for more details on the limit ranges.
                     * @param {number} lowerLimit the lower rotational limit in radians
                     * @throws IllegalArgumentException if lowerLimit is greater than the current upper limit
                     */
                    setLowerLimit(lowerLimit) {
                        if (lowerLimit > this.upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLowerLimit"));
                        if (this.limitEnabled && lowerLimit !== this.lowerLimit) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.lowerLimit = lowerLimit;
                    }
                    /**
                     * Sets the upper and lower rotational limits.
                     * <p>
                     * The lower limit must be less than or equal to the upper limit.
                     * <p>
                     * See the class documentation for more details on the limit ranges.
                     * @param {number} lowerLimit the lower limit in radians
                     * @param {number} upperLimit the upper limit in radians
                     * @throws IllegalArgumentException if the lowerLimit is greater than upperLimit
                     */
                    setLimits(lowerLimit, upperLimit) {
                        if (lowerLimit > upperLimit)
                            throw new java.lang.IllegalArgumentException(org.dyn4j.resources.Messages.getString("dynamics.joint.invalidLimits"));
                        if (this.limitEnabled && (lowerLimit !== this.lowerLimit || upperLimit !== this.upperLimit)) {
                            this.body1.setAsleep(false);
                            this.body2.setAsleep(false);
                        }
                        this.lowerLimit = lowerLimit;
                        this.upperLimit = upperLimit;
                    }
                    /**
                     * Returns the reference angle.
                     * <p>
                     * The reference angle is the angle calculated when the joint was created from the
                     * two joined bodies.  The reference angle is the angular difference between the
                     * bodies.
                     * @return {number} double
                     * @since 3.0.1
                     */
                    getReferenceAngle() {
                        return this.referenceAngle;
                    }
                    /**
                     * Sets the reference angle.
                     * <p>
                     * This method can be used to set the reference angle to override the computed
                     * reference angle from the constructor.  This is useful in recreating the joint
                     * from a current state.
                     * @param {number} angle the reference angle in radians
                     * @see #getReferenceAngle()
                     * @since 3.0.1
                     */
                    setReferenceAngle(angle) {
                        this.referenceAngle = angle;
                    }
                    /**
                     * Returns the current state of the limit.
                     * @return {org.dyn4j.dynamics.joint.LimitState} {@link LimitState}
                     * @since 3.2.0
                     */
                    getLimitState() {
                        return this.__org_dyn4j_dynamics_joint_TorsionJoint_limitState;
                    }
                    /**
                     * Translates local anchor Point of Joint on first body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor1(vt) {
                        this.localAnchor1.add$org_dyn4j_geometry_Vector2(vt);
                    }
                    /**
                     * Translates local anchor Point of Joint on second body (experimental)
                     * @param {org.dyn4j.geometry.Vector2} vt Translation vector
                     */
                    translateLocalAnchor2(vt) {
                        this.localAnchor2.add$org_dyn4j_geometry_Vector2(vt);
                    }
                }
                joint.TorsionJoint = TorsionJoint;
                TorsionJoint["__class"] = "org.dyn4j.dynamics.joint.TorsionJoint";
                TorsionJoint["__interfaces"] = ["org.dyn4j.DataContainer", "org.dyn4j.geometry.Shiftable"];
            })(joint = dynamics.joint || (dynamics.joint = {}));
        })(dynamics = dyn4j.dynamics || (dyn4j.dynamics = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * <p>
             * Creates a new triangle using the given points.  The center will be the area
             * weighted center of the points.
             * <p>
             * A triangle must have 3 non-null points of which one is not colinear with the
             * other two.
             * @param {org.dyn4j.geometry.Vector2} point1 the first point
             * @param {org.dyn4j.geometry.Vector2} point2 the second point
             * @param {org.dyn4j.geometry.Vector2} point3 the third point
             * @throws NullPointerException if point1, point2, or point3 is null
             * @throws IllegalArgumentException if point1, point2, and point3 contain coincident points or has clockwise winding
             * @class
             * @extends org.dyn4j.geometry.Polygon
             * @author William Bittle
             */
            class Triangle extends org.dyn4j.geometry.Polygon {
                constructor(point1, point2, point3) {
                    super([point1, point2, point3]);
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Triangle[").append(super.toString()).append("]");
                    return sb.toString();
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    let u;
                    let v;
                    const p = transform.getInverseTransformed$org_dyn4j_geometry_Vector2(point);
                    const p1 = this.vertices[0];
                    const p2 = this.vertices[1];
                    const p3 = this.vertices[2];
                    const ab = p1.to$org_dyn4j_geometry_Vector2(p2);
                    const ac = p1.to$org_dyn4j_geometry_Vector2(p3);
                    const pa = p1.to$org_dyn4j_geometry_Vector2(p);
                    const dot00 = ac.dot$org_dyn4j_geometry_Vector2(ac);
                    const dot01 = ac.dot$org_dyn4j_geometry_Vector2(ab);
                    const dot02 = ac.dot$org_dyn4j_geometry_Vector2(pa);
                    const dot11 = ab.dot$org_dyn4j_geometry_Vector2(ab);
                    const dot12 = ab.dot$org_dyn4j_geometry_Vector2(pa);
                    const denominator = dot00 * dot11 - dot01 * dot01;
                    const invD = 1.0 / denominator;
                    u = (dot11 * dot02 - dot01 * dot12) * invD;
                    if (u <= 0)
                        return false;
                    v = (dot00 * dot12 - dot01 * dot02) * invD;
                    return v > 0 && (u + v <= 1);
                }
                /**
                 * Returns true if the point is inside the {@link Triangle}.
                 * <p>
                 * The equation of a plane is:
                 * <p style="white-space: pre;"> N &middot; (P - A) = 0</p>
                 * Where A is any point on the plane. <br>
                 * Create two axes ({@link Vector2}s), we will choose V<sub>ab</sub> and V<sub>ac</sub>.
                 * <p style="white-space: pre;"> V<sub>ac</sub> = C - A
                 * V<sub>ab</sub> = B - A</p>
                 * Where A, B, and C are the vertices of the {@link Triangle}.<br>
                 * From this we can say that you can get to any point on the
                 * plane by going some u distance on V<sub>ac</sub> and some v distance on V<sub>ab</sub>
                 * where A is the origin.
                 * <p style="white-space: pre;"> P = A + u * V<sub>ac</sub> + v * V<sub>ab</sub></p>
                 * Simplifing P - A
                 * <p style="white-space: pre;"> V<sub>pa</sub> = u * V<sub>ac</sub> + v * V<sub>ab</sub></p>
                 * We still need another equation to solve for u and v:<br>
                 * Dot the equation by V<sub>ac</sub> to get
                 * <p style="white-space: pre;"> V<sub>pa</sub> &middot; V<sub>ac</sub> = (u * V<sub>ac</sub> + v * V<sub>ab</sub>) &middot; V<sub>ac</sub></p>
                 * Dot the equation by V<sub>ab</sub> to get the other
                 * <p style="white-space: pre;"> V<sub>pa</sub> &middot; V<sub>ab</sub> = (u * V<sub>ac</sub> + v * V<sub>ab</sub>) &middot; V<sub>ab</sub></p>
                 * Distribute out both equations
                 * <p style="white-space: pre;"> V<sub>pa</sub> &middot; V<sub>ac</sub> = u * V<sub>ac</sub> &middot; V<sub>ac</sub> + v * V<sub>ab</sub> &middot; V<sub>ac</sub>
                 * V<sub>pa</sub> &middot; V<sub>ab</sub> = u * V<sub>ac</sub> &middot; V<sub>ab</sub> + v * V<sub>ab</sub> &middot; V<sub>ab</sub></p>
                 * Solving the first equation for u:
                 * <p style="white-space: pre;"> u = (V<sub>pa</sub> &middot; V<sub>ac</sub> - v * V<sub>ab</sub> &middot; V<sub>ac</sub>) / (V<sub>ac</sub> &middot; V<sub>ac</sub>)</p>
                 * Substitute one into the other:
                 * <p style="white-space: pre;"> V<sub>pa</sub> &middot; V<sub>ab</sub> = (V<sub>pa</sub> &middot; V<sub>ac</sub> - v * V<sub>ab</sub> &middot; V<sub>ac</sub>) / (V<sub>ac</sub> &middot; V<sub>ac</sub>) * V<sub>ac</sub> &middot; V<sub>ab</sub> + v * V<sub>ab</sub> &middot; V<sub>ab</sub>
                 * V<sub>pa</sub> &middot; V<sub>ab</sub> = (V<sub>pa</sub> &middot; V<sub>ac</sub> / V<sub>ac</sub> &middot; V<sub>ac</sub>) * V<sub>ac</sub> &middot; V<sub>ab</sub> - v * (V<sub>ab</sub> &middot; V<sub>ac</sub> / V<sub>ac</sub> &middot; V<sub>ac</sub>) * V<sub>ac</sub> &middot; V<sub>ab</sub> + v * V<sub>ab</sub> &middot; V<sub>ab</sub>
                 * V<sub>pa</sub> &middot; V<sub>ab</sub> = (V<sub>pa</sub> &middot; V<sub>ac</sub> / V<sub>ac</sub> &middot; V<sub>ac</sub>) * V<sub>ac</sub> &middot; V<sub>ab</sub> + v * (V<sub>ab</sub> &middot; V<sub>ab</sub> - (V<sub>ab</sub> &middot; V<sub>ac</sub> / V<sub>ac</sub> &middot; V<sub>ac</sub>) * V<sub>ac</sub> &middot; V<sub>ab</sub>)
                 * v = (V<sub>pa</sub> &middot; V<sub>ab</sub> - (V<sub>pa</sub> &middot; V<sub>ac</sub> / V<sub>ac</sub> &middot; V<sub>ac</sub>) * V<sub>ac</sub> &middot; V<sub>ab</sub>) / (V<sub>ab</sub> &middot; V<sub>ab</sub> - (V<sub>ab</sub> &middot; V<sub>ac</sub> / V<sub>ac</sub> &middot; V<sub>ac</sub>) * V<sub>ac</sub> &middot; V<sub>ab</sub>)</p>
                 * Which reduces to:
                 * <p style="white-space: pre;"> v = ((V<sub>pa</sub> &middot; V<sub>ab</sub>) * (V<sub>ac</sub> &middot; V<sub>ac</sub>) - (V<sub>pa</sub> &middot; V<sub>ac</sub>) * (V<sub>ac</sub> &middot; V<sub>ab</sub>)) / ((V<sub>ab</sub> &middot; V<sub>ab</sub>) * (V<sub>ac</sub> &middot; V<sub>ac</sub>) - (V<sub>ab</sub> &middot; V<sub>ac</sub>) * (V<sub>ac</sub> &middot; V<sub>ab</sub>))</p>
                 * Once v is obtained use either equation to obtain u:
                 * <p style="white-space: pre;"> u = (v * V<sub>ab</sub> &middot; V<sub>ab</sub> - V<sub>pa</sub> &middot; V<sub>ab</sub>) / V<sub>ac</sub> &middot; V<sub>ab</sub></p>
                 * We know that the point is inside the {@link Triangle} if u and v are greater than
                 * zero and u + v is less than one.
                 * @param {org.dyn4j.geometry.Vector2} point world space point
                 * @param {org.dyn4j.geometry.Transform} transform {@link Transform} the {@link Shape}'s transform
                 * @return {boolean} boolean
                 */
                contains(point, transform) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            geometry.Triangle = Triangle;
            Triangle["__class"] = "org.dyn4j.geometry.Triangle";
            Triangle["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Wound", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * <p>
             * The center of the rectangle will be the origin.
             * <p>
             * A rectangle must have a width and height greater than zero.
             * @param {number} width the width
             * @param {number} height the height
             * @throws IllegalArgumentException if width or height is less than or equal to zero
             * @class
             * @extends org.dyn4j.geometry.Polygon
             * @author William Bittle
             */
            class Rectangle extends org.dyn4j.geometry.Polygon {
                constructor(width, height) {
                    super([new org.dyn4j.geometry.Vector2(-width * 0.5, -height * 0.5), new org.dyn4j.geometry.Vector2(width * 0.5, -height * 0.5), new org.dyn4j.geometry.Vector2(width * 0.5, height * 0.5), new org.dyn4j.geometry.Vector2(-width * 0.5, height * 0.5)]);
                    this.isRuler = false;
                    if (this.width === undefined) {
                        this.width = 0;
                    }
                    if (this.height === undefined) {
                        this.height = 0;
                    }
                    this.width = width;
                    this.height = height;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Rectangle[").append(super.toString()).append("|Width=").append(this.width).append("|Height=").append(this.height).append("]");
                    return sb.toString();
                }
                /**
                 * Returns the height.
                 * @return {number} double
                 */
                getHeight() {
                    return this.height;
                }
                /**
                 * Returns the width.
                 * @return {number} double
                 */
                getWidth() {
                    return this.width;
                }
                /**
                 * Returns the rotation about the local center in radians in the range [-&pi;, &pi;].
                 * @return {number} double the rotation in radians
                 * @since 3.0.1
                 */
                getRotationAngle() {
                    return Math.atan2(this.normals[1].y, this.normals[1].x);
                }
                /**
                 * @return {org.dyn4j.geometry.Rotation} the {@link Rotation} object that represents the local rotation
                 */
                getRotation() {
                    return new org.dyn4j.geometry.Rotation(this.normals[1].x, this.normals[1].y);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2[]} foci
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Vector2[]}
                 */
                getAxes(foci, transform) {
                    const fociSize = foci != null ? foci.length : 0;
                    const axes = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(2 + fociSize);
                    let n = 0;
                    axes[n++] = transform.getTransformedR$org_dyn4j_geometry_Vector2(this.normals[1]);
                    axes[n++] = transform.getTransformedR$org_dyn4j_geometry_Vector2(this.normals[2]);
                    for (let i = 0; i < fociSize; i++) {
                        {
                            const focus = foci[i];
                            let closest = transform.getTransformed$org_dyn4j_geometry_Vector2(this.vertices[0]);
                            let d = focus.distanceSquared$org_dyn4j_geometry_Vector2(closest);
                            for (let j = 1; j < 4; j++) {
                                {
                                    let vertex = this.vertices[j];
                                    vertex = transform.getTransformed$org_dyn4j_geometry_Vector2(vertex);
                                    const dt = focus.distanceSquared$org_dyn4j_geometry_Vector2(vertex);
                                    if (dt < d) {
                                        closest = vertex;
                                        d = dt;
                                    }
                                }
                                ;
                            }
                            const axis = focus.to$org_dyn4j_geometry_Vector2(closest);
                            axis.normalize();
                            axes[n++] = axis;
                        }
                        ;
                    }
                    return axes;
                }
                contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform) {
                    const p = transform.getInverseTransformed$org_dyn4j_geometry_Vector2(point);
                    const c = this.center;
                    const p1 = this.vertices[0];
                    const p2 = this.vertices[1];
                    const p4 = this.vertices[3];
                    const widthSquared = p1.distanceSquared$org_dyn4j_geometry_Vector2(p2);
                    const heightSquared = p1.distanceSquared$org_dyn4j_geometry_Vector2(p4);
                    const projectAxis0 = p1.to$org_dyn4j_geometry_Vector2(p2);
                    const projectAxis1 = p1.to$org_dyn4j_geometry_Vector2(p4);
                    const toPoint = c.to$org_dyn4j_geometry_Vector2(p);
                    if (toPoint.project(projectAxis0).getMagnitudeSquared() <= (widthSquared * 0.25)) {
                        if (toPoint.project(projectAxis1).getMagnitudeSquared() <= (heightSquared * 0.25)) {
                            return true;
                        }
                    }
                    return false;
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} point
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {boolean}
                 */
                contains(point, transform) {
                    if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.contains$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(point, transform);
                    }
                    else if (((point != null && point instanceof org.dyn4j.geometry.Vector2) || point === null) && transform === undefined) {
                        return this.contains$org_dyn4j_geometry_Vector2(point);
                    }
                    else
                        throw new Error('invalid overload');
                }
                project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform) {
                    const center = transform.getTransformed$org_dyn4j_geometry_Vector2(this.center);
                    const projectAxis0 = transform.getTransformedR$org_dyn4j_geometry_Vector2(this.normals[1]);
                    const projectAxis1 = transform.getTransformedR$org_dyn4j_geometry_Vector2(this.normals[2]);
                    const c = center.dot$org_dyn4j_geometry_Vector2(vector);
                    const e = (this.width * 0.5) * Math.abs(projectAxis0.dot$org_dyn4j_geometry_Vector2(vector)) + (this.height * 0.5) * Math.abs(projectAxis1.dot$org_dyn4j_geometry_Vector2(vector));
                    return new org.dyn4j.geometry.Interval(c - e, c + e);
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Vector2} vector
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.Interval}
                 */
                project(vector, transform) {
                    if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && ((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.project$org_dyn4j_geometry_Vector2$org_dyn4j_geometry_Transform(vector, transform);
                    }
                    else if (((vector != null && vector instanceof org.dyn4j.geometry.Vector2) || vector === null) && transform === undefined) {
                        return this.project$org_dyn4j_geometry_Vector2(vector);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Creates a {@link Mass} object using the geometric properties of
                 * this {@link Rectangle} and the given density.
                 * <p style="white-space: pre;"> m = d * h * w
                 * I = m * (h<sup>2</sup> + w<sup>2</sup>) / 12</p>
                 * @param {number} density the density in kg/m<sup>2</sup>
                 * @return {org.dyn4j.geometry.Mass} {@link Mass} the {@link Mass} of this {@link Rectangle}
                 */
                createMass(density) {
                    const height = this.height;
                    const width = this.width;
                    const mass = density * height * width;
                    const inertia = mass * (height * height + width * width) / 12.0;
                    return new org.dyn4j.geometry.Mass(this.center, mass, inertia);
                }
                createAABB$org_dyn4j_geometry_Transform(transform) {
                    const v0x = transform.getTransformedX(this.vertices[0]);
                    const v0y = transform.getTransformedY(this.vertices[0]);
                    const v1x = transform.getTransformedX(this.vertices[1]);
                    const v1y = transform.getTransformedY(this.vertices[1]);
                    const v2x = transform.getTransformedX(this.vertices[2]);
                    const v2y = transform.getTransformedY(this.vertices[2]);
                    const v3x = transform.getTransformedX(this.vertices[3]);
                    const v3y = transform.getTransformedY(this.vertices[3]);
                    if (v0y > v1y) {
                        if (v0x < v1x) {
                            return new org.dyn4j.geometry.AABB(v0x, v1y, v2x, v3y);
                        }
                        else {
                            return new org.dyn4j.geometry.AABB(v1x, v2y, v3x, v0y);
                        }
                    }
                    else {
                        if (v0x < v1x) {
                            return new org.dyn4j.geometry.AABB(v3x, v0y, v1x, v2y);
                        }
                        else {
                            return new org.dyn4j.geometry.AABB(v2x, v3y, v0x, v1y);
                        }
                    }
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Transform} transform
                 * @return {org.dyn4j.geometry.AABB}
                 */
                createAABB(transform) {
                    if (((transform != null && transform instanceof org.dyn4j.geometry.Transform) || transform === null)) {
                        return this.createAABB$org_dyn4j_geometry_Transform(transform);
                    }
                    else if (transform === undefined) {
                        return this.createAABB$();
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            geometry.Rectangle = Rectangle;
            Rectangle["__class"] = "org.dyn4j.geometry.Rectangle";
            Rectangle["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Wound", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Creates a new link.
             * @param {org.dyn4j.geometry.Vector2} point1 the first vertex
             * @param {org.dyn4j.geometry.Vector2} point2 the last vertex
             * @class
             * @extends org.dyn4j.geometry.Segment
             * @author William Bittle
             */
            class Link extends org.dyn4j.geometry.Segment {
                constructor(point1, point2) {
                    super(point1, point2);
                    if (this.previous === undefined) {
                        this.previous = null;
                    }
                    if (this.next === undefined) {
                        this.next = null;
                    }
                }
                /**
                 * Returns the last vertex of the previous segment.
                 * @return {org.dyn4j.geometry.Vector2} Vector2
                 */
                getPoint0() {
                    return this.previous != null ? this.previous.getPoint1() : null;
                }
                /**
                 * Returns the first vertex of the next segment.
                 * @return {org.dyn4j.geometry.Vector2} Vector2
                 */
                getPoint3() {
                    return this.next != null ? this.next.getPoint2() : null;
                }
                /**
                 * Returns the next link in the chain.
                 * @return {org.dyn4j.geometry.Link} {@link Link}
                 */
                getNext() {
                    return this.next;
                }
                /**
                 * Returns the previous link in the chain.
                 * @return {org.dyn4j.geometry.Link} {@link Link}
                 */
                getPrevious() {
                    return this.previous;
                }
                /**
                 * Sets the next link in the chain.
                 * <p>
                 * This method will also:
                 * <ol>
                 * <li>Unlink the current next (if applicable) and this link
                 * <li>Link the given next and this link
                 * </ol>
                 * @param {org.dyn4j.geometry.Link} next the next link
                 */
                setNext(next) {
                    if (this.next != null) {
                        this.next.previous = null;
                    }
                    this.next = next;
                    if (next != null) {
                        next.previous = this;
                    }
                }
                /**
                 * Sets the previous link in the chain.
                 * <p>
                 * This method will also:
                 * <ol>
                 * <li>Unlink the current previous (if applicable) and this link
                 * <li>Link the given previous and this link
                 * </ol>
                 * @param {org.dyn4j.geometry.Link} previous the previous link
                 */
                setPrevious(previous) {
                    if (this.previous != null) {
                        this.previous.next = null;
                    }
                    this.previous = previous;
                    if (previous != null) {
                        previous.next = this;
                    }
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    const sb = new java.lang.StringBuilder();
                    sb.append("Link[").append(super.toString()).append("|Length=").append(this.length).append("]");
                    return sb.toString();
                }
                /**
                 *
                 * @param {org.dyn4j.geometry.Rotation} rotation
                 * @param {number} x
                 * @param {number} y
                 */
                rotate(rotation, x, y) {
                    if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        super.rotate(rotation, x, y);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.rotate$double$double$double(rotation, x, y);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && ((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.rotate$double$org_dyn4j_geometry_Vector2(rotation, x);
                    }
                    else if (((rotation != null && rotation instanceof org.dyn4j.geometry.Rotation) || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$org_dyn4j_geometry_Rotation(rotation);
                    }
                    else if (((typeof rotation === 'number') || rotation === null) && x === undefined && y === undefined) {
                        return this.rotate$double(rotation);
                    }
                    else
                        throw new Error('invalid overload');
                }
                rotate$double$double$double(theta, x, y) {
                    super.rotate$double$double$double(theta, x, y);
                    if (this.next != null) {
                        this.next.vertices[0].set$org_dyn4j_geometry_Vector2(this.vertices[1]);
                        Link.updateNormals(this.next);
                        Link.updateLength(this.next);
                    }
                    if (this.previous != null) {
                        this.previous.vertices[1].set$org_dyn4j_geometry_Vector2(this.vertices[0]);
                        Link.updateNormals(this.previous);
                        Link.updateLength(this.previous);
                    }
                }
                translate$double$double(x, y) {
                    super.translate$double$double(x, y);
                    if (this.next != null) {
                        this.next.vertices[0].set$org_dyn4j_geometry_Vector2(this.vertices[1]);
                        Link.updateLength(this.next);
                    }
                    if (this.previous != null) {
                        this.previous.vertices[1].set$org_dyn4j_geometry_Vector2(this.vertices[0]);
                        Link.updateLength(this.previous);
                    }
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
                translate(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.translate$double$double(x, y);
                    }
                    else if (((x != null && x instanceof org.dyn4j.geometry.Vector2) || x === null) && y === undefined) {
                        return this.translate$org_dyn4j_geometry_Vector2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Updates the normals of the given {@link Segment}.
                 * <p>
                 * When rotating a link in a link chain, the connected links
                 * will need their normals recomputed to match the change.
                 * @param {org.dyn4j.geometry.Segment} segment the segment to update
                 * @private
                 */
                /*private*/ static updateNormals(segment) {
                    const v = segment.vertices[0].to$org_dyn4j_geometry_Vector2(segment.vertices[1]);
                    segment.normals[0] = v.copy();
                    segment.normals[0].normalize();
                    segment.normals[1] = v.right();
                    segment.normals[1].normalize();
                }
                /**
                 * Updates the length and radius of the given {@link Segment}.
                 * <p>
                 * When rotating or translating a link in a link chain, the connected links
                 * will need their lengths and maximum radius recomputed to match the change.
                 * @param {org.dyn4j.geometry.Segment} segment the segment to update
                 * @private
                 */
                /*private*/ static updateLength(segment) {
                    const length = segment.vertices[0].distance$org_dyn4j_geometry_Vector2(segment.vertices[1]);
                    segment.length = length;
                    segment.radius = length * 0.5;
                }
            }
            geometry.Link = Link;
            Link["__class"] = "org.dyn4j.geometry.Link";
            Link["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Wound", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
(function (org) {
    var dyn4j;
    (function (dyn4j) {
        var geometry;
        (function (geometry) {
            /**
             * Full constructor.
             * <p>
             * Creates a new {@link Ring} centered on the origin with the given radius.
             * @param {number} radius the radius
             * @throws IllegalArgumentException if the given radius is less than or equal to zero
             * @class
             * @extends org.dyn4j.geometry.Circle
             * @author Mahesh
             */
            class Ring extends org.dyn4j.geometry.Circle {
                constructor(radius) {
                    super(radius);
                }
                /**
                 * Creates a {@link Mass} object using the geometric properties of
                 * this {@link Ring} and the given density.
                 * <pre>
                 * m = d *2* &pi; * r
                 * I = m * r<sup>2</sup>
                 * </pre>
                 * @param {number} density the linear density in kg/m
                 * @return {org.dyn4j.geometry.Mass} {@link Mass} the {@link Mass} of this {@link Ring}
                 */
                createMass(density) {
                    const radius = this.radius;
                    const mass = density * 2 * Math.PI * radius;
                    const inertia = mass * radius * radius;
                    return new org.dyn4j.geometry.Mass(this.center, mass, inertia);
                }
            }
            geometry.Ring = Ring;
            Ring["__class"] = "org.dyn4j.geometry.Ring";
            Ring["__interfaces"] = ["org.dyn4j.geometry.Convex", "org.dyn4j.geometry.Shape", "org.dyn4j.DataContainer", "org.dyn4j.geometry.Transformable", "org.dyn4j.geometry.Translatable", "org.dyn4j.geometry.Rotatable"];
        })(geometry = dyn4j.geometry || (dyn4j.geometry = {}));
    })(dyn4j = org.dyn4j || (org.dyn4j = {}));
})(org || (org = {}));
org.dyn4j.geometry.HalfEllipse.INERTIA_CONSTANT_$LI$();
org.dyn4j.geometry.Ellipse.INV_GOLDEN_RATIO_$LI$();
org.dyn4j.collision.narrowphase.Gjk.DEFAULT_RAYCAST_EPSILON_$LI$();
org.dyn4j.collision.narrowphase.Gjk.DEFAULT_DISTANCE_EPSILON_$LI$();
org.dyn4j.collision.narrowphase.Gjk.ORIGIN_$LI$();
org.dyn4j.dynamics.World.ZERO_GRAVITY_$LI$();
org.dyn4j.dynamics.World.EARTH_GRAVITY_$LI$();
org.dyn4j.dynamics.World.IDENTITY_$LI$();
org.dyn4j.geometry.AbstractShape.IDENTITY_$LI$();
org.dyn4j.collision.continuous.ConservativeAdvancement.DEFAULT_DISTANCE_EPSILON_$LI$();
org.dyn4j.collision.narrowphase.Epa.DEFAULT_DISTANCE_EPSILON_$LI$();
org.dyn4j.geometry.decompose.EarClipping.CONTAINS_EPSILON_$LI$();
org.dyn4j.geometry.RobustGeometry.ERROR_BOUND_C_$LI$();
org.dyn4j.geometry.RobustGeometry.ERROR_BOUND_B_$LI$();
org.dyn4j.geometry.RobustGeometry.ERROR_BOUND_A_$LI$();
org.dyn4j.geometry.RobustGeometry.RESULT_ERROR_BOUND_$LI$();
org.dyn4j.geometry.RobustGeometry.SPLITTER_$LI$();
org.dyn4j.geometry.RobustGeometry.__static_initialize();
org.dyn4j.geometry.Geometry.INV_SQRT_3_$LI$();
org.dyn4j.geometry.Geometry.TWO_PI_$LI$();
org.dyn4j.geometry.Vector2.INV_Y_AXIS_$LI$();
org.dyn4j.geometry.Vector2.INV_X_AXIS_$LI$();
org.dyn4j.geometry.Vector2.Y_AXIS_$LI$();
org.dyn4j.geometry.Vector2.X_AXIS_$LI$();
org.dyn4j.geometry.Rotation.SQRT_2_INV_$LI$();
org.dyn4j.geometry.Transform.IDENTITY_$LI$();
org.dyn4j.geometry.ResolverRadialChaikin.tmp_$LI$();
org.dyn4j.Epsilon.E_$LI$();
org.dyn4j.samples.framework.input.CodeExporter.TAB3_$LI$();
org.dyn4j.samples.framework.input.CodeExporter.TAB2_$LI$();
org.dyn4j.samples.framework.input.CodeExporter.NEW_LINE_$LI$();
org.dyn4j.UnitConversion.NEWTON_METER_TO_FOOT_POUND_$LI$();
org.dyn4j.UnitConversion.NEWTON_TO_POUND_$LI$();
org.dyn4j.UnitConversion.KILOGRAM_TO_POUND_$LI$();
org.dyn4j.UnitConversion.KILOGRAM_TO_SLUG_$LI$();
org.dyn4j.UnitConversion.METER_TO_FOOT_$LI$();
org.dyn4j.dynamics.Settings.angularSlop_$LI$();
org.dyn4j.dynamics.Settings.maxTriadDistanceSquared_$LI$();
org.dyn4j.dynamics.Settings.invalidParticleIndex_$LI$();
org.dyn4j.dynamics.Settings.DEFAULT_MAXIMUM_ANGULAR_CORRECTION_$LI$();
org.dyn4j.dynamics.Settings.DEFAULT_ANGULAR_TOLERANCE_$LI$();
org.dyn4j.dynamics.Settings.DEFAULT_SLEEP_ANGULAR_VELOCITY_$LI$();
org.dyn4j.dynamics.Settings.DEFAULT_MAXIMUM_ROTATION_$LI$();
org.dyn4j.dynamics.Capacity.DEFAULT_CAPACITY_$LI$();
org.dyn4j.samples.framework.SimulationFrame.main(null);
org.dyn4j.Version.main(null);
